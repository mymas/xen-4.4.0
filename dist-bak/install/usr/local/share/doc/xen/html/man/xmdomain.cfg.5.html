<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#OPTIONS">OPTIONS</a></li>
  <li><a href="#ADDITIONAL-OPTIONS">ADDITIONAL OPTIONS</a></li>
  <li><a href="#DOMAIN-SHUTDOWN-OPTIONS">DOMAIN SHUTDOWN OPTIONS</a></li>
  <li><a href="#EXAMPLES">EXAMPLES</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#BUGS">BUGS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>xmdomain.cfg - xm domain config file format</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> /etc/xen/myxendomain
 /etc/xen/myxendomain2
 /etc/xen/auto/myxenautostarted</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The <b>xm</b>(1) program uses python executable config files to define domains to create from scratch. Each of these config files needs to contain a number of required options, and may specify many more.</p>

<p>Domain configuration files live in /etc/xen by default, if you store config files anywhere else the full path to the config file must be specified in the <i>xm create</i> command.</p>

<p>/etc/xen/auto is a special case. Domain config files in that directory will be started automatically at system boot if the xendomain init script is enabled. The contents of /etc/xen/auto should be symlinks to files in /etc/xen to allow <i>xm create</i> to be used without full paths.</p>

<p>Options are specified by <i>name = value</i> statements in the xmdomain.cfg files.</p>

<h1 id="OPTIONS">OPTIONS</h1>

<p>The following lists the most commonly used options for a domain config file.</p>

<dl>

<dt id="kernel"><b>kernel</b></dt>
<dd>

<p>The kernel image for the domain. The format of the parameter is the fully qualified path to the kernel image file, i.e. <i>/boot/vmlinuz-2.6.12-xenU</i>.</p>

</dd>
<dt id="ramdisk"><b>ramdisk</b></dt>
<dd>

<p>The initial ramdisk for the domain. The format of the parameter is the fully qualified path to the initrd, i.e. <i>/boot/initrd.gz</i>. On many Linux distros you will not need a ramdisk if using the default xen kernel.</p>

</dd>
<dt id="memory"><b>memory</b></dt>
<dd>

<p>The amount of RAM, in megabytes, to allocate to the domain when it starts. Allocating insufficient memory for a domain may produce extremely bizarre behavior. If there isn&#39;t enough free memory left on the machine to fulfil this request, the domain will fail to start.</p>

<p>Xen does not support overcommit of memory, so the total memory of all guests (+ 64 MB needed for Xen) must be less than or equal to the physical RAM in the machine.</p>

</dd>
<dt id="name"><b>name</b></dt>
<dd>

<p>A unique name for the domain. Attempting to create two domains with the same name will cause an error.</p>

</dd>
<dt id="root"><b>root</b></dt>
<dd>

<p>Specifies the root device for the domain. This is required for Linux domains, and possibly other OSes.</p>

</dd>
<dt id="nics"><b>nics</b></dt>
<dd>

<p>The number of network interfaces allocated to the domain on boot. It defaults to 1.</p>

</dd>
<dt id="disk"><b>disk</b></dt>
<dd>

<p>An array of block device stanzas, in the form:</p>

<pre><code>    disk = [ &quot;stanza1&quot;, &quot;stanza2&quot;, ... ]</code></pre>

<p>Each stanza has 3 terms, separated by commas, &quot;backend-dev,frontend-dev,mode&quot;.</p>

<dl>

<dt id="backend-dev"><i>backend-dev</i></dt>
<dd>

<p>The device in the backend domain that will be exported to the guest (frontend) domain. Supported formats include:</p>

<p><i>phy:device</i> - export the physical device listed. The device can be in symbolic form, as in sda7, or as the hex major/minor number, as in 0x301 (which is hda1).</p>

<p><i>file://path/to/file</i> - export the file listed as a loopback device. This will take care of the loopback setup before exporting the device.</p>

</dd>
<dt id="frontend-dev"><i>frontend-dev</i></dt>
<dd>

<p>How the device should appear in the guest domain. The device can be in symbolic form, as in sda7, or as the hex major/minor number, as in 0x301 (which is hda1).</p>

</dd>
<dt id="mode"><i>mode</i></dt>
<dd>

<p>The access mode for the device. There are currently 2 valid options, <i>r</i> (read-only), <i>w</i> (read/write).</p>

</dd>
</dl>

</dd>
<dt id="vif"><b>vif</b></dt>
<dd>

<p>An array of virtual interface stanzas in the form:</p>

<pre><code>    vif = [ &quot;stanza1&quot;, &quot;stanza2&quot;, ... ]</code></pre>

<p>Each stanza specifies a set of <i>name = value</i> options separated by commas, in the form: &quot;name1=value1, name2=value2, ...&quot;</p>

<p><b>OPTIONS</b></p>

<dl>

<dt id="bridge"><i>bridge</i></dt>
<dd>

<p>The network bridge to be used for this device. This is especially needed if multiple bridges exist on the machine.</p>

</dd>
<dt id="mac"><i>mac</i></dt>
<dd>

<p>The MAC address for the virtual interface. If mac is not specified, one will be randomly chosen by xen with the 00:16:3e vendor id prefix.</p>

</dd>
</dl>

</dd>
<dt id="vfb"><b>vfb</b></dt>
<dd>

<p>A virtual frame buffer stanza in the form:</p>

<pre><code>    vfb = [ &quot;stanza&quot; ]</code></pre>

<p>The stanza specifies a set of <i>name = value</i> options separated by commas, in the form: &quot;name1=value1, name2=value2, ...&quot;</p>

<p><b>OPTIONS</b></p>

<dl>

<dt id="type"><i>type</i></dt>
<dd>

<p>There are currently two valid options: <i>vnc</i> starts a VNC server that lets you connect an external VNC viewer, and <i>sdl</i> starts an internal viewer.</p>

</dd>
<dt id="vncdisplay"><i>vncdisplay</i></dt>
<dd>

<p>The VNC display number to use, defaults to the domain ID. The VNC server listens on port 5900 + display number.</p>

</dd>
<dt id="vnclisten"><i>vnclisten</i></dt>
<dd>

<p>The listening address for the VNC server, default 127.0.0.1.</p>

</dd>
<dt id="vncunused"><i>vncunused</i></dt>
<dd>

<p>If non-zero, the VNC server listens on the first unused port above 5900.</p>

</dd>
<dt id="vncpasswd"><i>vncpasswd</i></dt>
<dd>

<p>Overrides the XenD configured default password.</p>

</dd>
<dt id="display"><i>display</i></dt>
<dd>

<p>Display to use for the internal viewer, defaults to environment variable <i>DISPLAY</i>.</p>

</dd>
<dt id="xauthority"><i>xauthority</i></dt>
<dd>

<p>Authority file to use for the internal viewer, defaults to environment variable <i>XAUTHORITY</i>.</p>

</dd>
</dl>

</dd>
</dl>

<h1 id="ADDITIONAL-OPTIONS">ADDITIONAL OPTIONS</h1>

<p>The following options are also supported in the config file, though are far more rarely used.</p>

<dl>

<dt id="builder"><b>builder</b></dt>
<dd>

<p>Which builder should be used to construct the domain. This defaults to the <i>linux</i> if not specified, which is the builder for paravirtualized Linux domains.</p>

</dd>
<dt id="cpu"><b>cpu</b></dt>
<dd>

<p>Specifies which CPU the domain should be started on, where 0 specifies the first cpu, 1 the second, and so on. This defaults to -1, which means Xen is free to pick which CPU to start on.</p>

</dd>
<dt id="cpus"><b>cpus</b></dt>
<dd>

<p>Specifies a list of CPUs on which the domains&#39; VCPUs are allowed to execute upon. The syntax supports ranges (0-3), and negation, ^1. For instance:</p>

<pre><code>    cpus = &quot;0-3,5,^1&quot;</code></pre>

<p>Will result in CPUs 0, 2, 3, 5 being available for use by the domain.</p>

</dd>
<dt id="extra"><b>extra</b></dt>
<dd>

<p>Extra information to append to the end of the kernel parameter line. The format is a string, the contents of which can be anything that the kernel supports. For instance:</p>

<pre><code>    extra = &quot;4&quot;</code></pre>

<p>Will cause the domain to boot to runlevel 4.</p>

</dd>
<dt id="nfs_server"><b>nfs_server</b></dt>
<dd>

<p>The IP address of the NFS server to use as the root device for the domain. In order to do this you&#39;ll need to specify <i>root=/dev/nfs</i>, and specify <i>nfs_root</i>.</p>

</dd>
<dt id="nfs_root"><b>nfs_root</b></dt>
<dd>

<p>The directory on the NFS server to be used as the root filesystem. Specified as a fully qualified path, i.e. <i>/full/path/to/root/dir</i>.</p>

</dd>
<dt id="vcpus"><b>vcpus</b></dt>
<dd>

<p>The number of virtual cpus to allocate to the domain. In order to use this the xen kernel must be compiled with SMP support.</p>

<p>This defaults to 1, meaning running the domain as a UP.</p>

</dd>
</dl>

<h1 id="DOMAIN-SHUTDOWN-OPTIONS">DOMAIN SHUTDOWN OPTIONS</h1>

<p>There are 3 options which control domain shutdown (both planned and unplanned) under certain events. The 3 events currently captured are:</p>

<dl>

<dt id="on_shutdown"><b>on_shutdown</b></dt>
<dd>

<p>Triggered on either an <i>xm shutdown</i> or graceful shutdown from inside the DomU.</p>

</dd>
<dt id="on_reboot"><b>on_reboot</b></dt>
<dd>

<p>Triggered on either an <i>xm reboot</i> or graceful reboot from inside the DomU.</p>

</dd>
<dt id="on_crash"><b>on_crash</b></dt>
<dd>

<p>Triggered when a DomU goes to the crashed state for any reason.</p>

</dd>
</dl>

<p>All of them take one of 4 valid states listed below.</p>

<dl>

<dt id="destroy"><b>destroy</b></dt>
<dd>

<p>The domain will be cleaned up completely. No attempt at respawning will occur. This is what a typical shutdown would look like.</p>

</dd>
<dt id="restart"><b>restart</b></dt>
<dd>

<p>The domain will be restarted with the same name as the old domain. This is what a typical reboot would look like.</p>

</dd>
<dt id="preserve"><b>preserve</b></dt>
<dd>

<p>The domain will not be cleaned up at all. This is often useful for crash state domains which ensures that enough evidence is to debug the real issue.</p>

</dd>
<dt id="rename-restart"><b>rename-restart</b></dt>
<dd>

<p>The old domain will not be cleaned up, but will be renamed so a new domain can be restarted in it&#39;s place. The old domain will be renamed with a suffix -1, -2, etc, and assigned a new random UUID; the new domain will keep the original name and UUID. The old domain will release the devices that it holds, so that the new one may take them.</p>

</dd>
</dl>

<p>Additionally, the &quot;on_crash&quot; event can also take:</p>

<dl>

<dt id="coredump-destroy"><b>coredump-destroy</b></dt>
<dd>

<p>Dump the crashed domain&#39;s core and then destroy it.</p>

</dd>
<dt id="coredump-restart"><b>coredump-restart</b></dt>
<dd>

<p>Dump the crashed domain&#39;s core and then restart it.</p>

</dd>
</dl>

<h1 id="EXAMPLES">EXAMPLES</h1>

<p>The following are quick examples of ways that domains might be configured. They should not be considered an exhaustive set.</p>

<dl>

<dt id="A-Loopback-File-as-Root"><i>A Loopback File as Root</i></dt>
<dd>

<pre><code>    kernel = &quot;/boot/vmlinuz-2.6-xenU&quot;
    memory = 128
    name = &quot;MyLinux&quot;      
    root = &quot;/dev/hda1 ro&quot;
    disk = [ &quot;file:/var/xen/mylinux.img,hda1,w&quot; ]</code></pre>

<p>This creates a domain called MyLinux with 128 MB of memory using a default xen kernel, and the file /var/xen/mylinux.img loopback mounted at hda1, which is the root filesystem.</p>

</dd>
<dt id="NFS-Root"><i>NFS Root</i></dt>
<dd>

<p>FIXME: write me</p>

</dd>
<dt id="LVM-Root"><i>LVM Root</i></dt>
<dd>

<p>FIXME: write me</p>

</dd>
<dt id="Two-Networks"><i>Two Networks</i></dt>
<dd>

<p>FIXME: write me</p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><b>xm</b>(1)</p>

<h1 id="AUTHOR">AUTHOR</h1>

<pre><code>  Sean Dague &lt;sean at dague dot net&gt;</code></pre>

<h1 id="BUGS">BUGS</h1>

<p>Not all options are currently documented</p>


</body>

</html>


