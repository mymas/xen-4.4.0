/* This file is autogenerated by tracetool, do not edit. */

#ifndef TRACE__GENERATED_TRACERS_H
#define TRACE__GENERATED_TRACERS_H

#include "qemu-common.h"

static inline void trace_qxl_interface_set_mm_time(int qid, uint32_t mm_time)
{
}

static inline void trace_qxl_io_write_vga(int qid, const char * mode, uint32_t addr, uint32_t val)
{
}
#include <stdio.h>
#include "trace/control.h"

static inline void trace_qemu_memalign(size_t alignment, size_t size, void * ptr)
{
    bool _state = trace_event_get_state(TRACE_QEMU_MEMALIGN);
    if (_state) {
        fprintf(stderr, "qemu_memalign " "alignment %zu size %zu ptr %p" "\n" , alignment, size, ptr);
    }
}
static inline void trace_qemu_anon_ram_alloc(size_t size, void * ptr)
{
    bool _state = trace_event_get_state(TRACE_QEMU_ANON_RAM_ALLOC);
    if (_state) {
        fprintf(stderr, "qemu_anon_ram_alloc " "size %zu ptr %p" "\n" , size, ptr);
    }
}
static inline void trace_qemu_vfree(void * ptr)
{
    bool _state = trace_event_get_state(TRACE_QEMU_VFREE);
    if (_state) {
        fprintf(stderr, "qemu_vfree " "ptr %p" "\n" , ptr);
    }
}
static inline void trace_qemu_anon_ram_free(void * ptr, size_t size)
{
    bool _state = trace_event_get_state(TRACE_QEMU_ANON_RAM_FREE);
    if (_state) {
        fprintf(stderr, "qemu_anon_ram_free " "ptr %p size %zu" "\n" , ptr, size);
    }
}
static inline void trace_virtqueue_fill(void * vq, const void * elem, unsigned int len, unsigned int idx)
{
    bool _state = trace_event_get_state(TRACE_VIRTQUEUE_FILL);
    if (_state) {
        fprintf(stderr, "virtqueue_fill " "vq %p elem %p len %u idx %u" "\n" , vq, elem, len, idx);
    }
}
static inline void trace_virtqueue_flush(void * vq, unsigned int count)
{
    bool _state = trace_event_get_state(TRACE_VIRTQUEUE_FLUSH);
    if (_state) {
        fprintf(stderr, "virtqueue_flush " "vq %p count %u" "\n" , vq, count);
    }
}
static inline void trace_virtqueue_pop(void * vq, void * elem, unsigned int in_num, unsigned int out_num)
{
    bool _state = trace_event_get_state(TRACE_VIRTQUEUE_POP);
    if (_state) {
        fprintf(stderr, "virtqueue_pop " "vq %p elem %p in_num %u out_num %u" "\n" , vq, elem, in_num, out_num);
    }
}
static inline void trace_virtio_queue_notify(void * vdev, int n, void * vq)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_QUEUE_NOTIFY);
    if (_state) {
        fprintf(stderr, "virtio_queue_notify " "vdev %p n %d vq %p" "\n" , vdev, n, vq);
    }
}
static inline void trace_virtio_irq(void * vq)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_IRQ);
    if (_state) {
        fprintf(stderr, "virtio_irq " "vq %p" "\n" , vq);
    }
}
static inline void trace_virtio_notify(void * vdev, void * vq)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_NOTIFY);
    if (_state) {
        fprintf(stderr, "virtio_notify " "vdev %p vq %p" "\n" , vdev, vq);
    }
}
static inline void trace_virtio_set_status(void * vdev, uint8_t val)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_SET_STATUS);
    if (_state) {
        fprintf(stderr, "virtio_set_status " "vdev %p val %u" "\n" , vdev, val);
    }
}
static inline void trace_virtio_serial_send_control_event(unsigned int port, uint16_t event, uint16_t value)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_SERIAL_SEND_CONTROL_EVENT);
    if (_state) {
        fprintf(stderr, "virtio_serial_send_control_event " "port %u, event %u, value %u" "\n" , port, event, value);
    }
}
static inline void trace_virtio_serial_throttle_port(unsigned int port, bool throttle)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_SERIAL_THROTTLE_PORT);
    if (_state) {
        fprintf(stderr, "virtio_serial_throttle_port " "port %u, throttle %d" "\n" , port, throttle);
    }
}
static inline void trace_virtio_serial_handle_control_message(uint16_t event, uint16_t value)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE);
    if (_state) {
        fprintf(stderr, "virtio_serial_handle_control_message " "event %u, value %u" "\n" , event, value);
    }
}
static inline void trace_virtio_serial_handle_control_message_port(unsigned int port)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_SERIAL_HANDLE_CONTROL_MESSAGE_PORT);
    if (_state) {
        fprintf(stderr, "virtio_serial_handle_control_message_port " "port %u" "\n" , port);
    }
}
static inline void trace_virtio_console_flush_buf(unsigned int port, size_t len, ssize_t ret)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_CONSOLE_FLUSH_BUF);
    if (_state) {
        fprintf(stderr, "virtio_console_flush_buf " "port %u, in_len %zu, out_len %zd" "\n" , port, len, ret);
    }
}
static inline void trace_virtio_console_chr_read(unsigned int port, int size)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_READ);
    if (_state) {
        fprintf(stderr, "virtio_console_chr_read " "port %u, size %d" "\n" , port, size);
    }
}
static inline void trace_virtio_console_chr_event(unsigned int port, int event)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_CONSOLE_CHR_EVENT);
    if (_state) {
        fprintf(stderr, "virtio_console_chr_event " "port %u, event %d" "\n" , port, event);
    }
}
static inline void trace_bdrv_open_common(void * bs, const char * filename, int flags, const char * format_name)
{
    bool _state = trace_event_get_state(TRACE_BDRV_OPEN_COMMON);
    if (_state) {
        fprintf(stderr, "bdrv_open_common " "bs %p filename \"%s\" flags %#x format_name \"%s\"" "\n" , bs, filename, flags, format_name);
    }
}
static inline void trace_multiwrite_cb(void * mcb, int ret)
{
    bool _state = trace_event_get_state(TRACE_MULTIWRITE_CB);
    if (_state) {
        fprintf(stderr, "multiwrite_cb " "mcb %p ret %d" "\n" , mcb, ret);
    }
}
static inline void trace_bdrv_aio_multiwrite(void * mcb, int num_callbacks, int num_reqs)
{
    bool _state = trace_event_get_state(TRACE_BDRV_AIO_MULTIWRITE);
    if (_state) {
        fprintf(stderr, "bdrv_aio_multiwrite " "mcb %p num_callbacks %d num_reqs %d" "\n" , mcb, num_callbacks, num_reqs);
    }
}
static inline void trace_bdrv_aio_discard(void * bs, int64_t sector_num, int nb_sectors, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_BDRV_AIO_DISCARD);
    if (_state) {
        fprintf(stderr, "bdrv_aio_discard " "bs %p sector_num %"PRId64" nb_sectors %d opaque %p" "\n" , bs, sector_num, nb_sectors, opaque);
    }
}
static inline void trace_bdrv_aio_flush(void * bs, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_BDRV_AIO_FLUSH);
    if (_state) {
        fprintf(stderr, "bdrv_aio_flush " "bs %p opaque %p" "\n" , bs, opaque);
    }
}
static inline void trace_bdrv_aio_readv(void * bs, int64_t sector_num, int nb_sectors, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_BDRV_AIO_READV);
    if (_state) {
        fprintf(stderr, "bdrv_aio_readv " "bs %p sector_num %"PRId64" nb_sectors %d opaque %p" "\n" , bs, sector_num, nb_sectors, opaque);
    }
}
static inline void trace_bdrv_aio_writev(void * bs, int64_t sector_num, int nb_sectors, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_BDRV_AIO_WRITEV);
    if (_state) {
        fprintf(stderr, "bdrv_aio_writev " "bs %p sector_num %"PRId64" nb_sectors %d opaque %p" "\n" , bs, sector_num, nb_sectors, opaque);
    }
}
static inline void trace_bdrv_lock_medium(void * bs, bool locked)
{
    bool _state = trace_event_get_state(TRACE_BDRV_LOCK_MEDIUM);
    if (_state) {
        fprintf(stderr, "bdrv_lock_medium " "bs %p locked %d" "\n" , bs, locked);
    }
}
static inline void trace_bdrv_co_readv(void * bs, int64_t sector_num, int nb_sector)
{
    bool _state = trace_event_get_state(TRACE_BDRV_CO_READV);
    if (_state) {
        fprintf(stderr, "bdrv_co_readv " "bs %p sector_num %"PRId64" nb_sectors %d" "\n" , bs, sector_num, nb_sector);
    }
}
static inline void trace_bdrv_co_copy_on_readv(void * bs, int64_t sector_num, int nb_sector)
{
    bool _state = trace_event_get_state(TRACE_BDRV_CO_COPY_ON_READV);
    if (_state) {
        fprintf(stderr, "bdrv_co_copy_on_readv " "bs %p sector_num %"PRId64" nb_sectors %d" "\n" , bs, sector_num, nb_sector);
    }
}
static inline void trace_bdrv_co_writev(void * bs, int64_t sector_num, int nb_sector)
{
    bool _state = trace_event_get_state(TRACE_BDRV_CO_WRITEV);
    if (_state) {
        fprintf(stderr, "bdrv_co_writev " "bs %p sector_num %"PRId64" nb_sectors %d" "\n" , bs, sector_num, nb_sector);
    }
}
static inline void trace_bdrv_co_write_zeroes(void * bs, int64_t sector_num, int nb_sector)
{
    bool _state = trace_event_get_state(TRACE_BDRV_CO_WRITE_ZEROES);
    if (_state) {
        fprintf(stderr, "bdrv_co_write_zeroes " "bs %p sector_num %"PRId64" nb_sectors %d" "\n" , bs, sector_num, nb_sector);
    }
}
static inline void trace_bdrv_co_io_em(void * bs, int64_t sector_num, int nb_sectors, int is_write, void * acb)
{
    bool _state = trace_event_get_state(TRACE_BDRV_CO_IO_EM);
    if (_state) {
        fprintf(stderr, "bdrv_co_io_em " "bs %p sector_num %"PRId64" nb_sectors %d is_write %d acb %p" "\n" , bs, sector_num, nb_sectors, is_write, acb);
    }
}
static inline void trace_bdrv_co_do_copy_on_readv(void * bs, int64_t sector_num, int nb_sectors, int64_t cluster_sector_num, int cluster_nb_sectors)
{
    bool _state = trace_event_get_state(TRACE_BDRV_CO_DO_COPY_ON_READV);
    if (_state) {
        fprintf(stderr, "bdrv_co_do_copy_on_readv " "bs %p sector_num %"PRId64" nb_sectors %d cluster_sector_num %"PRId64" cluster_nb_sectors %d" "\n" , bs, sector_num, nb_sectors, cluster_sector_num, cluster_nb_sectors);
    }
}
static inline void trace_stream_one_iteration(void * s, int64_t sector_num, int nb_sectors, int is_allocated)
{
    bool _state = trace_event_get_state(TRACE_STREAM_ONE_ITERATION);
    if (_state) {
        fprintf(stderr, "stream_one_iteration " "s %p sector_num %"PRId64" nb_sectors %d is_allocated %d" "\n" , s, sector_num, nb_sectors, is_allocated);
    }
}
static inline void trace_stream_start(void * bs, void * base, void * s, void * co, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_STREAM_START);
    if (_state) {
        fprintf(stderr, "stream_start " "bs %p base %p s %p co %p opaque %p" "\n" , bs, base, s, co, opaque);
    }
}
static inline void trace_commit_one_iteration(void * s, int64_t sector_num, int nb_sectors, int is_allocated)
{
    bool _state = trace_event_get_state(TRACE_COMMIT_ONE_ITERATION);
    if (_state) {
        fprintf(stderr, "commit_one_iteration " "s %p sector_num %"PRId64" nb_sectors %d is_allocated %d" "\n" , s, sector_num, nb_sectors, is_allocated);
    }
}
static inline void trace_commit_start(void * bs, void * base, void * top, void * s, void * co, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_COMMIT_START);
    if (_state) {
        fprintf(stderr, "commit_start " "bs %p base %p top %p s %p co %p opaque %p" "\n" , bs, base, top, s, co, opaque);
    }
}
static inline void trace_mirror_start(void * bs, void * s, void * co, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_START);
    if (_state) {
        fprintf(stderr, "mirror_start " "bs %p s %p co %p opaque %p" "\n" , bs, s, co, opaque);
    }
}
static inline void trace_mirror_restart_iter(void * s, int64_t cnt)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_RESTART_ITER);
    if (_state) {
        fprintf(stderr, "mirror_restart_iter " "s %p dirty count %"PRId64 "\n" , s, cnt);
    }
}
static inline void trace_mirror_before_flush(void * s)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_BEFORE_FLUSH);
    if (_state) {
        fprintf(stderr, "mirror_before_flush " "s %p" "\n" , s);
    }
}
static inline void trace_mirror_before_drain(void * s, int64_t cnt)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_BEFORE_DRAIN);
    if (_state) {
        fprintf(stderr, "mirror_before_drain " "s %p dirty count %"PRId64 "\n" , s, cnt);
    }
}
static inline void trace_mirror_before_sleep(void * s, int64_t cnt, int synced)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_BEFORE_SLEEP);
    if (_state) {
        fprintf(stderr, "mirror_before_sleep " "s %p dirty count %"PRId64" synced %d" "\n" , s, cnt, synced);
    }
}
static inline void trace_mirror_one_iteration(void * s, int64_t sector_num, int nb_sectors)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_ONE_ITERATION);
    if (_state) {
        fprintf(stderr, "mirror_one_iteration " "s %p sector_num %"PRId64" nb_sectors %d" "\n" , s, sector_num, nb_sectors);
    }
}
static inline void trace_mirror_iteration_done(void * s, int64_t sector_num, int nb_sectors, int ret)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_ITERATION_DONE);
    if (_state) {
        fprintf(stderr, "mirror_iteration_done " "s %p sector_num %"PRId64" nb_sectors %d ret %d" "\n" , s, sector_num, nb_sectors, ret);
    }
}
static inline void trace_mirror_yield(void * s, int64_t cnt, int buf_free_count, int in_flight)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_YIELD);
    if (_state) {
        fprintf(stderr, "mirror_yield " "s %p dirty count %"PRId64" free buffers %d in_flight %d" "\n" , s, cnt, buf_free_count, in_flight);
    }
}
static inline void trace_mirror_yield_in_flight(void * s, int64_t sector_num, int in_flight)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_YIELD_IN_FLIGHT);
    if (_state) {
        fprintf(stderr, "mirror_yield_in_flight " "s %p sector_num %"PRId64" in_flight %d" "\n" , s, sector_num, in_flight);
    }
}
static inline void trace_mirror_yield_buf_busy(void * s, int nb_chunks, int in_flight)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_YIELD_BUF_BUSY);
    if (_state) {
        fprintf(stderr, "mirror_yield_buf_busy " "s %p requested chunks %d in_flight %d" "\n" , s, nb_chunks, in_flight);
    }
}
static inline void trace_mirror_break_buf_busy(void * s, int nb_chunks, int in_flight)
{
    bool _state = trace_event_get_state(TRACE_MIRROR_BREAK_BUF_BUSY);
    if (_state) {
        fprintf(stderr, "mirror_break_buf_busy " "s %p requested chunks %d in_flight %d" "\n" , s, nb_chunks, in_flight);
    }
}
static inline void trace_backup_do_cow_enter(void * job, int64_t start, int64_t sector_num, int nb_sectors)
{
    bool _state = trace_event_get_state(TRACE_BACKUP_DO_COW_ENTER);
    if (_state) {
        fprintf(stderr, "backup_do_cow_enter " "job %p start %"PRId64" sector_num %"PRId64" nb_sectors %d" "\n" , job, start, sector_num, nb_sectors);
    }
}
static inline void trace_backup_do_cow_return(void * job, int64_t sector_num, int nb_sectors, int ret)
{
    bool _state = trace_event_get_state(TRACE_BACKUP_DO_COW_RETURN);
    if (_state) {
        fprintf(stderr, "backup_do_cow_return " "job %p sector_num %"PRId64" nb_sectors %d ret %d" "\n" , job, sector_num, nb_sectors, ret);
    }
}
static inline void trace_backup_do_cow_skip(void * job, int64_t start)
{
    bool _state = trace_event_get_state(TRACE_BACKUP_DO_COW_SKIP);
    if (_state) {
        fprintf(stderr, "backup_do_cow_skip " "job %p start %"PRId64 "\n" , job, start);
    }
}
static inline void trace_backup_do_cow_process(void * job, int64_t start)
{
    bool _state = trace_event_get_state(TRACE_BACKUP_DO_COW_PROCESS);
    if (_state) {
        fprintf(stderr, "backup_do_cow_process " "job %p start %"PRId64 "\n" , job, start);
    }
}
static inline void trace_backup_do_cow_read_fail(void * job, int64_t start, int ret)
{
    bool _state = trace_event_get_state(TRACE_BACKUP_DO_COW_READ_FAIL);
    if (_state) {
        fprintf(stderr, "backup_do_cow_read_fail " "job %p start %"PRId64" ret %d" "\n" , job, start, ret);
    }
}
static inline void trace_backup_do_cow_write_fail(void * job, int64_t start, int ret)
{
    bool _state = trace_event_get_state(TRACE_BACKUP_DO_COW_WRITE_FAIL);
    if (_state) {
        fprintf(stderr, "backup_do_cow_write_fail " "job %p start %"PRId64" ret %d" "\n" , job, start, ret);
    }
}
static inline void trace_qmp_block_job_cancel(void * job)
{
    bool _state = trace_event_get_state(TRACE_QMP_BLOCK_JOB_CANCEL);
    if (_state) {
        fprintf(stderr, "qmp_block_job_cancel " "job %p" "\n" , job);
    }
}
static inline void trace_qmp_block_job_pause(void * job)
{
    bool _state = trace_event_get_state(TRACE_QMP_BLOCK_JOB_PAUSE);
    if (_state) {
        fprintf(stderr, "qmp_block_job_pause " "job %p" "\n" , job);
    }
}
static inline void trace_qmp_block_job_resume(void * job)
{
    bool _state = trace_event_get_state(TRACE_QMP_BLOCK_JOB_RESUME);
    if (_state) {
        fprintf(stderr, "qmp_block_job_resume " "job %p" "\n" , job);
    }
}
static inline void trace_qmp_block_job_complete(void * job)
{
    bool _state = trace_event_get_state(TRACE_QMP_BLOCK_JOB_COMPLETE);
    if (_state) {
        fprintf(stderr, "qmp_block_job_complete " "job %p" "\n" , job);
    }
}
static inline void trace_block_job_cb(void * bs, void * job, int ret)
{
    bool _state = trace_event_get_state(TRACE_BLOCK_JOB_CB);
    if (_state) {
        fprintf(stderr, "block_job_cb " "bs %p job %p ret %d" "\n" , bs, job, ret);
    }
}
static inline void trace_qmp_block_stream(void * bs, void * job)
{
    bool _state = trace_event_get_state(TRACE_QMP_BLOCK_STREAM);
    if (_state) {
        fprintf(stderr, "qmp_block_stream " "bs %p job %p" "\n" , bs, job);
    }
}
static inline void trace_virtio_blk_req_complete(void * req, int status)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_REQ_COMPLETE);
    if (_state) {
        fprintf(stderr, "virtio_blk_req_complete " "req %p status %d" "\n" , req, status);
    }
}
static inline void trace_virtio_blk_rw_complete(void * req, int ret)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_RW_COMPLETE);
    if (_state) {
        fprintf(stderr, "virtio_blk_rw_complete " "req %p ret %d" "\n" , req, ret);
    }
}
static inline void trace_virtio_blk_handle_write(void * req, uint64_t sector, size_t nsectors)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_WRITE);
    if (_state) {
        fprintf(stderr, "virtio_blk_handle_write " "req %p sector %"PRIu64" nsectors %zu" "\n" , req, sector, nsectors);
    }
}
static inline void trace_virtio_blk_handle_read(void * req, uint64_t sector, size_t nsectors)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_HANDLE_READ);
    if (_state) {
        fprintf(stderr, "virtio_blk_handle_read " "req %p sector %"PRIu64" nsectors %zu" "\n" , req, sector, nsectors);
    }
}
static inline void trace_virtio_blk_data_plane_start(void * s)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_DATA_PLANE_START);
    if (_state) {
        fprintf(stderr, "virtio_blk_data_plane_start " "dataplane %p" "\n" , s);
    }
}
static inline void trace_virtio_blk_data_plane_stop(void * s)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_DATA_PLANE_STOP);
    if (_state) {
        fprintf(stderr, "virtio_blk_data_plane_stop " "dataplane %p" "\n" , s);
    }
}
static inline void trace_virtio_blk_data_plane_process_request(void * s, unsigned int out_num, unsigned int in_num, unsigned int head)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_DATA_PLANE_PROCESS_REQUEST);
    if (_state) {
        fprintf(stderr, "virtio_blk_data_plane_process_request " "dataplane %p out_num %u in_num %u head %u" "\n" , s, out_num, in_num, head);
    }
}
static inline void trace_virtio_blk_data_plane_complete_request(void * s, unsigned int head, int ret)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_BLK_DATA_PLANE_COMPLETE_REQUEST);
    if (_state) {
        fprintf(stderr, "virtio_blk_data_plane_complete_request " "dataplane %p head %u ret %d" "\n" , s, head, ret);
    }
}
static inline void trace_vring_setup(uint64_t physical, void * desc, void * avail, void * used)
{
    bool _state = trace_event_get_state(TRACE_VRING_SETUP);
    if (_state) {
        fprintf(stderr, "vring_setup " "vring physical %#"PRIx64" desc %p avail %p used %p" "\n" , physical, desc, avail, used);
    }
}
static inline void trace_thread_pool_submit(void * pool, void * req, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_THREAD_POOL_SUBMIT);
    if (_state) {
        fprintf(stderr, "thread_pool_submit " "pool %p req %p opaque %p" "\n" , pool, req, opaque);
    }
}
static inline void trace_thread_pool_complete(void * pool, void * req, void * opaque, int ret)
{
    bool _state = trace_event_get_state(TRACE_THREAD_POOL_COMPLETE);
    if (_state) {
        fprintf(stderr, "thread_pool_complete " "pool %p req %p opaque %p ret %d" "\n" , pool, req, opaque, ret);
    }
}
static inline void trace_thread_pool_cancel(void * req, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_THREAD_POOL_CANCEL);
    if (_state) {
        fprintf(stderr, "thread_pool_cancel " "req %p opaque %p" "\n" , req, opaque);
    }
}
static inline void trace_paio_submit(void * acb, void * opaque, int64_t sector_num, int nb_sectors, int type)
{
    bool _state = trace_event_get_state(TRACE_PAIO_SUBMIT);
    if (_state) {
        fprintf(stderr, "paio_submit " "acb %p opaque %p sector_num %"PRId64" nb_sectors %d type %d" "\n" , acb, opaque, sector_num, nb_sectors, type);
    }
}
static inline void trace_cpu_in(unsigned int addr, unsigned int val)
{
    bool _state = trace_event_get_state(TRACE_CPU_IN);
    if (_state) {
        fprintf(stderr, "cpu_in " "addr %#x value %u" "\n" , addr, val);
    }
}
static inline void trace_cpu_out(unsigned int addr, unsigned int val)
{
    bool _state = trace_event_get_state(TRACE_CPU_OUT);
    if (_state) {
        fprintf(stderr, "cpu_out " "addr %#x value %u" "\n" , addr, val);
    }
}
static inline void trace_balloon_event(void * opaque, unsigned long addr)
{
    bool _state = trace_event_get_state(TRACE_BALLOON_EVENT);
    if (_state) {
        fprintf(stderr, "balloon_event " "opaque %p addr %lu" "\n" , opaque, addr);
    }
}
static inline void trace_cpu_set_apic_base(uint64_t val)
{
    bool _state = trace_event_get_state(TRACE_CPU_SET_APIC_BASE);
    if (_state) {
        fprintf(stderr, "cpu_set_apic_base " "%016"PRIx64 "\n" , val);
    }
}
static inline void trace_cpu_get_apic_base(uint64_t val)
{
    bool _state = trace_event_get_state(TRACE_CPU_GET_APIC_BASE);
    if (_state) {
        fprintf(stderr, "cpu_get_apic_base " "%016"PRIx64 "\n" , val);
    }
}
static inline void trace_apic_report_irq_delivered(int apic_irq_delivered)
{
    bool _state = trace_event_get_state(TRACE_APIC_REPORT_IRQ_DELIVERED);
    if (_state) {
        fprintf(stderr, "apic_report_irq_delivered " "coalescing %d" "\n" , apic_irq_delivered);
    }
}
static inline void trace_apic_reset_irq_delivered(int apic_irq_delivered)
{
    bool _state = trace_event_get_state(TRACE_APIC_RESET_IRQ_DELIVERED);
    if (_state) {
        fprintf(stderr, "apic_reset_irq_delivered " "old coalescing %d" "\n" , apic_irq_delivered);
    }
}
static inline void trace_apic_get_irq_delivered(int apic_irq_delivered)
{
    bool _state = trace_event_get_state(TRACE_APIC_GET_IRQ_DELIVERED);
    if (_state) {
        fprintf(stderr, "apic_get_irq_delivered " "returning coalescing %d" "\n" , apic_irq_delivered);
    }
}
static inline void trace_apic_local_deliver(int vector, uint32_t lvt)
{
    bool _state = trace_event_get_state(TRACE_APIC_LOCAL_DELIVER);
    if (_state) {
        fprintf(stderr, "apic_local_deliver " "vector %d delivery mode %d" "\n" , vector, lvt);
    }
}
static inline void trace_apic_deliver_irq(uint8_t dest, uint8_t dest_mode, uint8_t delivery_mode, uint8_t vector_num, uint8_t trigger_mode)
{
    bool _state = trace_event_get_state(TRACE_APIC_DELIVER_IRQ);
    if (_state) {
        fprintf(stderr, "apic_deliver_irq " "dest %d dest_mode %d delivery_mode %d vector %d trigger_mode %d" "\n" , dest, dest_mode, delivery_mode, vector_num, trigger_mode);
    }
}
static inline void trace_apic_mem_readl(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_APIC_MEM_READL);
    if (_state) {
        fprintf(stderr, "apic_mem_readl " "%"PRIx64" = %08x" "\n" , addr, val);
    }
}
static inline void trace_apic_mem_writel(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_APIC_MEM_WRITEL);
    if (_state) {
        fprintf(stderr, "apic_mem_writel " "%"PRIx64" = %08x" "\n" , addr, val);
    }
}
static inline void trace_cs4231_mem_readl_dreg(uint32_t reg, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_CS4231_MEM_READL_DREG);
    if (_state) {
        fprintf(stderr, "cs4231_mem_readl_dreg " "read dreg %d: 0x%02x" "\n" , reg, ret);
    }
}
static inline void trace_cs4231_mem_readl_reg(uint32_t reg, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_CS4231_MEM_READL_REG);
    if (_state) {
        fprintf(stderr, "cs4231_mem_readl_reg " "read reg %d: 0x%08x" "\n" , reg, ret);
    }
}
static inline void trace_cs4231_mem_writel_reg(uint32_t reg, uint32_t old, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_CS4231_MEM_WRITEL_REG);
    if (_state) {
        fprintf(stderr, "cs4231_mem_writel_reg " "write reg %d: 0x%08x -> 0x%08x" "\n" , reg, old, val);
    }
}
static inline void trace_cs4231_mem_writel_dreg(uint32_t reg, uint32_t old, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_CS4231_MEM_WRITEL_DREG);
    if (_state) {
        fprintf(stderr, "cs4231_mem_writel_dreg " "write dreg %d: 0x%02x -> 0x%02x" "\n" , reg, old, val);
    }
}
static inline void trace_nvram_read(uint32_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_NVRAM_READ);
    if (_state) {
        fprintf(stderr, "nvram_read " "read addr %d: 0x%02x" "\n" , addr, ret);
    }
}
static inline void trace_nvram_write(uint32_t addr, uint32_t old, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_NVRAM_WRITE);
    if (_state) {
        fprintf(stderr, "nvram_write " "write addr %d: 0x%02x -> 0x%02x" "\n" , addr, old, val);
    }
}
static inline void trace_ecc_mem_writel_mer(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_WRITEL_MER);
    if (_state) {
        fprintf(stderr, "ecc_mem_writel_mer " "Write memory enable %08x" "\n" , val);
    }
}
static inline void trace_ecc_mem_writel_mdr(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_WRITEL_MDR);
    if (_state) {
        fprintf(stderr, "ecc_mem_writel_mdr " "Write memory delay %08x" "\n" , val);
    }
}
static inline void trace_ecc_mem_writel_mfsr(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_WRITEL_MFSR);
    if (_state) {
        fprintf(stderr, "ecc_mem_writel_mfsr " "Write memory fault status %08x" "\n" , val);
    }
}
static inline void trace_ecc_mem_writel_vcr(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_WRITEL_VCR);
    if (_state) {
        fprintf(stderr, "ecc_mem_writel_vcr " "Write slot configuration %08x" "\n" , val);
    }
}
static inline void trace_ecc_mem_writel_dr(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_WRITEL_DR);
    if (_state) {
        fprintf(stderr, "ecc_mem_writel_dr " "Write diagnostic %08x" "\n" , val);
    }
}
static inline void trace_ecc_mem_writel_ecr0(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_WRITEL_ECR0);
    if (_state) {
        fprintf(stderr, "ecc_mem_writel_ecr0 " "Write event count 1 %08x" "\n" , val);
    }
}
static inline void trace_ecc_mem_writel_ecr1(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_WRITEL_ECR1);
    if (_state) {
        fprintf(stderr, "ecc_mem_writel_ecr1 " "Write event count 2 %08x" "\n" , val);
    }
}
static inline void trace_ecc_mem_readl_mer(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_MER);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_mer " "Read memory enable %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_mdr(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_MDR);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_mdr " "Read memory delay %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_mfsr(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_MFSR);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_mfsr " "Read memory fault status %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_vcr(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_VCR);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_vcr " "Read slot configuration %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_mfar0(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_MFAR0);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_mfar0 " "Read memory fault address 0 %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_mfar1(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_MFAR1);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_mfar1 " "Read memory fault address 1 %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_dr(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_DR);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_dr " "Read diagnostic %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_ecr0(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_ECR0);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_ecr0 " "Read event count 1 %08x" "\n" , ret);
    }
}
static inline void trace_ecc_mem_readl_ecr1(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_MEM_READL_ECR1);
    if (_state) {
        fprintf(stderr, "ecc_mem_readl_ecr1 " "Read event count 2 %08x" "\n" , ret);
    }
}
static inline void trace_ecc_diag_mem_writeb(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ECC_DIAG_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "ecc_diag_mem_writeb " "Write diagnostic %"PRId64" = %02x" "\n" , addr, val);
    }
}
static inline void trace_ecc_diag_mem_readb(uint64_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ECC_DIAG_MEM_READB);
    if (_state) {
        fprintf(stderr, "ecc_diag_mem_readb " "Read diagnostic %"PRId64"= %02x" "\n" , addr, ret);
    }
}
static inline void trace_fw_cfg_write(void * s, uint8_t value)
{
    bool _state = trace_event_get_state(TRACE_FW_CFG_WRITE);
    if (_state) {
        fprintf(stderr, "fw_cfg_write " "%p %d" "\n" , s, value);
    }
}
static inline void trace_fw_cfg_select(void * s, uint16_t key, int ret)
{
    bool _state = trace_event_get_state(TRACE_FW_CFG_SELECT);
    if (_state) {
        fprintf(stderr, "fw_cfg_select " "%p key %d = %d" "\n" , s, key, ret);
    }
}
static inline void trace_fw_cfg_read(void * s, uint8_t ret)
{
    bool _state = trace_event_get_state(TRACE_FW_CFG_READ);
    if (_state) {
        fprintf(stderr, "fw_cfg_read " "%p = %d" "\n" , s, ret);
    }
}
static inline void trace_fw_cfg_add_file_dupe(void * s, char * name)
{
    bool _state = trace_event_get_state(TRACE_FW_CFG_ADD_FILE_DUPE);
    if (_state) {
        fprintf(stderr, "fw_cfg_add_file_dupe " "%p %s" "\n" , s, name);
    }
}
static inline void trace_fw_cfg_add_file(void * s, int index, char * name, size_t len)
{
    bool _state = trace_event_get_state(TRACE_FW_CFG_ADD_FILE);
    if (_state) {
        fprintf(stderr, "fw_cfg_add_file " "%p #%d: %s (%zd bytes)" "\n" , s, index, name, len);
    }
}
static inline void trace_hd_geometry_lchs_guess(void * bs, int cyls, int heads, int secs)
{
    bool _state = trace_event_get_state(TRACE_HD_GEOMETRY_LCHS_GUESS);
    if (_state) {
        fprintf(stderr, "hd_geometry_lchs_guess " "bs %p LCHS %d %d %d" "\n" , bs, cyls, heads, secs);
    }
}
static inline void trace_hd_geometry_guess(void * bs, uint32_t cyls, uint32_t heads, uint32_t secs, int trans)
{
    bool _state = trace_event_get_state(TRACE_HD_GEOMETRY_GUESS);
    if (_state) {
        fprintf(stderr, "hd_geometry_guess " "bs %p CHS %u %u %u trans %d" "\n" , bs, cyls, heads, secs, trans);
    }
}
static inline void trace_jazz_led_read(uint64_t addr, uint8_t val)
{
    bool _state = trace_event_get_state(TRACE_JAZZ_LED_READ);
    if (_state) {
        fprintf(stderr, "jazz_led_read " "read addr=0x%"PRIx64": 0x%x" "\n" , addr, val);
    }
}
static inline void trace_jazz_led_write(uint64_t addr, uint8_t new)
{
    bool _state = trace_event_get_state(TRACE_JAZZ_LED_WRITE);
    if (_state) {
        fprintf(stderr, "jazz_led_write " "write addr=0x%"PRIx64": 0x%x" "\n" , addr, new);
    }
}
static inline void trace_lance_mem_readw(uint64_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_LANCE_MEM_READW);
    if (_state) {
        fprintf(stderr, "lance_mem_readw " "addr=%"PRIx64"val=0x%04x" "\n" , addr, ret);
    }
}
static inline void trace_lance_mem_writew(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_LANCE_MEM_WRITEW);
    if (_state) {
        fprintf(stderr, "lance_mem_writew " "addr=%"PRIx64"val=0x%04x" "\n" , addr, val);
    }
}
static inline void trace_slavio_intctl_mem_readl(uint32_t cpu, uint64_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTL_MEM_READL);
    if (_state) {
        fprintf(stderr, "slavio_intctl_mem_readl " "read cpu %d reg 0x%"PRIx64" = %x" "\n" , cpu, addr, ret);
    }
}
static inline void trace_slavio_intctl_mem_writel(uint32_t cpu, uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTL_MEM_WRITEL);
    if (_state) {
        fprintf(stderr, "slavio_intctl_mem_writel " "write cpu %d reg 0x%"PRIx64" = %x" "\n" , cpu, addr, val);
    }
}
static inline void trace_slavio_intctl_mem_writel_clear(uint32_t cpu, uint32_t val, uint32_t intreg_pending)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTL_MEM_WRITEL_CLEAR);
    if (_state) {
        fprintf(stderr, "slavio_intctl_mem_writel_clear " "Cleared cpu %d irq mask %x, curmask %x" "\n" , cpu, val, intreg_pending);
    }
}
static inline void trace_slavio_intctl_mem_writel_set(uint32_t cpu, uint32_t val, uint32_t intreg_pending)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTL_MEM_WRITEL_SET);
    if (_state) {
        fprintf(stderr, "slavio_intctl_mem_writel_set " "Set cpu %d irq mask %x, curmask %x" "\n" , cpu, val, intreg_pending);
    }
}
static inline void trace_slavio_intctlm_mem_readl(uint64_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTLM_MEM_READL);
    if (_state) {
        fprintf(stderr, "slavio_intctlm_mem_readl " "read system reg 0x%"PRIx64" = %x" "\n" , addr, ret);
    }
}
static inline void trace_slavio_intctlm_mem_writel(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTLM_MEM_WRITEL);
    if (_state) {
        fprintf(stderr, "slavio_intctlm_mem_writel " "write system reg 0x%"PRIx64" = %x" "\n" , addr, val);
    }
}
static inline void trace_slavio_intctlm_mem_writel_enable(uint32_t val, uint32_t intregm_disabled)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTLM_MEM_WRITEL_ENABLE);
    if (_state) {
        fprintf(stderr, "slavio_intctlm_mem_writel_enable " "Enabled master irq mask %x, curmask %x" "\n" , val, intregm_disabled);
    }
}
static inline void trace_slavio_intctlm_mem_writel_disable(uint32_t val, uint32_t intregm_disabled)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTLM_MEM_WRITEL_DISABLE);
    if (_state) {
        fprintf(stderr, "slavio_intctlm_mem_writel_disable " "Disabled master irq mask %x, curmask %x" "\n" , val, intregm_disabled);
    }
}
static inline void trace_slavio_intctlm_mem_writel_target(uint32_t cpu)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_INTCTLM_MEM_WRITEL_TARGET);
    if (_state) {
        fprintf(stderr, "slavio_intctlm_mem_writel_target " "Set master irq cpu %d" "\n" , cpu);
    }
}
static inline void trace_slavio_check_interrupts(uint32_t pending, uint32_t intregm_disabled)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_CHECK_INTERRUPTS);
    if (_state) {
        fprintf(stderr, "slavio_check_interrupts " "pending %x disabled %x" "\n" , pending, intregm_disabled);
    }
}
static inline void trace_slavio_set_irq(uint32_t target_cpu, int irq, uint32_t pil, int level)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_SET_IRQ);
    if (_state) {
        fprintf(stderr, "slavio_set_irq " "Set cpu %d irq %d -> pil %d level %d" "\n" , target_cpu, irq, pil, level);
    }
}
static inline void trace_slavio_set_timer_irq_cpu(int cpu, int level)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_SET_TIMER_IRQ_CPU);
    if (_state) {
        fprintf(stderr, "slavio_set_timer_irq_cpu " "Set cpu %d local timer level %d" "\n" , cpu, level);
    }
}
static inline void trace_slavio_misc_update_irq_raise(void)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_MISC_UPDATE_IRQ_RAISE);
    if (_state) {
        fprintf(stderr, "slavio_misc_update_irq_raise " "Raise IRQ" "\n" );
    }
}
static inline void trace_slavio_misc_update_irq_lower(void)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_MISC_UPDATE_IRQ_LOWER);
    if (_state) {
        fprintf(stderr, "slavio_misc_update_irq_lower " "Lower IRQ" "\n" );
    }
}
static inline void trace_slavio_set_power_fail(int power_failing, uint8_t config)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_SET_POWER_FAIL);
    if (_state) {
        fprintf(stderr, "slavio_set_power_fail " "Power fail: %d, config: %d" "\n" , power_failing, config);
    }
}
static inline void trace_slavio_cfg_mem_writeb(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_CFG_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "slavio_cfg_mem_writeb " "Write config %02x" "\n" , val);
    }
}
static inline void trace_slavio_cfg_mem_readb(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_CFG_MEM_READB);
    if (_state) {
        fprintf(stderr, "slavio_cfg_mem_readb " "Read config %02x" "\n" , ret);
    }
}
static inline void trace_slavio_diag_mem_writeb(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_DIAG_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "slavio_diag_mem_writeb " "Write diag %02x" "\n" , val);
    }
}
static inline void trace_slavio_diag_mem_readb(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_DIAG_MEM_READB);
    if (_state) {
        fprintf(stderr, "slavio_diag_mem_readb " "Read diag %02x" "\n" , ret);
    }
}
static inline void trace_slavio_mdm_mem_writeb(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_MDM_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "slavio_mdm_mem_writeb " "Write modem control %02x" "\n" , val);
    }
}
static inline void trace_slavio_mdm_mem_readb(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_MDM_MEM_READB);
    if (_state) {
        fprintf(stderr, "slavio_mdm_mem_readb " "Read modem control %02x" "\n" , ret);
    }
}
static inline void trace_slavio_aux1_mem_writeb(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_AUX1_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "slavio_aux1_mem_writeb " "Write aux1 %02x" "\n" , val);
    }
}
static inline void trace_slavio_aux1_mem_readb(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_AUX1_MEM_READB);
    if (_state) {
        fprintf(stderr, "slavio_aux1_mem_readb " "Read aux1 %02x" "\n" , ret);
    }
}
static inline void trace_slavio_aux2_mem_writeb(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_AUX2_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "slavio_aux2_mem_writeb " "Write aux2 %02x" "\n" , val);
    }
}
static inline void trace_slavio_aux2_mem_readb(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_AUX2_MEM_READB);
    if (_state) {
        fprintf(stderr, "slavio_aux2_mem_readb " "Read aux2 %02x" "\n" , ret);
    }
}
static inline void trace_apc_mem_writeb(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_APC_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "apc_mem_writeb " "Write power management %02x" "\n" , val);
    }
}
static inline void trace_apc_mem_readb(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_APC_MEM_READB);
    if (_state) {
        fprintf(stderr, "apc_mem_readb " "Read power management %02x" "\n" , ret);
    }
}
static inline void trace_slavio_sysctrl_mem_writel(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_SYSCTRL_MEM_WRITEL);
    if (_state) {
        fprintf(stderr, "slavio_sysctrl_mem_writel " "Write system control %08x" "\n" , val);
    }
}
static inline void trace_slavio_sysctrl_mem_readl(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_SYSCTRL_MEM_READL);
    if (_state) {
        fprintf(stderr, "slavio_sysctrl_mem_readl " "Read system control %08x" "\n" , ret);
    }
}
static inline void trace_slavio_led_mem_writew(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_LED_MEM_WRITEW);
    if (_state) {
        fprintf(stderr, "slavio_led_mem_writew " "Write diagnostic LED %04x" "\n" , val);
    }
}
static inline void trace_slavio_led_mem_readw(uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_LED_MEM_READW);
    if (_state) {
        fprintf(stderr, "slavio_led_mem_readw " "Read diagnostic LED %04x" "\n" , ret);
    }
}
static inline void trace_slavio_timer_get_out(uint64_t limit, uint32_t counthigh, uint32_t count)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_GET_OUT);
    if (_state) {
        fprintf(stderr, "slavio_timer_get_out " "limit %"PRIx64" count %x%08x" "\n" , limit, counthigh, count);
    }
}
static inline void trace_slavio_timer_irq(uint32_t counthigh, uint32_t count)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_IRQ);
    if (_state) {
        fprintf(stderr, "slavio_timer_irq " "callback: count %x%08x" "\n" , counthigh, count);
    }
}
static inline void trace_slavio_timer_mem_readl_invalid(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_READL_INVALID);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_readl_invalid " "invalid read address %"PRIx64 "\n" , addr);
    }
}
static inline void trace_slavio_timer_mem_readl(uint64_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_READL);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_readl " "read %"PRIx64" = %08x" "\n" , addr, ret);
    }
}
static inline void trace_slavio_timer_mem_writel(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel " "write %"PRIx64" = %08x" "\n" , addr, val);
    }
}
static inline void trace_slavio_timer_mem_writel_limit(unsigned int timer_index, uint64_t count)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_LIMIT);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_limit " "processor %d user timer set to %016"PRIx64 "\n" , timer_index, count);
    }
}
static inline void trace_slavio_timer_mem_writel_counter_invalid(void)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_COUNTER_INVALID);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_counter_invalid " "not user timer" "\n" );
    }
}
static inline void trace_slavio_timer_mem_writel_status_start(unsigned int timer_index)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_START);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_status_start " "processor %d user timer started" "\n" , timer_index);
    }
}
static inline void trace_slavio_timer_mem_writel_status_stop(unsigned int timer_index)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_STATUS_STOP);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_status_stop " "processor %d user timer stopped" "\n" , timer_index);
    }
}
static inline void trace_slavio_timer_mem_writel_mode_user(unsigned int timer_index)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_USER);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_mode_user " "processor %d changed from counter to user timer" "\n" , timer_index);
    }
}
static inline void trace_slavio_timer_mem_writel_mode_counter(unsigned int timer_index)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_COUNTER);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_mode_counter " "processor %d changed from user timer to counter" "\n" , timer_index);
    }
}
static inline void trace_slavio_timer_mem_writel_mode_invalid(void)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_MODE_INVALID);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_mode_invalid " "not system timer" "\n" );
    }
}
static inline void trace_slavio_timer_mem_writel_invalid(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_SLAVIO_TIMER_MEM_WRITEL_INVALID);
    if (_state) {
        fprintf(stderr, "slavio_timer_mem_writel_invalid " "invalid write address %"PRIx64 "\n" , addr);
    }
}
static inline void trace_ledma_memory_read(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_LEDMA_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "ledma_memory_read " "DMA read addr 0x%"PRIx64 "\n" , addr);
    }
}
static inline void trace_ledma_memory_write(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_LEDMA_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "ledma_memory_write " "DMA write addr 0x%"PRIx64 "\n" , addr);
    }
}
static inline void trace_sparc32_dma_set_irq_raise(void)
{
    bool _state = trace_event_get_state(TRACE_SPARC32_DMA_SET_IRQ_RAISE);
    if (_state) {
        fprintf(stderr, "sparc32_dma_set_irq_raise " "Raise IRQ" "\n" );
    }
}
static inline void trace_sparc32_dma_set_irq_lower(void)
{
    bool _state = trace_event_get_state(TRACE_SPARC32_DMA_SET_IRQ_LOWER);
    if (_state) {
        fprintf(stderr, "sparc32_dma_set_irq_lower " "Lower IRQ" "\n" );
    }
}
static inline void trace_espdma_memory_read(uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_ESPDMA_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "espdma_memory_read " "DMA read addr 0x%08x" "\n" , addr);
    }
}
static inline void trace_espdma_memory_write(uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_ESPDMA_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "espdma_memory_write " "DMA write addr 0x%08x" "\n" , addr);
    }
}
static inline void trace_sparc32_dma_mem_readl(uint64_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SPARC32_DMA_MEM_READL);
    if (_state) {
        fprintf(stderr, "sparc32_dma_mem_readl " "read dmareg %"PRIx64": 0x%08x" "\n" , addr, ret);
    }
}
static inline void trace_sparc32_dma_mem_writel(uint64_t addr, uint32_t old, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SPARC32_DMA_MEM_WRITEL);
    if (_state) {
        fprintf(stderr, "sparc32_dma_mem_writel " "write dmareg %"PRIx64": 0x%08x -> 0x%08x" "\n" , addr, old, val);
    }
}
static inline void trace_sparc32_dma_enable_raise(void)
{
    bool _state = trace_event_get_state(TRACE_SPARC32_DMA_ENABLE_RAISE);
    if (_state) {
        fprintf(stderr, "sparc32_dma_enable_raise " "Raise DMA enable" "\n" );
    }
}
static inline void trace_sparc32_dma_enable_lower(void)
{
    bool _state = trace_event_get_state(TRACE_SPARC32_DMA_ENABLE_LOWER);
    if (_state) {
        fprintf(stderr, "sparc32_dma_enable_lower " "Lower DMA enable" "\n" );
    }
}
static inline void trace_sun4m_cpu_interrupt(unsigned int level)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_CPU_INTERRUPT);
    if (_state) {
        fprintf(stderr, "sun4m_cpu_interrupt " "Set CPU IRQ %d" "\n" , level);
    }
}
static inline void trace_sun4m_cpu_reset_interrupt(unsigned int level)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_CPU_RESET_INTERRUPT);
    if (_state) {
        fprintf(stderr, "sun4m_cpu_reset_interrupt " "Reset CPU IRQ %d" "\n" , level);
    }
}
static inline void trace_sun4m_cpu_set_irq_raise(int level)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_CPU_SET_IRQ_RAISE);
    if (_state) {
        fprintf(stderr, "sun4m_cpu_set_irq_raise " "Raise CPU IRQ %d" "\n" , level);
    }
}
static inline void trace_sun4m_cpu_set_irq_lower(int level)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_CPU_SET_IRQ_LOWER);
    if (_state) {
        fprintf(stderr, "sun4m_cpu_set_irq_lower " "Lower CPU IRQ %d" "\n" , level);
    }
}
static inline void trace_sun4m_iommu_mem_readl(uint64_t addr, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_MEM_READL);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_mem_readl " "read reg[%"PRIx64"] = %x" "\n" , addr, ret);
    }
}
static inline void trace_sun4m_iommu_mem_writel(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_MEM_WRITEL);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_mem_writel " "write reg[%"PRIx64"] = %x" "\n" , addr, val);
    }
}
static inline void trace_sun4m_iommu_mem_writel_ctrl(uint64_t iostart)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_MEM_WRITEL_CTRL);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_mem_writel_ctrl " "iostart = %"PRIx64 "\n" , iostart);
    }
}
static inline void trace_sun4m_iommu_mem_writel_tlbflush(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_MEM_WRITEL_TLBFLUSH);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_mem_writel_tlbflush " "tlb flush %x" "\n" , val);
    }
}
static inline void trace_sun4m_iommu_mem_writel_pgflush(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_MEM_WRITEL_PGFLUSH);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_mem_writel_pgflush " "page flush %x" "\n" , val);
    }
}
static inline void trace_sun4m_iommu_page_get_flags(uint64_t pa, uint64_t iopte, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_PAGE_GET_FLAGS);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_page_get_flags " "get flags addr %"PRIx64" => pte %"PRIx64", *pte = %x" "\n" , pa, iopte, ret);
    }
}
static inline void trace_sun4m_iommu_translate_pa(uint64_t addr, uint64_t pa, uint32_t iopte)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_TRANSLATE_PA);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_translate_pa " "xlate dva %"PRIx64" => pa %"PRIx64" iopte = %x" "\n" , addr, pa, iopte);
    }
}
static inline void trace_sun4m_iommu_bad_addr(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_SUN4M_IOMMU_BAD_ADDR);
    if (_state) {
        fprintf(stderr, "sun4m_iommu_bad_addr " "bad addr %"PRIx64 "\n" , addr);
    }
}
static inline void trace_usb_packet_state_change(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    bool _state = trace_event_get_state(TRACE_USB_PACKET_STATE_CHANGE);
    if (_state) {
        fprintf(stderr, "usb_packet_state_change " "bus %d, port %s, ep %d, packet %p, state %s -> %s" "\n" , bus, port, ep, p, o, n);
    }
}
static inline void trace_usb_packet_state_fault(int bus, const char * port, int ep, void * p, const char * o, const char * n)
{
    bool _state = trace_event_get_state(TRACE_USB_PACKET_STATE_FAULT);
    if (_state) {
        fprintf(stderr, "usb_packet_state_fault " "bus %d, port %s, ep %d, packet %p, state %s, expected %s" "\n" , bus, port, ep, p, o, n);
    }
}
static inline void trace_usb_port_claim(int bus, const char * port)
{
    bool _state = trace_event_get_state(TRACE_USB_PORT_CLAIM);
    if (_state) {
        fprintf(stderr, "usb_port_claim " "bus %d, port %s" "\n" , bus, port);
    }
}
static inline void trace_usb_port_attach(int bus, const char * port, const char * devspeed, const char * portspeed)
{
    bool _state = trace_event_get_state(TRACE_USB_PORT_ATTACH);
    if (_state) {
        fprintf(stderr, "usb_port_attach " "bus %d, port %s, devspeed %s, portspeed %s" "\n" , bus, port, devspeed, portspeed);
    }
}
static inline void trace_usb_port_detach(int bus, const char * port)
{
    bool _state = trace_event_get_state(TRACE_USB_PORT_DETACH);
    if (_state) {
        fprintf(stderr, "usb_port_detach " "bus %d, port %s" "\n" , bus, port);
    }
}
static inline void trace_usb_port_release(int bus, const char * port)
{
    bool _state = trace_event_get_state(TRACE_USB_PORT_RELEASE);
    if (_state) {
        fprintf(stderr, "usb_port_release " "bus %d, port %s" "\n" , bus, port);
    }
}
static inline void trace_usb_ehci_reset(void)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_RESET);
    if (_state) {
        fprintf(stderr, "usb_ehci_reset " "=== RESET ===" "\n" );
    }
}
static inline void trace_usb_ehci_opreg_read(uint32_t addr, const char * str, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_OPREG_READ);
    if (_state) {
        fprintf(stderr, "usb_ehci_opreg_read " "rd mmio %04x [%s] = %x" "\n" , addr, str, val);
    }
}
static inline void trace_usb_ehci_opreg_write(uint32_t addr, const char * str, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_OPREG_WRITE);
    if (_state) {
        fprintf(stderr, "usb_ehci_opreg_write " "wr mmio %04x [%s] = %x" "\n" , addr, str, val);
    }
}
static inline void trace_usb_ehci_opreg_change(uint32_t addr, const char * str, uint32_t new, uint32_t old)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_OPREG_CHANGE);
    if (_state) {
        fprintf(stderr, "usb_ehci_opreg_change " "ch mmio %04x [%s] = %x (old: %x)" "\n" , addr, str, new, old);
    }
}
static inline void trace_usb_ehci_portsc_read(uint32_t addr, uint32_t port, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_PORTSC_READ);
    if (_state) {
        fprintf(stderr, "usb_ehci_portsc_read " "rd mmio %04x [port %d] = %x" "\n" , addr, port, val);
    }
}
static inline void trace_usb_ehci_portsc_write(uint32_t addr, uint32_t port, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_PORTSC_WRITE);
    if (_state) {
        fprintf(stderr, "usb_ehci_portsc_write " "wr mmio %04x [port %d] = %x" "\n" , addr, port, val);
    }
}
static inline void trace_usb_ehci_portsc_change(uint32_t addr, uint32_t port, uint32_t new, uint32_t old)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_PORTSC_CHANGE);
    if (_state) {
        fprintf(stderr, "usb_ehci_portsc_change " "ch mmio %04x [port %d] = %x (old: %x)" "\n" , addr, port, new, old);
    }
}
static inline void trace_usb_ehci_usbsts(const char * sts, int state)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_USBSTS);
    if (_state) {
        fprintf(stderr, "usb_ehci_usbsts " "usbsts %s %d" "\n" , sts, state);
    }
}
static inline void trace_usb_ehci_state(const char * schedule, const char * state)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_STATE);
    if (_state) {
        fprintf(stderr, "usb_ehci_state " "%s schedule %s" "\n" , schedule, state);
    }
}
static inline void trace_usb_ehci_qh_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t c_qtd, uint32_t n_qtd, uint32_t a_qtd)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_QH_PTRS);
    if (_state) {
        fprintf(stderr, "usb_ehci_qh_ptrs " "q %p - QH @ %08x: next %08x qtds %08x,%08x,%08x" "\n" , q, addr, nxt, c_qtd, n_qtd, a_qtd);
    }
}
static inline void trace_usb_ehci_qh_fields(uint32_t addr, int rl, int mplen, int eps, int ep, int devaddr)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_QH_FIELDS);
    if (_state) {
        fprintf(stderr, "usb_ehci_qh_fields " "QH @ %08x - rl %d, mplen %d, eps %d, ep %d, dev %d" "\n" , addr, rl, mplen, eps, ep, devaddr);
    }
}
static inline void trace_usb_ehci_qh_bits(uint32_t addr, int c, int h, int dtc, int i)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_QH_BITS);
    if (_state) {
        fprintf(stderr, "usb_ehci_qh_bits " "QH @ %08x - c %d, h %d, dtc %d, i %d" "\n" , addr, c, h, dtc, i);
    }
}
static inline void trace_usb_ehci_qtd_ptrs(void * q, uint32_t addr, uint32_t nxt, uint32_t altnext)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_QTD_PTRS);
    if (_state) {
        fprintf(stderr, "usb_ehci_qtd_ptrs " "q %p - QTD @ %08x: next %08x altnext %08x" "\n" , q, addr, nxt, altnext);
    }
}
static inline void trace_usb_ehci_qtd_fields(uint32_t addr, int tbytes, int cpage, int cerr, int pid)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_QTD_FIELDS);
    if (_state) {
        fprintf(stderr, "usb_ehci_qtd_fields " "QTD @ %08x - tbytes %d, cpage %d, cerr %d, pid %d" "\n" , addr, tbytes, cpage, cerr, pid);
    }
}
static inline void trace_usb_ehci_qtd_bits(uint32_t addr, int ioc, int active, int halt, int babble, int xacterr)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_QTD_BITS);
    if (_state) {
        fprintf(stderr, "usb_ehci_qtd_bits " "QTD @ %08x - ioc %d, active %d, halt %d, babble %d, xacterr %d" "\n" , addr, ioc, active, halt, babble, xacterr);
    }
}
static inline void trace_usb_ehci_itd(uint32_t addr, uint32_t nxt, uint32_t mplen, uint32_t mult, uint32_t ep, uint32_t devaddr)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_ITD);
    if (_state) {
        fprintf(stderr, "usb_ehci_itd " "ITD @ %08x: next %08x - mplen %d, mult %d, ep %d, dev %d" "\n" , addr, nxt, mplen, mult, ep, devaddr);
    }
}
static inline void trace_usb_ehci_sitd(uint32_t addr, uint32_t nxt, uint32_t active)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_SITD);
    if (_state) {
        fprintf(stderr, "usb_ehci_sitd " "ITD @ %08x: next %08x - active %d" "\n" , addr, nxt, active);
    }
}
static inline void trace_usb_ehci_port_attach(uint32_t port, const char * owner, const char * device)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_PORT_ATTACH);
    if (_state) {
        fprintf(stderr, "usb_ehci_port_attach " "attach port #%d, owner %s, device %s" "\n" , port, owner, device);
    }
}
static inline void trace_usb_ehci_port_detach(uint32_t port, const char * owner)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_PORT_DETACH);
    if (_state) {
        fprintf(stderr, "usb_ehci_port_detach " "detach port #%d, owner %s" "\n" , port, owner);
    }
}
static inline void trace_usb_ehci_port_reset(uint32_t port, int enable)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_PORT_RESET);
    if (_state) {
        fprintf(stderr, "usb_ehci_port_reset " "reset port #%d - %d" "\n" , port, enable);
    }
}
static inline void trace_usb_ehci_queue_action(void * q, const char * action)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_QUEUE_ACTION);
    if (_state) {
        fprintf(stderr, "usb_ehci_queue_action " "q %p: %s" "\n" , q, action);
    }
}
static inline void trace_usb_ehci_packet_action(void * q, void * p, const char * action)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_PACKET_ACTION);
    if (_state) {
        fprintf(stderr, "usb_ehci_packet_action " "q %p p %p: %s" "\n" , q, p, action);
    }
}
static inline void trace_usb_ehci_irq(uint32_t level, uint32_t frindex, uint32_t sts, uint32_t mask)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_IRQ);
    if (_state) {
        fprintf(stderr, "usb_ehci_irq " "level %d, frindex 0x%04x, sts 0x%x, mask 0x%x" "\n" , level, frindex, sts, mask);
    }
}
static inline void trace_usb_ehci_guest_bug(const char * reason)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_GUEST_BUG);
    if (_state) {
        fprintf(stderr, "usb_ehci_guest_bug " "%s" "\n" , reason);
    }
}
static inline void trace_usb_ehci_doorbell_ring(void)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_DOORBELL_RING);
    if (_state) {
        fprintf(stderr, "usb_ehci_doorbell_ring " "" "\n" );
    }
}
static inline void trace_usb_ehci_doorbell_ack(void)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_DOORBELL_ACK);
    if (_state) {
        fprintf(stderr, "usb_ehci_doorbell_ack " "" "\n" );
    }
}
static inline void trace_usb_ehci_dma_error(void)
{
    bool _state = trace_event_get_state(TRACE_USB_EHCI_DMA_ERROR);
    if (_state) {
        fprintf(stderr, "usb_ehci_dma_error " "" "\n" );
    }
}
static inline void trace_usb_uhci_reset(void)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_RESET);
    if (_state) {
        fprintf(stderr, "usb_uhci_reset " "=== RESET ===" "\n" );
    }
}
static inline void trace_usb_uhci_schedule_start(void)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_SCHEDULE_START);
    if (_state) {
        fprintf(stderr, "usb_uhci_schedule_start " "" "\n" );
    }
}
static inline void trace_usb_uhci_schedule_stop(void)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_SCHEDULE_STOP);
    if (_state) {
        fprintf(stderr, "usb_uhci_schedule_stop " "" "\n" );
    }
}
static inline void trace_usb_uhci_frame_start(uint32_t num)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_FRAME_START);
    if (_state) {
        fprintf(stderr, "usb_uhci_frame_start " "nr %d" "\n" , num);
    }
}
static inline void trace_usb_uhci_frame_stop_bandwidth(void)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_FRAME_STOP_BANDWIDTH);
    if (_state) {
        fprintf(stderr, "usb_uhci_frame_stop_bandwidth " "" "\n" );
    }
}
static inline void trace_usb_uhci_frame_loop_stop_idle(void)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_FRAME_LOOP_STOP_IDLE);
    if (_state) {
        fprintf(stderr, "usb_uhci_frame_loop_stop_idle " "" "\n" );
    }
}
static inline void trace_usb_uhci_frame_loop_continue(void)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_FRAME_LOOP_CONTINUE);
    if (_state) {
        fprintf(stderr, "usb_uhci_frame_loop_continue " "" "\n" );
    }
}
static inline void trace_usb_uhci_mmio_readw(uint32_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_MMIO_READW);
    if (_state) {
        fprintf(stderr, "usb_uhci_mmio_readw " "addr 0x%04x, ret 0x%04x" "\n" , addr, val);
    }
}
static inline void trace_usb_uhci_mmio_writew(uint32_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_MMIO_WRITEW);
    if (_state) {
        fprintf(stderr, "usb_uhci_mmio_writew " "addr 0x%04x, val 0x%04x" "\n" , addr, val);
    }
}
static inline void trace_usb_uhci_queue_add(uint32_t token)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_QUEUE_ADD);
    if (_state) {
        fprintf(stderr, "usb_uhci_queue_add " "token 0x%x" "\n" , token);
    }
}
static inline void trace_usb_uhci_queue_del(uint32_t token, const char * reason)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_QUEUE_DEL);
    if (_state) {
        fprintf(stderr, "usb_uhci_queue_del " "token 0x%x: %s" "\n" , token, reason);
    }
}
static inline void trace_usb_uhci_packet_add(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_ADD);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_add " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_link_async(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_LINK_ASYNC);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_link_async " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_unlink_async(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_UNLINK_ASYNC);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_unlink_async " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_cancel(uint32_t token, uint32_t addr, int done)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_CANCEL);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_cancel " "token 0x%x, td 0x%x, done %d" "\n" , token, addr, done);
    }
}
static inline void trace_usb_uhci_packet_complete_success(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_SUCCESS);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_complete_success " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_complete_shortxfer(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_SHORTXFER);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_complete_shortxfer " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_complete_stall(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_STALL);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_complete_stall " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_complete_babble(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_BABBLE);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_complete_babble " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_complete_error(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_COMPLETE_ERROR);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_complete_error " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_packet_del(uint32_t token, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_PACKET_DEL);
    if (_state) {
        fprintf(stderr, "usb_uhci_packet_del " "token 0x%x, td 0x%x" "\n" , token, addr);
    }
}
static inline void trace_usb_uhci_qh_load(uint32_t qh)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_QH_LOAD);
    if (_state) {
        fprintf(stderr, "usb_uhci_qh_load " "qh 0x%x" "\n" , qh);
    }
}
static inline void trace_usb_uhci_td_load(uint32_t qh, uint32_t td, uint32_t ctrl, uint32_t token)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_TD_LOAD);
    if (_state) {
        fprintf(stderr, "usb_uhci_td_load " "qh 0x%x, td 0x%x, ctrl 0x%x, token 0x%x" "\n" , qh, td, ctrl, token);
    }
}
static inline void trace_usb_uhci_td_queue(uint32_t td, uint32_t ctrl, uint32_t token)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_TD_QUEUE);
    if (_state) {
        fprintf(stderr, "usb_uhci_td_queue " "td 0x%x, ctrl 0x%x, token 0x%x" "\n" , td, ctrl, token);
    }
}
static inline void trace_usb_uhci_td_nextqh(uint32_t qh, uint32_t td)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_TD_NEXTQH);
    if (_state) {
        fprintf(stderr, "usb_uhci_td_nextqh " "qh 0x%x, td 0x%x" "\n" , qh, td);
    }
}
static inline void trace_usb_uhci_td_async(uint32_t qh, uint32_t td)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_TD_ASYNC);
    if (_state) {
        fprintf(stderr, "usb_uhci_td_async " "qh 0x%x, td 0x%x" "\n" , qh, td);
    }
}
static inline void trace_usb_uhci_td_complete(uint32_t qh, uint32_t td)
{
    bool _state = trace_event_get_state(TRACE_USB_UHCI_TD_COMPLETE);
    if (_state) {
        fprintf(stderr, "usb_uhci_td_complete " "qh 0x%x, td 0x%x" "\n" , qh, td);
    }
}
static inline void trace_usb_xhci_reset(void)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_RESET);
    if (_state) {
        fprintf(stderr, "usb_xhci_reset " "=== RESET ===" "\n" );
    }
}
static inline void trace_usb_xhci_run(void)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_RUN);
    if (_state) {
        fprintf(stderr, "usb_xhci_run " "" "\n" );
    }
}
static inline void trace_usb_xhci_stop(void)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_STOP);
    if (_state) {
        fprintf(stderr, "usb_xhci_stop " "" "\n" );
    }
}
static inline void trace_usb_xhci_cap_read(uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_CAP_READ);
    if (_state) {
        fprintf(stderr, "usb_xhci_cap_read " "off 0x%04x, ret 0x%08x" "\n" , off, val);
    }
}
static inline void trace_usb_xhci_oper_read(uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_OPER_READ);
    if (_state) {
        fprintf(stderr, "usb_xhci_oper_read " "off 0x%04x, ret 0x%08x" "\n" , off, val);
    }
}
static inline void trace_usb_xhci_port_read(uint32_t port, uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_PORT_READ);
    if (_state) {
        fprintf(stderr, "usb_xhci_port_read " "port %d, off 0x%04x, ret 0x%08x" "\n" , port, off, val);
    }
}
static inline void trace_usb_xhci_runtime_read(uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_RUNTIME_READ);
    if (_state) {
        fprintf(stderr, "usb_xhci_runtime_read " "off 0x%04x, ret 0x%08x" "\n" , off, val);
    }
}
static inline void trace_usb_xhci_doorbell_read(uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_DOORBELL_READ);
    if (_state) {
        fprintf(stderr, "usb_xhci_doorbell_read " "off 0x%04x, ret 0x%08x" "\n" , off, val);
    }
}
static inline void trace_usb_xhci_oper_write(uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_OPER_WRITE);
    if (_state) {
        fprintf(stderr, "usb_xhci_oper_write " "off 0x%04x, val 0x%08x" "\n" , off, val);
    }
}
static inline void trace_usb_xhci_port_write(uint32_t port, uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_PORT_WRITE);
    if (_state) {
        fprintf(stderr, "usb_xhci_port_write " "port %d, off 0x%04x, val 0x%08x" "\n" , port, off, val);
    }
}
static inline void trace_usb_xhci_runtime_write(uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_RUNTIME_WRITE);
    if (_state) {
        fprintf(stderr, "usb_xhci_runtime_write " "off 0x%04x, val 0x%08x" "\n" , off, val);
    }
}
static inline void trace_usb_xhci_doorbell_write(uint32_t off, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_DOORBELL_WRITE);
    if (_state) {
        fprintf(stderr, "usb_xhci_doorbell_write " "off 0x%04x, val 0x%08x" "\n" , off, val);
    }
}
static inline void trace_usb_xhci_irq_intx(uint32_t level)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_IRQ_INTX);
    if (_state) {
        fprintf(stderr, "usb_xhci_irq_intx " "level %d" "\n" , level);
    }
}
static inline void trace_usb_xhci_irq_msi(uint32_t nr)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_IRQ_MSI);
    if (_state) {
        fprintf(stderr, "usb_xhci_irq_msi " "nr %d" "\n" , nr);
    }
}
static inline void trace_usb_xhci_irq_msix(uint32_t nr)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX);
    if (_state) {
        fprintf(stderr, "usb_xhci_irq_msix " "nr %d" "\n" , nr);
    }
}
static inline void trace_usb_xhci_irq_msix_use(uint32_t nr)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX_USE);
    if (_state) {
        fprintf(stderr, "usb_xhci_irq_msix_use " "nr %d" "\n" , nr);
    }
}
static inline void trace_usb_xhci_irq_msix_unuse(uint32_t nr)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_IRQ_MSIX_UNUSE);
    if (_state) {
        fprintf(stderr, "usb_xhci_irq_msix_unuse " "nr %d" "\n" , nr);
    }
}
static inline void trace_usb_xhci_queue_event(uint32_t vector, uint32_t idx, const char * trb, const char * evt, uint64_t param, uint32_t status, uint32_t control)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_QUEUE_EVENT);
    if (_state) {
        fprintf(stderr, "usb_xhci_queue_event " "v %d, idx %d, %s, %s, p %016" PRIx64 ", s %08x, c 0x%08x" "\n" , vector, idx, trb, evt, param, status, control);
    }
}
static inline void trace_usb_xhci_fetch_trb(uint64_t addr, const char * name, uint64_t param, uint32_t status, uint32_t control)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_FETCH_TRB);
    if (_state) {
        fprintf(stderr, "usb_xhci_fetch_trb " "addr %016" PRIx64 ", %s, p %016" PRIx64 ", s %08x, c 0x%08x" "\n" , addr, name, param, status, control);
    }
}
static inline void trace_usb_xhci_port_reset(uint32_t port)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_PORT_RESET);
    if (_state) {
        fprintf(stderr, "usb_xhci_port_reset " "port %d" "\n" , port);
    }
}
static inline void trace_usb_xhci_port_link(uint32_t port, uint32_t pls)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_PORT_LINK);
    if (_state) {
        fprintf(stderr, "usb_xhci_port_link " "port %d, pls %d" "\n" , port, pls);
    }
}
static inline void trace_usb_xhci_port_notify(uint32_t port, uint32_t pls)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_PORT_NOTIFY);
    if (_state) {
        fprintf(stderr, "usb_xhci_port_notify " "port %d, bits %x" "\n" , port, pls);
    }
}
static inline void trace_usb_xhci_slot_enable(uint32_t slotid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_SLOT_ENABLE);
    if (_state) {
        fprintf(stderr, "usb_xhci_slot_enable " "slotid %d" "\n" , slotid);
    }
}
static inline void trace_usb_xhci_slot_disable(uint32_t slotid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_SLOT_DISABLE);
    if (_state) {
        fprintf(stderr, "usb_xhci_slot_disable " "slotid %d" "\n" , slotid);
    }
}
static inline void trace_usb_xhci_slot_address(uint32_t slotid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_SLOT_ADDRESS);
    if (_state) {
        fprintf(stderr, "usb_xhci_slot_address " "slotid %d" "\n" , slotid);
    }
}
static inline void trace_usb_xhci_slot_configure(uint32_t slotid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_SLOT_CONFIGURE);
    if (_state) {
        fprintf(stderr, "usb_xhci_slot_configure " "slotid %d" "\n" , slotid);
    }
}
static inline void trace_usb_xhci_slot_evaluate(uint32_t slotid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_SLOT_EVALUATE);
    if (_state) {
        fprintf(stderr, "usb_xhci_slot_evaluate " "slotid %d" "\n" , slotid);
    }
}
static inline void trace_usb_xhci_slot_reset(uint32_t slotid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_SLOT_RESET);
    if (_state) {
        fprintf(stderr, "usb_xhci_slot_reset " "slotid %d" "\n" , slotid);
    }
}
static inline void trace_usb_xhci_ep_enable(uint32_t slotid, uint32_t epid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_EP_ENABLE);
    if (_state) {
        fprintf(stderr, "usb_xhci_ep_enable " "slotid %d, epid %d" "\n" , slotid, epid);
    }
}
static inline void trace_usb_xhci_ep_disable(uint32_t slotid, uint32_t epid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_EP_DISABLE);
    if (_state) {
        fprintf(stderr, "usb_xhci_ep_disable " "slotid %d, epid %d" "\n" , slotid, epid);
    }
}
static inline void trace_usb_xhci_ep_set_dequeue(uint32_t slotid, uint32_t epid, uint32_t streamid, uint64_t param)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_EP_SET_DEQUEUE);
    if (_state) {
        fprintf(stderr, "usb_xhci_ep_set_dequeue " "slotid %d, epid %d, streamid %d, ptr %016" PRIx64 "\n" , slotid, epid, streamid, param);
    }
}
static inline void trace_usb_xhci_ep_kick(uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_EP_KICK);
    if (_state) {
        fprintf(stderr, "usb_xhci_ep_kick " "slotid %d, epid %d, streamid %d" "\n" , slotid, epid, streamid);
    }
}
static inline void trace_usb_xhci_ep_stop(uint32_t slotid, uint32_t epid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_EP_STOP);
    if (_state) {
        fprintf(stderr, "usb_xhci_ep_stop " "slotid %d, epid %d" "\n" , slotid, epid);
    }
}
static inline void trace_usb_xhci_ep_reset(uint32_t slotid, uint32_t epid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_EP_RESET);
    if (_state) {
        fprintf(stderr, "usb_xhci_ep_reset " "slotid %d, epid %d" "\n" , slotid, epid);
    }
}
static inline void trace_usb_xhci_xfer_start(void * xfer, uint32_t slotid, uint32_t epid, uint32_t streamid)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_XFER_START);
    if (_state) {
        fprintf(stderr, "usb_xhci_xfer_start " "%p: slotid %d, epid %d, streamid %d" "\n" , xfer, slotid, epid, streamid);
    }
}
static inline void trace_usb_xhci_xfer_async(void * xfer)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_XFER_ASYNC);
    if (_state) {
        fprintf(stderr, "usb_xhci_xfer_async " "%p" "\n" , xfer);
    }
}
static inline void trace_usb_xhci_xfer_nak(void * xfer)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_XFER_NAK);
    if (_state) {
        fprintf(stderr, "usb_xhci_xfer_nak " "%p" "\n" , xfer);
    }
}
static inline void trace_usb_xhci_xfer_retry(void * xfer)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_XFER_RETRY);
    if (_state) {
        fprintf(stderr, "usb_xhci_xfer_retry " "%p" "\n" , xfer);
    }
}
static inline void trace_usb_xhci_xfer_success(void * xfer, uint32_t bytes)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_XFER_SUCCESS);
    if (_state) {
        fprintf(stderr, "usb_xhci_xfer_success " "%p: len %d" "\n" , xfer, bytes);
    }
}
static inline void trace_usb_xhci_xfer_error(void * xfer, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_XFER_ERROR);
    if (_state) {
        fprintf(stderr, "usb_xhci_xfer_error " "%p: ret %d" "\n" , xfer, ret);
    }
}
static inline void trace_usb_xhci_unimplemented(const char * item, int nr)
{
    bool _state = trace_event_get_state(TRACE_USB_XHCI_UNIMPLEMENTED);
    if (_state) {
        fprintf(stderr, "usb_xhci_unimplemented " "%s (0x%x)" "\n" , item, nr);
    }
}
static inline void trace_usb_desc_device(int addr, int len, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_DESC_DEVICE);
    if (_state) {
        fprintf(stderr, "usb_desc_device " "dev %d query device, len %d, ret %d" "\n" , addr, len, ret);
    }
}
static inline void trace_usb_desc_device_qualifier(int addr, int len, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_DESC_DEVICE_QUALIFIER);
    if (_state) {
        fprintf(stderr, "usb_desc_device_qualifier " "dev %d query device qualifier, len %d, ret %d" "\n" , addr, len, ret);
    }
}
static inline void trace_usb_desc_config(int addr, int index, int len, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_DESC_CONFIG);
    if (_state) {
        fprintf(stderr, "usb_desc_config " "dev %d query config %d, len %d, ret %d" "\n" , addr, index, len, ret);
    }
}
static inline void trace_usb_desc_other_speed_config(int addr, int index, int len, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_DESC_OTHER_SPEED_CONFIG);
    if (_state) {
        fprintf(stderr, "usb_desc_other_speed_config " "dev %d query config %d, len %d, ret %d" "\n" , addr, index, len, ret);
    }
}
static inline void trace_usb_desc_string(int addr, int index, int len, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_DESC_STRING);
    if (_state) {
        fprintf(stderr, "usb_desc_string " "dev %d query string %d, len %d, ret %d" "\n" , addr, index, len, ret);
    }
}
static inline void trace_usb_desc_bos(int addr, int len, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_DESC_BOS);
    if (_state) {
        fprintf(stderr, "usb_desc_bos " "dev %d bos, len %d, ret %d" "\n" , addr, len, ret);
    }
}
static inline void trace_usb_set_addr(int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_SET_ADDR);
    if (_state) {
        fprintf(stderr, "usb_set_addr " "dev %d" "\n" , addr);
    }
}
static inline void trace_usb_set_config(int addr, int config, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_SET_CONFIG);
    if (_state) {
        fprintf(stderr, "usb_set_config " "dev %d, config %d, ret %d" "\n" , addr, config, ret);
    }
}
static inline void trace_usb_set_interface(int addr, int iface, int alt, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_SET_INTERFACE);
    if (_state) {
        fprintf(stderr, "usb_set_interface " "dev %d, interface %d, altsetting %d, ret %d" "\n" , addr, iface, alt, ret);
    }
}
static inline void trace_usb_clear_device_feature(int addr, int feature, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_CLEAR_DEVICE_FEATURE);
    if (_state) {
        fprintf(stderr, "usb_clear_device_feature " "dev %d, feature %d, ret %d" "\n" , addr, feature, ret);
    }
}
static inline void trace_usb_set_device_feature(int addr, int feature, int ret)
{
    bool _state = trace_event_get_state(TRACE_USB_SET_DEVICE_FEATURE);
    if (_state) {
        fprintf(stderr, "usb_set_device_feature " "dev %d, feature %d, ret %d" "\n" , addr, feature, ret);
    }
}
static inline void trace_usb_hub_reset(int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HUB_RESET);
    if (_state) {
        fprintf(stderr, "usb_hub_reset " "dev %d" "\n" , addr);
    }
}
static inline void trace_usb_hub_control(int addr, int request, int value, int index, int length)
{
    bool _state = trace_event_get_state(TRACE_USB_HUB_CONTROL);
    if (_state) {
        fprintf(stderr, "usb_hub_control " "dev %d, req 0x%x, value %d, index %d, langth %d" "\n" , addr, request, value, index, length);
    }
}
static inline void trace_usb_hub_get_port_status(int addr, int nr, int status, int changed)
{
    bool _state = trace_event_get_state(TRACE_USB_HUB_GET_PORT_STATUS);
    if (_state) {
        fprintf(stderr, "usb_hub_get_port_status " "dev %d, port %d, status 0x%x, changed 0x%x" "\n" , addr, nr, status, changed);
    }
}
static inline void trace_usb_hub_set_port_feature(int addr, int nr, const char * f)
{
    bool _state = trace_event_get_state(TRACE_USB_HUB_SET_PORT_FEATURE);
    if (_state) {
        fprintf(stderr, "usb_hub_set_port_feature " "dev %d, port %d, feature %s" "\n" , addr, nr, f);
    }
}
static inline void trace_usb_hub_clear_port_feature(int addr, int nr, const char * f)
{
    bool _state = trace_event_get_state(TRACE_USB_HUB_CLEAR_PORT_FEATURE);
    if (_state) {
        fprintf(stderr, "usb_hub_clear_port_feature " "dev %d, port %d, feature %s" "\n" , addr, nr, f);
    }
}
static inline void trace_usb_hub_attach(int addr, int nr)
{
    bool _state = trace_event_get_state(TRACE_USB_HUB_ATTACH);
    if (_state) {
        fprintf(stderr, "usb_hub_attach " "dev %d, port %d" "\n" , addr, nr);
    }
}
static inline void trace_usb_hub_detach(int addr, int nr)
{
    bool _state = trace_event_get_state(TRACE_USB_HUB_DETACH);
    if (_state) {
        fprintf(stderr, "usb_hub_detach " "dev %d, port %d" "\n" , addr, nr);
    }
}
static inline void trace_usb_uas_reset(int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_RESET);
    if (_state) {
        fprintf(stderr, "usb_uas_reset " "dev %d" "\n" , addr);
    }
}
static inline void trace_usb_uas_command(int addr, uint16_t tag, int lun, uint32_t lun64_1, uint32_t lun64_2)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_COMMAND);
    if (_state) {
        fprintf(stderr, "usb_uas_command " "dev %d, tag 0x%x, lun %d, lun64 %08x-%08x" "\n" , addr, tag, lun, lun64_1, lun64_2);
    }
}
static inline void trace_usb_uas_response(int addr, uint16_t tag, uint8_t code)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_RESPONSE);
    if (_state) {
        fprintf(stderr, "usb_uas_response " "dev %d, tag 0x%x, code 0x%x" "\n" , addr, tag, code);
    }
}
static inline void trace_usb_uas_sense(int addr, uint16_t tag, uint8_t status)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_SENSE);
    if (_state) {
        fprintf(stderr, "usb_uas_sense " "dev %d, tag 0x%x, status 0x%x" "\n" , addr, tag, status);
    }
}
static inline void trace_usb_uas_read_ready(int addr, uint16_t tag)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_READ_READY);
    if (_state) {
        fprintf(stderr, "usb_uas_read_ready " "dev %d, tag 0x%x" "\n" , addr, tag);
    }
}
static inline void trace_usb_uas_write_ready(int addr, uint16_t tag)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_WRITE_READY);
    if (_state) {
        fprintf(stderr, "usb_uas_write_ready " "dev %d, tag 0x%x" "\n" , addr, tag);
    }
}
static inline void trace_usb_uas_xfer_data(int addr, uint16_t tag, uint32_t copy, uint32_t uoff, uint32_t usize, uint32_t soff, uint32_t ssize)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_XFER_DATA);
    if (_state) {
        fprintf(stderr, "usb_uas_xfer_data " "dev %d, tag 0x%x, copy %d, usb-pkt %d/%d, scsi-buf %d/%d" "\n" , addr, tag, copy, uoff, usize, soff, ssize);
    }
}
static inline void trace_usb_uas_scsi_data(int addr, uint16_t tag, uint32_t bytes)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_SCSI_DATA);
    if (_state) {
        fprintf(stderr, "usb_uas_scsi_data " "dev %d, tag 0x%x, bytes %d" "\n" , addr, tag, bytes);
    }
}
static inline void trace_usb_uas_scsi_complete(int addr, uint16_t tag, uint32_t status, uint32_t resid)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_SCSI_COMPLETE);
    if (_state) {
        fprintf(stderr, "usb_uas_scsi_complete " "dev %d, tag 0x%x, status 0x%x, residue %d" "\n" , addr, tag, status, resid);
    }
}
static inline void trace_usb_uas_tmf_abort_task(int addr, uint16_t tag, uint16_t task_tag)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_TMF_ABORT_TASK);
    if (_state) {
        fprintf(stderr, "usb_uas_tmf_abort_task " "dev %d, tag 0x%x, task-tag 0x%x" "\n" , addr, tag, task_tag);
    }
}
static inline void trace_usb_uas_tmf_logical_unit_reset(int addr, uint16_t tag, int lun)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_TMF_LOGICAL_UNIT_RESET);
    if (_state) {
        fprintf(stderr, "usb_uas_tmf_logical_unit_reset " "dev %d, tag 0x%x, lun %d" "\n" , addr, tag, lun);
    }
}
static inline void trace_usb_uas_tmf_unsupported(int addr, uint16_t tag, uint32_t function)
{
    bool _state = trace_event_get_state(TRACE_USB_UAS_TMF_UNSUPPORTED);
    if (_state) {
        fprintf(stderr, "usb_uas_tmf_unsupported " "dev %d, tag 0x%x, function 0x%x" "\n" , addr, tag, function);
    }
}
static inline void trace_usb_host_open_started(int bus, int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_OPEN_STARTED);
    if (_state) {
        fprintf(stderr, "usb_host_open_started " "dev %d:%d" "\n" , bus, addr);
    }
}
static inline void trace_usb_host_open_success(int bus, int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_OPEN_SUCCESS);
    if (_state) {
        fprintf(stderr, "usb_host_open_success " "dev %d:%d" "\n" , bus, addr);
    }
}
static inline void trace_usb_host_open_failure(int bus, int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_OPEN_FAILURE);
    if (_state) {
        fprintf(stderr, "usb_host_open_failure " "dev %d:%d" "\n" , bus, addr);
    }
}
static inline void trace_usb_host_disconnect(int bus, int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_DISCONNECT);
    if (_state) {
        fprintf(stderr, "usb_host_disconnect " "dev %d:%d" "\n" , bus, addr);
    }
}
static inline void trace_usb_host_close(int bus, int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_CLOSE);
    if (_state) {
        fprintf(stderr, "usb_host_close " "dev %d:%d" "\n" , bus, addr);
    }
}
static inline void trace_usb_host_attach_kernel(int bus, int addr, int interface)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_ATTACH_KERNEL);
    if (_state) {
        fprintf(stderr, "usb_host_attach_kernel " "dev %d:%d, if %d" "\n" , bus, addr, interface);
    }
}
static inline void trace_usb_host_detach_kernel(int bus, int addr, int interface)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_DETACH_KERNEL);
    if (_state) {
        fprintf(stderr, "usb_host_detach_kernel " "dev %d:%d, if %d" "\n" , bus, addr, interface);
    }
}
static inline void trace_usb_host_set_address(int bus, int addr, int config)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_SET_ADDRESS);
    if (_state) {
        fprintf(stderr, "usb_host_set_address " "dev %d:%d, address %d" "\n" , bus, addr, config);
    }
}
static inline void trace_usb_host_set_config(int bus, int addr, int config)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_SET_CONFIG);
    if (_state) {
        fprintf(stderr, "usb_host_set_config " "dev %d:%d, config %d" "\n" , bus, addr, config);
    }
}
static inline void trace_usb_host_set_interface(int bus, int addr, int interface, int alt)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_SET_INTERFACE);
    if (_state) {
        fprintf(stderr, "usb_host_set_interface " "dev %d:%d, interface %d, alt %d" "\n" , bus, addr, interface, alt);
    }
}
static inline void trace_usb_host_claim_interfaces(int bus, int addr, int config, int nif)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_CLAIM_INTERFACES);
    if (_state) {
        fprintf(stderr, "usb_host_claim_interfaces " "dev %d:%d, config %d, nif %d" "\n" , bus, addr, config, nif);
    }
}
static inline void trace_usb_host_claim_interface(int bus, int addr, int config, int interface)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_CLAIM_INTERFACE);
    if (_state) {
        fprintf(stderr, "usb_host_claim_interface " "dev %d:%d, config %d, if %d" "\n" , bus, addr, config, interface);
    }
}
static inline void trace_usb_host_release_interfaces(int bus, int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_RELEASE_INTERFACES);
    if (_state) {
        fprintf(stderr, "usb_host_release_interfaces " "dev %d:%d" "\n" , bus, addr);
    }
}
static inline void trace_usb_host_release_interface(int bus, int addr, int interface)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_RELEASE_INTERFACE);
    if (_state) {
        fprintf(stderr, "usb_host_release_interface " "dev %d:%d, if %d" "\n" , bus, addr, interface);
    }
}
static inline void trace_usb_host_req_control(int bus, int addr, void * p, int req, int value, int index)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_REQ_CONTROL);
    if (_state) {
        fprintf(stderr, "usb_host_req_control " "dev %d:%d, packet %p, req 0x%x, value %d, index %d" "\n" , bus, addr, p, req, value, index);
    }
}
static inline void trace_usb_host_req_data(int bus, int addr, void * p, int in, int ep, int size)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_REQ_DATA);
    if (_state) {
        fprintf(stderr, "usb_host_req_data " "dev %d:%d, packet %p, in %d, ep %d, size %d" "\n" , bus, addr, p, in, ep, size);
    }
}
static inline void trace_usb_host_req_complete(int bus, int addr, void * p, int status, int length)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_REQ_COMPLETE);
    if (_state) {
        fprintf(stderr, "usb_host_req_complete " "dev %d:%d, packet %p, status %d, length %d" "\n" , bus, addr, p, status, length);
    }
}
static inline void trace_usb_host_req_emulated(int bus, int addr, void * p, int status)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_REQ_EMULATED);
    if (_state) {
        fprintf(stderr, "usb_host_req_emulated " "dev %d:%d, packet %p, status %d" "\n" , bus, addr, p, status);
    }
}
static inline void trace_usb_host_req_canceled(int bus, int addr, void * p)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_REQ_CANCELED);
    if (_state) {
        fprintf(stderr, "usb_host_req_canceled " "dev %d:%d, packet %p" "\n" , bus, addr, p);
    }
}
static inline void trace_usb_host_urb_submit(int bus, int addr, void * aurb, int length, int more)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_URB_SUBMIT);
    if (_state) {
        fprintf(stderr, "usb_host_urb_submit " "dev %d:%d, aurb %p, length %d, more %d" "\n" , bus, addr, aurb, length, more);
    }
}
static inline void trace_usb_host_urb_complete(int bus, int addr, void * aurb, int status, int length, int more)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_URB_COMPLETE);
    if (_state) {
        fprintf(stderr, "usb_host_urb_complete " "dev %d:%d, aurb %p, status %d, length %d, more %d" "\n" , bus, addr, aurb, status, length, more);
    }
}
static inline void trace_usb_host_urb_canceled(int bus, int addr, void * aurb)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_URB_CANCELED);
    if (_state) {
        fprintf(stderr, "usb_host_urb_canceled " "dev %d:%d, aurb %p" "\n" , bus, addr, aurb);
    }
}
static inline void trace_usb_host_ep_set_halt(int bus, int addr, int ep)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_EP_SET_HALT);
    if (_state) {
        fprintf(stderr, "usb_host_ep_set_halt " "dev %d:%d, ep %d" "\n" , bus, addr, ep);
    }
}
static inline void trace_usb_host_ep_clear_halt(int bus, int addr, int ep)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_EP_CLEAR_HALT);
    if (_state) {
        fprintf(stderr, "usb_host_ep_clear_halt " "dev %d:%d, ep %d" "\n" , bus, addr, ep);
    }
}
static inline void trace_usb_host_iso_start(int bus, int addr, int ep)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_ISO_START);
    if (_state) {
        fprintf(stderr, "usb_host_iso_start " "dev %d:%d, ep %d" "\n" , bus, addr, ep);
    }
}
static inline void trace_usb_host_iso_stop(int bus, int addr, int ep)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_ISO_STOP);
    if (_state) {
        fprintf(stderr, "usb_host_iso_stop " "dev %d:%d, ep %d" "\n" , bus, addr, ep);
    }
}
static inline void trace_usb_host_iso_out_of_bufs(int bus, int addr, int ep)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_ISO_OUT_OF_BUFS);
    if (_state) {
        fprintf(stderr, "usb_host_iso_out_of_bufs " "dev %d:%d, ep %d" "\n" , bus, addr, ep);
    }
}
static inline void trace_usb_host_iso_many_urbs(int bus, int addr, int count)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_ISO_MANY_URBS);
    if (_state) {
        fprintf(stderr, "usb_host_iso_many_urbs " "dev %d:%d, count %d" "\n" , bus, addr, count);
    }
}
static inline void trace_usb_host_reset(int bus, int addr)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_RESET);
    if (_state) {
        fprintf(stderr, "usb_host_reset " "dev %d:%d" "\n" , bus, addr);
    }
}
static inline void trace_usb_host_auto_scan_enabled(void)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_AUTO_SCAN_ENABLED);
    if (_state) {
        fprintf(stderr, "usb_host_auto_scan_enabled "  "\n" );
    }
}
static inline void trace_usb_host_auto_scan_disabled(void)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_AUTO_SCAN_DISABLED);
    if (_state) {
        fprintf(stderr, "usb_host_auto_scan_disabled "  "\n" );
    }
}
static inline void trace_usb_host_claim_port(int bus, int hub, int port)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_CLAIM_PORT);
    if (_state) {
        fprintf(stderr, "usb_host_claim_port " "bus %d, hub addr %d, port %d" "\n" , bus, hub, port);
    }
}
static inline void trace_usb_host_parse_device(int bus, int addr, int vendor, int product)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_PARSE_DEVICE);
    if (_state) {
        fprintf(stderr, "usb_host_parse_device " "dev %d:%d, id %04x:%04x" "\n" , bus, addr, vendor, product);
    }
}
static inline void trace_usb_host_parse_config(int bus, int addr, int value, int active)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_PARSE_CONFIG);
    if (_state) {
        fprintf(stderr, "usb_host_parse_config " "dev %d:%d, value %d, active %d" "\n" , bus, addr, value, active);
    }
}
static inline void trace_usb_host_parse_interface(int bus, int addr, int num, int alt, int active)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_PARSE_INTERFACE);
    if (_state) {
        fprintf(stderr, "usb_host_parse_interface " "dev %d:%d, num %d, alt %d, active %d" "\n" , bus, addr, num, alt, active);
    }
}
static inline void trace_usb_host_parse_endpoint(int bus, int addr, int ep, const char * dir, const char * type, int active)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_PARSE_ENDPOINT);
    if (_state) {
        fprintf(stderr, "usb_host_parse_endpoint " "dev %d:%d, ep %d, %s, %s, active %d" "\n" , bus, addr, ep, dir, type, active);
    }
}
static inline void trace_usb_host_parse_unknown(int bus, int addr, int len, int type)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_PARSE_UNKNOWN);
    if (_state) {
        fprintf(stderr, "usb_host_parse_unknown " "dev %d:%d, len %d, type %d" "\n" , bus, addr, len, type);
    }
}
static inline void trace_usb_host_parse_error(int bus, int addr, const char * errmsg)
{
    bool _state = trace_event_get_state(TRACE_USB_HOST_PARSE_ERROR);
    if (_state) {
        fprintf(stderr, "usb_host_parse_error " "dev %d:%d, msg %s" "\n" , bus, addr, errmsg);
    }
}
static inline void trace_scsi_req_alloc(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_ALLOC);
    if (_state) {
        fprintf(stderr, "scsi_req_alloc " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_scsi_req_cancel(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_CANCEL);
    if (_state) {
        fprintf(stderr, "scsi_req_cancel " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_scsi_req_data(int target, int lun, int tag, int len)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_DATA);
    if (_state) {
        fprintf(stderr, "scsi_req_data " "target %d lun %d tag %d len %d" "\n" , target, lun, tag, len);
    }
}
static inline void trace_scsi_req_data_canceled(int target, int lun, int tag, int len)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_DATA_CANCELED);
    if (_state) {
        fprintf(stderr, "scsi_req_data_canceled " "target %d lun %d tag %d len %d" "\n" , target, lun, tag, len);
    }
}
static inline void trace_scsi_req_dequeue(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_DEQUEUE);
    if (_state) {
        fprintf(stderr, "scsi_req_dequeue " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_scsi_req_continue(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_CONTINUE);
    if (_state) {
        fprintf(stderr, "scsi_req_continue " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_scsi_req_continue_canceled(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_CONTINUE_CANCELED);
    if (_state) {
        fprintf(stderr, "scsi_req_continue_canceled " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_scsi_req_parsed(int target, int lun, int tag, int cmd, int mode, int xfer)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_PARSED);
    if (_state) {
        fprintf(stderr, "scsi_req_parsed " "target %d lun %d tag %d command %d dir %d length %d" "\n" , target, lun, tag, cmd, mode, xfer);
    }
}
static inline void trace_scsi_req_parsed_lba(int target, int lun, int tag, int cmd, uint64_t lba)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_PARSED_LBA);
    if (_state) {
        fprintf(stderr, "scsi_req_parsed_lba " "target %d lun %d tag %d command %d lba %"PRIu64 "\n" , target, lun, tag, cmd, lba);
    }
}
static inline void trace_scsi_req_parse_bad(int target, int lun, int tag, int cmd)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_PARSE_BAD);
    if (_state) {
        fprintf(stderr, "scsi_req_parse_bad " "target %d lun %d tag %d command %d" "\n" , target, lun, tag, cmd);
    }
}
static inline void trace_scsi_req_build_sense(int target, int lun, int tag, int key, int asc, int ascq)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQ_BUILD_SENSE);
    if (_state) {
        fprintf(stderr, "scsi_req_build_sense " "target %d lun %d tag %d key %#02x asc %#02x ascq %#02x" "\n" , target, lun, tag, key, asc, ascq);
    }
}
static inline void trace_scsi_device_set_ua(int target, int lun, int key, int asc, int ascq)
{
    bool _state = trace_event_get_state(TRACE_SCSI_DEVICE_SET_UA);
    if (_state) {
        fprintf(stderr, "scsi_device_set_ua " "target %d lun %d key %#02x asc %#02x ascq %#02x" "\n" , target, lun, key, asc, ascq);
    }
}
static inline void trace_scsi_report_luns(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REPORT_LUNS);
    if (_state) {
        fprintf(stderr, "scsi_report_luns " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_scsi_inquiry(int target, int lun, int tag, int cdb1, int cdb2)
{
    bool _state = trace_event_get_state(TRACE_SCSI_INQUIRY);
    if (_state) {
        fprintf(stderr, "scsi_inquiry " "target %d lun %d tag %d page %#02x/%#02x" "\n" , target, lun, tag, cdb1, cdb2);
    }
}
static inline void trace_scsi_test_unit_ready(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_TEST_UNIT_READY);
    if (_state) {
        fprintf(stderr, "scsi_test_unit_ready " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_scsi_request_sense(int target, int lun, int tag)
{
    bool _state = trace_event_get_state(TRACE_SCSI_REQUEST_SENSE);
    if (_state) {
        fprintf(stderr, "scsi_request_sense " "target %d lun %d tag %d" "\n" , target, lun, tag);
    }
}
static inline void trace_vm_state_notify(int running, int reason)
{
    bool _state = trace_event_get_state(TRACE_VM_STATE_NOTIFY);
    if (_state) {
        fprintf(stderr, "vm_state_notify " "running %d reason %d" "\n" , running, reason);
    }
}
static inline void trace_load_file(const char * name, const char * path)
{
    bool _state = trace_event_get_state(TRACE_LOAD_FILE);
    if (_state) {
        fprintf(stderr, "load_file " "name %s location %s" "\n" , name, path);
    }
}
static inline void trace_runstate_set(int new_state)
{
    bool _state = trace_event_get_state(TRACE_RUNSTATE_SET);
    if (_state) {
        fprintf(stderr, "runstate_set " "new state %d" "\n" , new_state);
    }
}
static inline void trace_g_malloc(size_t size, void * ptr)
{
    bool _state = trace_event_get_state(TRACE_G_MALLOC);
    if (_state) {
        fprintf(stderr, "g_malloc " "size %zu ptr %p" "\n" , size, ptr);
    }
}
static inline void trace_g_realloc(void * ptr, size_t size, void * newptr)
{
    bool _state = trace_event_get_state(TRACE_G_REALLOC);
    if (_state) {
        fprintf(stderr, "g_realloc " "ptr %p size %zu newptr %p" "\n" , ptr, size, newptr);
    }
}
static inline void trace_g_free(void * ptr)
{
    bool _state = trace_event_get_state(TRACE_G_FREE);
    if (_state) {
        fprintf(stderr, "g_free " "ptr %p" "\n" , ptr);
    }
}
static inline void trace_qcow2_writev_start_req(void * co, int64_t sector, int nb_sectors)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_WRITEV_START_REQ);
    if (_state) {
        fprintf(stderr, "qcow2_writev_start_req " "co %p sector %" PRIx64 " nb_sectors %d" "\n" , co, sector, nb_sectors);
    }
}
static inline void trace_qcow2_writev_done_req(void * co, int ret)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_WRITEV_DONE_REQ);
    if (_state) {
        fprintf(stderr, "qcow2_writev_done_req " "co %p ret %d" "\n" , co, ret);
    }
}
static inline void trace_qcow2_writev_start_part(void * co)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_WRITEV_START_PART);
    if (_state) {
        fprintf(stderr, "qcow2_writev_start_part " "co %p" "\n" , co);
    }
}
static inline void trace_qcow2_writev_done_part(void * co, int cur_nr_sectors)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_WRITEV_DONE_PART);
    if (_state) {
        fprintf(stderr, "qcow2_writev_done_part " "co %p cur_nr_sectors %d" "\n" , co, cur_nr_sectors);
    }
}
static inline void trace_qcow2_writev_data(void * co, uint64_t offset)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_WRITEV_DATA);
    if (_state) {
        fprintf(stderr, "qcow2_writev_data " "co %p offset %" PRIx64 "\n" , co, offset);
    }
}
static inline void trace_qcow2_alloc_clusters_offset(void * co, uint64_t offset, int n_start, int n_end)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_ALLOC_CLUSTERS_OFFSET);
    if (_state) {
        fprintf(stderr, "qcow2_alloc_clusters_offset " "co %p offet %" PRIx64 " n_start %d n_end %d" "\n" , co, offset, n_start, n_end);
    }
}
static inline void trace_qcow2_handle_copied(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_HANDLE_COPIED);
    if (_state) {
        fprintf(stderr, "qcow2_handle_copied " "co %p guest_offet %" PRIx64 " host_offset %" PRIx64 " bytes %" PRIx64 "\n" , co, guest_offset, host_offset, bytes);
    }
}
static inline void trace_qcow2_handle_alloc(void * co, uint64_t guest_offset, uint64_t host_offset, uint64_t bytes)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_HANDLE_ALLOC);
    if (_state) {
        fprintf(stderr, "qcow2_handle_alloc " "co %p guest_offet %" PRIx64 " host_offset %" PRIx64 " bytes %" PRIx64 "\n" , co, guest_offset, host_offset, bytes);
    }
}
static inline void trace_qcow2_do_alloc_clusters_offset(void * co, uint64_t guest_offset, uint64_t host_offset, int nb_clusters)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_DO_ALLOC_CLUSTERS_OFFSET);
    if (_state) {
        fprintf(stderr, "qcow2_do_alloc_clusters_offset " "co %p guest_offet %" PRIx64 " host_offset %" PRIx64 " nb_clusters %d" "\n" , co, guest_offset, host_offset, nb_clusters);
    }
}
static inline void trace_qcow2_cluster_alloc_phys(void * co)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CLUSTER_ALLOC_PHYS);
    if (_state) {
        fprintf(stderr, "qcow2_cluster_alloc_phys " "co %p" "\n" , co);
    }
}
static inline void trace_qcow2_cluster_link_l2(void * co, int nb_clusters)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CLUSTER_LINK_L2);
    if (_state) {
        fprintf(stderr, "qcow2_cluster_link_l2 " "co %p nb_clusters %d" "\n" , co, nb_clusters);
    }
}
static inline void trace_qcow2_l2_allocate(void * bs, int l1_index)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE);
    if (_state) {
        fprintf(stderr, "qcow2_l2_allocate " "bs %p l1_index %d" "\n" , bs, l1_index);
    }
}
static inline void trace_qcow2_l2_allocate_get_empty(void * bs, int l1_index)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_GET_EMPTY);
    if (_state) {
        fprintf(stderr, "qcow2_l2_allocate_get_empty " "bs %p l1_index %d" "\n" , bs, l1_index);
    }
}
static inline void trace_qcow2_l2_allocate_write_l2(void * bs, int l1_index)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_WRITE_L2);
    if (_state) {
        fprintf(stderr, "qcow2_l2_allocate_write_l2 " "bs %p l1_index %d" "\n" , bs, l1_index);
    }
}
static inline void trace_qcow2_l2_allocate_write_l1(void * bs, int l1_index)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_WRITE_L1);
    if (_state) {
        fprintf(stderr, "qcow2_l2_allocate_write_l1 " "bs %p l1_index %d" "\n" , bs, l1_index);
    }
}
static inline void trace_qcow2_l2_allocate_done(void * bs, int l1_index, int ret)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_L2_ALLOCATE_DONE);
    if (_state) {
        fprintf(stderr, "qcow2_l2_allocate_done " "bs %p l1_index %d ret %d" "\n" , bs, l1_index, ret);
    }
}
static inline void trace_qcow2_cache_get(void * co, int c, uint64_t offset, bool read_from_disk)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CACHE_GET);
    if (_state) {
        fprintf(stderr, "qcow2_cache_get " "co %p is_l2_cache %d offset %" PRIx64 " read_from_disk %d" "\n" , co, c, offset, read_from_disk);
    }
}
static inline void trace_qcow2_cache_get_replace_entry(void * co, int c, int i)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CACHE_GET_REPLACE_ENTRY);
    if (_state) {
        fprintf(stderr, "qcow2_cache_get_replace_entry " "co %p is_l2_cache %d index %d" "\n" , co, c, i);
    }
}
static inline void trace_qcow2_cache_get_read(void * co, int c, int i)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CACHE_GET_READ);
    if (_state) {
        fprintf(stderr, "qcow2_cache_get_read " "co %p is_l2_cache %d index %d" "\n" , co, c, i);
    }
}
static inline void trace_qcow2_cache_get_done(void * co, int c, int i)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CACHE_GET_DONE);
    if (_state) {
        fprintf(stderr, "qcow2_cache_get_done " "co %p is_l2_cache %d index %d" "\n" , co, c, i);
    }
}
static inline void trace_qcow2_cache_flush(void * co, int c)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CACHE_FLUSH);
    if (_state) {
        fprintf(stderr, "qcow2_cache_flush " "co %p is_l2_cache %d" "\n" , co, c);
    }
}
static inline void trace_qcow2_cache_entry_flush(void * co, int c, int i)
{
    bool _state = trace_event_get_state(TRACE_QCOW2_CACHE_ENTRY_FLUSH);
    if (_state) {
        fprintf(stderr, "qcow2_cache_entry_flush " "co %p is_l2_cache %d index %d" "\n" , co, c, i);
    }
}
static inline void trace_qed_alloc_l2_cache_entry(void * l2_cache, void * entry)
{
    bool _state = trace_event_get_state(TRACE_QED_ALLOC_L2_CACHE_ENTRY);
    if (_state) {
        fprintf(stderr, "qed_alloc_l2_cache_entry " "l2_cache %p entry %p" "\n" , l2_cache, entry);
    }
}
static inline void trace_qed_unref_l2_cache_entry(void * entry, int ref)
{
    bool _state = trace_event_get_state(TRACE_QED_UNREF_L2_CACHE_ENTRY);
    if (_state) {
        fprintf(stderr, "qed_unref_l2_cache_entry " "entry %p ref %d" "\n" , entry, ref);
    }
}
static inline void trace_qed_find_l2_cache_entry(void * l2_cache, void * entry, uint64_t offset, int ref)
{
    bool _state = trace_event_get_state(TRACE_QED_FIND_L2_CACHE_ENTRY);
    if (_state) {
        fprintf(stderr, "qed_find_l2_cache_entry " "l2_cache %p entry %p offset %"PRIu64" ref %d" "\n" , l2_cache, entry, offset, ref);
    }
}
static inline void trace_qed_read_table(void * s, uint64_t offset, void * table)
{
    bool _state = trace_event_get_state(TRACE_QED_READ_TABLE);
    if (_state) {
        fprintf(stderr, "qed_read_table " "s %p offset %"PRIu64" table %p" "\n" , s, offset, table);
    }
}
static inline void trace_qed_read_table_cb(void * s, void * table, int ret)
{
    bool _state = trace_event_get_state(TRACE_QED_READ_TABLE_CB);
    if (_state) {
        fprintf(stderr, "qed_read_table_cb " "s %p table %p ret %d" "\n" , s, table, ret);
    }
}
static inline void trace_qed_write_table(void * s, uint64_t offset, void * table, unsigned int index, unsigned int n)
{
    bool _state = trace_event_get_state(TRACE_QED_WRITE_TABLE);
    if (_state) {
        fprintf(stderr, "qed_write_table " "s %p offset %"PRIu64" table %p index %u n %u" "\n" , s, offset, table, index, n);
    }
}
static inline void trace_qed_write_table_cb(void * s, void * table, int flush, int ret)
{
    bool _state = trace_event_get_state(TRACE_QED_WRITE_TABLE_CB);
    if (_state) {
        fprintf(stderr, "qed_write_table_cb " "s %p table %p flush %d ret %d" "\n" , s, table, flush, ret);
    }
}
static inline void trace_qed_need_check_timer_cb(void * s)
{
    bool _state = trace_event_get_state(TRACE_QED_NEED_CHECK_TIMER_CB);
    if (_state) {
        fprintf(stderr, "qed_need_check_timer_cb " "s %p" "\n" , s);
    }
}
static inline void trace_qed_start_need_check_timer(void * s)
{
    bool _state = trace_event_get_state(TRACE_QED_START_NEED_CHECK_TIMER);
    if (_state) {
        fprintf(stderr, "qed_start_need_check_timer " "s %p" "\n" , s);
    }
}
static inline void trace_qed_cancel_need_check_timer(void * s)
{
    bool _state = trace_event_get_state(TRACE_QED_CANCEL_NEED_CHECK_TIMER);
    if (_state) {
        fprintf(stderr, "qed_cancel_need_check_timer " "s %p" "\n" , s);
    }
}
static inline void trace_qed_aio_complete(void * s, void * acb, int ret)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_COMPLETE);
    if (_state) {
        fprintf(stderr, "qed_aio_complete " "s %p acb %p ret %d" "\n" , s, acb, ret);
    }
}
static inline void trace_qed_aio_setup(void * s, void * acb, int64_t sector_num, int nb_sectors, void * opaque, int flags)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_SETUP);
    if (_state) {
        fprintf(stderr, "qed_aio_setup " "s %p acb %p sector_num %"PRId64" nb_sectors %d opaque %p flags %#x" "\n" , s, acb, sector_num, nb_sectors, opaque, flags);
    }
}
static inline void trace_qed_aio_next_io(void * s, void * acb, int ret, uint64_t cur_pos)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_NEXT_IO);
    if (_state) {
        fprintf(stderr, "qed_aio_next_io " "s %p acb %p ret %d cur_pos %"PRIu64 "\n" , s, acb, ret, cur_pos);
    }
}
static inline void trace_qed_aio_read_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_READ_DATA);
    if (_state) {
        fprintf(stderr, "qed_aio_read_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n" , s, acb, ret, offset, len);
    }
}
static inline void trace_qed_aio_write_data(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_WRITE_DATA);
    if (_state) {
        fprintf(stderr, "qed_aio_write_data " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n" , s, acb, ret, offset, len);
    }
}
static inline void trace_qed_aio_write_prefill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_WRITE_PREFILL);
    if (_state) {
        fprintf(stderr, "qed_aio_write_prefill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n" , s, acb, start, len, offset);
    }
}
static inline void trace_qed_aio_write_postfill(void * s, void * acb, uint64_t start, size_t len, uint64_t offset)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_WRITE_POSTFILL);
    if (_state) {
        fprintf(stderr, "qed_aio_write_postfill " "s %p acb %p start %"PRIu64" len %zu offset %"PRIu64 "\n" , s, acb, start, len, offset);
    }
}
static inline void trace_qed_aio_write_main(void * s, void * acb, int ret, uint64_t offset, size_t len)
{
    bool _state = trace_event_get_state(TRACE_QED_AIO_WRITE_MAIN);
    if (_state) {
        fprintf(stderr, "qed_aio_write_main " "s %p acb %p ret %d offset %"PRIu64" len %zu" "\n" , s, acb, ret, offset, len);
    }
}
static inline void trace_g364fb_read(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_G364FB_READ);
    if (_state) {
        fprintf(stderr, "g364fb_read " "read addr=0x%"PRIx64": 0x%x" "\n" , addr, val);
    }
}
static inline void trace_g364fb_write(uint64_t addr, uint32_t new)
{
    bool _state = trace_event_get_state(TRACE_G364FB_WRITE);
    if (_state) {
        fprintf(stderr, "g364fb_write " "write addr=0x%"PRIx64": 0x%x" "\n" , addr, new);
    }
}
static inline void trace_grlib_gptimer_enable(int id, uint32_t count)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_GPTIMER_ENABLE);
    if (_state) {
        fprintf(stderr, "grlib_gptimer_enable " "timer:%d set count 0x%x and run" "\n" , id, count);
    }
}
static inline void trace_grlib_gptimer_disabled(int id, uint32_t config)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_GPTIMER_DISABLED);
    if (_state) {
        fprintf(stderr, "grlib_gptimer_disabled " "timer:%d Timer disable config 0x%x" "\n" , id, config);
    }
}
static inline void trace_grlib_gptimer_restart(int id, uint32_t reload)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_GPTIMER_RESTART);
    if (_state) {
        fprintf(stderr, "grlib_gptimer_restart " "timer:%d reload val: 0x%x" "\n" , id, reload);
    }
}
static inline void trace_grlib_gptimer_set_scaler(uint32_t scaler, uint32_t freq)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_GPTIMER_SET_SCALER);
    if (_state) {
        fprintf(stderr, "grlib_gptimer_set_scaler " "scaler:0x%x freq: 0x%x" "\n" , scaler, freq);
    }
}
static inline void trace_grlib_gptimer_hit(int id)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_GPTIMER_HIT);
    if (_state) {
        fprintf(stderr, "grlib_gptimer_hit " "timer:%d HIT" "\n" , id);
    }
}
static inline void trace_grlib_gptimer_readl(int id, uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_GPTIMER_READL);
    if (_state) {
        fprintf(stderr, "grlib_gptimer_readl " "timer:%d addr 0x%"PRIx64" 0x%x" "\n" , id, addr, val);
    }
}
static inline void trace_grlib_gptimer_writel(int id, uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_GPTIMER_WRITEL);
    if (_state) {
        fprintf(stderr, "grlib_gptimer_writel " "timer:%d addr 0x%"PRIx64" 0x%x" "\n" , id, addr, val);
    }
}
static inline void trace_grlib_irqmp_check_irqs(uint32_t pend, uint32_t force, uint32_t mask, uint32_t lvl1, uint32_t lvl2)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_IRQMP_CHECK_IRQS);
    if (_state) {
        fprintf(stderr, "grlib_irqmp_check_irqs " "pend:0x%04x force:0x%04x mask:0x%04x lvl1:0x%04x lvl0:0x%04x" "\n" , pend, force, mask, lvl1, lvl2);
    }
}
static inline void trace_grlib_irqmp_ack(int intno)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_IRQMP_ACK);
    if (_state) {
        fprintf(stderr, "grlib_irqmp_ack " "interrupt:%d" "\n" , intno);
    }
}
static inline void trace_grlib_irqmp_set_irq(int irq)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_IRQMP_SET_IRQ);
    if (_state) {
        fprintf(stderr, "grlib_irqmp_set_irq " "Raise CPU IRQ %d" "\n" , irq);
    }
}
static inline void trace_grlib_irqmp_readl_unknown(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_IRQMP_READL_UNKNOWN);
    if (_state) {
        fprintf(stderr, "grlib_irqmp_readl_unknown " "addr 0x%"PRIx64 "\n" , addr);
    }
}
static inline void trace_grlib_irqmp_writel_unknown(uint64_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_IRQMP_WRITEL_UNKNOWN);
    if (_state) {
        fprintf(stderr, "grlib_irqmp_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n" , addr, value);
    }
}
static inline void trace_grlib_apbuart_event(int event)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_APBUART_EVENT);
    if (_state) {
        fprintf(stderr, "grlib_apbuart_event " "event:%d" "\n" , event);
    }
}
static inline void trace_grlib_apbuart_writel_unknown(uint64_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_APBUART_WRITEL_UNKNOWN);
    if (_state) {
        fprintf(stderr, "grlib_apbuart_writel_unknown " "addr 0x%"PRIx64" value 0x%x" "\n" , addr, value);
    }
}
static inline void trace_grlib_apbuart_readl_unknown(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_GRLIB_APBUART_READL_UNKNOWN);
    if (_state) {
        fprintf(stderr, "grlib_apbuart_readl_unknown " "addr 0x%"PRIx64"" "\n" , addr);
    }
}
static inline void trace_leon3_set_irq(int intno)
{
    bool _state = trace_event_get_state(TRACE_LEON3_SET_IRQ);
    if (_state) {
        fprintf(stderr, "leon3_set_irq " "Set CPU IRQ %d" "\n" , intno);
    }
}
static inline void trace_leon3_reset_irq(int intno)
{
    bool _state = trace_event_get_state(TRACE_LEON3_RESET_IRQ);
    if (_state) {
        fprintf(stderr, "leon3_reset_irq " "Reset CPU IRQ %d" "\n" , intno);
    }
}
static inline void trace_spice_vmc_write(ssize_t out, int len)
{
    bool _state = trace_event_get_state(TRACE_SPICE_VMC_WRITE);
    if (_state) {
        fprintf(stderr, "spice_vmc_write " "spice wrottn %zd of requested %d" "\n" , out, len);
    }
}
static inline void trace_spice_vmc_read(int bytes, int len)
{
    bool _state = trace_event_get_state(TRACE_SPICE_VMC_READ);
    if (_state) {
        fprintf(stderr, "spice_vmc_read " "spice read %d of requested %d" "\n" , bytes, len);
    }
}
static inline void trace_spice_vmc_register_interface(void * scd)
{
    bool _state = trace_event_get_state(TRACE_SPICE_VMC_REGISTER_INTERFACE);
    if (_state) {
        fprintf(stderr, "spice_vmc_register_interface " "spice vmc registered interface %p" "\n" , scd);
    }
}
static inline void trace_spice_vmc_unregister_interface(void * scd)
{
    bool _state = trace_event_get_state(TRACE_SPICE_VMC_UNREGISTER_INTERFACE);
    if (_state) {
        fprintf(stderr, "spice_vmc_unregister_interface " "spice vmc unregistered interface %p" "\n" , scd);
    }
}
static inline void trace_spice_vmc_event(int event)
{
    bool _state = trace_event_get_state(TRACE_SPICE_VMC_EVENT);
    if (_state) {
        fprintf(stderr, "spice_vmc_event " "spice vmc event %d" "\n" , event);
    }
}
static inline void trace_lm32_pic_raise_irq(void)
{
    bool _state = trace_event_get_state(TRACE_LM32_PIC_RAISE_IRQ);
    if (_state) {
        fprintf(stderr, "lm32_pic_raise_irq " "Raise CPU interrupt" "\n" );
    }
}
static inline void trace_lm32_pic_lower_irq(void)
{
    bool _state = trace_event_get_state(TRACE_LM32_PIC_LOWER_IRQ);
    if (_state) {
        fprintf(stderr, "lm32_pic_lower_irq " "Lower CPU interrupt" "\n" );
    }
}
static inline void trace_lm32_pic_interrupt(int irq, int level)
{
    bool _state = trace_event_get_state(TRACE_LM32_PIC_INTERRUPT);
    if (_state) {
        fprintf(stderr, "lm32_pic_interrupt " "Set IRQ%d %d" "\n" , irq, level);
    }
}
static inline void trace_lm32_pic_set_im(uint32_t im)
{
    bool _state = trace_event_get_state(TRACE_LM32_PIC_SET_IM);
    if (_state) {
        fprintf(stderr, "lm32_pic_set_im " "im 0x%08x" "\n" , im);
    }
}
static inline void trace_lm32_pic_set_ip(uint32_t ip)
{
    bool _state = trace_event_get_state(TRACE_LM32_PIC_SET_IP);
    if (_state) {
        fprintf(stderr, "lm32_pic_set_ip " "ip 0x%08x" "\n" , ip);
    }
}
static inline void trace_lm32_pic_get_im(uint32_t im)
{
    bool _state = trace_event_get_state(TRACE_LM32_PIC_GET_IM);
    if (_state) {
        fprintf(stderr, "lm32_pic_get_im " "im 0x%08x" "\n" , im);
    }
}
static inline void trace_lm32_pic_get_ip(uint32_t ip)
{
    bool _state = trace_event_get_state(TRACE_LM32_PIC_GET_IP);
    if (_state) {
        fprintf(stderr, "lm32_pic_get_ip " "ip 0x%08x" "\n" , ip);
    }
}
static inline void trace_lm32_juart_get_jtx(uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_JUART_GET_JTX);
    if (_state) {
        fprintf(stderr, "lm32_juart_get_jtx " "jtx 0x%08x" "\n" , value);
    }
}
static inline void trace_lm32_juart_set_jtx(uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_JUART_SET_JTX);
    if (_state) {
        fprintf(stderr, "lm32_juart_set_jtx " "jtx 0x%08x" "\n" , value);
    }
}
static inline void trace_lm32_juart_get_jrx(uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_JUART_GET_JRX);
    if (_state) {
        fprintf(stderr, "lm32_juart_get_jrx " "jrx 0x%08x" "\n" , value);
    }
}
static inline void trace_lm32_juart_set_jrx(uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_JUART_SET_JRX);
    if (_state) {
        fprintf(stderr, "lm32_juart_set_jrx " "jrx 0x%08x" "\n" , value);
    }
}
static inline void trace_lm32_timer_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_TIMER_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "lm32_timer_memory_write " "addr 0x%08x value 0x%08x" "\n" , addr, value);
    }
}
static inline void trace_lm32_timer_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_TIMER_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "lm32_timer_memory_read " "addr 0x%08x value 0x%08x" "\n" , addr, value);
    }
}
static inline void trace_lm32_timer_hit(void)
{
    bool _state = trace_event_get_state(TRACE_LM32_TIMER_HIT);
    if (_state) {
        fprintf(stderr, "lm32_timer_hit " "timer hit" "\n" );
    }
}
static inline void trace_lm32_timer_irq_state(int level)
{
    bool _state = trace_event_get_state(TRACE_LM32_TIMER_IRQ_STATE);
    if (_state) {
        fprintf(stderr, "lm32_timer_irq_state " "irq state %d" "\n" , level);
    }
}
static inline void trace_lm32_uart_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_UART_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "lm32_uart_memory_write " "addr 0x%08x value 0x%08x" "\n" , addr, value);
    }
}
static inline void trace_lm32_uart_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_UART_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "lm32_uart_memory_read " "addr 0x%08x value 0x%08x" "\n" , addr, value);
    }
}
static inline void trace_lm32_uart_irq_state(int level)
{
    bool _state = trace_event_get_state(TRACE_LM32_UART_IRQ_STATE);
    if (_state) {
        fprintf(stderr, "lm32_uart_irq_state " "irq state %d" "\n" , level);
    }
}
static inline void trace_lm32_sys_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_LM32_SYS_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "lm32_sys_memory_write " "addr 0x%08x value 0x%08x" "\n" , addr, value);
    }
}
static inline void trace_megasas_init_firmware(uint64_t pa)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_INIT_FIRMWARE);
    if (_state) {
        fprintf(stderr, "megasas_init_firmware " "pa %" PRIx64 " " "\n" , pa);
    }
}
static inline void trace_megasas_init_queue(uint64_t queue_pa, int queue_len, uint64_t head, uint64_t tail, uint32_t flags)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_INIT_QUEUE);
    if (_state) {
        fprintf(stderr, "megasas_init_queue " "queue at %" PRIx64 " len %d head %" PRIx64 " tail %" PRIx64 " flags %x" "\n" , queue_pa, queue_len, head, tail, flags);
    }
}
static inline void trace_megasas_initq_map_failed(int frame)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_INITQ_MAP_FAILED);
    if (_state) {
        fprintf(stderr, "megasas_initq_map_failed " "scmd %d: failed to map queue" "\n" , frame);
    }
}
static inline void trace_megasas_initq_mismatch(int queue_len, int fw_cmds)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_INITQ_MISMATCH);
    if (_state) {
        fprintf(stderr, "megasas_initq_mismatch " "queue size %d max fw cmds %d" "\n" , queue_len, fw_cmds);
    }
}
static inline void trace_megasas_qf_found(unsigned int index, uint64_t pa)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_FOUND);
    if (_state) {
        fprintf(stderr, "megasas_qf_found " "found mapped frame %x pa %" PRIx64 "" "\n" , index, pa);
    }
}
static inline void trace_megasas_qf_new(unsigned int index, void * cmd)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_NEW);
    if (_state) {
        fprintf(stderr, "megasas_qf_new " "return new frame %x cmd %p" "\n" , index, cmd);
    }
}
static inline void trace_megasas_qf_failed(unsigned long pa)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_FAILED);
    if (_state) {
        fprintf(stderr, "megasas_qf_failed " "all frames busy for frame %lx" "\n" , pa);
    }
}
static inline void trace_megasas_qf_enqueue(unsigned int index, unsigned int count, uint64_t context, unsigned int tail, int busy)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_ENQUEUE);
    if (_state) {
        fprintf(stderr, "megasas_qf_enqueue " "enqueue frame %x count %d context %" PRIx64 " tail %x busy %d" "\n" , index, count, context, tail, busy);
    }
}
static inline void trace_megasas_qf_update(unsigned int head, unsigned int busy)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_UPDATE);
    if (_state) {
        fprintf(stderr, "megasas_qf_update " "update reply queue head %x busy %d" "\n" , head, busy);
    }
}
static inline void trace_megasas_qf_map_failed(int cmd, unsigned long frame)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_MAP_FAILED);
    if (_state) {
        fprintf(stderr, "megasas_qf_map_failed " "scmd %d: frame %lu" "\n" , cmd, frame);
    }
}
static inline void trace_megasas_qf_complete_noirq(uint64_t context)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_COMPLETE_NOIRQ);
    if (_state) {
        fprintf(stderr, "megasas_qf_complete_noirq " "context %" PRIx64 " " "\n" , context);
    }
}
static inline void trace_megasas_qf_complete(uint64_t context, unsigned int tail, unsigned int offset, int busy, unsigned int doorbell)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_QF_COMPLETE);
    if (_state) {
        fprintf(stderr, "megasas_qf_complete " "context %" PRIx64 " tail %x offset %d busy %d doorbell %x" "\n" , context, tail, offset, busy, doorbell);
    }
}
static inline void trace_megasas_frame_busy(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_FRAME_BUSY);
    if (_state) {
        fprintf(stderr, "megasas_frame_busy " "frame %" PRIx64 " busy" "\n" , addr);
    }
}
static inline void trace_megasas_unhandled_frame_cmd(int cmd, uint8_t frame_cmd)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_UNHANDLED_FRAME_CMD);
    if (_state) {
        fprintf(stderr, "megasas_unhandled_frame_cmd " "scmd %d: Unhandled MFI cmd %x" "\n" , cmd, frame_cmd);
    }
}
static inline void trace_megasas_handle_scsi(const char * frame, int bus, int dev, int lun, void * sdev, unsigned long size)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_HANDLE_SCSI);
    if (_state) {
        fprintf(stderr, "megasas_handle_scsi " "%s dev %x/%x/%x sdev %p xfer %lu" "\n" , frame, bus, dev, lun, sdev, size);
    }
}
static inline void trace_megasas_scsi_target_not_present(const char * frame, int bus, int dev, int lun)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_SCSI_TARGET_NOT_PRESENT);
    if (_state) {
        fprintf(stderr, "megasas_scsi_target_not_present " "%s dev %x/%x/%x target not present" "\n" , frame, bus, dev, lun);
    }
}
static inline void trace_megasas_scsi_invalid_cdb_len(const char * frame, int bus, int dev, int lun, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_SCSI_INVALID_CDB_LEN);
    if (_state) {
        fprintf(stderr, "megasas_scsi_invalid_cdb_len " "%s dev %x/%x/%x invalid cdb len %d" "\n" , frame, bus, dev, lun, len);
    }
}
static inline void trace_megasas_iov_read_overflow(int cmd, int bytes, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOV_READ_OVERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iov_read_overflow " "scmd %d: %d/%d bytes" "\n" , cmd, bytes, len);
    }
}
static inline void trace_megasas_iov_write_overflow(int cmd, int bytes, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOV_WRITE_OVERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iov_write_overflow " "scmd %d: %d/%d bytes" "\n" , cmd, bytes, len);
    }
}
static inline void trace_megasas_iov_read_underflow(int cmd, int bytes, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOV_READ_UNDERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iov_read_underflow " "scmd %d: %d/%d bytes" "\n" , cmd, bytes, len);
    }
}
static inline void trace_megasas_iov_write_underflow(int cmd, int bytes, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOV_WRITE_UNDERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iov_write_underflow " "scmd %d: %d/%d bytes" "\n" , cmd, bytes, len);
    }
}
static inline void trace_megasas_scsi_req_alloc_failed(const char * frame, int dev, int lun)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_SCSI_REQ_ALLOC_FAILED);
    if (_state) {
        fprintf(stderr, "megasas_scsi_req_alloc_failed " "%s dev %x/%x req allocation failed" "\n" , frame, dev, lun);
    }
}
static inline void trace_megasas_scsi_read_start(int cmd, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_SCSI_READ_START);
    if (_state) {
        fprintf(stderr, "megasas_scsi_read_start " "scmd %d: transfer %d bytes of data" "\n" , cmd, len);
    }
}
static inline void trace_megasas_scsi_write_start(int cmd, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_SCSI_WRITE_START);
    if (_state) {
        fprintf(stderr, "megasas_scsi_write_start " "scmd %d: transfer %d bytes of data" "\n" , cmd, len);
    }
}
static inline void trace_megasas_scsi_nodata(int cmd)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_SCSI_NODATA);
    if (_state) {
        fprintf(stderr, "megasas_scsi_nodata " "scmd %d: no data to be transferred" "\n" , cmd);
    }
}
static inline void trace_megasas_scsi_complete(int cmd, uint32_t status, int len, int xfer)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_SCSI_COMPLETE);
    if (_state) {
        fprintf(stderr, "megasas_scsi_complete " "scmd %d: finished with status %x, len %u/%u" "\n" , cmd, status, len, xfer);
    }
}
static inline void trace_megasas_command_complete(int cmd, uint32_t status, uint32_t resid)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_COMMAND_COMPLETE);
    if (_state) {
        fprintf(stderr, "megasas_command_complete " "scmd %d: command completed, status %x, residual %d" "\n" , cmd, status, resid);
    }
}
static inline void trace_megasas_handle_io(int cmd, const char * frame, int dev, int lun, unsigned long lba, unsigned long count)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_HANDLE_IO);
    if (_state) {
        fprintf(stderr, "megasas_handle_io " "scmd %d: %s dev %x/%x lba %lx count %lu" "\n" , cmd, frame, dev, lun, lba, count);
    }
}
static inline void trace_megasas_io_target_not_present(int cmd, const char * frame, int dev, int lun)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IO_TARGET_NOT_PRESENT);
    if (_state) {
        fprintf(stderr, "megasas_io_target_not_present " "scmd %d: %s dev 1/%x/%x LUN not present" "\n" , cmd, frame, dev, lun);
    }
}
static inline void trace_megasas_io_read_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IO_READ_START);
    if (_state) {
        fprintf(stderr, "megasas_io_read_start " "scmd %d: start LBA %lx %lu blocks (%lu bytes)" "\n" , cmd, lba, count, len);
    }
}
static inline void trace_megasas_io_write_start(int cmd, unsigned long lba, unsigned long count, unsigned long len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IO_WRITE_START);
    if (_state) {
        fprintf(stderr, "megasas_io_write_start " "scmd %d: start LBA %lx %lu blocks (%lu bytes)" "\n" , cmd, lba, count, len);
    }
}
static inline void trace_megasas_io_complete(int cmd, uint32_t len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IO_COMPLETE);
    if (_state) {
        fprintf(stderr, "megasas_io_complete " "scmd %d: %d bytes completed" "\n" , cmd, len);
    }
}
static inline void trace_megasas_io_read(int cmd, int bytes, int len, unsigned long offset)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IO_READ);
    if (_state) {
        fprintf(stderr, "megasas_io_read " "scmd %d: %d/%d bytes, iov offset %lu" "\n" , cmd, bytes, len, offset);
    }
}
static inline void trace_megasas_io_write(int cmd, int bytes, int len, unsigned long offset)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IO_WRITE);
    if (_state) {
        fprintf(stderr, "megasas_io_write " "scmd %d: %d/%d bytes, iov offset %lu" "\n" , cmd, bytes, len, offset);
    }
}
static inline void trace_megasas_iovec_sgl_overflow(int cmd, int index, int limit)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_OVERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iovec_sgl_overflow " "scmd %d: iovec count %d limit %d" "\n" , cmd, index, limit);
    }
}
static inline void trace_megasas_iovec_sgl_underflow(int cmd, int index)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_UNDERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iovec_sgl_underflow " "scmd %d: iovec count %d" "\n" , cmd, index);
    }
}
static inline void trace_megasas_iovec_sgl_invalid(int cmd, int index, uint64_t pa, uint32_t len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOVEC_SGL_INVALID);
    if (_state) {
        fprintf(stderr, "megasas_iovec_sgl_invalid " "scmd %d: element %d pa %" PRIx64 " len %u" "\n" , cmd, index, pa, len);
    }
}
static inline void trace_megasas_iovec_overflow(int cmd, int len, int limit)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOVEC_OVERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iovec_overflow " "scmd %d: len %d limit %d" "\n" , cmd, len, limit);
    }
}
static inline void trace_megasas_iovec_underflow(int cmd, int len, int limit)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IOVEC_UNDERFLOW);
    if (_state) {
        fprintf(stderr, "megasas_iovec_underflow " "scmd %d: len %d limit %d" "\n" , cmd, len, limit);
    }
}
static inline void trace_megasas_handle_dcmd(int cmd, int opcode)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_HANDLE_DCMD);
    if (_state) {
        fprintf(stderr, "megasas_handle_dcmd " "scmd %d: MFI DCMD opcode %x" "\n" , cmd, opcode);
    }
}
static inline void trace_megasas_finish_dcmd(int cmd, int size)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_FINISH_DCMD);
    if (_state) {
        fprintf(stderr, "megasas_finish_dcmd " "scmd %d: MFI DCMD wrote %d bytes" "\n" , cmd, size);
    }
}
static inline void trace_megasas_dcmd_req_alloc_failed(int cmd, const char * desc)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_REQ_ALLOC_FAILED);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_req_alloc_failed " "scmd %d: %s alloc failed" "\n" , cmd, desc);
    }
}
static inline void trace_megasas_dcmd_internal_submit(int cmd, const char * desc, int dev)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_SUBMIT);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_internal_submit " "scmd %d: %s to dev %d" "\n" , cmd, desc, dev);
    }
}
static inline void trace_megasas_dcmd_internal_finish(int cmd, int opcode, int lun)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_FINISH);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_internal_finish " "scmd %d: DCMD finish internal cmd %x lun %d" "\n" , cmd, opcode, lun);
    }
}
static inline void trace_megasas_dcmd_internal_invalid(int cmd, int opcode)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_INTERNAL_INVALID);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_internal_invalid " "scmd %d: Invalid internal DCMD %x" "\n" , cmd, opcode);
    }
}
static inline void trace_megasas_dcmd_unhandled(int cmd, int opcode, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_UNHANDLED);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_unhandled " "scmd %d: opcode %x, len %d" "\n" , cmd, opcode, len);
    }
}
static inline void trace_megasas_dcmd_zero_sge(int cmd)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_ZERO_SGE);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_zero_sge " "scmd %d: zero DCMD sge count" "\n" , cmd);
    }
}
static inline void trace_megasas_dcmd_invalid_sge(int cmd, int count)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_INVALID_SGE);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_invalid_sge " "scmd %d: invalid DCMD sge count %d" "\n" , cmd, count);
    }
}
static inline void trace_megasas_dcmd_invalid_xfer_len(int cmd, unsigned long size, unsigned long max)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_INVALID_XFER_LEN);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_invalid_xfer_len " "scmd %d: invalid xfer len %ld, max %ld" "\n" , cmd, size, max);
    }
}
static inline void trace_megasas_dcmd_enter(int cmd, const char * dcmd, int len)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_ENTER);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_enter " "scmd %d: DCMD %s len %d" "\n" , cmd, dcmd, len);
    }
}
static inline void trace_megasas_dcmd_dummy(int cmd, unsigned long size)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_DUMMY);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_dummy " "scmd %d: DCMD dummy xfer len %ld" "\n" , cmd, size);
    }
}
static inline void trace_megasas_dcmd_set_fw_time(int cmd, unsigned long time)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_SET_FW_TIME);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_set_fw_time " "scmd %d: Set FW time %lx" "\n" , cmd, time);
    }
}
static inline void trace_megasas_dcmd_pd_get_list(int cmd, int num, int max, int offset)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_PD_GET_LIST);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_pd_get_list " "scmd %d: DCMD PD get list: %d / %d PDs, size %d" "\n" , cmd, num, max, offset);
    }
}
static inline void trace_megasas_dcmd_ld_get_list(int cmd, int num, int max)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_LD_GET_LIST);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_ld_get_list " "scmd %d: DCMD LD get list: found %d / %d LDs" "\n" , cmd, num, max);
    }
}
static inline void trace_megasas_dcmd_ld_get_info(int cmd, int ld_id)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_LD_GET_INFO);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_ld_get_info " "scmd %d: DCMD LD get info for dev %d" "\n" , cmd, ld_id);
    }
}
static inline void trace_megasas_dcmd_pd_get_info(int cmd, int pd_id)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_PD_GET_INFO);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_pd_get_info " "scmd %d: DCMD PD get info for dev %d" "\n" , cmd, pd_id);
    }
}
static inline void trace_megasas_dcmd_pd_list_query(int cmd, int flags)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_PD_LIST_QUERY);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_pd_list_query " "scmd %d: DCMD PD list query flags %x" "\n" , cmd, flags);
    }
}
static inline void trace_megasas_dcmd_unsupported(int cmd, unsigned long size)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_DCMD_UNSUPPORTED);
    if (_state) {
        fprintf(stderr, "megasas_dcmd_unsupported " "scmd %d: set properties len %ld" "\n" , cmd, size);
    }
}
static inline void trace_megasas_abort_frame(int cmd, int abort_cmd)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_ABORT_FRAME);
    if (_state) {
        fprintf(stderr, "megasas_abort_frame " "scmd %d: aborting frame %x" "\n" , cmd, abort_cmd);
    }
}
static inline void trace_megasas_abort_no_cmd(int cmd, uint64_t context)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_ABORT_NO_CMD);
    if (_state) {
        fprintf(stderr, "megasas_abort_no_cmd " "scmd %d: no active command for frame context %" PRIx64 "" "\n" , cmd, context);
    }
}
static inline void trace_megasas_abort_invalid_context(int cmd, uint64_t context, int abort_cmd)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_ABORT_INVALID_CONTEXT);
    if (_state) {
        fprintf(stderr, "megasas_abort_invalid_context " "scmd %d: invalid frame context %" PRIx64 " for abort frame %x" "\n" , cmd, context, abort_cmd);
    }
}
static inline void trace_megasas_reset(void)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_RESET);
    if (_state) {
        fprintf(stderr, "megasas_reset " "Reset" "\n" );
    }
}
static inline void trace_megasas_init(int sges, int cmds, const char * intr, const char * mode)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_INIT);
    if (_state) {
        fprintf(stderr, "megasas_init " "Using %d sges, %d cmds, %s, %s mode" "\n" , sges, cmds, intr, mode);
    }
}
static inline void trace_megasas_msix_raise(int vector)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_MSIX_RAISE);
    if (_state) {
        fprintf(stderr, "megasas_msix_raise " "vector %d" "\n" , vector);
    }
}
static inline void trace_megasas_irq_lower(void)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IRQ_LOWER);
    if (_state) {
        fprintf(stderr, "megasas_irq_lower " "INTx" "\n" );
    }
}
static inline void trace_megasas_irq_raise(void)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_IRQ_RAISE);
    if (_state) {
        fprintf(stderr, "megasas_irq_raise " "INTx" "\n" );
    }
}
static inline void trace_megasas_intr_enabled(void)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_INTR_ENABLED);
    if (_state) {
        fprintf(stderr, "megasas_intr_enabled " "Interrupts enabled" "\n" );
    }
}
static inline void trace_megasas_intr_disabled(void)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_INTR_DISABLED);
    if (_state) {
        fprintf(stderr, "megasas_intr_disabled " "Interrupts disabled" "\n" );
    }
}
static inline void trace_megasas_mmio_readl(unsigned long addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_MMIO_READL);
    if (_state) {
        fprintf(stderr, "megasas_mmio_readl " "addr 0x%lx: 0x%x" "\n" , addr, val);
    }
}
static inline void trace_megasas_mmio_invalid_readl(unsigned long addr)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_MMIO_INVALID_READL);
    if (_state) {
        fprintf(stderr, "megasas_mmio_invalid_readl " "addr 0x%lx" "\n" , addr);
    }
}
static inline void trace_megasas_mmio_writel(uint32_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_MMIO_WRITEL);
    if (_state) {
        fprintf(stderr, "megasas_mmio_writel " "addr 0x%x: 0x%x" "\n" , addr, val);
    }
}
static inline void trace_megasas_mmio_invalid_writel(uint32_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_MEGASAS_MMIO_INVALID_WRITEL);
    if (_state) {
        fprintf(stderr, "megasas_mmio_invalid_writel " "addr 0x%x: 0x%x" "\n" , addr, val);
    }
}
static inline void trace_milkymist_ac97_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_ac97_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_ac97_pulse_irq_crrequest(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_PULSE_IRQ_CRREQUEST);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_pulse_irq_crrequest " "Pulse IRQ CR request" "\n" );
    }
}
static inline void trace_milkymist_ac97_pulse_irq_crreply(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_PULSE_IRQ_CRREPLY);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_pulse_irq_crreply " "Pulse IRQ CR reply" "\n" );
    }
}
static inline void trace_milkymist_ac97_pulse_irq_dmaw(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_PULSE_IRQ_DMAW);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_pulse_irq_dmaw " "Pulse IRQ DMA write" "\n" );
    }
}
static inline void trace_milkymist_ac97_pulse_irq_dmar(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_PULSE_IRQ_DMAR);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_pulse_irq_dmar " "Pulse IRQ DMA read" "\n" );
    }
}
static inline void trace_milkymist_ac97_in_cb(int avail, uint32_t remaining)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_IN_CB);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_in_cb " "avail %d remaining %u" "\n" , avail, remaining);
    }
}
static inline void trace_milkymist_ac97_in_cb_transferred(int transferred)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_IN_CB_TRANSFERRED);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_in_cb_transferred " "transferred %d" "\n" , transferred);
    }
}
static inline void trace_milkymist_ac97_out_cb(int free, uint32_t remaining)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_OUT_CB);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_out_cb " "free %d remaining %u" "\n" , free, remaining);
    }
}
static inline void trace_milkymist_ac97_out_cb_transferred(int transferred)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_AC97_OUT_CB_TRANSFERRED);
    if (_state) {
        fprintf(stderr, "milkymist_ac97_out_cb_transferred " "transferred %d" "\n" , transferred);
    }
}
static inline void trace_milkymist_hpdmc_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_HPDMC_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_hpdmc_memory_read " "addr=%08x value=%08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_hpdmc_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_HPDMC_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_hpdmc_memory_write " "addr=%08x value=%08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_memcard_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MEMCARD_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_memcard_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_memcard_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MEMCARD_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_memcard_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_minimac2_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_minimac2_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_minimac2_mdio_write(uint8_t phy_addr, uint8_t addr, uint16_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MDIO_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_mdio_write " "phy_addr %02x addr %02x value %04x" "\n" , phy_addr, addr, value);
    }
}
static inline void trace_milkymist_minimac2_mdio_read(uint8_t phy_addr, uint8_t addr, uint16_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_MDIO_READ);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_mdio_read " "phy_addr %02x addr %02x value %04x" "\n" , phy_addr, addr, value);
    }
}
static inline void trace_milkymist_minimac2_tx_frame(uint32_t length)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_TX_FRAME);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_tx_frame " "length %u" "\n" , length);
    }
}
static inline void trace_milkymist_minimac2_rx_frame(const void * buf, uint32_t length)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_RX_FRAME);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_rx_frame " "buf %p length %u" "\n" , buf, length);
    }
}
static inline void trace_milkymist_minimac2_drop_rx_frame(const void * buf)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_DROP_RX_FRAME);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_drop_rx_frame " "buf %p" "\n" , buf);
    }
}
static inline void trace_milkymist_minimac2_rx_transfer(const void * buf, uint32_t length)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_RX_TRANSFER);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_rx_transfer " "buf %p length %d" "\n" , buf, length);
    }
}
static inline void trace_milkymist_minimac2_raise_irq_rx(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_RAISE_IRQ_RX);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_raise_irq_rx " "Raise IRQ RX" "\n" );
    }
}
static inline void trace_milkymist_minimac2_lower_irq_rx(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_LOWER_IRQ_RX);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_lower_irq_rx " "Lower IRQ RX" "\n" );
    }
}
static inline void trace_milkymist_minimac2_pulse_irq_tx(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_MINIMAC2_PULSE_IRQ_TX);
    if (_state) {
        fprintf(stderr, "milkymist_minimac2_pulse_irq_tx " "Pulse IRQ TX" "\n" );
    }
}
static inline void trace_milkymist_pfpu_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_PFPU_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_pfpu_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_pfpu_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_PFPU_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_pfpu_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_pfpu_vectout(uint32_t a, uint32_t b, uint32_t dma_ptr)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_PFPU_VECTOUT);
    if (_state) {
        fprintf(stderr, "milkymist_pfpu_vectout " "a %08x b %08x dma_ptr %08x" "\n" , a, b, dma_ptr);
    }
}
static inline void trace_milkymist_pfpu_pulse_irq(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_PFPU_PULSE_IRQ);
    if (_state) {
        fprintf(stderr, "milkymist_pfpu_pulse_irq " "Pulse IRQ" "\n" );
    }
}
static inline void trace_milkymist_softusb_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SOFTUSB_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_softusb_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_softusb_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SOFTUSB_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_softusb_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_softusb_mevt(uint8_t m)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SOFTUSB_MEVT);
    if (_state) {
        fprintf(stderr, "milkymist_softusb_mevt " "m %d" "\n" , m);
    }
}
static inline void trace_milkymist_softusb_kevt(uint8_t m)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SOFTUSB_KEVT);
    if (_state) {
        fprintf(stderr, "milkymist_softusb_kevt " "m %d" "\n" , m);
    }
}
static inline void trace_milkymist_softusb_pulse_irq(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SOFTUSB_PULSE_IRQ);
    if (_state) {
        fprintf(stderr, "milkymist_softusb_pulse_irq " "Pulse IRQ" "\n" );
    }
}
static inline void trace_milkymist_sysctl_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_sysctl_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_sysctl_icap_write(uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_ICAP_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_icap_write " "value %08x" "\n" , value);
    }
}
static inline void trace_milkymist_sysctl_start_timer0(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_START_TIMER0);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_start_timer0 " "Start timer0" "\n" );
    }
}
static inline void trace_milkymist_sysctl_stop_timer0(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_STOP_TIMER0);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_stop_timer0 " "Stop timer0" "\n" );
    }
}
static inline void trace_milkymist_sysctl_start_timer1(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_START_TIMER1);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_start_timer1 " "Start timer1" "\n" );
    }
}
static inline void trace_milkymist_sysctl_stop_timer1(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_STOP_TIMER1);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_stop_timer1 " "Stop timer1" "\n" );
    }
}
static inline void trace_milkymist_sysctl_pulse_irq_timer0(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER0);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_pulse_irq_timer0 " "Pulse IRQ Timer0" "\n" );
    }
}
static inline void trace_milkymist_sysctl_pulse_irq_timer1(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_SYSCTL_PULSE_IRQ_TIMER1);
    if (_state) {
        fprintf(stderr, "milkymist_sysctl_pulse_irq_timer1 " "Pulse IRQ Timer1" "\n" );
    }
}
static inline void trace_milkymist_tmu2_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_TMU2_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_tmu2_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_tmu2_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_TMU2_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_tmu2_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_tmu2_start(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_TMU2_START);
    if (_state) {
        fprintf(stderr, "milkymist_tmu2_start " "Start TMU" "\n" );
    }
}
static inline void trace_milkymist_tmu2_pulse_irq(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_TMU2_PULSE_IRQ);
    if (_state) {
        fprintf(stderr, "milkymist_tmu2_pulse_irq " "Pulse IRQ" "\n" );
    }
}
static inline void trace_milkymist_uart_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_uart_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_uart_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_UART_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_uart_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_uart_raise_irq(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_UART_RAISE_IRQ);
    if (_state) {
        fprintf(stderr, "milkymist_uart_raise_irq " "Raise IRQ" "\n" );
    }
}
static inline void trace_milkymist_uart_lower_irq(void)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_UART_LOWER_IRQ);
    if (_state) {
        fprintf(stderr, "milkymist_uart_lower_irq " "Lower IRQ" "\n" );
    }
}
static inline void trace_milkymist_vgafb_memory_read(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_VGAFB_MEMORY_READ);
    if (_state) {
        fprintf(stderr, "milkymist_vgafb_memory_read " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_milkymist_vgafb_memory_write(uint32_t addr, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_MILKYMIST_VGAFB_MEMORY_WRITE);
    if (_state) {
        fprintf(stderr, "milkymist_vgafb_memory_write " "addr %08x value %08x" "\n" , addr, value);
    }
}
static inline void trace_mipsnet_send(uint32_t size)
{
    bool _state = trace_event_get_state(TRACE_MIPSNET_SEND);
    if (_state) {
        fprintf(stderr, "mipsnet_send " "sending len=%u" "\n" , size);
    }
}
static inline void trace_mipsnet_receive(uint32_t size)
{
    bool _state = trace_event_get_state(TRACE_MIPSNET_RECEIVE);
    if (_state) {
        fprintf(stderr, "mipsnet_receive " "receiving len=%u" "\n" , size);
    }
}
static inline void trace_mipsnet_read(uint64_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_MIPSNET_READ);
    if (_state) {
        fprintf(stderr, "mipsnet_read " "read addr=0x%" PRIx64 " val=0x%x" "\n" , addr, val);
    }
}
static inline void trace_mipsnet_write(uint64_t addr, uint64_t val)
{
    bool _state = trace_event_get_state(TRACE_MIPSNET_WRITE);
    if (_state) {
        fprintf(stderr, "mipsnet_write " "write addr=0x%" PRIx64 " val=0x%" PRIx64 "" "\n" , addr, val);
    }
}
static inline void trace_mipsnet_irq(uint32_t isr, uint32_t intctl)
{
    bool _state = trace_event_get_state(TRACE_MIPSNET_IRQ);
    if (_state) {
        fprintf(stderr, "mipsnet_irq " "set irq to %d (%02x)" "\n" , isr, intctl);
    }
}
static inline void trace_pc87312_io_read(uint32_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_PC87312_IO_READ);
    if (_state) {
        fprintf(stderr, "pc87312_io_read " "read addr=%x val=%x" "\n" , addr, val);
    }
}
static inline void trace_pc87312_io_write(uint32_t addr, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_PC87312_IO_WRITE);
    if (_state) {
        fprintf(stderr, "pc87312_io_write " "write addr=%x val=%x" "\n" , addr, val);
    }
}
static inline void trace_pc87312_info_floppy(uint32_t base)
{
    bool _state = trace_event_get_state(TRACE_PC87312_INFO_FLOPPY);
    if (_state) {
        fprintf(stderr, "pc87312_info_floppy " "base 0x%x" "\n" , base);
    }
}
static inline void trace_pc87312_info_ide(uint32_t base)
{
    bool _state = trace_event_get_state(TRACE_PC87312_INFO_IDE);
    if (_state) {
        fprintf(stderr, "pc87312_info_ide " "base 0x%x" "\n" , base);
    }
}
static inline void trace_pc87312_info_parallel(uint32_t base, uint32_t irq)
{
    bool _state = trace_event_get_state(TRACE_PC87312_INFO_PARALLEL);
    if (_state) {
        fprintf(stderr, "pc87312_info_parallel " "base 0x%x, irq %u" "\n" , base, irq);
    }
}
static inline void trace_pc87312_info_serial(int n, uint32_t base, uint32_t irq)
{
    bool _state = trace_event_get_state(TRACE_PC87312_INFO_SERIAL);
    if (_state) {
        fprintf(stderr, "pc87312_info_serial " "id=%d, base 0x%x, irq %u" "\n" , n, base, irq);
    }
}
static inline void trace_pvscsi_ring_init_data(uint32_t txr_len_log2, uint32_t rxr_len_log2)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_RING_INIT_DATA);
    if (_state) {
        fprintf(stderr, "pvscsi_ring_init_data " "TX/RX rings logarithms set to %d/%d" "\n" , txr_len_log2, rxr_len_log2);
    }
}
static inline void trace_pvscsi_ring_init_msg(uint32_t len_log2)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_RING_INIT_MSG);
    if (_state) {
        fprintf(stderr, "pvscsi_ring_init_msg " "MSG ring logarithm set to %d" "\n" , len_log2);
    }
}
static inline void trace_pvscsi_ring_flush_cmp(uint64_t filled_cmp_ptr)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_RING_FLUSH_CMP);
    if (_state) {
        fprintf(stderr, "pvscsi_ring_flush_cmp " "new production counter of completion ring is 0x%"PRIx64"" "\n" , filled_cmp_ptr);
    }
}
static inline void trace_pvscsi_ring_flush_msg(uint64_t filled_cmp_ptr)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_RING_FLUSH_MSG);
    if (_state) {
        fprintf(stderr, "pvscsi_ring_flush_msg " "new production counter of message ring is 0x%"PRIx64"" "\n" , filled_cmp_ptr);
    }
}
static inline void trace_pvscsi_update_irq_level(bool raise, uint64_t mask, uint64_t status)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_UPDATE_IRQ_LEVEL);
    if (_state) {
        fprintf(stderr, "pvscsi_update_irq_level " "interrupt level set to %d (MASK: 0x%"PRIx64", STATUS: 0x%"PRIx64")" "\n" , raise, mask, status);
    }
}
static inline void trace_pvscsi_update_irq_msi(void)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_UPDATE_IRQ_MSI);
    if (_state) {
        fprintf(stderr, "pvscsi_update_irq_msi " "sending MSI notification" "\n" );
    }
}
static inline void trace_pvscsi_cmp_ring_put(unsigned long addr)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_CMP_RING_PUT);
    if (_state) {
        fprintf(stderr, "pvscsi_cmp_ring_put " "got completion descriptor 0x%lx" "\n" , addr);
    }
}
static inline void trace_pvscsi_msg_ring_put(unsigned long addr)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_MSG_RING_PUT);
    if (_state) {
        fprintf(stderr, "pvscsi_msg_ring_put " "got message descriptor 0x%lx" "\n" , addr);
    }
}
static inline void trace_pvscsi_complete_request(uint64_t context, uint64_t len, uint8_t sense_key)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_COMPLETE_REQUEST);
    if (_state) {
        fprintf(stderr, "pvscsi_complete_request " "completion: ctx: 0x%"PRIx64", len: 0x%"PRIx64", sense key: %u" "\n" , context, len, sense_key);
    }
}
static inline void trace_pvscsi_get_sg_list(int nsg, size_t size)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_GET_SG_LIST);
    if (_state) {
        fprintf(stderr, "pvscsi_get_sg_list " "get SG list: depth: %u, size: %zu" "\n" , nsg, size);
    }
}
static inline void trace_pvscsi_get_next_sg_elem(uint32_t flags)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_GET_NEXT_SG_ELEM);
    if (_state) {
        fprintf(stderr, "pvscsi_get_next_sg_elem " "unknown flags in SG element (val: 0x%x)" "\n" , flags);
    }
}
static inline void trace_pvscsi_command_complete_not_found(uint32_t tag)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_NOT_FOUND);
    if (_state) {
        fprintf(stderr, "pvscsi_command_complete_not_found " "can't find request for tag 0x%x" "\n" , tag);
    }
}
static inline void trace_pvscsi_command_complete_data_run(void)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_DATA_RUN);
    if (_state) {
        fprintf(stderr, "pvscsi_command_complete_data_run " "not all data required for command transferred" "\n" );
    }
}
static inline void trace_pvscsi_command_complete_sense_len(int len)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_COMMAND_COMPLETE_SENSE_LEN);
    if (_state) {
        fprintf(stderr, "pvscsi_command_complete_sense_len " "sense information length is %d bytes" "\n" , len);
    }
}
static inline void trace_pvscsi_convert_sglist(uint64_t context, unsigned long addr, uint32_t resid)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_CONVERT_SGLIST);
    if (_state) {
        fprintf(stderr, "pvscsi_convert_sglist " "element: ctx: 0x%"PRIx64" addr: 0x%lx, len: %ul" "\n" , context, addr, resid);
    }
}
static inline void trace_pvscsi_process_req_descr(uint8_t cmd, uint64_t ctx)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR);
    if (_state) {
        fprintf(stderr, "pvscsi_process_req_descr " "SCSI cmd 0x%x, ctx: 0x%"PRIx64"" "\n" , cmd, ctx);
    }
}
static inline void trace_pvscsi_process_req_descr_unknown_device(void)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR_UNKNOWN_DEVICE);
    if (_state) {
        fprintf(stderr, "pvscsi_process_req_descr_unknown_device " "command directed to unknown device rejected" "\n" );
    }
}
static inline void trace_pvscsi_process_req_descr_invalid_dir(void)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_PROCESS_REQ_DESCR_INVALID_DIR);
    if (_state) {
        fprintf(stderr, "pvscsi_process_req_descr_invalid_dir " "command with invalid transfer direction rejected" "\n" );
    }
}
static inline void trace_pvscsi_process_io(unsigned long addr)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_PROCESS_IO);
    if (_state) {
        fprintf(stderr, "pvscsi_process_io " "got descriptor 0x%lx" "\n" , addr);
    }
}
static inline void trace_pvscsi_on_cmd_noimpl(const char* cmd)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_ON_CMD_NOIMPL);
    if (_state) {
        fprintf(stderr, "pvscsi_on_cmd_noimpl " "unimplemented command %s ignored" "\n" , cmd);
    }
}
static inline void trace_pvscsi_on_cmd_reset_dev(uint32_t tgt, int lun, void* dev)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_ON_CMD_RESET_DEV);
    if (_state) {
        fprintf(stderr, "pvscsi_on_cmd_reset_dev " "PVSCSI_CMD_RESET_DEVICE[target %u lun %d (dev 0x%p)]" "\n" , tgt, lun, dev);
    }
}
static inline void trace_pvscsi_on_cmd_arrived(const char* cmd)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_ON_CMD_ARRIVED);
    if (_state) {
        fprintf(stderr, "pvscsi_on_cmd_arrived " "command %s arrived" "\n" , cmd);
    }
}
static inline void trace_pvscsi_on_cmd_abort(uint64_t ctx, uint32_t tgt)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_ON_CMD_ABORT);
    if (_state) {
        fprintf(stderr, "pvscsi_on_cmd_abort " "command PVSCSI_CMD_ABORT_CMD for ctx 0x%"PRIx64", target %u" "\n" , ctx, tgt);
    }
}
static inline void trace_pvscsi_on_cmd_unknown(uint64_t cmd_id)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_ON_CMD_UNKNOWN);
    if (_state) {
        fprintf(stderr, "pvscsi_on_cmd_unknown " "unknown command %"PRIx64"" "\n" , cmd_id);
    }
}
static inline void trace_pvscsi_on_cmd_unknown_data(uint32_t data)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_ON_CMD_UNKNOWN_DATA);
    if (_state) {
        fprintf(stderr, "pvscsi_on_cmd_unknown_data " "data for unknown command 0x:%x" "\n" , data);
    }
}
static inline void trace_pvscsi_io_write(const char* cmd, uint64_t val)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_IO_WRITE);
    if (_state) {
        fprintf(stderr, "pvscsi_io_write " "%s write: %"PRIx64"" "\n" , cmd, val);
    }
}
static inline void trace_pvscsi_io_write_unknown(unsigned long addr, unsigned sz, uint64_t val)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_IO_WRITE_UNKNOWN);
    if (_state) {
        fprintf(stderr, "pvscsi_io_write_unknown " "unknown write address: 0x%lx size: %u bytes value: 0x%"PRIx64"" "\n" , addr, sz, val);
    }
}
static inline void trace_pvscsi_io_read(const char* cmd, uint64_t status)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_IO_READ);
    if (_state) {
        fprintf(stderr, "pvscsi_io_read " "%s read: 0x%"PRIx64"" "\n" , cmd, status);
    }
}
static inline void trace_pvscsi_io_read_unknown(unsigned long addr, unsigned sz)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_IO_READ_UNKNOWN);
    if (_state) {
        fprintf(stderr, "pvscsi_io_read_unknown " "unknown read address: 0x%lx size: %u bytes" "\n" , addr, sz);
    }
}
static inline void trace_pvscsi_init_msi_fail(int res)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_INIT_MSI_FAIL);
    if (_state) {
        fprintf(stderr, "pvscsi_init_msi_fail " "failed to initialize MSI, error %d" "\n" , res);
    }
}
static inline void trace_pvscsi_state(const char* state)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_STATE);
    if (_state) {
        fprintf(stderr, "pvscsi_state " "starting %s ..." "\n" , state);
    }
}
static inline void trace_pvscsi_tx_rings_ppn(const char* label, uint64_t ppn)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_TX_RINGS_PPN);
    if (_state) {
        fprintf(stderr, "pvscsi_tx_rings_ppn " "%s page: %"PRIx64"" "\n" , label, ppn);
    }
}
static inline void trace_pvscsi_tx_rings_num_pages(const char* label, uint32_t num)
{
    bool _state = trace_event_get_state(TRACE_PVSCSI_TX_RINGS_NUM_PAGES);
    if (_state) {
        fprintf(stderr, "pvscsi_tx_rings_num_pages " "Number of %s pages: %u" "\n" , label, num);
    }
}
static inline void trace_xen_ram_alloc(unsigned long ram_addr, unsigned long size)
{
    bool _state = trace_event_get_state(TRACE_XEN_RAM_ALLOC);
    if (_state) {
        fprintf(stderr, "xen_ram_alloc " "requested: %#lx, size %#lx" "\n" , ram_addr, size);
    }
}
static inline void trace_xen_client_set_memory(uint64_t start_addr, unsigned long size, bool log_dirty)
{
    bool _state = trace_event_get_state(TRACE_XEN_CLIENT_SET_MEMORY);
    if (_state) {
        fprintf(stderr, "xen_client_set_memory " "%#"PRIx64" size %#lx, log_dirty %i" "\n" , start_addr, size, log_dirty);
    }
}
static inline void trace_xen_map_cache(uint64_t phys_addr)
{
    bool _state = trace_event_get_state(TRACE_XEN_MAP_CACHE);
    if (_state) {
        fprintf(stderr, "xen_map_cache " "want %#"PRIx64 "\n" , phys_addr);
    }
}
static inline void trace_xen_remap_bucket(uint64_t index)
{
    bool _state = trace_event_get_state(TRACE_XEN_REMAP_BUCKET);
    if (_state) {
        fprintf(stderr, "xen_remap_bucket " "index %#"PRIx64 "\n" , index);
    }
}
static inline void trace_xen_map_cache_return(void* ptr)
{
    bool _state = trace_event_get_state(TRACE_XEN_MAP_CACHE_RETURN);
    if (_state) {
        fprintf(stderr, "xen_map_cache_return " "%p" "\n" , ptr);
    }
}
static inline void trace_xen_platform_log(char * s)
{
    bool _state = trace_event_get_state(TRACE_XEN_PLATFORM_LOG);
    if (_state) {
        fprintf(stderr, "xen_platform_log " "xen platform: %s" "\n" , s);
    }
}
static inline void trace_qemu_coroutine_enter(void * from, void * to, void * opaque)
{
    bool _state = trace_event_get_state(TRACE_QEMU_COROUTINE_ENTER);
    if (_state) {
        fprintf(stderr, "qemu_coroutine_enter " "from %p to %p opaque %p" "\n" , from, to, opaque);
    }
}
static inline void trace_qemu_coroutine_yield(void * from, void * to)
{
    bool _state = trace_event_get_state(TRACE_QEMU_COROUTINE_YIELD);
    if (_state) {
        fprintf(stderr, "qemu_coroutine_yield " "from %p to %p" "\n" , from, to);
    }
}
static inline void trace_qemu_coroutine_terminate(void * co)
{
    bool _state = trace_event_get_state(TRACE_QEMU_COROUTINE_TERMINATE);
    if (_state) {
        fprintf(stderr, "qemu_coroutine_terminate " "self %p" "\n" , co);
    }
}
static inline void trace_qemu_co_queue_run_restart(void * co)
{
    bool _state = trace_event_get_state(TRACE_QEMU_CO_QUEUE_RUN_RESTART);
    if (_state) {
        fprintf(stderr, "qemu_co_queue_run_restart " "co %p" "\n" , co);
    }
}
static inline void trace_qemu_co_queue_next(void * nxt)
{
    bool _state = trace_event_get_state(TRACE_QEMU_CO_QUEUE_NEXT);
    if (_state) {
        fprintf(stderr, "qemu_co_queue_next " "next %p" "\n" , nxt);
    }
}
static inline void trace_qemu_co_mutex_lock_entry(void * mutex, void * self)
{
    bool _state = trace_event_get_state(TRACE_QEMU_CO_MUTEX_LOCK_ENTRY);
    if (_state) {
        fprintf(stderr, "qemu_co_mutex_lock_entry " "mutex %p self %p" "\n" , mutex, self);
    }
}
static inline void trace_qemu_co_mutex_lock_return(void * mutex, void * self)
{
    bool _state = trace_event_get_state(TRACE_QEMU_CO_MUTEX_LOCK_RETURN);
    if (_state) {
        fprintf(stderr, "qemu_co_mutex_lock_return " "mutex %p self %p" "\n" , mutex, self);
    }
}
static inline void trace_qemu_co_mutex_unlock_entry(void * mutex, void * self)
{
    bool _state = trace_event_get_state(TRACE_QEMU_CO_MUTEX_UNLOCK_ENTRY);
    if (_state) {
        fprintf(stderr, "qemu_co_mutex_unlock_entry " "mutex %p self %p" "\n" , mutex, self);
    }
}
static inline void trace_qemu_co_mutex_unlock_return(void * mutex, void * self)
{
    bool _state = trace_event_get_state(TRACE_QEMU_CO_MUTEX_UNLOCK_RETURN);
    if (_state) {
        fprintf(stderr, "qemu_co_mutex_unlock_return " "mutex %p self %p" "\n" , mutex, self);
    }
}
static inline void trace_escc_put_queue(char channel, int b)
{
    bool _state = trace_event_get_state(TRACE_ESCC_PUT_QUEUE);
    if (_state) {
        fprintf(stderr, "escc_put_queue " "channel %c put: 0x%02x" "\n" , channel, b);
    }
}
static inline void trace_escc_get_queue(char channel, int val)
{
    bool _state = trace_event_get_state(TRACE_ESCC_GET_QUEUE);
    if (_state) {
        fprintf(stderr, "escc_get_queue " "channel %c get 0x%02x" "\n" , channel, val);
    }
}
static inline void trace_escc_update_irq(int irq)
{
    bool _state = trace_event_get_state(TRACE_ESCC_UPDATE_IRQ);
    if (_state) {
        fprintf(stderr, "escc_update_irq " "IRQ = %d" "\n" , irq);
    }
}
static inline void trace_escc_update_parameters(char channel, int speed, int parity, int data_bits, int stop_bits)
{
    bool _state = trace_event_get_state(TRACE_ESCC_UPDATE_PARAMETERS);
    if (_state) {
        fprintf(stderr, "escc_update_parameters " "channel %c: speed=%d parity=%c data=%d stop=%d" "\n" , channel, speed, parity, data_bits, stop_bits);
    }
}
static inline void trace_escc_mem_writeb_ctrl(char channel, uint32_t reg, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESCC_MEM_WRITEB_CTRL);
    if (_state) {
        fprintf(stderr, "escc_mem_writeb_ctrl " "Write channel %c, reg[%d] = %2.2x" "\n" , channel, reg, val);
    }
}
static inline void trace_escc_mem_writeb_data(char channel, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESCC_MEM_WRITEB_DATA);
    if (_state) {
        fprintf(stderr, "escc_mem_writeb_data " "Write channel %c, ch %d" "\n" , channel, val);
    }
}
static inline void trace_escc_mem_readb_ctrl(char channel, uint32_t reg, uint8_t val)
{
    bool _state = trace_event_get_state(TRACE_ESCC_MEM_READB_CTRL);
    if (_state) {
        fprintf(stderr, "escc_mem_readb_ctrl " "Read channel %c, reg[%d] = %2.2x" "\n" , channel, reg, val);
    }
}
static inline void trace_escc_mem_readb_data(char channel, uint32_t ret)
{
    bool _state = trace_event_get_state(TRACE_ESCC_MEM_READB_DATA);
    if (_state) {
        fprintf(stderr, "escc_mem_readb_data " "Read channel %c, ch %d" "\n" , channel, ret);
    }
}
static inline void trace_escc_serial_receive_byte(char channel, int ch)
{
    bool _state = trace_event_get_state(TRACE_ESCC_SERIAL_RECEIVE_BYTE);
    if (_state) {
        fprintf(stderr, "escc_serial_receive_byte " "channel %c put ch %d" "\n" , channel, ch);
    }
}
static inline void trace_escc_sunkbd_event_in(int ch)
{
    bool _state = trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_IN);
    if (_state) {
        fprintf(stderr, "escc_sunkbd_event_in " "Untranslated keycode %2.2x" "\n" , ch);
    }
}
static inline void trace_escc_sunkbd_event_out(int ch)
{
    bool _state = trace_event_get_state(TRACE_ESCC_SUNKBD_EVENT_OUT);
    if (_state) {
        fprintf(stderr, "escc_sunkbd_event_out " "Translated keycode %2.2x" "\n" , ch);
    }
}
static inline void trace_escc_kbd_command(int val)
{
    bool _state = trace_event_get_state(TRACE_ESCC_KBD_COMMAND);
    if (_state) {
        fprintf(stderr, "escc_kbd_command " "Command %d" "\n" , val);
    }
}
static inline void trace_escc_sunmouse_event(int dx, int dy, int buttons_state)
{
    bool _state = trace_event_get_state(TRACE_ESCC_SUNMOUSE_EVENT);
    if (_state) {
        fprintf(stderr, "escc_sunmouse_event " "dx=%d dy=%d buttons=%01x" "\n" , dx, dy, buttons_state);
    }
}
static inline void trace_iscsi_aio_write16_cb(void * iscsi, int status, void * acb, int canceled)
{
    bool _state = trace_event_get_state(TRACE_ISCSI_AIO_WRITE16_CB);
    if (_state) {
        fprintf(stderr, "iscsi_aio_write16_cb " "iscsi %p status %d acb %p canceled %d" "\n" , iscsi, status, acb, canceled);
    }
}
static inline void trace_iscsi_aio_writev(void * iscsi, int64_t sector_num, int nb_sectors, void * opaque, void * acb)
{
    bool _state = trace_event_get_state(TRACE_ISCSI_AIO_WRITEV);
    if (_state) {
        fprintf(stderr, "iscsi_aio_writev " "iscsi %p sector_num %"PRId64" nb_sectors %d opaque %p acb %p" "\n" , iscsi, sector_num, nb_sectors, opaque, acb);
    }
}
static inline void trace_iscsi_aio_read16_cb(void * iscsi, int status, void * acb, int canceled)
{
    bool _state = trace_event_get_state(TRACE_ISCSI_AIO_READ16_CB);
    if (_state) {
        fprintf(stderr, "iscsi_aio_read16_cb " "iscsi %p status %d acb %p canceled %d" "\n" , iscsi, status, acb, canceled);
    }
}
static inline void trace_iscsi_aio_readv(void * iscsi, int64_t sector_num, int nb_sectors, void * opaque, void * acb)
{
    bool _state = trace_event_get_state(TRACE_ISCSI_AIO_READV);
    if (_state) {
        fprintf(stderr, "iscsi_aio_readv " "iscsi %p sector_num %"PRId64" nb_sectors %d opaque %p acb %p" "\n" , iscsi, sector_num, nb_sectors, opaque, acb);
    }
}
static inline void trace_esp_error_fifo_overrun(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_ERROR_FIFO_OVERRUN);
    if (_state) {
        fprintf(stderr, "esp_error_fifo_overrun " "FIFO overrun" "\n" );
    }
}
static inline void trace_esp_error_unhandled_command(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_ERROR_UNHANDLED_COMMAND);
    if (_state) {
        fprintf(stderr, "esp_error_unhandled_command " "unhandled command (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_error_invalid_write(uint32_t val, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_ESP_ERROR_INVALID_WRITE);
    if (_state) {
        fprintf(stderr, "esp_error_invalid_write " "invalid write of 0x%02x at [0x%x]" "\n" , val, addr);
    }
}
static inline void trace_esp_raise_irq(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_RAISE_IRQ);
    if (_state) {
        fprintf(stderr, "esp_raise_irq " "Raise IRQ" "\n" );
    }
}
static inline void trace_esp_lower_irq(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_LOWER_IRQ);
    if (_state) {
        fprintf(stderr, "esp_lower_irq " "Lower IRQ" "\n" );
    }
}
static inline void trace_esp_dma_enable(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_DMA_ENABLE);
    if (_state) {
        fprintf(stderr, "esp_dma_enable " "Raise enable" "\n" );
    }
}
static inline void trace_esp_dma_disable(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_DMA_DISABLE);
    if (_state) {
        fprintf(stderr, "esp_dma_disable " "Lower enable" "\n" );
    }
}
static inline void trace_esp_get_cmd(uint32_t dmalen, int target)
{
    bool _state = trace_event_get_state(TRACE_ESP_GET_CMD);
    if (_state) {
        fprintf(stderr, "esp_get_cmd " "len %d target %d" "\n" , dmalen, target);
    }
}
static inline void trace_esp_do_busid_cmd(uint8_t busid)
{
    bool _state = trace_event_get_state(TRACE_ESP_DO_BUSID_CMD);
    if (_state) {
        fprintf(stderr, "esp_do_busid_cmd " "busid 0x%x" "\n" , busid);
    }
}
static inline void trace_esp_handle_satn_stop(uint32_t cmdlen)
{
    bool _state = trace_event_get_state(TRACE_ESP_HANDLE_SATN_STOP);
    if (_state) {
        fprintf(stderr, "esp_handle_satn_stop " "cmdlen %d" "\n" , cmdlen);
    }
}
static inline void trace_esp_write_response(uint32_t status)
{
    bool _state = trace_event_get_state(TRACE_ESP_WRITE_RESPONSE);
    if (_state) {
        fprintf(stderr, "esp_write_response " "Transfer status (status=%d)" "\n" , status);
    }
}
static inline void trace_esp_do_dma(uint32_t cmdlen, uint32_t len)
{
    bool _state = trace_event_get_state(TRACE_ESP_DO_DMA);
    if (_state) {
        fprintf(stderr, "esp_do_dma " "command len %d + %d" "\n" , cmdlen, len);
    }
}
static inline void trace_esp_command_complete(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE);
    if (_state) {
        fprintf(stderr, "esp_command_complete " "SCSI Command complete" "\n" );
    }
}
static inline void trace_esp_command_complete_unexpected(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE_UNEXPECTED);
    if (_state) {
        fprintf(stderr, "esp_command_complete_unexpected " "SCSI command completed unexpectedly" "\n" );
    }
}
static inline void trace_esp_command_complete_fail(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_COMMAND_COMPLETE_FAIL);
    if (_state) {
        fprintf(stderr, "esp_command_complete_fail " "Command failed" "\n" );
    }
}
static inline void trace_esp_transfer_data(uint32_t dma_left, int32_t ti_size)
{
    bool _state = trace_event_get_state(TRACE_ESP_TRANSFER_DATA);
    if (_state) {
        fprintf(stderr, "esp_transfer_data " "transfer %d/%d" "\n" , dma_left, ti_size);
    }
}
static inline void trace_esp_handle_ti(uint32_t minlen)
{
    bool _state = trace_event_get_state(TRACE_ESP_HANDLE_TI);
    if (_state) {
        fprintf(stderr, "esp_handle_ti " "Transfer Information len %d" "\n" , minlen);
    }
}
static inline void trace_esp_handle_ti_cmd(uint32_t cmdlen)
{
    bool _state = trace_event_get_state(TRACE_ESP_HANDLE_TI_CMD);
    if (_state) {
        fprintf(stderr, "esp_handle_ti_cmd " "command len %d" "\n" , cmdlen);
    }
}
static inline void trace_esp_mem_readb(uint32_t saddr, uint8_t reg)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_READB);
    if (_state) {
        fprintf(stderr, "esp_mem_readb " "reg[%d]: 0x%2.2x" "\n" , saddr, reg);
    }
}
static inline void trace_esp_mem_writeb(uint32_t saddr, uint8_t reg, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb " "reg[%d]: 0x%2.2x -> 0x%2.2x" "\n" , saddr, reg, val);
    }
}
static inline void trace_esp_mem_writeb_cmd_nop(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_NOP);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_nop " "NOP (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_flush(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_FLUSH);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_flush " "Flush FIFO (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_reset(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_RESET);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_reset " "Chip reset (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_bus_reset(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_BUS_RESET);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_bus_reset " "Bus reset (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_iccs(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_ICCS);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_iccs " "Initiator Command Complete Sequence (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_msgacc(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_MSGACC);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_msgacc " "Message Accepted (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_pad(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_PAD);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_pad " "Transfer padding (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_satn(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SATN);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_satn " "Set ATN (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_rstatn(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_RSTATN);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_rstatn " "Reset ATN (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_sel(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SEL);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_sel " "Select without ATN (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_selatn(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SELATN);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_selatn " "Select with ATN (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_selatns(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_SELATNS);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_selatns " "Select with ATN & stop (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_ensel(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_ENSEL);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_ensel " "Enable selection (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_mem_writeb_cmd_dissel(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_MEM_WRITEB_CMD_DISSEL);
    if (_state) {
        fprintf(stderr, "esp_mem_writeb_cmd_dissel " "Disable selection (%2.2x)" "\n" , val);
    }
}
static inline void trace_esp_pci_error_invalid_dma_direction(void)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_DMA_DIRECTION);
    if (_state) {
        fprintf(stderr, "esp_pci_error_invalid_dma_direction " "invalid DMA transfer direction" "\n" );
    }
}
static inline void trace_esp_pci_error_invalid_read(uint32_t reg)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_READ);
    if (_state) {
        fprintf(stderr, "esp_pci_error_invalid_read " "read access outside bounds (reg 0x%x)" "\n" , reg);
    }
}
static inline void trace_esp_pci_error_invalid_write(uint32_t reg)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_WRITE);
    if (_state) {
        fprintf(stderr, "esp_pci_error_invalid_write " "write access outside bounds (reg 0x%x)" "\n" , reg);
    }
}
static inline void trace_esp_pci_error_invalid_write_dma(uint32_t val, uint32_t addr)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_ERROR_INVALID_WRITE_DMA);
    if (_state) {
        fprintf(stderr, "esp_pci_error_invalid_write_dma " "invalid write of 0x%02x at [0x%x]" "\n" , val, addr);
    }
}
static inline void trace_esp_pci_dma_read(uint32_t saddr, uint32_t reg)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_DMA_READ);
    if (_state) {
        fprintf(stderr, "esp_pci_dma_read " "reg[%d]: 0x%8.8x" "\n" , saddr, reg);
    }
}
static inline void trace_esp_pci_dma_write(uint32_t saddr, uint32_t reg, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_DMA_WRITE);
    if (_state) {
        fprintf(stderr, "esp_pci_dma_write " "reg[%d]: 0x%8.8x -> 0x%8.8x" "\n" , saddr, reg, val);
    }
}
static inline void trace_esp_pci_dma_idle(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_DMA_IDLE);
    if (_state) {
        fprintf(stderr, "esp_pci_dma_idle " "IDLE (%.8x)" "\n" , val);
    }
}
static inline void trace_esp_pci_dma_blast(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_DMA_BLAST);
    if (_state) {
        fprintf(stderr, "esp_pci_dma_blast " "BLAST (%.8x)" "\n" , val);
    }
}
static inline void trace_esp_pci_dma_abort(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_DMA_ABORT);
    if (_state) {
        fprintf(stderr, "esp_pci_dma_abort " "ABORT (%.8x)" "\n" , val);
    }
}
static inline void trace_esp_pci_dma_start(uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_DMA_START);
    if (_state) {
        fprintf(stderr, "esp_pci_dma_start " "START (%.8x)" "\n" , val);
    }
}
static inline void trace_esp_pci_sbac_read(uint32_t reg)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_SBAC_READ);
    if (_state) {
        fprintf(stderr, "esp_pci_sbac_read " "sbac: 0x%8.8x" "\n" , reg);
    }
}
static inline void trace_esp_pci_sbac_write(uint32_t reg, uint32_t val)
{
    bool _state = trace_event_get_state(TRACE_ESP_PCI_SBAC_WRITE);
    if (_state) {
        fprintf(stderr, "esp_pci_sbac_write " "sbac: 0x%8.8x -> 0x%8.8x" "\n" , reg, val);
    }
}
static inline void trace_handle_qmp_command(void * mon, const char * cmd_name)
{
    bool _state = trace_event_get_state(TRACE_HANDLE_QMP_COMMAND);
    if (_state) {
        fprintf(stderr, "handle_qmp_command " "mon %p cmd_name \"%s\"" "\n" , mon, cmd_name);
    }
}
static inline void trace_monitor_protocol_emitter(void * mon)
{
    bool _state = trace_event_get_state(TRACE_MONITOR_PROTOCOL_EMITTER);
    if (_state) {
        fprintf(stderr, "monitor_protocol_emitter " "mon %p" "\n" , mon);
    }
}
static inline void trace_monitor_protocol_event(uint32_t event, const char * evname, void * data)
{
    bool _state = trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT);
    if (_state) {
        fprintf(stderr, "monitor_protocol_event " "event=%d name \"%s\" data %p" "\n" , event, evname, data);
    }
}
static inline void trace_monitor_protocol_event_handler(uint32_t event, void * data, uint64_t last, uint64_t now)
{
    bool _state = trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_HANDLER);
    if (_state) {
        fprintf(stderr, "monitor_protocol_event_handler " "event=%d data=%p last=%" PRId64 " now=%" PRId64 "\n" , event, data, last, now);
    }
}
static inline void trace_monitor_protocol_event_emit(uint32_t event, void * data)
{
    bool _state = trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_EMIT);
    if (_state) {
        fprintf(stderr, "monitor_protocol_event_emit " "event=%d data=%p" "\n" , event, data);
    }
}
static inline void trace_monitor_protocol_event_queue(uint32_t event, void * data, uint64_t rate, uint64_t last, uint64_t now)
{
    bool _state = trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_QUEUE);
    if (_state) {
        fprintf(stderr, "monitor_protocol_event_queue " "event=%d data=%p rate=%" PRId64 " last=%" PRId64 " now=%" PRId64 "\n" , event, data, rate, last, now);
    }
}
static inline void trace_monitor_protocol_event_throttle(uint32_t event, uint64_t rate)
{
    bool _state = trace_event_get_state(TRACE_MONITOR_PROTOCOL_EVENT_THROTTLE);
    if (_state) {
        fprintf(stderr, "monitor_protocol_event_throttle " "event=%d rate=%" PRId64 "\n" , event, rate);
    }
}
static inline void trace_open_eth_mii_write(unsigned idx, uint16_t v)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_MII_WRITE);
    if (_state) {
        fprintf(stderr, "open_eth_mii_write " "MII[%02x] <- %04x" "\n" , idx, v);
    }
}
static inline void trace_open_eth_mii_read(unsigned idx, uint16_t v)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_MII_READ);
    if (_state) {
        fprintf(stderr, "open_eth_mii_read " "MII[%02x] -> %04x" "\n" , idx, v);
    }
}
static inline void trace_open_eth_update_irq(uint32_t v)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_UPDATE_IRQ);
    if (_state) {
        fprintf(stderr, "open_eth_update_irq " "IRQ <- %x" "\n" , v);
    }
}
static inline void trace_open_eth_receive(unsigned len)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_RECEIVE);
    if (_state) {
        fprintf(stderr, "open_eth_receive " "RX: len: %u" "\n" , len);
    }
}
static inline void trace_open_eth_receive_mcast(unsigned idx, uint32_t h0, uint32_t h1)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_RECEIVE_MCAST);
    if (_state) {
        fprintf(stderr, "open_eth_receive_mcast " "MCAST: idx = %u, hash: %08x:%08x" "\n" , idx, h0, h1);
    }
}
static inline void trace_open_eth_receive_reject(void)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_RECEIVE_REJECT);
    if (_state) {
        fprintf(stderr, "open_eth_receive_reject " "RX: rejected" "\n" );
    }
}
static inline void trace_open_eth_receive_desc(uint32_t addr, uint32_t len_flags)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_RECEIVE_DESC);
    if (_state) {
        fprintf(stderr, "open_eth_receive_desc " "RX: %08x, len_flags: %08x" "\n" , addr, len_flags);
    }
}
static inline void trace_open_eth_start_xmit(uint32_t addr, unsigned len, unsigned tx_len)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_START_XMIT);
    if (_state) {
        fprintf(stderr, "open_eth_start_xmit " "TX: %08x, len: %u, tx_len: %u" "\n" , addr, len, tx_len);
    }
}
static inline void trace_open_eth_reg_read(uint32_t addr, uint32_t v)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_REG_READ);
    if (_state) {
        fprintf(stderr, "open_eth_reg_read " "MAC[%02x] -> %08x" "\n" , addr, v);
    }
}
static inline void trace_open_eth_reg_write(uint32_t addr, uint32_t v)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_REG_WRITE);
    if (_state) {
        fprintf(stderr, "open_eth_reg_write " "MAC[%02x] <- %08x" "\n" , addr, v);
    }
}
static inline void trace_open_eth_desc_read(uint32_t addr, uint32_t v)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_DESC_READ);
    if (_state) {
        fprintf(stderr, "open_eth_desc_read " "DESC[%04x] -> %08x" "\n" , addr, v);
    }
}
static inline void trace_open_eth_desc_write(uint32_t addr, uint32_t v)
{
    bool _state = trace_event_get_state(TRACE_OPEN_ETH_DESC_WRITE);
    if (_state) {
        fprintf(stderr, "open_eth_desc_write " "DESC[%04x] <- %08x" "\n" , addr, v);
    }
}
static inline void trace_v9fs_rerror(uint16_t tag, uint8_t id, int err)
{
    bool _state = trace_event_get_state(TRACE_V9FS_RERROR);
    if (_state) {
        fprintf(stderr, "v9fs_rerror " "tag %d id %d err %d" "\n" , tag, id, err);
    }
}
static inline void trace_v9fs_version(uint16_t tag, uint8_t id, int32_t msize, char* version)
{
    bool _state = trace_event_get_state(TRACE_V9FS_VERSION);
    if (_state) {
        fprintf(stderr, "v9fs_version " "tag %d id %d msize %d version %s" "\n" , tag, id, msize, version);
    }
}
static inline void trace_v9fs_version_return(uint16_t tag, uint8_t id, int32_t msize, char* version)
{
    bool _state = trace_event_get_state(TRACE_V9FS_VERSION_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_version_return " "tag %d id %d msize %d version %s" "\n" , tag, id, msize, version);
    }
}
static inline void trace_v9fs_attach(uint16_t tag, uint8_t id, int32_t fid, int32_t afid, char* uname, char* aname)
{
    bool _state = trace_event_get_state(TRACE_V9FS_ATTACH);
    if (_state) {
        fprintf(stderr, "v9fs_attach " "tag %u id %u fid %d afid %d uname %s aname %s" "\n" , tag, id, fid, afid, uname, aname);
    }
}
static inline void trace_v9fs_attach_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path)
{
    bool _state = trace_event_get_state(TRACE_V9FS_ATTACH_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_attach_return " "tag %d id %d type %d version %d path %"PRId64"" "\n" , tag, id, type, version, path);
    }
}
static inline void trace_v9fs_stat(uint16_t tag, uint8_t id, int32_t fid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_STAT);
    if (_state) {
        fprintf(stderr, "v9fs_stat " "tag %d id %d fid %d" "\n" , tag, id, fid);
    }
}
static inline void trace_v9fs_stat_return(uint16_t tag, uint8_t id, int32_t mode, int32_t atime, int32_t mtime, int64_t length)
{
    bool _state = trace_event_get_state(TRACE_V9FS_STAT_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_stat_return " "tag %d id %d stat={mode %d atime %d mtime %d length %"PRId64"}" "\n" , tag, id, mode, atime, mtime, length);
    }
}
static inline void trace_v9fs_getattr(uint16_t tag, uint8_t id, int32_t fid, uint64_t request_mask)
{
    bool _state = trace_event_get_state(TRACE_V9FS_GETATTR);
    if (_state) {
        fprintf(stderr, "v9fs_getattr " "tag %d id %d fid %d request_mask %"PRIu64"" "\n" , tag, id, fid, request_mask);
    }
}
static inline void trace_v9fs_getattr_return(uint16_t tag, uint8_t id, uint64_t result_mask, uint32_t mode, uint32_t uid, uint32_t gid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_GETATTR_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_getattr_return " "tag %d id %d getattr={result_mask %"PRId64" mode %u uid %u gid %u}" "\n" , tag, id, result_mask, mode, uid, gid);
    }
}
static inline void trace_v9fs_walk(uint16_t tag, uint8_t id, int32_t fid, int32_t newfid, uint16_t nwnames)
{
    bool _state = trace_event_get_state(TRACE_V9FS_WALK);
    if (_state) {
        fprintf(stderr, "v9fs_walk " "tag %d id %d fid %d newfid %d nwnames %d" "\n" , tag, id, fid, newfid, nwnames);
    }
}
static inline void trace_v9fs_walk_return(uint16_t tag, uint8_t id, uint16_t nwnames, void* qids)
{
    bool _state = trace_event_get_state(TRACE_V9FS_WALK_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_walk_return " "tag %d id %d nwnames %d qids %p" "\n" , tag, id, nwnames, qids);
    }
}
static inline void trace_v9fs_open(uint16_t tag, uint8_t id, int32_t fid, int32_t mode)
{
    bool _state = trace_event_get_state(TRACE_V9FS_OPEN);
    if (_state) {
        fprintf(stderr, "v9fs_open " "tag %d id %d fid %d mode %d" "\n" , tag, id, fid, mode);
    }
}
static inline void trace_v9fs_open_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int iounit)
{
    bool _state = trace_event_get_state(TRACE_V9FS_OPEN_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_open_return " "tag %d id %d qid={type %d version %d path %"PRId64"} iounit %d" "\n" , tag, id, type, version, path, iounit);
    }
}
static inline void trace_v9fs_lcreate(uint16_t tag, uint8_t id, int32_t dfid, int32_t flags, int32_t mode, uint32_t gid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_LCREATE);
    if (_state) {
        fprintf(stderr, "v9fs_lcreate " "tag %d id %d dfid %d flags %d mode %d gid %u" "\n" , tag, id, dfid, flags, mode, gid);
    }
}
static inline void trace_v9fs_lcreate_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int32_t iounit)
{
    bool _state = trace_event_get_state(TRACE_V9FS_LCREATE_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_lcreate_return " "tag %d id %d qid={type %d version %d path %"PRId64"} iounit %d" "\n" , tag, id, type, version, path, iounit);
    }
}
static inline void trace_v9fs_fsync(uint16_t tag, uint8_t id, int32_t fid, int datasync)
{
    bool _state = trace_event_get_state(TRACE_V9FS_FSYNC);
    if (_state) {
        fprintf(stderr, "v9fs_fsync " "tag %d id %d fid %d datasync %d" "\n" , tag, id, fid, datasync);
    }
}
static inline void trace_v9fs_clunk(uint16_t tag, uint8_t id, int32_t fid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_CLUNK);
    if (_state) {
        fprintf(stderr, "v9fs_clunk " "tag %d id %d fid %d" "\n" , tag, id, fid);
    }
}
static inline void trace_v9fs_read(uint16_t tag, uint8_t id, int32_t fid, uint64_t off, uint32_t max_count)
{
    bool _state = trace_event_get_state(TRACE_V9FS_READ);
    if (_state) {
        fprintf(stderr, "v9fs_read " "tag %d id %d fid %d off %"PRIu64" max_count %u" "\n" , tag, id, fid, off, max_count);
    }
}
static inline void trace_v9fs_read_return(uint16_t tag, uint8_t id, int32_t count, ssize_t err)
{
    bool _state = trace_event_get_state(TRACE_V9FS_READ_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_read_return " "tag %d id %d count %d err %zd" "\n" , tag, id, count, err);
    }
}
static inline void trace_v9fs_readdir(uint16_t tag, uint8_t id, int32_t fid, uint64_t offset, uint32_t max_count)
{
    bool _state = trace_event_get_state(TRACE_V9FS_READDIR);
    if (_state) {
        fprintf(stderr, "v9fs_readdir " "tag %d id %d fid %d offset %"PRIu64" max_count %u" "\n" , tag, id, fid, offset, max_count);
    }
}
static inline void trace_v9fs_readdir_return(uint16_t tag, uint8_t id, uint32_t count, ssize_t retval)
{
    bool _state = trace_event_get_state(TRACE_V9FS_READDIR_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_readdir_return " "tag %d id %d count %u retval %zd" "\n" , tag, id, count, retval);
    }
}
static inline void trace_v9fs_write(uint16_t tag, uint8_t id, int32_t fid, uint64_t off, uint32_t count, int cnt)
{
    bool _state = trace_event_get_state(TRACE_V9FS_WRITE);
    if (_state) {
        fprintf(stderr, "v9fs_write " "tag %d id %d fid %d off %"PRIu64" count %u cnt %d" "\n" , tag, id, fid, off, count, cnt);
    }
}
static inline void trace_v9fs_write_return(uint16_t tag, uint8_t id, int32_t total, ssize_t err)
{
    bool _state = trace_event_get_state(TRACE_V9FS_WRITE_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_write_return " "tag %d id %d total %d err %zd" "\n" , tag, id, total, err);
    }
}
static inline void trace_v9fs_create(uint16_t tag, uint8_t id, int32_t fid, char* name, int32_t perm, int8_t mode)
{
    bool _state = trace_event_get_state(TRACE_V9FS_CREATE);
    if (_state) {
        fprintf(stderr, "v9fs_create " "tag %d id %d fid %d name %s perm %d mode %d" "\n" , tag, id, fid, name, perm, mode);
    }
}
static inline void trace_v9fs_create_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int iounit)
{
    bool _state = trace_event_get_state(TRACE_V9FS_CREATE_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_create_return " "tag %d id %d qid={type %d version %d path %"PRId64"} iounit %d" "\n" , tag, id, type, version, path, iounit);
    }
}
static inline void trace_v9fs_symlink(uint16_t tag, uint8_t id, int32_t fid, char* name, char* symname, uint32_t gid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_SYMLINK);
    if (_state) {
        fprintf(stderr, "v9fs_symlink " "tag %d id %d fid %d name %s symname %s gid %u" "\n" , tag, id, fid, name, symname, gid);
    }
}
static inline void trace_v9fs_symlink_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path)
{
    bool _state = trace_event_get_state(TRACE_V9FS_SYMLINK_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_symlink_return " "tag %d id %d qid={type %d version %d path %"PRId64"}" "\n" , tag, id, type, version, path);
    }
}
static inline void trace_v9fs_flush(uint16_t tag, uint8_t id, int16_t flush_tag)
{
    bool _state = trace_event_get_state(TRACE_V9FS_FLUSH);
    if (_state) {
        fprintf(stderr, "v9fs_flush " "tag %d id %d flush_tag %d" "\n" , tag, id, flush_tag);
    }
}
static inline void trace_v9fs_link(uint16_t tag, uint8_t id, int32_t dfid, int32_t oldfid, char* name)
{
    bool _state = trace_event_get_state(TRACE_V9FS_LINK);
    if (_state) {
        fprintf(stderr, "v9fs_link " "tag %d id %d dfid %d oldfid %d name %s" "\n" , tag, id, dfid, oldfid, name);
    }
}
static inline void trace_v9fs_remove(uint16_t tag, uint8_t id, int32_t fid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_REMOVE);
    if (_state) {
        fprintf(stderr, "v9fs_remove " "tag %d id %d fid %d" "\n" , tag, id, fid);
    }
}
static inline void trace_v9fs_wstat(uint16_t tag, uint8_t id, int32_t fid, int32_t mode, int32_t atime, int32_t mtime)
{
    bool _state = trace_event_get_state(TRACE_V9FS_WSTAT);
    if (_state) {
        fprintf(stderr, "v9fs_wstat " "tag %u id %u fid %d stat={mode %d atime %d mtime %d}" "\n" , tag, id, fid, mode, atime, mtime);
    }
}
static inline void trace_v9fs_mknod(uint16_t tag, uint8_t id, int32_t fid, int mode, int major, int minor)
{
    bool _state = trace_event_get_state(TRACE_V9FS_MKNOD);
    if (_state) {
        fprintf(stderr, "v9fs_mknod " "tag %d id %d fid %d mode %d major %d minor %d" "\n" , tag, id, fid, mode, major, minor);
    }
}
static inline void trace_v9fs_mknod_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path)
{
    bool _state = trace_event_get_state(TRACE_V9FS_MKNOD_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_mknod_return " "tag %d id %d qid={type %d version %d path %"PRId64"}" "\n" , tag, id, type, version, path);
    }
}
static inline void trace_v9fs_lock(uint16_t tag, uint8_t id, int32_t fid, uint8_t type, uint64_t start, uint64_t length)
{
    bool _state = trace_event_get_state(TRACE_V9FS_LOCK);
    if (_state) {
        fprintf(stderr, "v9fs_lock " "tag %d id %d fid %d type %d start %"PRIu64" length %"PRIu64"" "\n" , tag, id, fid, type, start, length);
    }
}
static inline void trace_v9fs_lock_return(uint16_t tag, uint8_t id, int8_t status)
{
    bool _state = trace_event_get_state(TRACE_V9FS_LOCK_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_lock_return " "tag %d id %d status %d" "\n" , tag, id, status);
    }
}
static inline void trace_v9fs_getlock(uint16_t tag, uint8_t id, int32_t fid, uint8_t type, uint64_t start, uint64_t length)
{
    bool _state = trace_event_get_state(TRACE_V9FS_GETLOCK);
    if (_state) {
        fprintf(stderr, "v9fs_getlock " "tag %d id %d fid %d type %d start %"PRIu64" length %"PRIu64"" "\n" , tag, id, fid, type, start, length);
    }
}
static inline void trace_v9fs_getlock_return(uint16_t tag, uint8_t id, uint8_t type, uint64_t start, uint64_t length, uint32_t proc_id)
{
    bool _state = trace_event_get_state(TRACE_V9FS_GETLOCK_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_getlock_return " "tag %d id %d type %d start %"PRIu64" length %"PRIu64" proc_id %u" "\n" , tag, id, type, start, length, proc_id);
    }
}
static inline void trace_v9fs_mkdir(uint16_t tag, uint8_t id, int32_t fid, char* name, int mode, uint32_t gid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_MKDIR);
    if (_state) {
        fprintf(stderr, "v9fs_mkdir " "tag %u id %u fid %d name %s mode %d gid %u" "\n" , tag, id, fid, name, mode, gid);
    }
}
static inline void trace_v9fs_mkdir_return(uint16_t tag, uint8_t id, int8_t type, int32_t version, int64_t path, int err)
{
    bool _state = trace_event_get_state(TRACE_V9FS_MKDIR_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_mkdir_return " "tag %u id %u qid={type %d version %d path %"PRId64"} err %d" "\n" , tag, id, type, version, path, err);
    }
}
static inline void trace_v9fs_xattrwalk(uint16_t tag, uint8_t id, int32_t fid, int32_t newfid, char* name)
{
    bool _state = trace_event_get_state(TRACE_V9FS_XATTRWALK);
    if (_state) {
        fprintf(stderr, "v9fs_xattrwalk " "tag %d id %d fid %d newfid %d name %s" "\n" , tag, id, fid, newfid, name);
    }
}
static inline void trace_v9fs_xattrwalk_return(uint16_t tag, uint8_t id, int64_t size)
{
    bool _state = trace_event_get_state(TRACE_V9FS_XATTRWALK_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_xattrwalk_return " "tag %d id %d size %"PRId64"" "\n" , tag, id, size);
    }
}
static inline void trace_v9fs_xattrcreate(uint16_t tag, uint8_t id, int32_t fid, char* name, int64_t size, int flags)
{
    bool _state = trace_event_get_state(TRACE_V9FS_XATTRCREATE);
    if (_state) {
        fprintf(stderr, "v9fs_xattrcreate " "tag %d id %d fid %d name %s size %"PRId64" flags %d" "\n" , tag, id, fid, name, size, flags);
    }
}
static inline void trace_v9fs_readlink(uint16_t tag, uint8_t id, int32_t fid)
{
    bool _state = trace_event_get_state(TRACE_V9FS_READLINK);
    if (_state) {
        fprintf(stderr, "v9fs_readlink " "tag %d id %d fid %d" "\n" , tag, id, fid);
    }
}
static inline void trace_v9fs_readlink_return(uint16_t tag, uint8_t id, char* target)
{
    bool _state = trace_event_get_state(TRACE_V9FS_READLINK_RETURN);
    if (_state) {
        fprintf(stderr, "v9fs_readlink_return " "tag %d id %d name %s" "\n" , tag, id, target);
    }
}
static inline void trace_mmu_helper_dfault(uint64_t address, uint64_t context, int mmu_idx, uint32_t tl)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_DFAULT);
    if (_state) {
        fprintf(stderr, "mmu_helper_dfault " "DFAULT at %"PRIx64" context %"PRIx64" mmu_idx=%d tl=%d" "\n" , address, context, mmu_idx, tl);
    }
}
static inline void trace_mmu_helper_dprot(uint64_t address, uint64_t context, int mmu_idx, uint32_t tl)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_DPROT);
    if (_state) {
        fprintf(stderr, "mmu_helper_dprot " "DPROT at %"PRIx64" context %"PRIx64" mmu_idx=%d tl=%d" "\n" , address, context, mmu_idx, tl);
    }
}
static inline void trace_mmu_helper_dmiss(uint64_t address, uint64_t context)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_DMISS);
    if (_state) {
        fprintf(stderr, "mmu_helper_dmiss " "DMISS at %"PRIx64" context %"PRIx64"" "\n" , address, context);
    }
}
static inline void trace_mmu_helper_tfault(uint64_t address, uint64_t context)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_TFAULT);
    if (_state) {
        fprintf(stderr, "mmu_helper_tfault " "TFAULT at %"PRIx64" context %"PRIx64"" "\n" , address, context);
    }
}
static inline void trace_mmu_helper_tmiss(uint64_t address, uint64_t context)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_TMISS);
    if (_state) {
        fprintf(stderr, "mmu_helper_tmiss " "TMISS at %"PRIx64" context %"PRIx64"" "\n" , address, context);
    }
}
static inline void trace_mmu_helper_get_phys_addr_code(uint32_t tl, int mmu_idx, uint64_t prim_context, uint64_t sec_context, uint64_t address)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_GET_PHYS_ADDR_CODE);
    if (_state) {
        fprintf(stderr, "mmu_helper_get_phys_addr_code " "tl=%d mmu_idx=%d primary context=%"PRIx64" secondary context=%"PRIx64" address=%"PRIx64"" "\n" , tl, mmu_idx, prim_context, sec_context, address);
    }
}
static inline void trace_mmu_helper_get_phys_addr_data(uint32_t tl, int mmu_idx, uint64_t prim_context, uint64_t sec_context, uint64_t address)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_GET_PHYS_ADDR_DATA);
    if (_state) {
        fprintf(stderr, "mmu_helper_get_phys_addr_data " "tl=%d mmu_idx=%d primary context=%"PRIx64" secondary context=%"PRIx64" address=%"PRIx64"" "\n" , tl, mmu_idx, prim_context, sec_context, address);
    }
}
static inline void trace_mmu_helper_mmu_fault(uint64_t address, uint64_t paddr, int mmu_idx, uint32_t tl, uint64_t prim_context, uint64_t sec_context)
{
    bool _state = trace_event_get_state(TRACE_MMU_HELPER_MMU_FAULT);
    if (_state) {
        fprintf(stderr, "mmu_helper_mmu_fault " "Translate at %"PRIx64" -> %"PRIx64", mmu_idx=%d tl=%d primary context=%"PRIx64" secondary context=%"PRIx64"" "\n" , address, paddr, mmu_idx, tl, prim_context, sec_context);
    }
}
static inline void trace_int_helper_set_softint(uint32_t softint)
{
    bool _state = trace_event_get_state(TRACE_INT_HELPER_SET_SOFTINT);
    if (_state) {
        fprintf(stderr, "int_helper_set_softint " "new %08x" "\n" , softint);
    }
}
static inline void trace_int_helper_clear_softint(uint32_t softint)
{
    bool _state = trace_event_get_state(TRACE_INT_HELPER_CLEAR_SOFTINT);
    if (_state) {
        fprintf(stderr, "int_helper_clear_softint " "new %08x" "\n" , softint);
    }
}
static inline void trace_int_helper_write_softint(uint32_t softint)
{
    bool _state = trace_event_get_state(TRACE_INT_HELPER_WRITE_SOFTINT);
    if (_state) {
        fprintf(stderr, "int_helper_write_softint " "new %08x" "\n" , softint);
    }
}
static inline void trace_int_helper_icache_freeze(void)
{
    bool _state = trace_event_get_state(TRACE_INT_HELPER_ICACHE_FREEZE);
    if (_state) {
        fprintf(stderr, "int_helper_icache_freeze " "Instruction cache: freeze" "\n" );
    }
}
static inline void trace_int_helper_dcache_freeze(void)
{
    bool _state = trace_event_get_state(TRACE_INT_HELPER_DCACHE_FREEZE);
    if (_state) {
        fprintf(stderr, "int_helper_dcache_freeze " "Data cache: freeze" "\n" );
    }
}
static inline void trace_win_helper_gregset_error(uint32_t pstate)
{
    bool _state = trace_event_get_state(TRACE_WIN_HELPER_GREGSET_ERROR);
    if (_state) {
        fprintf(stderr, "win_helper_gregset_error " "ERROR in get_gregset: active pstate bits=%x" "\n" , pstate);
    }
}
static inline void trace_win_helper_switch_pstate(uint32_t pstate_regs, uint32_t new_pstate_regs)
{
    bool _state = trace_event_get_state(TRACE_WIN_HELPER_SWITCH_PSTATE);
    if (_state) {
        fprintf(stderr, "win_helper_switch_pstate " "change_pstate: switching regs old=%x new=%x" "\n" , pstate_regs, new_pstate_regs);
    }
}
static inline void trace_win_helper_no_switch_pstate(uint32_t new_pstate_regs)
{
    bool _state = trace_event_get_state(TRACE_WIN_HELPER_NO_SWITCH_PSTATE);
    if (_state) {
        fprintf(stderr, "win_helper_no_switch_pstate " "change_pstate: regs new=%x (unchanged)" "\n" , new_pstate_regs);
    }
}
static inline void trace_win_helper_wrpil(uint32_t psrpil, uint32_t new_pil)
{
    bool _state = trace_event_get_state(TRACE_WIN_HELPER_WRPIL);
    if (_state) {
        fprintf(stderr, "win_helper_wrpil " "old=%x new=%x" "\n" , psrpil, new_pil);
    }
}
static inline void trace_win_helper_done(uint32_t tl)
{
    bool _state = trace_event_get_state(TRACE_WIN_HELPER_DONE);
    if (_state) {
        fprintf(stderr, "win_helper_done " "tl=%d" "\n" , tl);
    }
}
static inline void trace_win_helper_retry(uint32_t tl)
{
    bool _state = trace_event_get_state(TRACE_WIN_HELPER_RETRY);
    if (_state) {
        fprintf(stderr, "win_helper_retry " "tl=%d" "\n" , tl);
    }
}
static inline void trace_dma_bdrv_io(void * dbs, void * bs, int64_t sector_num, bool to_dev)
{
    bool _state = trace_event_get_state(TRACE_DMA_BDRV_IO);
    if (_state) {
        fprintf(stderr, "dma_bdrv_io " "dbs=%p bs=%p sector_num=%" PRId64 " to_dev=%d" "\n" , dbs, bs, sector_num, to_dev);
    }
}
static inline void trace_dma_aio_cancel(void * dbs)
{
    bool _state = trace_event_get_state(TRACE_DMA_AIO_CANCEL);
    if (_state) {
        fprintf(stderr, "dma_aio_cancel " "dbs=%p" "\n" , dbs);
    }
}
static inline void trace_dma_complete(void * dbs, int ret, void * cb)
{
    bool _state = trace_event_get_state(TRACE_DMA_COMPLETE);
    if (_state) {
        fprintf(stderr, "dma_complete " "dbs=%p ret=%d cb=%p" "\n" , dbs, ret, cb);
    }
}
static inline void trace_dma_bdrv_cb(void * dbs, int ret)
{
    bool _state = trace_event_get_state(TRACE_DMA_BDRV_CB);
    if (_state) {
        fprintf(stderr, "dma_bdrv_cb " "dbs=%p ret=%d" "\n" , dbs, ret);
    }
}
static inline void trace_dma_map_wait(void * dbs)
{
    bool _state = trace_event_get_state(TRACE_DMA_MAP_WAIT);
    if (_state) {
        fprintf(stderr, "dma_map_wait " "dbs=%p" "\n" , dbs);
    }
}
static inline void trace_console_gfx_new(void)
{
    bool _state = trace_event_get_state(TRACE_CONSOLE_GFX_NEW);
    if (_state) {
        fprintf(stderr, "console_gfx_new " "" "\n" );
    }
}
static inline void trace_console_txt_new(int w, int h)
{
    bool _state = trace_event_get_state(TRACE_CONSOLE_TXT_NEW);
    if (_state) {
        fprintf(stderr, "console_txt_new " "%dx%d" "\n" , w, h);
    }
}
static inline void trace_console_select(int nr)
{
    bool _state = trace_event_get_state(TRACE_CONSOLE_SELECT);
    if (_state) {
        fprintf(stderr, "console_select " "%d" "\n" , nr);
    }
}
static inline void trace_console_refresh(int interval)
{
    bool _state = trace_event_get_state(TRACE_CONSOLE_REFRESH);
    if (_state) {
        fprintf(stderr, "console_refresh " "interval %d ms" "\n" , interval);
    }
}
static inline void trace_displaysurface_create(void * display_surface, int w, int h)
{
    bool _state = trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE);
    if (_state) {
        fprintf(stderr, "displaysurface_create " "surface=%p, %dx%d" "\n" , display_surface, w, h);
    }
}
static inline void trace_displaysurface_create_from(void * display_surface, int w, int h, int bpp, int swap)
{
    bool _state = trace_event_get_state(TRACE_DISPLAYSURFACE_CREATE_FROM);
    if (_state) {
        fprintf(stderr, "displaysurface_create_from " "surface=%p, %dx%d, bpp %d, bswap %d" "\n" , display_surface, w, h, bpp, swap);
    }
}
static inline void trace_displaysurface_free(void * display_surface)
{
    bool _state = trace_event_get_state(TRACE_DISPLAYSURFACE_FREE);
    if (_state) {
        fprintf(stderr, "displaysurface_free " "surface=%p" "\n" , display_surface);
    }
}
static inline void trace_displaychangelistener_register(void * dcl, const char * name)
{
    bool _state = trace_event_get_state(TRACE_DISPLAYCHANGELISTENER_REGISTER);
    if (_state) {
        fprintf(stderr, "displaychangelistener_register " "%p [ %s ]" "\n" , dcl, name);
    }
}
static inline void trace_displaychangelistener_unregister(void * dcl, const char * name)
{
    bool _state = trace_event_get_state(TRACE_DISPLAYCHANGELISTENER_UNREGISTER);
    if (_state) {
        fprintf(stderr, "displaychangelistener_unregister " "%p [ %s ]" "\n" , dcl, name);
    }
}
static inline void trace_ppm_save(const char * filename, void * display_surface)
{
    bool _state = trace_event_get_state(TRACE_PPM_SAVE);
    if (_state) {
        fprintf(stderr, "ppm_save " "%s surface=%p" "\n" , filename, display_surface);
    }
}
static inline void trace_vmware_value_read(uint32_t index, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_VMWARE_VALUE_READ);
    if (_state) {
        fprintf(stderr, "vmware_value_read " "index %d, value 0x%x" "\n" , index, value);
    }
}
static inline void trace_vmware_value_write(uint32_t index, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_VMWARE_VALUE_WRITE);
    if (_state) {
        fprintf(stderr, "vmware_value_write " "index %d, value 0x%x" "\n" , index, value);
    }
}
static inline void trace_vmware_palette_read(uint32_t index, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_VMWARE_PALETTE_READ);
    if (_state) {
        fprintf(stderr, "vmware_palette_read " "index %d, value 0x%x" "\n" , index, value);
    }
}
static inline void trace_vmware_palette_write(uint32_t index, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_VMWARE_PALETTE_WRITE);
    if (_state) {
        fprintf(stderr, "vmware_palette_write " "index %d, value 0x%x" "\n" , index, value);
    }
}
static inline void trace_vmware_scratch_read(uint32_t index, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_VMWARE_SCRATCH_READ);
    if (_state) {
        fprintf(stderr, "vmware_scratch_read " "index %d, value 0x%x" "\n" , index, value);
    }
}
static inline void trace_vmware_scratch_write(uint32_t index, uint32_t value)
{
    bool _state = trace_event_get_state(TRACE_VMWARE_SCRATCH_WRITE);
    if (_state) {
        fprintf(stderr, "vmware_scratch_write " "index %d, value 0x%x" "\n" , index, value);
    }
}
static inline void trace_vmware_setmode(uint32_t w, uint32_t h, uint32_t bpp)
{
    bool _state = trace_event_get_state(TRACE_VMWARE_SETMODE);
    if (_state) {
        fprintf(stderr, "vmware_setmode " "%dx%d @ %d bpp" "\n" , w, h, bpp);
    }
}
static inline void trace_savevm_section_start(void)
{
    bool _state = trace_event_get_state(TRACE_SAVEVM_SECTION_START);
    if (_state) {
        fprintf(stderr, "savevm_section_start " "" "\n" );
    }
}
static inline void trace_savevm_section_end(unsigned int section_id)
{
    bool _state = trace_event_get_state(TRACE_SAVEVM_SECTION_END);
    if (_state) {
        fprintf(stderr, "savevm_section_end " "section_id %u" "\n" , section_id);
    }
}
static inline void trace_migration_bitmap_sync_start(void)
{
    bool _state = trace_event_get_state(TRACE_MIGRATION_BITMAP_SYNC_START);
    if (_state) {
        fprintf(stderr, "migration_bitmap_sync_start " "" "\n" );
    }
}
static inline void trace_migration_bitmap_sync_end(uint64_t dirty_pages)
{
    bool _state = trace_event_get_state(TRACE_MIGRATION_BITMAP_SYNC_END);
    if (_state) {
        fprintf(stderr, "migration_bitmap_sync_end " "dirty_pages %" PRIu64"" "\n" , dirty_pages);
    }
}
static inline void trace_migration_throttle(void)
{
    bool _state = trace_event_get_state(TRACE_MIGRATION_THROTTLE);
    if (_state) {
        fprintf(stderr, "migration_throttle " "" "\n" );
    }
}
static inline void trace_qxl_create_guest_primary(int qid, uint32_t width, uint32_t height, uint64_t mem, uint32_t format, uint32_t position)
{
    bool _state = trace_event_get_state(TRACE_QXL_CREATE_GUEST_PRIMARY);
    if (_state) {
        fprintf(stderr, "qxl_create_guest_primary " "%d %ux%u mem=%" PRIx64 " %u,%u" "\n" , qid, width, height, mem, format, position);
    }
}
static inline void trace_qxl_create_guest_primary_rest(int qid, int32_t stride, uint32_t type, uint32_t flags)
{
    bool _state = trace_event_get_state(TRACE_QXL_CREATE_GUEST_PRIMARY_REST);
    if (_state) {
        fprintf(stderr, "qxl_create_guest_primary_rest " "%d %d,%d,%d" "\n" , qid, stride, type, flags);
    }
}
static inline void trace_qxl_destroy_primary(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_DESTROY_PRIMARY);
    if (_state) {
        fprintf(stderr, "qxl_destroy_primary " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_enter_vga_mode(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_ENTER_VGA_MODE);
    if (_state) {
        fprintf(stderr, "qxl_enter_vga_mode " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_exit_vga_mode(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_EXIT_VGA_MODE);
    if (_state) {
        fprintf(stderr, "qxl_exit_vga_mode " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_hard_reset(int qid, int64_t loadvm)
{
    bool _state = trace_event_get_state(TRACE_QXL_HARD_RESET);
    if (_state) {
        fprintf(stderr, "qxl_hard_reset " "%d loadvm=%"PRId64"" "\n" , qid, loadvm);
    }
}
static inline void trace_qxl_interface_async_complete_io(int qid, uint32_t current_async, void * cookie)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_ASYNC_COMPLETE_IO);
    if (_state) {
        fprintf(stderr, "qxl_interface_async_complete_io " "%d current=%d cookie=%p" "\n" , qid, current_async, cookie);
    }
}
static inline void trace_qxl_interface_attach_worker(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_ATTACH_WORKER);
    if (_state) {
        fprintf(stderr, "qxl_interface_attach_worker " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_interface_get_init_info(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_GET_INIT_INFO);
    if (_state) {
        fprintf(stderr, "qxl_interface_get_init_info " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_interface_set_compression_level(int qid, int64_t level)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_SET_COMPRESSION_LEVEL);
    if (_state) {
        fprintf(stderr, "qxl_interface_set_compression_level " "%d %"PRId64 "\n" , qid, level);
    }
}
static inline void trace_qxl_interface_update_area_complete(int qid, uint32_t surface_id, uint32_t dirty_left, uint32_t dirty_right, uint32_t dirty_top, uint32_t dirty_bottom)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_UPDATE_AREA_COMPLETE);
    if (_state) {
        fprintf(stderr, "qxl_interface_update_area_complete " "%d surface=%d [%d,%d,%d,%d]" "\n" , qid, surface_id, dirty_left, dirty_right, dirty_top, dirty_bottom);
    }
}
static inline void trace_qxl_interface_update_area_complete_rest(int qid, uint32_t num_updated_rects)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_UPDATE_AREA_COMPLETE_REST);
    if (_state) {
        fprintf(stderr, "qxl_interface_update_area_complete_rest " "%d #=%d" "\n" , qid, num_updated_rects);
    }
}
static inline void trace_qxl_interface_update_area_complete_overflow(int qid, int max)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_UPDATE_AREA_COMPLETE_OVERFLOW);
    if (_state) {
        fprintf(stderr, "qxl_interface_update_area_complete_overflow " "%d max=%d" "\n" , qid, max);
    }
}
static inline void trace_qxl_interface_update_area_complete_schedule_bh(int qid, uint32_t num_dirty)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERFACE_UPDATE_AREA_COMPLETE_SCHEDULE_BH);
    if (_state) {
        fprintf(stderr, "qxl_interface_update_area_complete_schedule_bh " "%d #dirty=%d" "\n" , qid, num_dirty);
    }
}
static inline void trace_qxl_io_destroy_primary_ignored(int qid, const char * mode)
{
    bool _state = trace_event_get_state(TRACE_QXL_IO_DESTROY_PRIMARY_IGNORED);
    if (_state) {
        fprintf(stderr, "qxl_io_destroy_primary_ignored " "%d %s" "\n" , qid, mode);
    }
}
static inline void trace_qxl_io_log(int qid, const uint8_t * log_buf)
{
    bool _state = trace_event_get_state(TRACE_QXL_IO_LOG);
    if (_state) {
        fprintf(stderr, "qxl_io_log " "%d %s" "\n" , qid, log_buf);
    }
}
static inline void trace_qxl_io_read_unexpected(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_IO_READ_UNEXPECTED);
    if (_state) {
        fprintf(stderr, "qxl_io_read_unexpected " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_io_unexpected_vga_mode(int qid, uint64_t addr, uint64_t val, const char * desc)
{
    bool _state = trace_event_get_state(TRACE_QXL_IO_UNEXPECTED_VGA_MODE);
    if (_state) {
        fprintf(stderr, "qxl_io_unexpected_vga_mode " "%d 0x%"PRIx64"=%"PRIu64" (%s)" "\n" , qid, addr, val, desc);
    }
}
static inline void trace_qxl_io_write(int qid, const char * mode, uint64_t addr, uint64_t val, unsigned size, int async)
{
    bool _state = trace_event_get_state(TRACE_QXL_IO_WRITE);
    if (_state) {
        fprintf(stderr, "qxl_io_write " "%d %s addr=%"PRIu64 " val=%"PRIu64" size=%u async=%d" "\n" , qid, mode, addr, val, size, async);
    }
}
static inline void trace_qxl_memslot_add_guest(int qid, uint32_t slot_id, uint64_t guest_start, uint64_t guest_end)
{
    bool _state = trace_event_get_state(TRACE_QXL_MEMSLOT_ADD_GUEST);
    if (_state) {
        fprintf(stderr, "qxl_memslot_add_guest " "%d %u: guest phys 0x%"PRIx64 " - 0x%" PRIx64 "\n" , qid, slot_id, guest_start, guest_end);
    }
}
static inline void trace_qxl_post_load(int qid, const char * mode)
{
    bool _state = trace_event_get_state(TRACE_QXL_POST_LOAD);
    if (_state) {
        fprintf(stderr, "qxl_post_load " "%d %s" "\n" , qid, mode);
    }
}
static inline void trace_qxl_pre_load(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_PRE_LOAD);
    if (_state) {
        fprintf(stderr, "qxl_pre_load " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_pre_save(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_PRE_SAVE);
    if (_state) {
        fprintf(stderr, "qxl_pre_save " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_reset_surfaces(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_RESET_SURFACES);
    if (_state) {
        fprintf(stderr, "qxl_reset_surfaces " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_ring_command_check(int qid, const char * mode)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_COMMAND_CHECK);
    if (_state) {
        fprintf(stderr, "qxl_ring_command_check " "%d %s" "\n" , qid, mode);
    }
}
static inline void trace_qxl_ring_command_get(int qid, const char * mode)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_COMMAND_GET);
    if (_state) {
        fprintf(stderr, "qxl_ring_command_get " "%d %s" "\n" , qid, mode);
    }
}
static inline void trace_qxl_ring_command_req_notification(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_COMMAND_REQ_NOTIFICATION);
    if (_state) {
        fprintf(stderr, "qxl_ring_command_req_notification " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_ring_cursor_check(int qid, const char * mode)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_CURSOR_CHECK);
    if (_state) {
        fprintf(stderr, "qxl_ring_cursor_check " "%d %s" "\n" , qid, mode);
    }
}
static inline void trace_qxl_ring_cursor_get(int qid, const char * mode)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_CURSOR_GET);
    if (_state) {
        fprintf(stderr, "qxl_ring_cursor_get " "%d %s" "\n" , qid, mode);
    }
}
static inline void trace_qxl_ring_cursor_req_notification(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_CURSOR_REQ_NOTIFICATION);
    if (_state) {
        fprintf(stderr, "qxl_ring_cursor_req_notification " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_ring_res_push(int qid, const char * mode, uint32_t surface_count, uint32_t free_res, void * last_release, const char * notify)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_RES_PUSH);
    if (_state) {
        fprintf(stderr, "qxl_ring_res_push " "%d %s s#=%d res#=%d last=%p notify=%s" "\n" , qid, mode, surface_count, free_res, last_release, notify);
    }
}
static inline void trace_qxl_ring_res_push_rest(int qid, uint32_t ring_has, uint32_t ring_size, uint32_t prod, uint32_t cons)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_RES_PUSH_REST);
    if (_state) {
        fprintf(stderr, "qxl_ring_res_push_rest " "%d ring %d/%d [%d,%d]" "\n" , qid, ring_has, ring_size, prod, cons);
    }
}
static inline void trace_qxl_ring_res_put(int qid, uint32_t free_res)
{
    bool _state = trace_event_get_state(TRACE_QXL_RING_RES_PUT);
    if (_state) {
        fprintf(stderr, "qxl_ring_res_put " "%d #res=%d" "\n" , qid, free_res);
    }
}
static inline void trace_qxl_set_mode(int qid, int modenr, uint32_t x_res, uint32_t y_res, uint32_t bits, uint64_t devmem)
{
    bool _state = trace_event_get_state(TRACE_QXL_SET_MODE);
    if (_state) {
        fprintf(stderr, "qxl_set_mode " "%d mode=%d [ x=%d y=%d @ bpp=%d devmem=0x%" PRIx64 " ]" "\n" , qid, modenr, x_res, y_res, bits, devmem);
    }
}
static inline void trace_qxl_soft_reset(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SOFT_RESET);
    if (_state) {
        fprintf(stderr, "qxl_soft_reset " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_spice_destroy_surfaces_complete(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_DESTROY_SURFACES_COMPLETE);
    if (_state) {
        fprintf(stderr, "qxl_spice_destroy_surfaces_complete " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_spice_destroy_surfaces(int qid, int async)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_DESTROY_SURFACES);
    if (_state) {
        fprintf(stderr, "qxl_spice_destroy_surfaces " "%d async=%d" "\n" , qid, async);
    }
}
static inline void trace_qxl_spice_destroy_surface_wait_complete(int qid, uint32_t id)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_DESTROY_SURFACE_WAIT_COMPLETE);
    if (_state) {
        fprintf(stderr, "qxl_spice_destroy_surface_wait_complete " "%d sid=%d" "\n" , qid, id);
    }
}
static inline void trace_qxl_spice_destroy_surface_wait(int qid, uint32_t id, int async)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_DESTROY_SURFACE_WAIT);
    if (_state) {
        fprintf(stderr, "qxl_spice_destroy_surface_wait " "%d sid=%d async=%d" "\n" , qid, id, async);
    }
}
static inline void trace_qxl_spice_flush_surfaces_async(int qid, uint32_t surface_count, uint32_t num_free_res)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_FLUSH_SURFACES_ASYNC);
    if (_state) {
        fprintf(stderr, "qxl_spice_flush_surfaces_async " "%d s#=%d, res#=%d" "\n" , qid, surface_count, num_free_res);
    }
}
static inline void trace_qxl_spice_monitors_config(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_MONITORS_CONFIG);
    if (_state) {
        fprintf(stderr, "qxl_spice_monitors_config " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_spice_loadvm_commands(int qid, void * ext, uint32_t count)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_LOADVM_COMMANDS);
    if (_state) {
        fprintf(stderr, "qxl_spice_loadvm_commands " "%d ext=%p count=%d" "\n" , qid, ext, count);
    }
}
static inline void trace_qxl_spice_oom(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_OOM);
    if (_state) {
        fprintf(stderr, "qxl_spice_oom " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_spice_reset_cursor(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_RESET_CURSOR);
    if (_state) {
        fprintf(stderr, "qxl_spice_reset_cursor " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_spice_reset_image_cache(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_RESET_IMAGE_CACHE);
    if (_state) {
        fprintf(stderr, "qxl_spice_reset_image_cache " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_spice_reset_memslots(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_RESET_MEMSLOTS);
    if (_state) {
        fprintf(stderr, "qxl_spice_reset_memslots " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_spice_update_area(int qid, uint32_t surface_id, uint32_t left, uint32_t right, uint32_t top, uint32_t bottom)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_UPDATE_AREA);
    if (_state) {
        fprintf(stderr, "qxl_spice_update_area " "%d sid=%d [%d,%d,%d,%d]" "\n" , qid, surface_id, left, right, top, bottom);
    }
}
static inline void trace_qxl_spice_update_area_rest(int qid, uint32_t num_dirty_rects, uint32_t clear_dirty_region)
{
    bool _state = trace_event_get_state(TRACE_QXL_SPICE_UPDATE_AREA_REST);
    if (_state) {
        fprintf(stderr, "qxl_spice_update_area_rest " "%d #d=%d clear=%d" "\n" , qid, num_dirty_rects, clear_dirty_region);
    }
}
static inline void trace_qxl_surfaces_dirty(int qid, int surface, int offset, int size)
{
    bool _state = trace_event_get_state(TRACE_QXL_SURFACES_DIRTY);
    if (_state) {
        fprintf(stderr, "qxl_surfaces_dirty " "%d surface=%d offset=%d size=%d" "\n" , qid, surface, offset, size);
    }
}
static inline void trace_qxl_send_events(int qid, uint32_t events)
{
    bool _state = trace_event_get_state(TRACE_QXL_SEND_EVENTS);
    if (_state) {
        fprintf(stderr, "qxl_send_events " "%d %d" "\n" , qid, events);
    }
}
static inline void trace_qxl_send_events_vm_stopped(int qid, uint32_t events)
{
    bool _state = trace_event_get_state(TRACE_QXL_SEND_EVENTS_VM_STOPPED);
    if (_state) {
        fprintf(stderr, "qxl_send_events_vm_stopped " "%d %d" "\n" , qid, events);
    }
}
static inline void trace_qxl_set_guest_bug(int qid)
{
    bool _state = trace_event_get_state(TRACE_QXL_SET_GUEST_BUG);
    if (_state) {
        fprintf(stderr, "qxl_set_guest_bug " "%d" "\n" , qid);
    }
}
static inline void trace_qxl_interrupt_client_monitors_config(int qid, int num_heads, void * heads)
{
    bool _state = trace_event_get_state(TRACE_QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);
    if (_state) {
        fprintf(stderr, "qxl_interrupt_client_monitors_config " "%d %d %p" "\n" , qid, num_heads, heads);
    }
}
static inline void trace_qxl_client_monitors_config_unsupported_by_guest(int qid, uint32_t int_mask, void * client_monitors_config)
{
    bool _state = trace_event_get_state(TRACE_QXL_CLIENT_MONITORS_CONFIG_UNSUPPORTED_BY_GUEST);
    if (_state) {
        fprintf(stderr, "qxl_client_monitors_config_unsupported_by_guest " "%d %X %p" "\n" , qid, int_mask, client_monitors_config);
    }
}
static inline void trace_qxl_client_monitors_config_unsupported_by_device(int qid, int revision)
{
    bool _state = trace_event_get_state(TRACE_QXL_CLIENT_MONITORS_CONFIG_UNSUPPORTED_BY_DEVICE);
    if (_state) {
        fprintf(stderr, "qxl_client_monitors_config_unsupported_by_device " "%d revision=%d" "\n" , qid, revision);
    }
}
static inline void trace_qxl_client_monitors_config_capped(int qid, int requested, int limit)
{
    bool _state = trace_event_get_state(TRACE_QXL_CLIENT_MONITORS_CONFIG_CAPPED);
    if (_state) {
        fprintf(stderr, "qxl_client_monitors_config_capped " "%d %d %d" "\n" , qid, requested, limit);
    }
}
static inline void trace_qxl_client_monitors_config_crc(int qid, unsigned size, uint32_t crc32)
{
    bool _state = trace_event_get_state(TRACE_QXL_CLIENT_MONITORS_CONFIG_CRC);
    if (_state) {
        fprintf(stderr, "qxl_client_monitors_config_crc " "%d %u %u" "\n" , qid, size, crc32);
    }
}
static inline void trace_qxl_set_client_capabilities_unsupported_by_revision(int qid, int revision)
{
    bool _state = trace_event_get_state(TRACE_QXL_SET_CLIENT_CAPABILITIES_UNSUPPORTED_BY_REVISION);
    if (_state) {
        fprintf(stderr, "qxl_set_client_capabilities_unsupported_by_revision " "%d revision=%d" "\n" , qid, revision);
    }
}
static inline void trace_qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async)
{
    bool _state = trace_event_get_state(TRACE_QEMU_SPICE_ADD_MEMSLOT);
    if (_state) {
        fprintf(stderr, "qemu_spice_add_memslot " "%d %u: host virt 0x%lx - 0x%lx async=%d" "\n" , qid, slot_id, virt_start, virt_end, async);
    }
}
static inline void trace_qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id)
{
    bool _state = trace_event_get_state(TRACE_QEMU_SPICE_DEL_MEMSLOT);
    if (_state) {
        fprintf(stderr, "qemu_spice_del_memslot " "%d gid=%u sid=%u" "\n" , qid, gid, slot_id);
    }
}
static inline void trace_qemu_spice_create_primary_surface(int qid, uint32_t sid, void * surface, int async)
{
    bool _state = trace_event_get_state(TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE);
    if (_state) {
        fprintf(stderr, "qemu_spice_create_primary_surface " "%d sid=%u surface=%p async=%d" "\n" , qid, sid, surface, async);
    }
}
static inline void trace_qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async)
{
    bool _state = trace_event_get_state(TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE);
    if (_state) {
        fprintf(stderr, "qemu_spice_destroy_primary_surface " "%d sid=%u async=%d" "\n" , qid, sid, async);
    }
}
static inline void trace_qemu_spice_wakeup(uint32_t qid)
{
    bool _state = trace_event_get_state(TRACE_QEMU_SPICE_WAKEUP);
    if (_state) {
        fprintf(stderr, "qemu_spice_wakeup " "%d" "\n" , qid);
    }
}
static inline void trace_qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom)
{
    bool _state = trace_event_get_state(TRACE_QEMU_SPICE_CREATE_UPDATE);
    if (_state) {
        fprintf(stderr, "qemu_spice_create_update " "lr %d -> %d,  tb -> %d -> %d" "\n" , left, right, top, bottom);
    }
}
static inline void trace_qxl_render_blit_guest_primary_initialized(void)
{
    bool _state = trace_event_get_state(TRACE_QXL_RENDER_BLIT_GUEST_PRIMARY_INITIALIZED);
    if (_state) {
        fprintf(stderr, "qxl_render_blit_guest_primary_initialized " "" "\n" );
    }
}
static inline void trace_qxl_render_blit(int32_t stride, int32_t left, int32_t right, int32_t top, int32_t bottom)
{
    bool _state = trace_event_get_state(TRACE_QXL_RENDER_BLIT);
    if (_state) {
        fprintf(stderr, "qxl_render_blit " "stride=%d [%d, %d, %d, %d]" "\n" , stride, left, right, top, bottom);
    }
}
static inline void trace_qxl_render_guest_primary_resized(int32_t width, int32_t height, int32_t stride, int32_t bytes_pp, int32_t bits_pp)
{
    bool _state = trace_event_get_state(TRACE_QXL_RENDER_GUEST_PRIMARY_RESIZED);
    if (_state) {
        fprintf(stderr, "qxl_render_guest_primary_resized " "%dx%d, stride %d, bpp %d, depth %d" "\n" , width, height, stride, bytes_pp, bits_pp);
    }
}
static inline void trace_qxl_render_update_area_done(void * cookie)
{
    bool _state = trace_event_get_state(TRACE_QXL_RENDER_UPDATE_AREA_DONE);
    if (_state) {
        fprintf(stderr, "qxl_render_update_area_done " "%p" "\n" , cookie);
    }
}
static inline void trace_spapr_pci_msi(const char * msg, uint32_t n, uint32_t ca)
{
    bool _state = trace_event_get_state(TRACE_SPAPR_PCI_MSI);
    if (_state) {
        fprintf(stderr, "spapr_pci_msi " "%s (device#%d, cfg=%x)" "\n" , msg, n, ca);
    }
}
static inline void trace_spapr_pci_msi_setup(const char * name, unsigned vector, uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_SPAPR_PCI_MSI_SETUP);
    if (_state) {
        fprintf(stderr, "spapr_pci_msi_setup " "dev\"%s\" vector %u, addr=%"PRIx64 "\n" , name, vector, addr);
    }
}
static inline void trace_spapr_pci_rtas_ibm_change_msi(unsigned func, unsigned req)
{
    bool _state = trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_CHANGE_MSI);
    if (_state) {
        fprintf(stderr, "spapr_pci_rtas_ibm_change_msi " "func %u, requested %u" "\n" , func, req);
    }
}
static inline void trace_spapr_pci_rtas_ibm_query_interrupt_source_number(unsigned ioa, unsigned intr)
{
    bool _state = trace_event_get_state(TRACE_SPAPR_PCI_RTAS_IBM_QUERY_INTERRUPT_SOURCE_NUMBER);
    if (_state) {
        fprintf(stderr, "spapr_pci_rtas_ibm_query_interrupt_source_number " "queries for #%u, IRQ%u" "\n" , ioa, intr);
    }
}
static inline void trace_spapr_pci_msi_write(uint64_t addr, uint64_t data, uint32_t dt_irq)
{
    bool _state = trace_event_get_state(TRACE_SPAPR_PCI_MSI_WRITE);
    if (_state) {
        fprintf(stderr, "spapr_pci_msi_write " "@%"PRIx64"<=%"PRIx64" IRQ %u" "\n" , addr, data, dt_irq);
    }
}
static inline void trace_spapr_pci_lsi_set(const char * busname, int pin, uint32_t irq)
{
    bool _state = trace_event_get_state(TRACE_SPAPR_PCI_LSI_SET);
    if (_state) {
        fprintf(stderr, "spapr_pci_lsi_set " "%s PIN%d IRQ %u" "\n" , busname, pin, irq);
    }
}
static inline void trace_xics_icp_check_ipi(int server, uint8_t mfrr)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICP_CHECK_IPI);
    if (_state) {
        fprintf(stderr, "xics_icp_check_ipi " "CPU %d can take IPI mfrr=%#x" "\n" , server, mfrr);
    }
}
static inline void trace_xics_icp_accept(uint32_t old_xirr, uint32_t new_xirr)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICP_ACCEPT);
    if (_state) {
        fprintf(stderr, "xics_icp_accept " "icp_accept: XIRR %#"PRIx32"->%#"PRIx32 "\n" , old_xirr, new_xirr);
    }
}
static inline void trace_xics_icp_eoi(int server, uint32_t xirr, uint32_t new_xirr)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICP_EOI);
    if (_state) {
        fprintf(stderr, "xics_icp_eoi " "icp_eoi: server %d given XIRR %#"PRIx32" new XIRR %#"PRIx32 "\n" , server, xirr, new_xirr);
    }
}
static inline void trace_xics_icp_irq(int server, int nr, uint8_t priority)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICP_IRQ);
    if (_state) {
        fprintf(stderr, "xics_icp_irq " "cpu %d trying to deliver irq %#"PRIx32" priority %#x" "\n" , server, nr, priority);
    }
}
static inline void trace_xics_icp_raise(uint32_t xirr, uint8_t pending_priority)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICP_RAISE);
    if (_state) {
        fprintf(stderr, "xics_icp_raise " "raising IRQ new XIRR=%#x new pending priority=%#x" "\n" , xirr, pending_priority);
    }
}
static inline void trace_xics_set_irq_msi(int srcno, int nr)
{
    bool _state = trace_event_get_state(TRACE_XICS_SET_IRQ_MSI);
    if (_state) {
        fprintf(stderr, "xics_set_irq_msi " "set_irq_msi: srcno %d [irq %#x]" "\n" , srcno, nr);
    }
}
static inline void trace_xics_masked_pending(void)
{
    bool _state = trace_event_get_state(TRACE_XICS_MASKED_PENDING);
    if (_state) {
        fprintf(stderr, "xics_masked_pending " "set_irq_msi: masked pending" "\n" );
    }
}
static inline void trace_xics_set_irq_lsi(int srcno, int nr)
{
    bool _state = trace_event_get_state(TRACE_XICS_SET_IRQ_LSI);
    if (_state) {
        fprintf(stderr, "xics_set_irq_lsi " "set_irq_lsi: srcno %d [irq %#x]" "\n" , srcno, nr);
    }
}
static inline void trace_xics_ics_write_xive(int nr, int srcno, int server, uint8_t priority)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICS_WRITE_XIVE);
    if (_state) {
        fprintf(stderr, "xics_ics_write_xive " "ics_write_xive: irq %#x [src %d] server %#x prio %#x" "\n" , nr, srcno, server, priority);
    }
}
static inline void trace_xics_ics_reject(int nr, int srcno)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICS_REJECT);
    if (_state) {
        fprintf(stderr, "xics_ics_reject " "reject irq %#x [src %d]" "\n" , nr, srcno);
    }
}
static inline void trace_xics_ics_eoi(int nr)
{
    bool _state = trace_event_get_state(TRACE_XICS_ICS_EOI);
    if (_state) {
        fprintf(stderr, "xics_ics_eoi " "ics_eoi: irq %#x" "\n" , nr);
    }
}
static inline void trace_hbitmap_iter_skip_words(const void * hb, void * hbi, uint64_t pos, unsigned long cur)
{
    bool _state = trace_event_get_state(TRACE_HBITMAP_ITER_SKIP_WORDS);
    if (_state) {
        fprintf(stderr, "hbitmap_iter_skip_words " "hb %p hbi %p pos %"PRId64" cur 0x%lx" "\n" , hb, hbi, pos, cur);
    }
}
static inline void trace_hbitmap_reset(void * hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit)
{
    bool _state = trace_event_get_state(TRACE_HBITMAP_RESET);
    if (_state) {
        fprintf(stderr, "hbitmap_reset " "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64 "\n" , hb, start, count, sbit, ebit);
    }
}
static inline void trace_hbitmap_set(void * hb, uint64_t start, uint64_t count, uint64_t sbit, uint64_t ebit)
{
    bool _state = trace_event_get_state(TRACE_HBITMAP_SET);
    if (_state) {
        fprintf(stderr, "hbitmap_set " "hb %p items %"PRIu64",%"PRIu64" bits %"PRIu64"..%"PRIu64 "\n" , hb, start, count, sbit, ebit);
    }
}
static inline void trace_ioinst(const char * insn)
{
    bool _state = trace_event_get_state(TRACE_IOINST);
    if (_state) {
        fprintf(stderr, "ioinst " "IOINST: %s" "\n" , insn);
    }
}
static inline void trace_ioinst_sch_id(const char * insn, int cssid, int ssid, int schid)
{
    bool _state = trace_event_get_state(TRACE_IOINST_SCH_ID);
    if (_state) {
        fprintf(stderr, "ioinst_sch_id " "IOINST: %s (%x.%x.%04x)" "\n" , insn, cssid, ssid, schid);
    }
}
static inline void trace_ioinst_chp_id(const char * insn, int cssid, int chpid)
{
    bool _state = trace_event_get_state(TRACE_IOINST_CHP_ID);
    if (_state) {
        fprintf(stderr, "ioinst_chp_id " "IOINST: %s (%x.%02x)" "\n" , insn, cssid, chpid);
    }
}
static inline void trace_ioinst_chsc_cmd(uint16_t cmd, uint16_t len)
{
    bool _state = trace_event_get_state(TRACE_IOINST_CHSC_CMD);
    if (_state) {
        fprintf(stderr, "ioinst_chsc_cmd " "IOINST: chsc command %04x, len %04x" "\n" , cmd, len);
    }
}
static inline void trace_css_enable_facility(const char * facility)
{
    bool _state = trace_event_get_state(TRACE_CSS_ENABLE_FACILITY);
    if (_state) {
        fprintf(stderr, "css_enable_facility " "CSS: enable %s" "\n" , facility);
    }
}
static inline void trace_css_crw(uint8_t rsc, uint8_t erc, uint16_t rsid, const char * chained)
{
    bool _state = trace_event_get_state(TRACE_CSS_CRW);
    if (_state) {
        fprintf(stderr, "css_crw " "CSS: queueing crw: rsc=%x, erc=%x, rsid=%x %s" "\n" , rsc, erc, rsid, chained);
    }
}
static inline void trace_css_chpid_add(uint8_t cssid, uint8_t chpid, uint8_t type)
{
    bool _state = trace_event_get_state(TRACE_CSS_CHPID_ADD);
    if (_state) {
        fprintf(stderr, "css_chpid_add " "CSS: add chpid %x.%02x (type %02x)" "\n" , cssid, chpid, type);
    }
}
static inline void trace_css_new_image(uint8_t cssid, const char * default_cssid)
{
    bool _state = trace_event_get_state(TRACE_CSS_NEW_IMAGE);
    if (_state) {
        fprintf(stderr, "css_new_image " "CSS: add css image %02x %s" "\n" , cssid, default_cssid);
    }
}
static inline void trace_css_assign_subch(const char * do_assign, uint8_t cssid, uint8_t ssid, uint16_t schid, uint16_t devno)
{
    bool _state = trace_event_get_state(TRACE_CSS_ASSIGN_SUBCH);
    if (_state) {
        fprintf(stderr, "css_assign_subch " "CSS: %s %x.%x.%04x (devno %04x)" "\n" , do_assign, cssid, ssid, schid, devno);
    }
}
static inline void trace_css_io_interrupt(int cssid, int ssid, int schid, uint32_t intparm, uint8_t isc, const char * conditional)
{
    bool _state = trace_event_get_state(TRACE_CSS_IO_INTERRUPT);
    if (_state) {
        fprintf(stderr, "css_io_interrupt " "CSS: I/O interrupt on sch %x.%x.%04x (intparm %08x, isc %x) %s" "\n" , cssid, ssid, schid, intparm, isc, conditional);
    }
}
static inline void trace_virtio_ccw_interpret_ccw(int cssid, int ssid, int schid, int cmd_code)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_CCW_INTERPRET_CCW);
    if (_state) {
        fprintf(stderr, "virtio_ccw_interpret_ccw " "VIRTIO-CCW: %x.%x.%04x: interpret command %x" "\n" , cssid, ssid, schid, cmd_code);
    }
}
static inline void trace_virtio_ccw_new_device(int cssid, int ssid, int schid, int devno, const char * devno_mode)
{
    bool _state = trace_event_get_state(TRACE_VIRTIO_CCW_NEW_DEVICE);
    if (_state) {
        fprintf(stderr, "virtio_ccw_new_device " "VIRTIO-CCW: add subchannel %x.%x.%04x, devno %04x (%s)" "\n" , cssid, ssid, schid, devno, devno_mode);
    }
}
static inline void trace_migrate_set_state(int new_state)
{
    bool _state = trace_event_get_state(TRACE_MIGRATE_SET_STATE);
    if (_state) {
        fprintf(stderr, "migrate_set_state " "new state %d" "\n" , new_state);
    }
}
static inline void trace_kvm_ioctl(int type, void * arg)
{
    bool _state = trace_event_get_state(TRACE_KVM_IOCTL);
    if (_state) {
        fprintf(stderr, "kvm_ioctl " "type %d, arg %p" "\n" , type, arg);
    }
}
static inline void trace_kvm_vm_ioctl(int type, void * arg)
{
    bool _state = trace_event_get_state(TRACE_KVM_VM_IOCTL);
    if (_state) {
        fprintf(stderr, "kvm_vm_ioctl " "type %d, arg %p" "\n" , type, arg);
    }
}
static inline void trace_kvm_vcpu_ioctl(int cpu_index, int type, void * arg)
{
    bool _state = trace_event_get_state(TRACE_KVM_VCPU_IOCTL);
    if (_state) {
        fprintf(stderr, "kvm_vcpu_ioctl " "cpu_index %d, type %d, arg %p" "\n" , cpu_index, type, arg);
    }
}
static inline void trace_kvm_run_exit(int cpu_index, uint32_t reason)
{
    bool _state = trace_event_get_state(TRACE_KVM_RUN_EXIT);
    if (_state) {
        fprintf(stderr, "kvm_run_exit " "cpu_index %d, reason %d" "\n" , cpu_index, reason);
    }
}
static inline void trace_memory_region_ops_read(void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    bool _state = trace_event_get_state(TRACE_MEMORY_REGION_OPS_READ);
    if (_state) {
        fprintf(stderr, "memory_region_ops_read " "mr %p addr %#"PRIx64" value %#"PRIx64" size %u" "\n" , mr, addr, value, size);
    }
}
static inline void trace_memory_region_ops_write(void * mr, uint64_t addr, uint64_t value, unsigned size)
{
    bool _state = trace_event_get_state(TRACE_MEMORY_REGION_OPS_WRITE);
    if (_state) {
        fprintf(stderr, "memory_region_ops_write " "mr %p addr %#"PRIx64" value %#"PRIx64" size %u" "\n" , mr, addr, value, size);
    }
}
static inline void trace_object_dynamic_cast_assert(const char * type, const char * target, const char * file, int line, const char * func)
{
    bool _state = trace_event_get_state(TRACE_OBJECT_DYNAMIC_CAST_ASSERT);
    if (_state) {
        fprintf(stderr, "object_dynamic_cast_assert " "%s->%s (%s:%d:%s)" "\n" , type, target, file, line, func);
    }
}
static inline void trace_object_class_dynamic_cast_assert(const char * type, const char * target, const char * file, int line, const char * func)
{
    bool _state = trace_event_get_state(TRACE_OBJECT_CLASS_DYNAMIC_CAST_ASSERT);
    if (_state) {
        fprintf(stderr, "object_class_dynamic_cast_assert " "%s->%s (%s:%d:%s)" "\n" , type, target, file, line, func);
    }
}
static inline void trace_xen_pv_mmio_read(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_XEN_PV_MMIO_READ);
    if (_state) {
        fprintf(stderr, "xen_pv_mmio_read " "WARNING: read from Xen PV Device MMIO space (address %"PRIx64")" "\n" , addr);
    }
}
static inline void trace_xen_pv_mmio_write(uint64_t addr)
{
    bool _state = trace_event_get_state(TRACE_XEN_PV_MMIO_WRITE);
    if (_state) {
        fprintf(stderr, "xen_pv_mmio_write " "WARNING: write to Xen PV Device MMIO space (address %"PRIx64")" "\n" , addr);
    }
}
#endif /* TRACE__GENERATED_TRACERS_H */
