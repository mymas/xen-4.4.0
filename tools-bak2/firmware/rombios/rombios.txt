00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 struct rombios_info {
00004                                           ! 2     unsigned long bios32_entry;
00005                                           !BCC_EOS
00006                                           ! 3 };
00007                                           !BCC_EOS
00008                                           ! 4 #asm
00009                                           !BCC_ASM
00010 0000                                      .rom
00011 0000                                      .org 0x0000
00012                                           use16 386
00013                                           MACRO HALT
00014                                             ;; the HALT macro is called with the line number of the HALT call.
00015                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00016                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00017                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00018                                             ;; However, users can choose to make panics non-fatal and continue.
00019                                             mov dx,#0x400
00020                                             mov ax,#?1
00021                                             out dx,ax
00022                                           MEND
00023                                           MACRO JMP_AP
00024                                             db 0xea
00025                                             dw ?2
00026                                             dw ?1
00027                                           MEND
00028                                           MACRO SET_INT_VECTOR
00029                                             mov ax, ?3
00030                                             mov ?1*4, ax
00031                                             mov ax, ?2
00032                                             mov ?1*4+2, ax
00033                                           MEND
00034                                           ! 29 endasm
00035                                           !BCC_ENDASM
00036                                           ! 30 typedef unsigned char Bit8u;
00037                                           !BCC_EOS
00038                                           ! 31 typedef unsigned short Bit16u;
00039                                           !BCC_EOS
00040                                           ! 32 typedef unsigned short bx_bool;
00041                                           !BCC_EOS
00042                                           ! 33 typedef unsigned long Bit32u;
00043                                           !BCC_EOS
00044                                           ! 34   void memsetb(seg,offset,value,count);
00045                                           !BCC_EOS
00046                                           ! 35   void memcpyb(dseg,doffset,sseg,soffset,count);
00047                                           !BCC_EOS
00048                                           ! 36   void memcpyd(dseg,doffset,sseg,soffset,count);
00049                                           !BCC_EOS
00050                                           ! 37     void
00051                                           ! 38   memsetb(seg,offset,value,count)
00052                                           ! 39     Bit16u seg;
00053                                           export	_memsetb
00054                       00000000            _memsetb:
00055                                           !BCC_EOS
00056                                           ! 40     Bit16u offset;
00057                                           !BCC_EOS
00058                                           ! 41     Bit16u value;
00059                                           !BCC_EOS
00060                                           ! 42     Bit16u count;
00061                                           !BCC_EOS
00062                                           ! 43   {
00063                                           ! 44 #asm
00064                                           !BCC_ASM
00065                       00000008            _memsetb.count	set	8
00066                       00000002            _memsetb.seg	set	2
00067                       00000006            _memsetb.value	set	6
00068                       00000004            _memsetb.offset	set	4
00069 0000           55                             push bp
00070 0001           89E5                           mov bp, sp
00071 0003           50                               push ax
00072 0004           51                               push cx
00073 0005           06                               push es
00074 0006           57                               push di
00075 0007           8B4E         0A                  mov cx, 10[bp] ; count
00076 000A           85C9                             test cx, cx
00077 000C           74           10                  je memsetb_end
00078 000E           8B46         04                  mov ax, 4[bp] ; segment
00079 0011           8EC0                             mov es, ax
00080 0013           8B46         06                  mov ax, 6[bp] ; offset
00081 0016           89C7                             mov di, ax
00082 0018           8A46         08                  mov al, 8[bp] ; value
00083 001B           FC                               cld
00084 001C           F3                               rep
00085 001D           AA                                stosb
00086                       0000001E              memsetb_end:
00087 001E           5F                               pop di
00088 001F           07                               pop es
00089 0020           59                               pop cx
00090 0021           58                               pop ax
00091 0022           5D                             pop bp
00092                                           ! 68 endasm
00093                                           !BCC_ENDASM
00094                                           ! 69   }
00095 0023           C3                         ret
00096                                           ! 70     void
00097                                           ! 71   memcpyb(dseg,doffset,sseg,soffset,count)
00098                                           ! 72     Bit16u dseg;
00099                                           export	_memcpyb
00100                       00000024            _memcpyb:
00101                                           !BCC_EOS
00102                                           ! 73     Bit16u doffset;
00103                                           !BCC_EOS
00104                                           ! 74     Bit16u sseg;
00105                                           !BCC_EOS
00106                                           ! 75     Bit16u soffset;
00107                                           !BCC_EOS
00108                                           ! 76     Bit16u count;
00109                                           !BCC_EOS
00110                                           ! 77   {
00111                                           ! 78 #asm
00112                                           !BCC_ASM
00113                       0000000A            _memcpyb.count	set	$A
00114                       00000006            _memcpyb.sseg	set	6
00115                       00000008            _memcpyb.soffset	set	8
00116                       00000002            _memcpyb.dseg	set	2
00117                       00000004            _memcpyb.doffset	set	4
00118 0024           55                             push bp
00119 0025           89E5                           mov bp, sp
00120 0027           50                               push ax
00121 0028           51                               push cx
00122 0029           06                               push es
00123 002A           57                               push di
00124 002B           1E                               push ds
00125 002C           56                               push si
00126 002D           8B4E         0C                  mov cx, 12[bp] ; count
00127 0030           85C9                             test cx, cx
00128 0032           74           17                  je memcpyb_end
00129 0034           8B46         04                  mov ax, 4[bp] ; dsegment
00130 0037           8EC0                             mov es, ax
00131 0039           8B46         06                  mov ax, 6[bp] ; doffset
00132 003C           89C7                             mov di, ax
00133 003E           8B46         08                  mov ax, 8[bp] ; ssegment
00134 0041           8ED8                             mov ds, ax
00135 0043           8B46         0A                  mov ax, 10[bp] ; soffset
00136 0046           89C6                             mov si, ax
00137 0048           FC                               cld
00138 0049           F3                               rep
00139 004A           A4                                movsb
00140                       0000004B              memcpyb_end:
00141 004B           5E                               pop si
00142 004C           1F                               pop ds
00143 004D           5F                               pop di
00144 004E           07                               pop es
00145 004F           59                               pop cx
00146 0050           58                               pop ax
00147 0051           5D                             pop bp
00148                                           ! 109 endasm
00149                                           !BCC_ENDASM
00150                                           ! 110   }
00151 0052           C3                         ret
00152                                           ! 111     void
00153                                           ! 112   memcpyd(dseg,doffset,sseg,soffset,count)
00154                                           ! 113     Bit16u dseg;
00155                                           export	_memcpyd
00156                       00000053            _memcpyd:
00157                                           !BCC_EOS
00158                                           ! 114     Bit16u doffset;
00159                                           !BCC_EOS
00160                                           ! 115     Bit16u sseg;
00161                                           !BCC_EOS
00162                                           ! 116     Bit16u soffset;
00163                                           !BCC_EOS
00164                                           ! 117     Bit16u count;
00165                                           !BCC_EOS
00166                                           ! 118   {
00167                                           ! 119 #asm
00168                                           !BCC_ASM
00169                       0000000A            _memcpyd.count	set	$A
00170                       00000006            _memcpyd.sseg	set	6
00171                       00000008            _memcpyd.soffset	set	8
00172                       00000002            _memcpyd.dseg	set	2
00173                       00000004            _memcpyd.doffset	set	4
00174 0053           55                             push bp
00175 0054           89E5                           mov bp, sp
00176 0056           50                               push ax
00177 0057           51                               push cx
00178 0058           06                               push es
00179 0059           57                               push di
00180 005A           1E                               push ds
00181 005B           56                               push si
00182 005C           8B4E         0C                  mov cx, 12[bp] ; count
00183 005F           85C9                             test cx, cx
00184 0061           74           18                  je memcpyd_end
00185 0063           8B46         04                  mov ax, 4[bp] ; dsegment
00186 0066           8EC0                             mov es, ax
00187 0068           8B46         06                  mov ax, 6[bp] ; doffset
00188 006B           89C7                             mov di, ax
00189 006D           8B46         08                  mov ax, 8[bp] ; ssegment
00190 0070           8ED8                             mov ds, ax
00191 0072           8B46         0A                  mov ax, 10[bp] ; soffset
00192 0075           89C6                             mov si, ax
00193 0077           FC                               cld
00194 0078           F3                               rep
00195 0079     66    A5                                movsd
00196                       0000007B              memcpyd_end:
00197 007B           5E                               pop si
00198 007C           1F                               pop ds
00199 007D           5F                               pop di
00200 007E           07                               pop es
00201 007F           59                               pop cx
00202 0080           58                               pop ax
00203 0081           5D                             pop bp
00204                                           ! 150 endasm
00205                                           !BCC_ENDASM
00206                                           ! 151   }
00207 0082           C3                         ret
00208                                           ! 152   static Bit32u read_dword();
00209                                           !BCC_EOS
00210                                           ! 153   static void write_dword();
00211                                           !BCC_EOS
00212                                           ! 154     Bit32u
00213                                           ! 155   read_dword(seg, offset)
00214                                           ! 156     Bit16u seg;
00215                                           export	_read_dword
00216                       00000083            _read_dword:
00217                                           !BCC_EOS
00218                                           ! 157     Bit16u offset;
00219                                           !BCC_EOS
00220                                           ! 158   {
00221                                           ! 159 #asm
00222                                           !BCC_ASM
00223                       00000002            _read_dword.seg	set	2
00224                       00000004            _read_dword.offset	set	4
00225 0083           55                             push bp
00226 0084           89E5                           mov bp, sp
00227 0086           53                               push bx
00228 0087           1E                               push ds
00229 0088           8B46         04                  mov ax, 4[bp] ; segment
00230 008B           8ED8                             mov ds, ax
00231 008D           8B5E         06                  mov bx, 6[bp] ; offset
00232 0090           8B07                             mov ax, [bx]
00233 0092           83C3                   02        add bx, #2
00234 0095           8B17                             mov dx, [bx]
00235                                                 ;; ax = return value (word)
00236                                                 ;; dx = return value (word)
00237 0097           1F                               pop ds
00238 0098           5B                               pop bx
00239 0099           5D                             pop bp
00240                                           ! 175 endasm
00241                                           !BCC_ENDASM
00242                                           ! 176   }
00243 009A           C3                         ret
00244                                           ! 177     void
00245                                           ! 178   write_dword(seg, offset, data)
00246                                           ! 179     Bit16u seg;
00247                                           export	_write_dword
00248                       0000009B            _write_dword:
00249                                           !BCC_EOS
00250                                           ! 180     Bit16u offset;
00251                                           !BCC_EOS
00252                                           ! 181     Bit32u data;
00253                                           !BCC_EOS
00254                                           ! 182   {
00255                                           ! 183 #asm
00256                                           !BCC_ASM
00257                       00000002            _write_dword.seg	set	2
00258                       00000006            _write_dword.data	set	6
00259                       00000004            _write_dword.offset	set	4
00260 009B           55                             push bp
00261 009C           89E5                           mov bp, sp
00262 009E           50                               push ax
00263 009F           53                               push bx
00264 00A0           1E                               push ds
00265 00A1           8B46         04                  mov ax, 4[bp] ; segment
00266 00A4           8ED8                             mov ds, ax
00267 00A6           8B5E         06                  mov bx, 6[bp] ; offset
00268 00A9           8B46         08                  mov ax, 8[bp] ; data word
00269 00AC           8907                             mov [bx], ax ; write data word
00270 00AE           83C3                   02        add bx, #2
00271 00B1           8B46         0A                  mov ax, 10[bp] ; data word
00272 00B4           8907                             mov [bx], ax ; write data word
00273 00B6           1F                               pop ds
00274 00B7           5B                               pop bx
00275 00B8           58                               pop ax
00276 00B9           5D                             pop bp
00277                                           ! 201 endasm
00278                                           !BCC_ENDASM
00279                                           ! 202   }
00280 00BA           C3                         ret
00281                                           ! 203 #asm
00282                                           !BCC_ASM
00283                       00000002            _write_dword.seg	set	2
00284                       00000006            _write_dword.data	set	6
00285                       00000004            _write_dword.offset	set	4
00286                                             ;; and function
00287                       000000BB              landl:
00288                       000000BB              landul:
00289 00BB           36                             SEG SS
00290 00BC           2305                             and ax,[di]
00291 00BE           36                             SEG SS
00292 00BF           235D         02                  and bx,2[di]
00293 00C2           C3                             ret
00294                                             ;; add function
00295                       000000C3              laddl:
00296                       000000C3              laddul:
00297 00C3           36                             SEG SS
00298 00C4           0305                             add ax,[di]
00299 00C6           36                             SEG SS
00300 00C7           135D         02                  adc bx,2[di]
00301 00CA           C3                             ret
00302                                             ;; cmp function
00303                       000000CB              lcmpl:
00304                       000000CB              lcmpul:
00305 00CB     66    25               0000FFFF      and eax, #0x0000FFFF
00306 00D1     66    C1E3                   10      shl ebx, #16
00307 00D5     66    09D8                           or eax, ebx
00308 00D8     66    C1EB                   10      shr ebx, #16
00309 00DC           36                             SEG SS
00310 00DD     66    3B05                             cmp eax, dword ptr [di]
00311 00E0           C3                             ret
00312                                             ;; sub function
00313                       000000E1              lsubl:
00314                       000000E1              lsubul:
00315 00E1           36                             SEG SS
00316 00E2           2B05                           sub ax,[di]
00317 00E4           36                             SEG SS
00318 00E5           1B5D         02                sbb bx,2[di]
00319 00E8           C3                             ret
00320                                             ;; mul function
00321                       000000E9              lmull:
00322                       000000E9              lmulul:
00323 00E9     66    25               0000FFFF      and eax, #0x0000FFFF
00324 00EF     66    C1E3                   10      shl ebx, #16
00325 00F3     66    09D8                           or eax, ebx
00326 00F6           36                             SEG SS
00327 00F7     66    F725                           mul eax, dword ptr [di]
00328 00FA     66    89C3                           mov ebx, eax
00329 00FD     66    C1EB                   10      shr ebx, #16
00330 0101           C3                             ret
00331                                             ;; dec function
00332                       00000102              ldecl:
00333                       00000102              ldecul:
00334 0102           36                             SEG SS
00335 0103     66    FF0F                           dec dword ptr [bx]
00336 0106           C3                             ret
00337                                             ;; or function
00338                       00000107              lorl:
00339                       00000107              lorul:
00340 0107           36                             SEG SS
00341 0108           0B05                           or ax,[di]
00342 010A           36                             SEG SS
00343 010B           0B5D         02                or bx,2[di]
00344 010E           C3                             ret
00345                                             ;; inc function
00346                       0000010F              lincl:
00347                       0000010F              lincul:
00348 010F           36                             SEG SS
00349 0110     66    FF07                           inc dword ptr [bx]
00350 0113           C3                             ret
00351                                             ;; tst function
00352                       00000114              ltstl:
00353                       00000114              ltstul:
00354 0114     66    25               0000FFFF      and eax, #0x0000FFFF
00355 011A     66    C1E3                   10      shl ebx, #16
00356 011E     66    09D8                           or eax, ebx
00357 0121     66    C1EB                   10      shr ebx, #16
00358 0125     66    85C0                           test eax, eax
00359 0128           C3                             ret
00360                                             ;; sr function
00361                       00000129              lsrul:
00362 0129           89F9                           mov cx,di
00363 012B           E3           19                jcxz lsr_exit
00364 012D     66    25               0000FFFF      and eax, #0x0000FFFF
00365 0133     66    C1E3                   10      shl ebx, #16
00366 0137     66    09D8                           or eax, ebx
00367                       0000013A              lsr_loop:
00368 013A     66    D1E8                           shr eax, #1
00369 013D           E2           FB                loop lsr_loop
00370 013F     66    89C3                           mov ebx, eax
00371 0142     66    C1EB                   10      shr ebx, #16
00372                       00000146              lsr_exit:
00373 0146           C3                             ret
00374                                             ;; sl function
00375                       00000147              lsll:
00376                       00000147              lslul:
00377 0147           89F9                           mov cx,di
00378 0149           E3           19                jcxz lsl_exit
00379 014B     66    25               0000FFFF      and eax, #0x0000FFFF
00380 0151     66    C1E3                   10      shl ebx, #16
00381 0155     66    09D8                           or eax, ebx
00382                       00000158              lsl_loop:
00383 0158     66    D1E0                           shl eax, #1
00384 015B           E2           FB                loop lsl_loop
00385 015D     66    89C3                           mov ebx, eax
00386 0160     66    C1EB                   10      shr ebx, #16
00387                       00000164              lsl_exit:
00388 0164           C3                             ret
00389                       00000165              idiv_:
00390 0165           99                             cwd
00391 0166           F7FB                           idiv bx
00392 0168           C3                             ret
00393                       00000169              idiv_u:
00394 0169           31D2                           xor dx,dx
00395 016B           F7F3                           div bx
00396 016D           C3                             ret
00397                       0000016E              ldivul:
00398 016E     66    25               0000FFFF      and eax, #0x0000FFFF
00399 0174     66    C1E3                   10      shl ebx, #16
00400 0178     66    09D8                           or eax, ebx
00401 017B     66    31D2                           xor edx, edx
00402 017E           36                             SEG SS
00403 017F           8B5D         02                mov bx, 2[di]
00404 0182     66    C1E3                   10      shl ebx, #16
00405 0186           36                             SEG SS
00406 0187           8B1D                           mov bx, [di]
00407 0189     66    F7F3                           div ebx
00408 018C     66    89C3                           mov ebx, eax
00409 018F     66    C1EB                   10      shr ebx, #16
00410 0193           C3                             ret
00411                                           ! 329 endasm
00412                                           !BCC_ENDASM
00413                                           ! 330 typedef struct {
00414                                           ! 331   unsigned char filler1[0x400];
00415                                           !BCC_EOS
00416                                           ! 332   unsigned char filler2[0x6c];
00417                                           !BCC_EOS
00418                                           ! 333   Bit16u ticks_low;
00419                                           !BCC_EOS
00420                                           ! 334   Bit16u ticks_high;
00421                                           !BCC_EOS
00422                                           ! 335   Bit8u midnight_flag;
00423                                           !BCC_EOS
00424                                           ! 336   } bios_data_t;
00425                                           !BCC_EOS
00426                                           ! 337   typedef struct {
00427                                           ! 338     Bit16u heads;
00428                                           !BCC_EOS
00429                                           ! 339     Bit16u cylinders;
00430                                           !BCC_EOS
00431                                           ! 340     Bit16u spt;
00432                                           !BCC_EOS
00433                                           ! 341     } chs_t;
00434                                           !BCC_EOS
00435                                           ! 342   typedef struct {
00436                                           ! 343     Bit16u iobase1;
00437                                           !BCC_EOS
00438                                           ! 344     Bit16u iobase2;
00439                                           !BCC_EOS
00440                                           ! 345     Bit8u prefix;
00441                                           !BCC_EOS
00442                                           ! 346     Bit8u unused;
00443                                           !BCC_EOS
00444                                           ! 347     Bit8u irq;
00445                                           !BCC_EOS
00446                                           ! 348     Bit8u blkcount;
00447                                           !BCC_EOS
00448                                           ! 349     Bit8u dma;
00449                                           !BCC_EOS
00450                                           ! 350     Bit8u pio;
00451                                           !BCC_EOS
00452                                           ! 351     Bit16u options;
00453                                           !BCC_EOS
00454                                           ! 352     Bit16u reserved;
00455                                           !BCC_EOS
00456                                           ! 353     Bit8u revision;
00457                                           !BCC_EOS
00458                                           ! 354     Bit8u checksum;
00459                                           !BCC_EOS
00460                                           ! 355     } dpte_t;
00461                                           !BCC_EOS
00462                                           ! 356   typedef struct {
00463                                           ! 357     Bit8u iface;
00464                                           !BCC_EOS
00465                                           ! 358     Bit16u iobase1;
00466                                           !BCC_EOS
00467                                           ! 359     Bit16u iobase2;
00468                                           !BCC_EOS
00469                                           ! 360     Bit8u irq;
00470                                           !BCC_EOS
00471                                           ! 361     } ata_channel_t;
00472                                           !BCC_EOS
00473                                           ! 362   typedef struct {
00474                                           ! 363     Bit8u type;
00475                                           !BCC_EOS
00476                                           ! 364     Bit8u device;
00477                                           !BCC_EOS
00478                                           ! 365     Bit8u removab
00479                                           ! 365 le;
00480                                           !BCC_EOS
00481                                           ! 366     Bit8u lock;
00482                                           !BCC_EOS
00483                                           ! 367     Bit8u mode;
00484                                           !BCC_EOS
00485                                           ! 368     Bit16u blksize;
00486                                           !BCC_EOS
00487                                           ! 369     Bit8u translation;
00488                                           !BCC_EOS
00489                                           ! 370     chs_t lchs;
00490                                           !BCC_EOS
00491                                           ! 371     chs_t pchs;
00492                                           !BCC_EOS
00493                                           ! 372     Bit32u sectors_low;
00494                                           !BCC_EOS
00495                                           ! 373     Bit32u sectors_high;
00496                                           !BCC_EOS
00497                                           ! 374     } ata_device_t;
00498                                           !BCC_EOS
00499                                           ! 375   typedef struct {
00500                                           ! 376     ata_channel_t channels[4];
00501                                           !BCC_EOS
00502                                           ! 377     ata_device_t devices[(4*2)];
00503                                           !BCC_EOS
00504                                           ! 378     Bit8u hdcount, hdidmap[(4*2)];
00505                                           !BCC_EOS
00506                                           ! 379     Bit8u cdcount, cdidmap[(4*2)];
00507                                           !BCC_EOS
00508                                           ! 380     dpte_t dpte;
00509                                           !BCC_EOS
00510                                           ! 381     Bit16u trsfsectors;
00511                                           !BCC_EOS
00512                                           ! 382     Bit32u trsfbytes;
00513                                           !BCC_EOS
00514                                           ! 383     } ata_t;
00515                                           !BCC_EOS
00516                                           ! 384   typedef struct {
00517                                           ! 385     Bit8u active;
00518                                           !BCC_EOS
00519                                           ! 386     Bit8u media;
00520                                           !BCC_EOS
00521                                           ! 387     Bit8u emulated_drive;
00522                                           !BCC_EOS
00523                                           ! 388     Bit8u controller_index;
00524                                           !BCC_EOS
00525                                           ! 389     Bit16u device_spec;
00526                                           !BCC_EOS
00527                                           ! 390     Bit32u ilba;
00528                                           !BCC_EOS
00529                                           ! 391     Bit16u buffer_segment;
00530                                           !BCC_EOS
00531                                           ! 392     Bit16u load_segment;
00532                                           !BCC_EOS
00533                                           ! 393     Bit16u sector_count;
00534                                           !BCC_EOS
00535                                           ! 394     chs_t vdevice;
00536                                           !BCC_EOS
00537                                           ! 395     } cdemu_t;
00538                                           !BCC_EOS
00539                                           ! 396 Bit32u TCGInterruptHandler ();
00540                                           !BCC_EOS
00541                                           ! 397 void tcpa_acpi_init ();
00542                                           !BCC_EOS
00543                                           ! 398 Bit32u tcpa_extend_acpi_log ();
00544                                           !BCC_EOS
00545                                           ! 399 void tcpa_calling_int19h ();
00546                                           !BCC_EOS
00547                                           ! 400 void tcpa_returned_int19h ();
00548                                           !BCC_EOS
00549                                           ! 401 void tcpa_add_event_separators ();
00550                                           !BCC_EOS
00551                                           ! 402 void tcpa_wake_event ();
00552                                           !BCC_EOS
00553                                           ! 403 void tcpa_add_bootdevice ();
00554                                           !BCC_EOS
00555                                           ! 404 void tcpa_start_option_rom_scan ();
00556                                           !BCC_EOS
00557                                           ! 405 void tcpa_option_rom ();
00558                                           !BCC_EOS
00559                                           ! 406 void tcpa_ipl ();
00560                                           !BCC_EOS
00561                                           ! 407 void tcpa_measure_post ();
00562                                           !BCC_EOS
00563                                           ! 408 Bit32u tcpa_initialize_tpm ();
00564                                           !BCC_EOS
00565                                           ! 409 Bit32u get_s3_waking_vector ();
00566                                           !BCC_EOS
00567                                           ! 410 Bit32u pmm ();
00568                                           !BCC_EOS
00569                                           ! 411   typedef struct {
00570                                           ! 412     unsigned char ebda_size;
00571                                           !BCC_EOS
00572                                           ! 413     unsigned char cmos_shutdown_status;
00573                                           !BCC_EOS
00574                                           ! 414     unsigned char filler1[0x3B];
00575                                           !BCC_EOS
00576                                           ! 415     unsigned char fdpt0[0x10];
00577                                           !BCC_EOS
00578                                           ! 416     unsigned char fdpt1[0x10];
00579                                           !BCC_EOS
00580                                           ! 417     unsigned char filler2[0xC4];
00581                                           !BCC_EOS
00582                                           ! 418     ata_t ata;
00583                                           !BCC_EOS
00584                                           ! 419     cdemu_t cdemu;
00585                                           !BCC_EOS
00586                                           ! 420     } ebda_data_t;
00587                                           !BCC_EOS
00588                                           ! 421   typedef struct {
00589                                           ! 422     Bit8u size;
00590                                           !BCC_EOS
00591                                           ! 423     Bit8u reserved;
00592                                           !BCC_EOS
00593                                           ! 424     Bit16u count;
00594                                           !BCC_EOS
00595                                           ! 425     Bit16u offset;
00596                                           !BCC_EOS
00597                                           ! 426     Bit16u segment;
00598                                           !BCC_EOS
00599                                           ! 427     Bit32u lba1;
00600                                           !BCC_EOS
00601                                           ! 428     Bit32u lba2;
00602                                           !BCC_EOS
00603                                           ! 429     } int13ext_t;
00604                                           !BCC_EOS
00605                                           ! 430   typedef struct {
00606                                           ! 431     Bit16u size;
00607                                           !BCC_EOS
00608                                           ! 432     Bit16u infos;
00609                                           !BCC_EOS
00610                                           ! 433     Bit32u cylinders;
00611                                           !BCC_EOS
00612                                           ! 434     Bit32u heads;
00613                                           !BCC_EOS
00614                                           ! 435     Bit32u spt;
00615                                           !BCC_EOS
00616                                           ! 436     Bit32u sector_count1;
00617                                           !BCC_EOS
00618                                           ! 437     Bit32u sector_count2;
00619                                           !BCC_EOS
00620                                           ! 438     Bit16u blksize;
00621                                           !BCC_EOS
00622                                           ! 439     Bit16u dpte_offset;
00623                                           !BCC_EOS
00624                                           ! 440     Bit16u dpte_segment;
00625                                           !BCC_EOS
00626                                           ! 441     Bit16u key;
00627                                           !BCC_EOS
00628                                           ! 442     Bit8u dpi_length;
00629                                           !BCC_EOS
00630                                           ! 443     Bit8u reserved1;
00631                                           !BCC_EOS
00632                                           ! 444     Bit16u reserved2;
00633                                           !BCC_EOS
00634                                           ! 445     Bit8u host_bus[4];
00635                                           !BCC_EOS
00636                                           ! 446     Bit8u iface_type[8];
00637                                           !BCC_EOS
00638                                           ! 447     Bit8u iface_path[8];
00639                                           !BCC_EOS
00640                                           ! 448     Bit8u device_path[8];
00641                                           !BCC_EOS
00642                                           ! 449     Bit8u reserved3;
00643                                           !BCC_EOS
00644                                           ! 450     Bit8u checksum;
00645                                           !BCC_EOS
00646                                           ! 451     } dpt_t;
00647                                           !BCC_EOS
00648                                           ! 452 typedef struct {
00649                                           ! 453   union {
00650                                           ! 454     struct {
00651                                           ! 455       Bit16u di, si, b
00652                                           ! 455 p, sp;
00653                                           !BCC_EOS
00654                                           ! 456       Bit16u bx, dx, cx, ax;
00655                                           !BCC_EOS
00656                                           ! 457       } r16;
00657                                           !BCC_EOS
00658                                           ! 458     struct {
00659                                           ! 459       Bit16u filler[4];
00660                                           !BCC_EOS
00661                                           ! 460       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00662                                           !BCC_EOS
00663                                           ! 461       } r8;
00664                                           !BCC_EOS
00665                                           ! 462     } u;
00666                                           !BCC_EOS
00667                                           ! 463   } pusha_regs_t;
00668                                           !BCC_EOS
00669                                           ! 464 typedef struct {
00670                                           ! 465  union {
00671                                           ! 466   struct {
00672                                           ! 467     Bit32u edi, esi, ebp, esp;
00673                                           !BCC_EOS
00674                                           ! 468     Bit32u ebx, edx, ecx, eax;
00675                                           !BCC_EOS
00676                                           ! 469     } r32;
00677                                           !BCC_EOS
00678                                           ! 470   struct {
00679                                           ! 471     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00680                                           !BCC_EOS
00681                                           ! 472     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00682                                           !BCC_EOS
00683                                           ! 473     } r16;
00684                                           !BCC_EOS
00685                                           ! 474   struct {
00686                                           ! 475     Bit32u filler[4];
00687                                           !BCC_EOS
00688                                           ! 476     Bit8u bl, bh;
00689                                           !BCC_EOS
00690                                           ! 477     Bit16u filler1;
00691                                           !BCC_EOS
00692                                           ! 478     Bit8u dl, dh;
00693                                           !BCC_EOS
00694                                           ! 479     Bit16u filler2;
00695                                           !BCC_EOS
00696                                           ! 480     Bit8u cl, ch;
00697                                           !BCC_EOS
00698                                           ! 481     Bit16u filler3;
00699                                           !BCC_EOS
00700                                           ! 482     Bit8u al, ah;
00701                                           !BCC_EOS
00702                                           ! 483     Bit16u filler4;
00703                                           !BCC_EOS
00704                                           ! 484     } r8;
00705                                           !BCC_EOS
00706                                           ! 485   } u;
00707                                           !BCC_EOS
00708                                           ! 486 } pushad_regs_t;
00709                                           !BCC_EOS
00710                                           ! 487 typedef struct {
00711                                           ! 488   union {
00712                                           ! 489     struct {
00713                                           ! 490       Bit16u flags;
00714                                           !BCC_EOS
00715                                           ! 491       } r16;
00716                                           !BCC_EOS
00717                                           ! 492     struct {
00718                                           ! 493       Bit8u flagsl;
00719                                           !BCC_EOS
00720                                           ! 494       Bit8u flagsh;
00721                                           !BCC_EOS
00722                                           ! 495       } r8;
00723                                           !BCC_EOS
00724                                           ! 496     } u;
00725                                           !BCC_EOS
00726                                           ! 497   } flags_t;
00727                                           !BCC_EOS
00728                                           ! 498 typedef struct {
00729                                           ! 499   Bit16u ip;
00730                                           !BCC_EOS
00731                                           ! 500   Bit16u cs;
00732                                           !BCC_EOS
00733                                           ! 501   flags_t flags;
00734                                           !BCC_EOS
00735                                           ! 502   } iret_addr_t;
00736                                           !BCC_EOS
00737                                           ! 503 typedef struct {
00738                                           ! 504   Bit16u type;
00739                                           !BCC_EOS
00740                                           ! 505   Bit16u flags;
00741                                           !BCC_EOS
00742                                           ! 506   Bit32u vector;
00743                                           !BCC_EOS
00744                                           ! 507   Bit32u description;
00745                                           !BCC_EOS
00746                                           ! 508   Bit32u reserved;
00747                                           !BCC_EOS
00748                                           ! 509   } ipl_entry_t;
00749                                           !BCC_EOS
00750                                           ! 510 static Bit8u inb();
00751                                           !BCC_EOS
00752                                           ! 511 static Bit8u inb_cmos();
00753                                           !BCC_EOS
00754                                           ! 512 static void outb();
00755                                           !BCC_EOS
00756                                           ! 513 static void outb_cmos();
00757                                           !BCC_EOS
00758                                           ! 514 static Bit16u inw();
00759                                           !BCC_EOS
00760                                           ! 515 static void outw();
00761                                           !BCC_EOS
00762                                           ! 516 static void init_rtc();
00763                                           !BCC_EOS
00764                                           ! 517 static bx_bool rtc_updating();
00765                                           !BCC_EOS
00766                                           ! 518 static Bit8u read_byte();
00767                                           !BCC_EOS
00768                                           ! 519 static Bit16u read_word();
00769                                           !BCC_EOS
00770                                           ! 520 static void write_byte();
00771                                           !BCC_EOS
00772                                           ! 521 static void write_word();
00773                                           !BCC_EOS
00774                                           ! 522 static void bios_printf();
00775                                           !BCC_EOS
00776                                           ! 523 static Bit8u inhibit_mouse_int_and_events();
00777                                           !BCC_EOS
00778                                           ! 524 static void enable_mouse_int_and_events();
00779                                           !BCC_EOS
00780                                           ! 525 static Bit8u send_to_mouse_ctrl();
00781                                           !BCC_EOS
00782                                           ! 526 static Bit8u get_mouse_data();
00783                                           !BCC_EOS
00784                                           ! 527 static void set_kbd_command_byte();
00785                                           !BCC_EOS
00786                                           ! 528 static void int09_function();
00787                                           !BCC_EOS
00788                                           ! 529 static void int13_harddisk();
00789                                           !BCC_EOS
00790                                           ! 530 static void int13_cdrom();
00791                                           !BCC_EOS
00792                                           ! 531 static void int13_cdemu();
00793                                           !BCC_EOS
00794                                           ! 532 static void int13_eltorito();
00795                                           !BCC_EOS
00796                                           ! 533 static void int13_diskette_function();
00797                                           !BCC_EOS
00798                                           ! 534 static void int14_function();
00799                                           !BCC_EOS
00800                                           ! 535 static void int15_function();
00801                                           !BCC_EOS
00802                                           ! 536 static void int16_function();
00803                                           !BCC_EOS
00804                                           ! 537 static void int17_function();
00805                                           !BCC_EOS
00806                                           ! 538 static void int18_function();
00807                                           !BCC_EOS
00808                                           ! 539 static void int1a_function();
00809                                           !BCC_EOS
00810                                           ! 540 static void int70_function();
00811                                           !BCC_EOS
00812                                           ! 541 static void int74_function();
00813                                           !BCC_EOS
00814                                           ! 542 static Bit16u get_CS();
00815                                           !BCC_EOS
00816                                           ! 543 static Bit16u get_SS();
00817                                           !BCC_EOS
00818                                           ! 544 static unsigned int enqueue_key();
00819                                           !BCC_EOS
00820                                           ! 545 static unsigned int dequeue_
00821                                           ! 545 key();
00822                                           !BCC_EOS
00823                                           ! 546 static void get_hd_geometry();
00824                                           !BCC_EOS
00825                                           ! 547 static void set_diskette_ret_status();
00826                                           !BCC_EOS
00827                                           ! 548 static void set_diskette_current_cyl();
00828                                           !BCC_EOS
00829                                           ! 549 static void determine_floppy_media();
00830                                           !BCC_EOS
00831                                           ! 550 static bx_bool floppy_drive_exists();
00832                                           !BCC_EOS
00833                                           ! 551 static bx_bool floppy_drive_recal();
00834                                           !BCC_EOS
00835                                           ! 552 static bx_bool floppy_media_known();
00836                                           !BCC_EOS
00837                                           ! 553 static bx_bool floppy_media_sense();
00838                                           !BCC_EOS
00839                                           ! 554 static bx_bool set_enable_a20();
00840                                           !BCC_EOS
00841                                           ! 555 static void debugger_on();
00842                                           !BCC_EOS
00843                                           ! 556 static void debugger_off();
00844                                           !BCC_EOS
00845                                           ! 557 static void keyboard_init();
00846                                           !BCC_EOS
00847                                           ! 558 static void keyboard_panic();
00848                                           !BCC_EOS
00849                                           ! 559 static void shutdown_status_panic();
00850                                           !BCC_EOS
00851                                           ! 560 static void nmi_handler_msg();
00852                                           !BCC_EOS
00853                                           ! 561 static void delay_ticks();
00854                                           !BCC_EOS
00855                                           ! 562 static void delay_ticks_and_check_for_keystroke();
00856                                           !BCC_EOS
00857                                           ! 563 static void interactive_bootkey();
00858                                           !BCC_EOS
00859                                           ! 564 static void print_bios_banner();
00860                                           !BCC_EOS
00861                                           ! 565 static void print_boot_device();
00862                                           !BCC_EOS
00863                                           ! 566 static void print_boot_failure();
00864                                           !BCC_EOS
00865                                           ! 567 static void print_cdromboot_failure();
00866                                           !BCC_EOS
00867                                           ! 568 void ata_init();
00868                                           !BCC_EOS
00869                                           ! 569 void ata_detect();
00870                                           !BCC_EOS
00871                                           ! 570 void ata_reset();
00872                                           !BCC_EOS
00873                                           ! 571 Bit16u ata_cmd_non_data();
00874                                           !BCC_EOS
00875                                           ! 572 Bit16u ata_cmd_data_in();
00876                                           !BCC_EOS
00877                                           ! 573 Bit16u ata_cmd_data_out();
00878                                           !BCC_EOS
00879                                           ! 574 Bit16u ata_cmd_packet();
00880                                           !BCC_EOS
00881                                           ! 575 Bit16u atapi_get_sense();
00882                                           !BCC_EOS
00883                                           ! 576 Bit16u atapi_is_ready();
00884                                           !BCC_EOS
00885                                           ! 577 Bit16u atapi_is_cdrom();
00886                                           !BCC_EOS
00887                                           ! 578 void cdemu_init();
00888                                           !BCC_EOS
00889                                           ! 579 Bit8u cdemu_isactive();
00890                                           !BCC_EOS
00891                                           ! 580 Bit8u cdemu_emulated_drive();
00892                                           !BCC_EOS
00893                                           ! 581 Bit16u cdrom_boot();
00894                                           !BCC_EOS
00895                                           ! 582 static char bios_cvs_version_string[] = "$Revision: 1.221 $ $Date: 2008/12/07 17:32:29 $";
00896                                           
00897                       00000194            _bios_cvs_version_string:
00898                       00000194            .1:
00899 0194                        24            .ascii	"$Revision: 1.221 $ $Date: 2008/12/07 17:"
00900 01BC                        33            .ascii	"32:29 $"
00901 01C3                        00            .byte	0
00902                                           !BCC_EOS
00903                                           ! 583 static struct {
00904                                           ! 584   Bit16u normal;
00905                                           !BCC_EOS
00906                                           ! 585   Bit16u shift;
00907                                           !BCC_EOS
00908                                           ! 586   Bit16u control;
00909                                           !BCC_EOS
00910                                           ! 587   Bit16u alt;
00911                                           !BCC_EOS
00912                                           ! 588   Bit8u lock_flags;
00913                                           !BCC_EOS
00914                                           ! 589   } scan_to_scanascii[0x58 + 1] = {
00915                       000001C4            _scan_to_scanascii:
00916                                           ! 590       { 0, 0, 0, 0, 0 },
00917 01C4                      0000            .word	0
00918 01C6                      0000            .word	0
00919 01C8                      0000            .word	0
00920 01CA                      0000            .word	0
00921 01CC                        00            .byte	0
00922 01CD                  00000001            .blkb	1
00923                                           ! 591       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00924 01CE                      011B            .word	$11B
00925 01D0                      011B            .word	$11B
00926 01D2                      011B            .word	$11B
00927 01D4                      0100            .word	$100
00928 01D6                        00            .byte	0
00929 01D7                  00000001            .blkb	1
00930                                           ! 592       { 0x0231, 0x0221, 0, 0x7800, 0 },
00931 01D8                      0231            .word	$231
00932 01DA                      0221            .word	$221
00933 01DC                      0000            .word	0
00934 01DE                      7800            .word	$7800
00935 01E0                        00            .byte	0
00936 01E1                  00000001            .blkb	1
00937                                           ! 593       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00938 01E2                      0332            .word	$332
00939 01E4                      0340            .word	$340
00940 01E6                      0300            .word	$300
00941 01E8                      7900            .word	$7900
00942 01EA                        00            .byte	0
00943 01EB                  00000001            .blkb	1
00944                                           ! 594       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00945 01EC                      0433            .word	$433
00946 01EE                      0423            .word	$423
00947 01F0                      0000            .word	0
00948 01F2                      7A00            .word	$7A00
00949 01F4                        00            .byte	0
00950 01F5                  00000001            .blkb	1
00951                                           ! 595       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00952 01F6                      0534            .word	$534
00953 01F8                      0524            .word	$524
00954 01FA                      0000            .word	0
00955 01FC                      7B00            .word	$7B00
00956 01FE                        00            .byte	0
00957 01FF                  00000001            .blkb	1
00958                                           ! 596       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00959 0200                      0635            .word	$635
00960 0202                      0625            .word	$625
00961 0204                      0000            .word	0
00962 0206                      7C00            .word	$7C00
00963 0208                        00            .byte	0
00964 0209                  00000001            .blkb	1
00965                                           ! 597       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00966 020A                      0736            .word	$736
00967 020C                      075E            .word	$75E
00968 020E                      071E            .word	$71E
00969 0210                      7D00            .word	$7D00
00970 0212                        00            .byte	0
00971 0213                  00000001            .blkb	1
00972                                           ! 598       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00973 0214                      0837            .word	$837
00974 0216                      0826            .word	$826
00975 0218                      0000            .word	0
00976 021A                      7E00            .word	$7E00
00977 021C                        00            .byte	0
00978 021D                  00000001            .blkb	1
00979                                           ! 599       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00980 021E                      0938            .word	$938
00981 0220                      092A            .word	$92A
00982 0222                      0000            .word	0
00983 0224                      7F00            .word	$7F00
00984 0226                        00            .byte	0
00985 0227                  00000001            .blkb	1
00986                                           ! 600       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00987 0228                      0A39            .word	$A39
00988 022A                      0A28            .word	$A28
00989 022C                      0000            .word	0
00990 022E                      8000            .word	$8000
00991 0230                        00            .byte	0
00992 0231                  00000001            .blkb	1
00993                                           ! 601       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00994 0232                      0B30            .word	$B30
00995 0234                      0B29            .word	$B29
00996 0236                      0000            .word	0
00997 0238                      8100            .word	$8100
00998 023A                        00            .byte	0
00999 023B                  00000001            .blkb	1
01000                                           ! 602       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01001 023C                      0C2D            .word	$C2D
01002 023E                      0C5F            .word	$C5F
01003 0240                      0C1F            .word	$C1F
01004 0242                      8200            .word	$8200
01005 0244                        00            .byte	0
01006 0245                  00000001            .blkb	1
01007                                           ! 603       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01008 0246                      0D3D            .word	$D3D
01009 0248                      0D2B            .word	$D2B
01010 024A                      0000            .word	0
01011 024C                      8300            .word	$8300
01012 024E                        00            .byte	0
01013 024F                  00000001            .blkb	1
01014                                           ! 604       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01015 0250                      0E08            .word	$E08
01016 0252                      0E08            .word	$E08
01017 0254                      0E7F            .word	$E7F
01018 0256                      0000            .word	0
01019 0258                        00            .byte	0
01020 0259                  00000001            .blkb	1
01021                                           ! 605       { 0x0f09, 0x0f00, 0, 0, 0 },
01022 025A                      0F09            .word	$F09
01023 025C                      0F00            .word	$F00
01024 025E                      0000            .word	0
01025 0260                      0000            .word	0
01026 0262                        00            .byte	0
01027 0263                  00000001            .blkb	1
01028                                           ! 606       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01029 0264                      1071            .word	$1071
01030 0266                      1051            .word	$1051
01031 0268                      1011            .word	$1011
01032 026A                      1000            .word	$1000
01033 026C                        40            .byte	$40
01034 026D                  00000001            .blkb	1
01035                                           ! 607       { 0x1177, 0x1157, 0x1117, 
01036 026E                      1177            .word	$1177
01037 0270                      1157            .word	$1157
01038 0272                      1117            .word	$1117
01039                                           ! 607 0x1100, 0x40 },
01040 0274                      1100            .word	$1100
01041 0276                        40            .byte	$40
01042 0277                  00000001            .blkb	1
01043                                           ! 608       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01044 0278                      1265            .word	$1265
01045 027A                      1245            .word	$1245
01046 027C                      1205            .word	$1205
01047 027E                      1200            .word	$1200
01048 0280                        40            .byte	$40
01049 0281                  00000001            .blkb	1
01050                                           ! 609       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01051 0282                      1372            .word	$1372
01052 0284                      1352            .word	$1352
01053 0286                      1312            .word	$1312
01054 0288                      1300            .word	$1300
01055 028A                        40            .byte	$40
01056 028B                  00000001            .blkb	1
01057                                           ! 610       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01058 028C                      1474            .word	$1474
01059 028E                      1454            .word	$1454
01060 0290                      1414            .word	$1414
01061 0292                      1400            .word	$1400
01062 0294                        40            .byte	$40
01063 0295                  00000001            .blkb	1
01064                                           ! 611       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01065 0296                      1579            .word	$1579
01066 0298                      1559            .word	$1559
01067 029A                      1519            .word	$1519
01068 029C                      1500            .word	$1500
01069 029E                        40            .byte	$40
01070 029F                  00000001            .blkb	1
01071                                           ! 612       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01072 02A0                      1675            .word	$1675
01073 02A2                      1655            .word	$1655
01074 02A4                      1615            .word	$1615
01075 02A6                      1600            .word	$1600
01076 02A8                        40            .byte	$40
01077 02A9                  00000001            .blkb	1
01078                                           ! 613       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01079 02AA                      1769            .word	$1769
01080 02AC                      1749            .word	$1749
01081 02AE                      1709            .word	$1709
01082 02B0                      1700            .word	$1700
01083 02B2                        40            .byte	$40
01084 02B3                  00000001            .blkb	1
01085                                           ! 614       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01086 02B4                      186F            .word	$186F
01087 02B6                      184F            .word	$184F
01088 02B8                      180F            .word	$180F
01089 02BA                      1800            .word	$1800
01090 02BC                        40            .byte	$40
01091 02BD                  00000001            .blkb	1
01092                                           ! 615       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01093 02BE                      1970            .word	$1970
01094 02C0                      1950            .word	$1950
01095 02C2                      1910            .word	$1910
01096 02C4                      1900            .word	$1900
01097 02C6                        40            .byte	$40
01098 02C7                  00000001            .blkb	1
01099                                           ! 616       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01100 02C8                      1A5B            .word	$1A5B
01101 02CA                      1A7B            .word	$1A7B
01102 02CC                      1A1B            .word	$1A1B
01103 02CE                      0000            .word	0
01104 02D0                        00            .byte	0
01105 02D1                  00000001            .blkb	1
01106                                           ! 617       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01107 02D2                      1B5D            .word	$1B5D
01108 02D4                      1B7D            .word	$1B7D
01109 02D6                      1B1D            .word	$1B1D
01110 02D8                      0000            .word	0
01111 02DA                        00            .byte	0
01112 02DB                  00000001            .blkb	1
01113                                           ! 618       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01114 02DC                      1C0D            .word	$1C0D
01115 02DE                      1C0D            .word	$1C0D
01116 02E0                      1C0A            .word	$1C0A
01117 02E2                      0000            .word	0
01118 02E4                        00            .byte	0
01119 02E5                  00000001            .blkb	1
01120                                           ! 619       { 0, 0, 0, 0, 0 },
01121 02E6                      0000            .word	0
01122 02E8                      0000            .word	0
01123 02EA                      0000            .word	0
01124 02EC                      0000            .word	0
01125 02EE                        00            .byte	0
01126 02EF                  00000001            .blkb	1
01127                                           ! 620       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01128 02F0                      1E61            .word	$1E61
01129 02F2                      1E41            .word	$1E41
01130 02F4                      1E01            .word	$1E01
01131 02F6                      1E00            .word	$1E00
01132 02F8                        40            .byte	$40
01133 02F9                  00000001            .blkb	1
01134                                           ! 621       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01135 02FA                      1F73            .word	$1F73
01136 02FC                      1F53            .word	$1F53
01137 02FE                      1F13            .word	$1F13
01138 0300                      1F00            .word	$1F00
01139 0302                        40            .byte	$40
01140 0303                  00000001            .blkb	1
01141                                           ! 622       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01142 0304                      2064            .word	$2064
01143 0306                      2044            .word	$2044
01144 0308                      2004            .word	$2004
01145 030A                      2000            .word	$2000
01146 030C                        40            .byte	$40
01147 030D                  00000001            .blkb	1
01148                                           ! 623       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01149 030E                      2166            .word	$2166
01150 0310                      2146            .word	$2146
01151 0312                      2106            .word	$2106
01152 0314                      2100            .word	$2100
01153 0316                        40            .byte	$40
01154 0317                  00000001            .blkb	1
01155                                           ! 624       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01156 0318                      2267            .word	$2267
01157 031A                      2247            .word	$2247
01158 031C                      2207            .word	$2207
01159 031E                      2200            .word	$2200
01160 0320                        40            .byte	$40
01161 0321                  00000001            .blkb	1
01162                                           ! 625       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01163 0322                      2368            .word	$2368
01164 0324                      2348            .word	$2348
01165 0326                      2308            .word	$2308
01166 0328                      2300            .word	$2300
01167 032A                        40            .byte	$40
01168 032B                  00000001            .blkb	1
01169                                           ! 626       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01170 032C                      246A            .word	$246A
01171 032E                      244A            .word	$244A
01172 0330                      240A            .word	$240A
01173 0332                      2400            .word	$2400
01174 0334                        40            .byte	$40
01175 0335                  00000001            .blkb	1
01176                                           ! 627       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01177 0336                      256B            .word	$256B
01178 0338                      254B            .word	$254B
01179 033A                      250B            .word	$250B
01180 033C                      2500            .word	$2500
01181 033E                        40            .byte	$40
01182 033F                  00000001            .blkb	1
01183                                           ! 628       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01184 0340                      266C            .word	$266C
01185 0342                      264C            .word	$264C
01186 0344                      260C            .word	$260C
01187 0346                      2600            .word	$2600
01188 0348                        40            .byte	$40
01189 0349                  00000001            .blkb	1
01190                                           ! 629       { 0x273b, 0x273a, 0, 0, 0 },
01191 034A                      273B            .word	$273B
01192 034C                      273A            .word	$273A
01193 034E                      0000            .word	0
01194 0350                      0000            .word	0
01195 0352                        00            .byte	0
01196 0353                  00000001            .blkb	1
01197                                           ! 630       { 0x2827, 0x2822, 0, 0, 0 },
01198 0354                      2827            .word	$2827
01199 0356                      2822            .word	$2822
01200 0358                      0000            .word	0
01201 035A                      0000            .word	0
01202 035C                        00            .byte	0
01203 035D                  00000001            .blkb	1
01204                                           ! 631       { 0x2960, 0x297e, 0, 0, 0 },
01205 035E                      2960            .word	$2960
01206 0360                      297E            .word	$297E
01207 0362                      0000            .word	0
01208 0364                      0000            .word	0
01209 0366                        00            .byte	0
01210 0367                  00000001            .blkb	1
01211                                           ! 632       { 0, 0, 0, 0, 0 },
01212 0368                      0000            .word	0
01213 036A                      0000            .word	0
01214 036C                      0000            .word	0
01215 036E                      0000            .word	0
01216 0370                        00            .byte	0
01217 0371                  00000001            .blkb	1
01218                                           ! 633       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01219 0372                      2B5C            .word	$2B5C
01220 0374                      2B7C            .word	$2B7C
01221 0376                      2B1C            .word	$2B1C
01222 0378                      0000            .word	0
01223 037A                        00            .byte	0
01224 037B                  00000001            .blkb	1
01225                                           ! 634       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01226 037C                      2C7A            .word	$2C7A
01227 037E                      2C5A            .word	$2C5A
01228 0380                      2C1A            .word	$2C1A
01229 0382                      2C00            .word	$2C00
01230 0384                        40            .byte	$40
01231 0385                  00000001            .blkb	1
01232                                           ! 635       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01233 0386                      2D78            .word	$2D78
01234 0388                      2D58            .word	$2D58
01235 038A                      2D18            .word	$2D18
01236 038C                      2D00            .word	$2D00
01237 038E                        40            .byte	$40
01238 038F                  00000001            .blkb	1
01239                                           ! 636       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01240 0390                      2E63            .word	$2E63
01241 0392                      2E43            .word	$2E43
01242 0394                      2E03            .word	$2E03
01243 0396                      2E00            .word	$2E00
01244 0398                        40            .byte	$40
01245 0399                  00000001            .blkb	1
01246                                           ! 637       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01247 039A                      2F76            .word	$2F76
01248 039C                      2F56            .word	$2F56
01249 039E                      2F16            .word	$2F16
01250 03A0                      2F00            .word	$2F00
01251 03A2                        40            .byte	$40
01252 03A3                  00000001            .blkb	1
01253                                           ! 638       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01254 03A4                      3062            .word	$3062
01255 03A6                      3042            .word	$3042
01256 03A8                      3002            .word	$3002
01257 03AA                      3000            .word	$3000
01258 03AC                        40            .byte	$40
01259 03AD                  00000001            .blkb	1
01260                                           ! 639       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01261 03AE                      316E            .word	$316E
01262 03B0                      314E            .word	$314E
01263 03B2                      310E            .word	$310E
01264 03B4                      3100            .word	$3100
01265 03B6                        40            .byte	$40
01266 03B7                  00000001            .blkb	1
01267                                           ! 640       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01268 03B8                      326D            .word	$326D
01269 03BA                      324D            .word	$324D
01270 03BC                      320D            .word	$320D
01271 03BE                      3200            .word	$3200
01272 03C0                        40            .byte	$40
01273 03C1                  00000001            .blkb	1
01274                                           ! 641       { 0x332c, 0x333c, 0, 0, 0 },
01275 03C2                      332C            .word	$332C
01276 03C4                      333C            .word	$333C
01277 03C6                      0000            .word	0
01278 03C8                      0000            .word	0
01279 03CA                        00            .byte	0
01280 03CB                  00000001            .blkb	1
01281                                           ! 642       { 0x342e, 0x343e, 0, 0, 0 },
01282 03CC                      342E            .word	$342E
01283 03CE                      343E            .word	$343E
01284 03D0                      0000            .word	0
01285 03D2                      0000            .word	0
01286 03D4                        00            .byte	0
01287 03D5                  00000001            .blkb	1
01288                                           ! 643       { 0x352f, 0x353f, 0, 0, 0 },
01289 03D6                      352F            .word	$352F
01290 03D8                      353F            .word	$353F
01291 03DA                      0000            .word	0
01292 03DC                      0000            .word	0
01293 03DE                        00            .byte	0
01294 03DF                  00000001            .blkb	1
01295                                           ! 644       { 0, 0, 0, 0, 0 },
01296 03E0                      0000            .word	0
01297 03E2                      0000            .word	0
01298 03E4                      0000            .word	0
01299 03E6                      0000            .word	0
01300 03E8                        00            .byte	0
01301 03E9                  00000001            .blkb	1
01302                                           ! 645       { 0x372a, 0x372a, 0, 0, 0 },
01303 03EA                      372A            .word	$372A
01304 03EC                      372A            .word	$372A
01305 03EE                      0000            .word	0
01306 03F0                      0000            .word	0
01307 03F2                        00            .byte	0
01308 03F3                  00000001            .blkb	1
01309                                           ! 646       { 0, 0, 0, 0, 0 },
01310 03F4                      0000            .word	0
01311 03F6                      0000            .word	0
01312 03F8                      0000            .word	0
01313 03FA                      0000            .word	0
01314 03FC                        00            .byte	0
01315 03FD                  00000001            .blkb	1
01316                                           ! 647       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01317 03FE                      3920            .word	$3920
01318 0400                      3920            .word	$3920
01319 0402                      3920            .word	$3920
01320 0404                      3920            .word	$3920
01321 0406                        00            .byte	0
01322 0407                  00000001            .blkb	1
01323                                           ! 648       { 0, 0, 0, 0, 0 },
01324 0408                      0000            .word	0
01325 040A                      0000            .word	0
01326 040C                      0000            .word	0
01327 040E                      0000            .word	0
01328 0410                        00            .byte	0
01329 0411                  00000001            .blkb	1
01330                                           ! 649       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01331 0412                      3B00            .word	$3B00
01332 0414                      5400            .word	$5400
01333 0416                      5E00            .word	$5E00
01334 0418                      6800            .word	$6800
01335 041A                        00            .byte	0
01336 041B                  00000001            .blkb	1
01337                                           ! 650       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01338 041C                      3C00            .word	$3C00
01339 041E                      5500            .word	$5500
01340 0420                      5F00            .word	$5F00
01341 0422                      6900            .word	$6900
01342 0424                        00            .byte	0
01343 0425                  00000001            .blkb	1
01344                                           ! 651       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01345 0426                      3D00            .word	$3D00
01346 0428                      5600            .word	$5600
01347 042A                      6000            .word	$6000
01348 042C                      6A00            .word	$6A00
01349 042E                        00            .byte	0
01350 042F                  00000001            .blkb	1
01351                                           ! 652       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01352 0430                      3E00            .word	$3E00
01353 0432                      5700            .word	$5700
01354 0434                      6100            .word	$6100
01355 0436                      6B00            .word	$6B00
01356 0438                        00            .byte	0
01357 0439                  00000001            .blkb	1
01358                                           ! 653       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01359 043A                      3F00            .word	$3F00
01360 043C                      5800            .word	$5800
01361 043E                      6200            .word	$6200
01362 0440                      6C00            .word	$6C00
01363 0442                        00            .byte	0
01364 0443                  00000001            .blkb	1
01365                                           ! 654       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01366 0444                      4000            .word	$4000
01367 0446                      5900            .word	$5900
01368 0448                      6300            .word	$6300
01369 044A                      6D00            .word	$6D00
01370 044C                        00            .byte	0
01371 044D                  00000001            .blkb	1
01372                                           ! 655       { 0x4100, 0x5a00, 0x6400, 0x6
01373 044E                      4100            .word	$4100
01374 0450                      5A00            .word	$5A00
01375 0452                      6400            .word	$6400
01376                                           ! 655 e00, 0 },
01377 0454                      6E00            .word	$6E00
01378 0456                        00            .byte	0
01379 0457                  00000001            .blkb	1
01380                                           ! 656       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01381 0458                      4200            .word	$4200
01382 045A                      5B00            .word	$5B00
01383 045C                      6500            .word	$6500
01384 045E                      6F00            .word	$6F00
01385 0460                        00            .byte	0
01386 0461                  00000001            .blkb	1
01387                                           ! 657       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01388 0462                      4300            .word	$4300
01389 0464                      5C00            .word	$5C00
01390 0466                      6600            .word	$6600
01391 0468                      7000            .word	$7000
01392 046A                        00            .byte	0
01393 046B                  00000001            .blkb	1
01394                                           ! 658       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01395 046C                      4400            .word	$4400
01396 046E                      5D00            .word	$5D00
01397 0470                      6700            .word	$6700
01398 0472                      7100            .word	$7100
01399 0474                        00            .byte	0
01400 0475                  00000001            .blkb	1
01401                                           ! 659       { 0, 0, 0, 0, 0 },
01402 0476                      0000            .word	0
01403 0478                      0000            .word	0
01404 047A                      0000            .word	0
01405 047C                      0000            .word	0
01406 047E                        00            .byte	0
01407 047F                  00000001            .blkb	1
01408                                           ! 660       { 0, 0, 0, 0, 0 },
01409 0480                      0000            .word	0
01410 0482                      0000            .word	0
01411 0484                      0000            .word	0
01412 0486                      0000            .word	0
01413 0488                        00            .byte	0
01414 0489                  00000001            .blkb	1
01415                                           ! 661       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01416 048A                      4700            .word	$4700
01417 048C                      4737            .word	$4737
01418 048E                      7700            .word	$7700
01419 0490                      0000            .word	0
01420 0492                        20            .byte	$20
01421 0493                  00000001            .blkb	1
01422                                           ! 662       { 0x4800, 0x4838, 0, 0, 0x20 },
01423 0494                      4800            .word	$4800
01424 0496                      4838            .word	$4838
01425 0498                      0000            .word	0
01426 049A                      0000            .word	0
01427 049C                        20            .byte	$20
01428 049D                  00000001            .blkb	1
01429                                           ! 663       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01430 049E                      4900            .word	$4900
01431 04A0                      4939            .word	$4939
01432 04A2                      8400            .word	$8400
01433 04A4                      0000            .word	0
01434 04A6                        20            .byte	$20
01435 04A7                  00000001            .blkb	1
01436                                           ! 664       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01437 04A8                      4A2D            .word	$4A2D
01438 04AA                      4A2D            .word	$4A2D
01439 04AC                      0000            .word	0
01440 04AE                      0000            .word	0
01441 04B0                        00            .byte	0
01442 04B1                  00000001            .blkb	1
01443                                           ! 665       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01444 04B2                      4B00            .word	$4B00
01445 04B4                      4B34            .word	$4B34
01446 04B6                      7300            .word	$7300
01447 04B8                      0000            .word	0
01448 04BA                        20            .byte	$20
01449 04BB                  00000001            .blkb	1
01450                                           ! 666       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01451 04BC                      4C00            .word	$4C00
01452 04BE                      4C35            .word	$4C35
01453 04C0                      0000            .word	0
01454 04C2                      0000            .word	0
01455 04C4                        20            .byte	$20
01456 04C5                  00000001            .blkb	1
01457                                           ! 667       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01458 04C6                      4D00            .word	$4D00
01459 04C8                      4D36            .word	$4D36
01460 04CA                      7400            .word	$7400
01461 04CC                      0000            .word	0
01462 04CE                        20            .byte	$20
01463 04CF                  00000001            .blkb	1
01464                                           ! 668       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01465 04D0                      4E2B            .word	$4E2B
01466 04D2                      4E2B            .word	$4E2B
01467 04D4                      0000            .word	0
01468 04D6                      0000            .word	0
01469 04D8                        00            .byte	0
01470 04D9                  00000001            .blkb	1
01471                                           ! 669       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01472 04DA                      4F00            .word	$4F00
01473 04DC                      4F31            .word	$4F31
01474 04DE                      7500            .word	$7500
01475 04E0                      0000            .word	0
01476 04E2                        20            .byte	$20
01477 04E3                  00000001            .blkb	1
01478                                           ! 670       { 0x5000, 0x5032, 0, 0, 0x20 },
01479 04E4                      5000            .word	$5000
01480 04E6                      5032            .word	$5032
01481 04E8                      0000            .word	0
01482 04EA                      0000            .word	0
01483 04EC                        20            .byte	$20
01484 04ED                  00000001            .blkb	1
01485                                           ! 671       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01486 04EE                      5100            .word	$5100
01487 04F0                      5133            .word	$5133
01488 04F2                      7600            .word	$7600
01489 04F4                      0000            .word	0
01490 04F6                        20            .byte	$20
01491 04F7                  00000001            .blkb	1
01492                                           ! 672       { 0x5200, 0x5230, 0, 0, 0x20 },
01493 04F8                      5200            .word	$5200
01494 04FA                      5230            .word	$5230
01495 04FC                      0000            .word	0
01496 04FE                      0000            .word	0
01497 0500                        20            .byte	$20
01498 0501                  00000001            .blkb	1
01499                                           ! 673       { 0x5300, 0x532e, 0, 0, 0x20 },
01500 0502                      5300            .word	$5300
01501 0504                      532E            .word	$532E
01502 0506                      0000            .word	0
01503 0508                      0000            .word	0
01504 050A                        20            .byte	$20
01505 050B                  00000001            .blkb	1
01506                                           ! 674       { 0, 0, 0, 0, 0 },
01507 050C                      0000            .word	0
01508 050E                      0000            .word	0
01509 0510                      0000            .word	0
01510 0512                      0000            .word	0
01511 0514                        00            .byte	0
01512 0515                  00000001            .blkb	1
01513                                           ! 675       { 0, 0, 0, 0, 0 },
01514 0516                      0000            .word	0
01515 0518                      0000            .word	0
01516 051A                      0000            .word	0
01517 051C                      0000            .word	0
01518 051E                        00            .byte	0
01519 051F                  00000001            .blkb	1
01520                                           ! 676       { 0x565c, 0x567c, 0, 0, 0 },
01521 0520                      565C            .word	$565C
01522 0522                      567C            .word	$567C
01523 0524                      0000            .word	0
01524 0526                      0000            .word	0
01525 0528                        00            .byte	0
01526 0529                  00000001            .blkb	1
01527                                           ! 677       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01528 052A                      8500            .word	$8500
01529 052C                      8700            .word	$8700
01530 052E                      8900            .word	$8900
01531 0530                      8B00            .word	$8B00
01532 0532                        00            .byte	0
01533 0533                  00000001            .blkb	1
01534                                           ! 678       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01535 0534                      8600            .word	$8600
01536 0536                      8800            .word	$8800
01537 0538                      8A00            .word	$8A00
01538 053A                      8C00            .word	$8C00
01539 053C                        00            .byte	0
01540 053D                  00000001            .blkb	1
01541                                           ! 679       };
01542                                           !BCC_EOS
01543                                           ! 680   Bit8u
01544                                           ! 681 inb(port)
01545                                           ! 682   Bit16u port;
01546                                           
01547                                           export	_inb
01548                       0000053E            _inb:
01549                                           !BCC_EOS
01550                                           ! 683 {
01551                                           ! 684 #asm
01552                                           !BCC_ASM
01553                       00000002            _inb.port	set	2
01554 053E           55                           push bp
01555 053F           89E5                         mov bp, sp
01556 0541           52                             push dx
01557 0542           8B56         04                mov dx, 4[bp]
01558 0545           EC                             in al, dx
01559 0546           5A                             pop dx
01560 0547           5D                           pop bp
01561                                           ! 692 endasm
01562                                           !BCC_ENDASM
01563                                           ! 693 }
01564 0548           C3                         ret
01565                                           ! 694   Bit16u
01566                                           ! 695 inw(port)
01567                                           ! 696   Bit16u port;
01568                                           export	_inw
01569                       00000549            _inw:
01570                                           !BCC_EOS
01571                                           ! 697 {
01572                                           ! 698 #asm
01573                                           !BCC_ASM
01574                       00000002            _inw.port	set	2
01575 0549           55                           push bp
01576 054A           89E5                         mov bp, sp
01577 054C           52                             push dx
01578 054D           8B56         04                mov dx, 4[bp]
01579 0550           ED                             in ax, dx
01580 0551           5A                             pop dx
01581 0552           5D                           pop bp
01582                                           ! 706 endasm
01583                                           !BCC_ENDASM
01584                                           ! 707 }
01585 0553           C3                         ret
01586                                           ! 708   void
01587                                           ! 709 outb(port, val)
01588                                           ! 710   Bit16u port;
01589                                           export	_outb
01590                       00000554            _outb:
01591                                           !BCC_EOS
01592                                           ! 711   Bit8u val;
01593                                           !BCC_EOS
01594                                           ! 712 {
01595                                           ! 713 #asm
01596                                           !BCC_ASM
01597                       00000004            _outb.val	set	4
01598                       00000002            _outb.port	set	2
01599 0554           55                           push bp
01600 0555           89E5                         mov bp, sp
01601 0557           50                             push ax
01602 0558           52                             push dx
01603 0559           8B56         04                mov dx, 4[bp]
01604 055C           8A46         06                mov al, 6[bp]
01605 055F           EE                             out dx, al
01606 0560           5A                             pop dx
01607 0561           58                             pop ax
01608 0562           5D                           pop bp
01609                                           ! 724 endasm
01610                                           !BCC_ENDASM
01611                                           ! 725 }
01612 0563           C3                         ret
01613                                           ! 726   void
01614                                           ! 727 outw(port, val)
01615                                           ! 728   Bit16u port;
01616                                           export	_outw
01617                       00000564            _outw:
01618                                           !BCC_EOS
01619                                           ! 729   Bit16u val;
01620                                           !BCC_EOS
01621                                           ! 730 {
01622                                           ! 731 #asm
01623                                           !BCC_ASM
01624                       00000004            _outw.val	set	4
01625                       00000002            _outw.port	set	2
01626 0564           55                           push bp
01627 0565           89E5                         mov bp, sp
01628 0567           50                             push ax
01629 0568           52                             push dx
01630 0569           8B56         04                mov dx, 4[bp]
01631 056C           8B46         06                mov ax, 6[bp]
01632 056F           EF                             out dx, ax
01633 0570           5A                             pop dx
01634 0571           58                             pop ax
01635 0572           5D                           pop bp
01636                                           ! 742 endasm
01637                                           !BCC_ENDASM
01638                                           ! 743 }
01639 0573           C3                         ret
01640                                           ! 744   void
01641                                           ! 745 outb_cmos(cmos_reg, val)
01642                                           ! 746   Bit8u cmos_reg;
01643                                           export	_outb_cmos
01644                       00000574            _outb_cmos:
01645                                           !BCC_EOS
01646                                           ! 747   Bit8u val;
01647                                           !BCC_EOS
01648                                           ! 748 {
01649                                           ! 749 #asm
01650                                           !BCC_ASM
01651                       00000002            _outb_cmos.cmos_reg	set	2
01652                       00000004            _outb_cmos.val	set	4
01653 0574           55                           push bp
01654 0575           89E5                         mov bp, sp
01655 0577           8A46         04                mov al, 4[bp] ;; cmos_reg
01656 057A           E6                     70      out 0x70, al
01657 057C           8A46         06                mov al, 6[bp] ;; val
01658 057F           E6                     71      out 0x71, al
01659 0581           5D                           pop bp
01660                                           ! 757 endasm
01661                                           !BCC_ENDASM
01662                                           ! 758 }
01663 0582           C3                         ret
01664                                           ! 759   Bit8u
01665                                           ! 760 inb_cmos(cmos_reg)
01666                                           ! 761   Bit8u cmos_reg;
01667                                           export	_inb_cmos
01668                       00000583            _inb_cmos:
01669                                           !BCC_EOS
01670                                           ! 762 {
01671                                           ! 763 #asm
01672                                           !BCC_ASM
01673                       00000002            _inb_cmos.cmos_reg	set	2
01674 0583           55                           push bp
01675 0584           89E5                         mov bp, sp
01676 0586           8A46         04                mov al, 4[bp] ;; cmos_reg
01677 0589           E6                     70      out 0x70, al
01678 058B           E4                     71      in al, 0x71
01679 058D           5D                           pop bp
01680                                           ! 770 endasm
01681                                           !BCC_ENDASM
01682                                           ! 771 }
01683 058E           C3                         ret
01684                                           ! 772   void
01685                                           ! 773 init_rtc()
01686                                           ! 774 {
01687                                           export	_init_rtc
01688                       0000058F            _init_rtc:
01689                                           ! 775   outb_cmos(0x0a, 0x26);
01690 058F           55                         push	bp
01691 0590           89E5                       mov	bp,sp
01692                                           ! Debug: list int = const $26 (used reg = )
01693 0592           B8                   0026  mov	ax,*$26
01694 0595           50                         push	ax
01695                                           ! Debug: list int = const $A (used reg = )
01696 0596           B8                   000A  mov	ax,*$A
01697 0599           50                         push	ax
01698                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01699 059A           E8         FFD7            call	_outb_cmos
01700 059D           89EC                       mov	sp,bp
01701                                           !BCC_EOS
01702                                           ! 776   outb_cmos(0x0b, 0x02);
01703                                           ! Debug: list int = const 2 (used reg = )
01704 059F           B8                   0002  mov	ax,*2
01705 05A2           50                         push	ax
01706                                           ! Debug: list int = const $B (used reg = )
01707 05A3           B8                   000B  mov	ax,*$B
01708 05A6           50                         push	ax
01709                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01710 05A7           E8         FFCA            call	_outb_cmos
01711 05AA           89EC                       mov	sp,bp
01712                                           !BCC_EOS
01713                                           ! 777   inb_cmos(0x0c);
01714                                           ! Debug: list int = const $C (used reg = )
01715 05AC           B8                   000C  mov	ax,*$C
01716 05AF           50                         push	ax
01717                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01718 05B0           E8         FFD0            call	_inb_cmos
01719 05B3           89EC                       mov	sp,bp
01720                                           !BCC_EOS
01721                                           ! 778   inb_cmos(0x0d);
01722                                           ! Debug: list int = const $D (used reg = )
01723 05B5           B8                   000D  mov	ax,*$D
01724 05B8           50                         push	ax
01725                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01726 05B9           E8         FFC7            call	_inb_cmos
01727 05BC           89EC                       mov	sp,bp
01728                                           !BCC_EOS
01729                                           ! 779 }
01730 05BE           5D                         pop	bp
01731 05BF           C3                         ret
01732                                           ! 780   bx_bool
01733                                           ! 781 rtc_u
01734                                           ! 781 pdating()
01735                                           ! 782 {
01736                                           export	_rtc_updating
01737                       000005C0            _rtc_updating:
01738                                           ! 783   Bit16u count;
01739                                           !BCC_EOS
01740                                           ! 784   count = 25000;
01741 05C0           55                         push	bp
01742 05C1           89E5                       mov	bp,sp
01743 05C3           4C                         dec	sp
01744 05C4           4C                         dec	sp
01745                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01746 05C5           B8                   61A8  mov	ax,#$61A8
01747 05C8           8946         FE            mov	-2[bp],ax
01748                                           !BCC_EOS
01749                                           ! 785   while (--count != 0) {
01750 05CB           EB           15            jmp .3
01751                       000005CD            .4:
01752                                           ! 786     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01753                                           ! Debug: list int = const $A (used reg = )
01754 05CD           B8                   000A  mov	ax,*$A
01755 05D0           50                         push	ax
01756                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01757 05D1           E8         FFAF            call	_inb_cmos
01758 05D4           44                         inc	sp
01759 05D5           44                         inc	sp
01760                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01761 05D6           24                     80  and	al,#$80
01762                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01763 05D8           84C0                       test	al,al
01764 05DA           75           06            jne 	.5
01765                       000005DC            .6:
01766                                           ! 787       return(0);
01767 05DC           31C0                       xor	ax,ax
01768 05DE           89EC                       mov	sp,bp
01769 05E0           5D                         pop	bp
01770 05E1           C3                         ret
01771                                           !BCC_EOS
01772                                           ! 788     }
01773                       000005E2            .5:
01774                                           ! 789   return(1);
01775                       000005E2            .3:
01776                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01777 05E2           8B46         FE            mov	ax,-2[bp]
01778 05E5           48                         dec	ax
01779 05E6           8946         FE            mov	-2[bp],ax
01780                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01781 05E9           85C0                       test	ax,ax
01782 05EB           75           E0            jne	.4
01783                       000005ED            .7:
01784                       000005ED            .2:
01785 05ED           B8                   0001  mov	ax,*1
01786 05F0           89EC                       mov	sp,bp
01787 05F2           5D                         pop	bp
01788 05F3           C3                         ret
01789                                           !BCC_EOS
01790                                           ! 790 }
01791                                           ! 791   Bit8u
01792                                           ! 792 read_byte(seg, offset)
01793                                           ! 793   Bit16u seg;
01794                                           export	_read_byte
01795                       000005F4            _read_byte:
01796                                           !BCC_EOS
01797                                           ! 794   Bit16u offset;
01798                                           !BCC_EOS
01799                                           ! 795 {
01800                                           ! 796 #asm
01801                                           !BCC_ASM
01802                       00000002            _read_byte.seg	set	2
01803                       00000004            _read_byte.offset	set	4
01804 05F4           55                           push bp
01805 05F5           89E5                         mov bp, sp
01806 05F7           53                             push bx
01807 05F8           1E                             push ds
01808 05F9           8B46         04                mov ax, 4[bp] ; segment
01809 05FC           8ED8                           mov ds, ax
01810 05FE           8B5E         06                mov bx, 6[bp] ; offset
01811 0601           8A07                           mov al, [bx]
01812                                               ;; al = return value (byte)
01813 0603           1F                             pop ds
01814 0604           5B                             pop bx
01815 0605           5D                           pop bp
01816                                           ! 809 endasm
01817                                           !BCC_ENDASM
01818                                           ! 810 }
01819 0606           C3                         ret
01820                                           ! 811   Bit16u
01821                                           ! 812 read_word(seg, offset)
01822                                           ! 813   Bit16u seg;
01823                                           export	_read_word
01824                       00000607            _read_word:
01825                                           !BCC_EOS
01826                                           ! 814   Bit16u offset;
01827                                           !BCC_EOS
01828                                           ! 815 {
01829                                           ! 816 #asm
01830                                           !BCC_ASM
01831                       00000002            _read_word.seg	set	2
01832                       00000004            _read_word.offset	set	4
01833 0607           55                           push bp
01834 0608           89E5                         mov bp, sp
01835 060A           53                             push bx
01836 060B           1E                             push ds
01837 060C           8B46         04                mov ax, 4[bp] ; segment
01838 060F           8ED8                           mov ds, ax
01839 0611           8B5E         06                mov bx, 6[bp] ; offset
01840 0614           8B07                           mov ax, [bx]
01841                                               ;; ax = return value (word)
01842 0616           1F                             pop ds
01843 0617           5B                             pop bx
01844 0618           5D                           pop bp
01845                                           ! 829 endasm
01846                                           !BCC_ENDASM
01847                                           ! 830 }
01848 0619           C3                         ret
01849                                           ! 831   void
01850                                           ! 832 write_byte(seg, offset, data)
01851                                           ! 833   Bit16u seg;
01852                                           export	_write_byte
01853                       0000061A            _write_byte:
01854                                           !BCC_EOS
01855                                           ! 834   Bit16u offset;
01856                                           !BCC_EOS
01857                                           ! 835   Bit8u data;
01858                                           !BCC_EOS
01859                                           ! 836 {
01860                                           ! 837 #asm
01861                                           !BCC_ASM
01862                       00000002            _write_byte.seg	set	2
01863                       00000006            _write_byte.data	set	6
01864                       00000004            _write_byte.offset	set	4
01865 061A           55                           push bp
01866 061B           89E5                         mov bp, sp
01867 061D           50                             push ax
01868 061E           53                             push bx
01869 061F           1E                             push ds
01870 0620           8B46         04                mov ax, 4[bp] ; segment
01871 0623           8ED8                           mov ds, ax
01872 0625           8B5E         06                mov bx, 6[bp] ; offset
01873 0628           8A46         08                mov al, 8[bp] ; data byte
01874 062B           8807                           mov [bx], al ; write data byte
01875 062D           1F                             pop ds
01876 062E           5B                             pop bx
01877 062F           58                             pop ax
01878 0630           5D                           pop bp
01879                                           ! 852 endasm
01880                                           !BCC_ENDASM
01881                                           ! 853 }
01882 0631           C3                         ret
01883                                           ! 854   void
01884                                           ! 855 write_word(seg, offset, data)
01885                                           ! 856   Bit16u seg;
01886                                           export	_write_word
01887                       00000632            _write_word:
01888                                           !BCC_EOS
01889                                           ! 857   Bit16u offset;
01890                                           !BCC_EOS
01891                                           ! 858   Bit16u data;
01892                                           !BCC_EOS
01893                                           ! 859 {
01894                                           ! 860 #asm
01895                                           !BCC_ASM
01896                       00000002            _write_word.seg	set	2
01897                       00000006            _write_word.data	set	6
01898                       00000004            _write_word.offset	set	4
01899 0632           55                           push bp
01900 0633           89E5                         mov bp, sp
01901 0635           50                             push ax
01902 0636           53                             push bx
01903 0637           1E                             push ds
01904 0638           8B46         04                mov ax, 4[bp] ; segment
01905 063B           8ED8                           mov ds, ax
01906 063D           8B5E         06                mov bx, 6[bp] ; offset
01907 0640           8B46         08                mov ax, 8[bp] ; data word
01908 0643           8907                           mov [bx], ax ; write data word
01909 0645           1F                             pop ds
01910 0646           5B                             pop bx
01911 0647           58                             pop ax
01912 0648           5D                           pop bp
01913                                           ! 875 endasm
01914                                           !BCC_ENDASM
01915                                           ! 876 }
01916 0649           C3                         ret
01917                                           ! 877   Bit16u
01918                                           ! 878 get_CS()
01919                                           ! 879 {
01920                                           export	_get_CS
01921                       0000064A            _get_CS:
01922                                           ! 880 #asm
01923                                           !BCC_ASM
01924 064A           8CC8                         mov ax, cs
01925                                           ! 882 endasm
01926                                           !BCC_ENDASM
01927                                           ! 883 }
01928 064C           C3                         ret
01929                                           ! 884   Bit16u
01930                                           ! 885 get_SS()
01931                                           ! 886 {
01932                                           export	_get_SS
01933                       0000064D            _get_SS:
01934                                           ! 887 #asm
01935                                           !BCC_ASM
01936 064D           8CD0                         mov ax, ss
01937                                           ! 889 endasm
01938                                           !BCC_ENDASM
01939                                           ! 890 }
01940 064F           C3                         ret
01941                                           ! 891 void
01942                                           ! 892 fixup_base_mem_in_k()
01943                                           ! 893 {
01944                                           export	_fixup_base_mem_in_k
01945                       00000650            _fixup_base_mem_in_k:
01946                                           ! 894   Bit32u base_mem = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 8);
01947 0650           55                         push	bp
01948 0651           89E5                       mov	bp,sp
01949 0653           83C4                   FC  add	sp,*-4
01950                                           ! Debug: list int = const $10 (used reg = )
01951 0656           B8                   0010  mov	ax,*$10
01952 0659           50                         push	ax
01953                                           ! Debug: list unsigned short = const $EA10 (used reg = )
01954 065A           B8                   EA10  mov	ax,#$EA10
01955 065D           50                         push	ax
01956                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
01957 065E           E8         FA22            call	_read_dword
01958 0661           89D3                       mov	bx,dx
01959 0663           83C4                   04  add	sp,*4
01960                                           ! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+6-6] (used reg = )
01961 0666           8946         FC            mov	-4[bp],ax
01962 0669           895E         FE            mov	-2[bp],bx
01963                                           !BCC_EOS
01964                                           ! 895   write_word(0x40, 0x13, base_mem >> 10);
01965                                           ! Debug: sr int = const $A to unsigned long base_mem = [S+6-6] (used reg = )
01966 066C           8B46         FC            mov	ax,-4[bp]
01967 066F           8B5E         FE            mov	bx,-2[bp]
01968 0672           88E0                       mov	al,ah
01969 0674           88DC                       mov	ah,bl
01970 0676           88FB                       mov	bl,bh
01971 0678           28FF                       sub	bh,bh
01972 067A           BF                   0002  mov	di,*2
01973 067D           E8         FAA9            call	lsrul
01974                                           ! Debug: list unsigned long = bx+0 (used reg = )
01975 0680           53                         push	bx
01976 0681           50                         push	ax
01977                                           ! Debug: list int = const $13 (used reg = )
01978 0682           B8                   0013  mov	ax,*$13
01979 0685           50                         push	ax
01980                                           ! Debug: list int = const $40 (used reg = )
01981 0686           B8                   0040  mov	ax,*$40
01982 0689           50                         push	ax
01983                                           ! Debug: func () void = write_word+0 (used reg = )
01984 068A           E8         FFA5            call	_write_word
01985 068D           83C4                   08  add	sp,*8
01986                                           !BCC_EOS
01987                                           ! 896 }
01988 0690           89EC                       mov	sp,bp
01989 0692           5D                         pop	bp
01990 0693           C3                         ret
01991                                           ! 897 void enable_rom_write_access()
01992                                           ! Register BX used in function fixup_base_mem_in_k
01993                                           ! 898 {
01994                                           export	_enable_rom_write_access
01995                       00000694            _enable_rom_write_access:
01996                                           ! 899     outb(0x10, 0);
01997 0694           55                         push	bp
01998 0695           89E5                       mov	bp,sp
01999                                           ! Debug: list int = const 0 (used reg = )
02000 0697           31C0                       xor	ax,ax
02001 0699           50                         push	ax
02002                                           ! Debug: list int = const $10 (used reg = )
02003 069A           B8                   0010  mov	ax,*$10
02004 069D           50                         push	ax
02005                                           ! Debug: func () void = outb+0 (used reg = )
02006 069E           E8         FEB3            call	_outb
02007 06A1           89EC                       mov	sp,bp
02008                                           !BCC_EOS
02009                                           ! 900 }
02010 06A3           5D                         pop	bp
02011 06A4           C3                         ret
02012                                           ! 901 void disable_rom_write_access()
02013                                           ! 902 {
02014                                           export	_disable_rom_write_access
02015                       000006A5            _disable_rom_write_access:
02016                                           ! 903     outb(0x10, 1);
02017 06A5           55                         push	bp
02018 06A6           89E5                       mov	bp,sp
02019                                           ! Debug: list int = const 1 (used reg = )
02020 06A8           B8                   0001  mov	ax,*1
02021 06AB           50                         push	ax
02022                                           ! Debug: list int = const $10 (used reg = )
02023 06AC           B8                   0010  mov	ax,*$10
02024 06AF           50                         push	ax
02025                                           ! Debug: func () void = outb+0 (used reg = )
02026 06B0           E8         FEA1            call	_outb
02027 06B3           89EC                       mov	sp,bp
02028                                           !BCC_EOS
02029                                           ! 904 }
02030 06B5           5D                         pop	bp
02031 06B6           C3                         ret
02032                                           ! 905   void
02033                                           ! 906 wrch(c)
02034                                           ! 907   Bit8u c;
02035                                           export	_wrch
02036                       000006B7            _wrch:
02037                                           !BCC_EOS
02038                                           ! 908 {
02039                                           ! 909 #asm
02040                                           !BCC_ASM
02041                       00000002            _wrch.c	set	2
02042 06B7           55                           push bp
02043 06B8           89E5                         mov bp, sp
02044 06BA           53                           push bx
02045 06BB           B4                     0E    mov ah, #0x0e
02046 06BD           8A46         04              mov al, 4[bp]
02047 06C0           31DB                         xor bx,bx
02048 06C2           CD                     10    int #0x10
02049 06C4           5B                           pop bx
02050 06C5           5D                           pop bp
02051                                           ! 919 endasm
02052                                           !BCC_ENDASM
02053                                           ! 920 }
02054 06C6           C3                         ret
02055                                           ! 921   void
02056                                           ! 922 send(action, c)
02057                                           ! 923   Bit16u action;
02058                                           export	_send
02059                       000006C7            _send:
02060                                           !BCC_EOS
02061                                           ! 924   Bit8u c;
02062                                           !BCC_EOS
02063                                           ! 925 {
02064                                           ! 926   outb(0xE9, c);
02065 06C7           55                         push	bp
02066 06C8           89E5                       mov	bp,sp
02067                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02068 06CA           8A46         06            mov	al,6[bp]
02069 06CD           30E4                       xor	ah,ah
02070 06CF           50                         push	ax
02071                                           ! Debug: list int = const $E9 (used reg = )
02072 06D0           B8                   00E9  mov	ax,#$E9
02073 06D3           50                         push	ax
02074                                           ! Debug: func () void = outb+0 (used reg = )
02075 06D4           E8         FE7D            call	_outb
02076 06D7           89EC                       mov	sp,bp
02077                                           !BCC_EOS
02078                                           ! 927   if (action & 8) outb(0x403, c);
02079                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02080 06D9           8A46         04            mov	al,4[bp]
02081 06DC           24                     08  and	al,*8
02082 06DE           84C0                       test	al,al
02083 06E0           74           0F            je  	.8
02084                       000006E2            .9:
02085                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02086 06E2           8A46         06            mov	al,6[bp]
02087 06E5           30E4                       xor	ah,ah
02088 06E7           50                         push	ax
02089                                           ! Debug: list int = const $403 (used reg = )
02090 06E8           B8                   0403  mov	ax,#$403
02091 06EB           50                         push	ax
02092                                           ! Debug: func () void = outb+0 (used reg = )
02093 06EC           E8         FE65            call	_outb
02094 06EF           89EC                       mov	sp,bp
02095                                           !BCC_EOS
02096                                           ! 928   if (action & 4) outb(0x402, c);
02097                       000006F1            .8:
02098                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02099 06F1           8A46         04            mov	al,4[bp]
02100 06F4           24                     04  and	al,*4
02101 06F6           84C0                       test	al,al
02102 06F8           74           0F            je  	.A
02103                       000006FA            .B:
02104                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02105 06FA           8A46         06            mov	al,6[bp]
02106 06FD           30E4                       xor	ah,ah
02107 06FF           50                         push	ax
02108                                           ! Debug: list int = const $402 (used reg = )
02109 0700           B8                   0402  mov	ax,#$402
02110 0703           50                         push	ax
02111                                           ! Debug: func () void = outb+0 (used reg = )
02112 0704           E8         FE4D            call	_outb
02113 0707           89EC                       mov	sp,bp
02114                                           !BCC_EOS
02115                                           ! 929   if (action & 2) {
02116                       00000709            .A:
02117                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02118 0709           8A46         04            mov	al,4[bp]
02119 070C           24                     02  and	al,*2
02120 070E           84C0                       test	al,al
02121 0710           74           1B            je  	.C
02122                       00000712            .D:
02123                                           ! 930     if (c == '\n') wrc
02124                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02125 0712           8A46         06            mov	al,6[bp]
02126 0715           3C                     0A  cmp	al,*$A
02127 0717           75           09            jne 	.E
02128                       00000719            .F:
02129                                           ! 930 h('\r');
02130                                           ! Debug: list int = const $D (used reg = )
02131 0719           B8                   000D  mov	ax,*$D
02132 071C           50                         push	ax
02133                                           ! Debug: func () void = wrch+0 (used reg = )
02134 071D           E8         FF97            call	_wrch
02135 0720           89EC                       mov	sp,bp
02136                                           !BCC_EOS
02137                                           ! 931     wrch(c);
02138                       00000722            .E:
02139                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02140 0722           8A46         06            mov	al,6[bp]
02141 0725           30E4                       xor	ah,ah
02142 0727           50                         push	ax
02143                                           ! Debug: func () void = wrch+0 (used reg = )
02144 0728           E8         FF8C            call	_wrch
02145 072B           89EC                       mov	sp,bp
02146                                           !BCC_EOS
02147                                           ! 932   }
02148                                           ! 933 }
02149                       0000072D            .C:
02150 072D           5D                         pop	bp
02151 072E           C3                         ret
02152                                           ! 934   void
02153                                           ! 935 put_int(action, val, width, neg)
02154                                           ! 936   Bit16u action;
02155                                           export	_put_int
02156                       0000072F            _put_int:
02157                                           !BCC_EOS
02158                                           ! 937   short val, width;
02159                                           !BCC_EOS
02160                                           ! 938   bx_bool neg;
02161                                           !BCC_EOS
02162                                           ! 939 {
02163                                           ! 940   short nval = val / 10;
02164 072F           55                         push	bp
02165 0730           89E5                       mov	bp,sp
02166 0732           4C                         dec	sp
02167 0733           4C                         dec	sp
02168                                           ! Debug: div int = const $A to short val = [S+4+4] (used reg = )
02169 0734           8B46         06            mov	ax,6[bp]
02170 0737           BB                   000A  mov	bx,*$A
02171 073A           99                         cwd
02172 073B           F7FB                       idiv	bx
02173                                           ! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
02174 073D           8946         FE            mov	-2[bp],ax
02175                                           !BCC_EOS
02176                                           ! 941   if (nval)
02177 0740           8B46         FE            mov	ax,-2[bp]
02178 0743           85C0                       test	ax,ax
02179 0745         0F84         0016            beq 	.10
02180                       00000749            .11:
02181                                           ! 942     put_int(action, nval, width - 1, neg);
02182                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02183 0749           FF76         0A            push	$A[bp]
02184                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02185 074C           8B46         08            mov	ax,8[bp]
02186                                           ! Debug: list int = ax-1 (used reg = )
02187 074F           48                         dec	ax
02188 0750           50                         push	ax
02189                                           ! Debug: list short nval = [S+8-4] (used reg = )
02190 0751           FF76         FE            push	-2[bp]
02191                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02192 0754           FF76         04            push	4[bp]
02193                                           ! Debug: func () void = put_int+0 (used reg = )
02194 0757           E8         FFD5            call	_put_int
02195 075A           83C4                   08  add	sp,*8
02196                                           !BCC_EOS
02197                                           ! 943   else {
02198 075D           EB           2E            jmp .12
02199                       0000075F            .10:
02200                                           ! 944     while (--width > 0) send(action, ' ');
02201 075F           EB           0D            jmp .14
02202                       00000761            .15:
02203                                           ! Debug: list int = const $20 (used reg = )
02204 0761           B8                   0020  mov	ax,*$20
02205 0764           50                         push	ax
02206                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02207 0765           FF76         04            push	4[bp]
02208                                           ! Debug: func () void = send+0 (used reg = )
02209 0768           E8         FF5C            call	_send
02210 076B           83C4                   04  add	sp,*4
02211                                           !BCC_EOS
02212                                           ! 945     if (neg) send(action, '-');
02213                       0000076E            .14:
02214                                           ! Debug: predec short width = [S+4+6] (used reg = )
02215 076E           8B46         08            mov	ax,8[bp]
02216 0771           48                         dec	ax
02217 0772           8946         08            mov	8[bp],ax
02218                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02219 0775           85C0                       test	ax,ax
02220 0777           7F           E8            jg 	.15
02221                       00000779            .16:
02222                       00000779            .13:
02223 0779           8B46         0A            mov	ax,$A[bp]
02224 077C           85C0                       test	ax,ax
02225 077E           74           0D            je  	.17
02226                       00000780            .18:
02227                                           ! Debug: list int = const $2D (used reg = )
02228 0780           B8                   002D  mov	ax,*$2D
02229 0783           50                         push	ax
02230                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02231 0784           FF76         04            push	4[bp]
02232                                           ! Debug: func () void = send+0 (used reg = )
02233 0787           E8         FF3D            call	_send
02234 078A           83C4                   04  add	sp,*4
02235                                           !BCC_EOS
02236                                           ! 946   }
02237                       0000078D            .17:
02238                                           ! 947   send(action, val - (nval * 10) + '0');
02239                       0000078D            .12:
02240                                           ! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
02241 078D           8B46         FE            mov	ax,-2[bp]
02242 0790           89C2                       mov	dx,ax
02243 0792           D1E0                       shl	ax,*1
02244 0794           D1E0                       shl	ax,*1
02245 0796           01D0                       add	ax,dx
02246 0798           D1E0                       shl	ax,*1
02247                                           ! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
02248 079A           50                         push	ax
02249 079B           8B46         06            mov	ax,6[bp]
02250 079E           2B46         FC            sub	ax,-4[bp]
02251 07A1           44                         inc	sp
02252 07A2           44                         inc	sp
02253                                           ! Debug: add int = const $30 to int = ax+0 (used reg = )
02254                                           ! Debug: list int = ax+$30 (used reg = )
02255 07A3           05                   0030  add	ax,*$30
02256 07A6           50                         push	ax
02257                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02258 07A7           FF76         04            push	4[bp]
02259                                           ! Debug: func () void = send+0 (used reg = )
02260 07AA           E8         FF1A            call	_send
02261 07AD           83C4                   04  add	sp,*4
02262                                           !BCC_EOS
02263                                           ! 948 }
02264 07B0           89EC                       mov	sp,bp
02265 07B2           5D                         pop	bp
02266 07B3           C3                         ret
02267                                           ! 949   void
02268                                           ! Register BX used in function put_int
02269                                           ! 950 put_uint(action, val, width, neg)
02270                                           ! 951   Bit16u action;
02271                                           export	_put_uint
02272                       000007B4            _put_uint:
02273                                           !BCC_EOS
02274                                           ! 952   unsigned short val;
02275                                           !BCC_EOS
02276                                           ! 953   short width;
02277                                           !BCC_EOS
02278                                           ! 954   bx_bool neg;
02279                                           !BCC_EOS
02280                                           ! 955 {
02281                                           ! 956   unsigned short nval = val / 10;
02282 07B4           55                         push	bp
02283 07B5           89E5                       mov	bp,sp
02284 07B7           4C                         dec	sp
02285 07B8           4C                         dec	sp
02286                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02287 07B9           8B46         06            mov	ax,6[bp]
02288 07BC           BB                   000A  mov	bx,*$A
02289 07BF           E8         F9A7            call	idiv_u
02290                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02291 07C2           8946         FE            mov	-2[bp],ax
02292                                           !BCC_EOS
02293                                           ! 957   if (nval)
02294 07C5           8B46         FE            mov	ax,-2[bp]
02295 07C8           85C0                       test	ax,ax
02296 07CA           74           16            je  	.19
02297                       000007CC            .1A:
02298                                           ! 958     put_uint(action, nval, width - 1, neg);
02299                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02300 07CC           FF76         0A            push	$A[bp]
02301                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02302 07CF           8B46         08            mov	ax,8[bp]
02303                                           ! Debug: list int = ax-1 (used reg = )
02304 07D2           48                         dec	ax
02305 07D3           50                         push	ax
02306                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02307 07D4           FF76         FE            push	-2[bp]
02308                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02309 07D7           FF76         04            push	4[bp]
02310                                           ! Debug: func () void = put_uint+0 (used reg = )
02311 07DA           E8         FFD7            call	_put_uint
02312 07DD           83C4                   08  add	sp,*8
02313                                           !BCC_EOS
02314                                           ! 959   else {
02315 07E0           EB           2E            jmp .1B
02316                       000007E2            .19:
02317                                           ! 960     while (--width > 0) send(action, ' ');
02318 07E2           EB           0D            jmp .1D
02319                       000007E4            .1E:
02320                                           ! Debug: list int = const $20 (used reg = )
02321 07E4           B8                   0020  mov	ax,*$20
02322 07E7           50                         push	ax
02323                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02324 07E8           FF76         04            push	4[bp]
02325                                           ! Debug: func () void = send+0 (used reg = )
02326 07EB           E8         FED9            call	_send
02327 07EE           83C4                   04  add	sp,*4
02328                                           !BCC_EOS
02329                                           ! 961     if (neg) send(action, '-');
02330                       000007F1            .1D:
02331                                           ! Debug: predec short width = [S+4+6] (used reg = )
02332 07F1           8B46         08            mov	ax,8[bp]
02333 07F4           48                         dec	ax
02334 07F5           8946         08            mov	8[bp],ax
02335                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02336 07F8           85C0                       test	ax,ax
02337 07FA           7F           E8            jg 	.1E
02338                       000007FC            .1F:
02339                       000007FC            .1C:
02340 07FC           8B46         0A            mov	ax,$A[bp]
02341 07FF           85C0                       test	ax,ax
02342 0801           74           0D            je  	.20
02343                       00000803            .21:
02344                                           ! Debug: list int = const $2D (used reg = )
02345 0803           B8                   002D  mov	ax,*$2D
02346 0806           50                         push	ax
02347                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02348 0807           FF76         04            push	4[bp]
02349                                           ! Debug: func () void = send+0 (used reg = )
02350 080A           E8         FEBA            call	_send
02351 080D           83C4                   04  add	sp,*4
02352                                           !BCC_EOS
02353                                           ! 962   }
02354                       00000810            .20:
02355                                           ! 963   send(action, val - (nval * 10) + '0');
02356                       00000810            .1B:
02357                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02358 0810           8B46         FE            mov	ax,-2[bp]
02359 0813           89C2                       mov	dx,ax
02360 0815           D1E0                       shl	ax,*1
02361 0817           D1E0                       shl	ax,*1
02362 0819           01D0                       add	ax,dx
02363 081B           D1E0                       shl	ax,*1
02364                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02365 081D           50                         push	ax
02366 081E           8B46         06            mov	ax,6[bp]
02367 0821           2B46         FC            sub	ax,-4[bp]
02368 0824           44                         inc	sp
02369 0825           44                         inc	sp
02370                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02371                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02372 0826           05                   0030  add	ax,*$30
02373 0829           50                         push	ax
02374                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02375 082A           FF76         04            push	4[bp]
02376                                           ! Debug: func () void = send+0 (used reg = )
02377 082D           E8         FE97            call	_send
02378 0830           83C4                   04  add	sp,*4
02379                                           !BCC_EOS
02380                                           ! 964 }
02381 0833           89EC                       mov	sp,bp
02382 0835           5D                         pop	bp
02383 0836           C3                         ret
02384                                           ! 965   void
02385                                           ! Register BX used in function put_uint
02386                                           ! 966 put_luint(action, val, width, neg)
02387                                           ! 967   Bit16u action;
02388                                           export	_put_luint
02389                       00000837            _put_luint:
02390                                           !BCC_EOS
02391                                           ! 968   unsigned long val;
02392                                           !BCC_EOS
02393                                           ! 969   short width;
02394                                           !BCC_EOS
02395                                           ! 970   bx_bool neg;
02396                                           !BCC_EOS
02397                                           ! 971 {
02398                                           ! 972   unsigned long nval = val / 10;
02399 0837           55                         push	bp
02400 0838           89E5                       mov	bp,sp
02401 083A           83C4                   FC  add	sp,*-4
02402                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02403 083D           B8                   000A  mov	ax,*$A
02404 0840           31DB                       xor	bx,bx
02405 0842           53                         push	bx
02406 0843           50                         push	ax
02407 0844           8B46         06            mov	ax,6[bp]
02408 0847           8B5E         08            mov	bx,8[bp]
02409 084A           8D7E         F8            lea	di,-8[bp]
02410 084D           E8         F91E            call	ldivul
02411 0850           83C4                   04  add	sp,*4
02412                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02413 0853           8946         FC            mov	-4[bp],ax
02414 0856           895E         FE            mov	-2[bp],bx
02415                                           !BCC_EOS
02416                                           ! 973   if (nval)
02417 0859           8B46         FC            mov	ax,-4[bp]
02418 085C           8B5E         FE            mov	bx,-2[bp]
02419 085F           E8         F8B2            call	ltstl
02420 0862           74           19            je  	.22
02421                       00000864            .23:
02422                                           ! 974     put_luint(action, nval, width - 1, neg);
02423                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02424 0864           FF76         0C            push	$C[bp]
02425                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02426 0867           8B46         0A            mov	ax,$A[bp]
02427                                           ! Debug: list int = ax-1 (used reg = )
02428 086A           48                         dec	ax
02429 086B           50                         push	ax
02430                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02431 086C           FF76         FE            push	-2[bp]
02432 086F           FF76         FC            push	-4[bp]
02433                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02434 0872           FF76         04            push	4[bp]
02435                                           ! Debug: func () void = put_luint+0 (used reg = )
02436 0875           E8         FFBF            call	_put_luint
02437 0878           83C4                   0A  add	sp,*$A
02438                                           !BCC_EOS
02439                                           ! 975   else {
02440 087B           EB           2E            jmp .24
02441                       0000087D            .22:
02442                                           ! 976     while (--width > 0) send(action, ' ');
02443 087D           EB           0D            jmp .26
02444                       0000087F            .27:
02445                                           ! Debug: list int = const $20 (used reg = )
02446 087F           B8                   0020  mov	ax,*$20
02447 0882           50                         push	ax
02448                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02449 0883           FF76         04            push	4[bp]
02450                                           ! Debug: func () void = send+0 (used reg = )
02451 0886           E8         FE3E            call	_send
02452 0889           83C4                   04  add	sp,*4
02453                                           !BCC_EOS
02454                                           ! 977     if (neg) send(action, '-');
02455                       0000088C            .26:
02456                                           ! Debug: predec short width = [S+6+8] (used reg = )
02457 088C           8B46         0A            mov	ax,$A[bp]
02458 088F           48                         dec	ax
02459 0890           8946         0A            mov	$A[bp],ax
02460                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02461 0893           85C0                       test	ax,ax
02462 0895           7F           E8            jg 	.27
02463                       00000897            .28:
02464                       00000897            .25:
02465 0897           8B46         0C            mov	ax,$C[bp]
02466 089A           85C0                       test	ax,ax
02467 089C           74           0D            je  	.29
02468                       0000089E            .2A:
02469                                           ! Debug: list int = const $2D (used reg = )
02470 089E           B8                   002D  mov	ax,*$2D
02471 08A1           50                         push	ax
02472                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02473 08A2           FF76         04            push	4[bp]
02474                                           ! Debug: func () void = send+0 (used reg = )
02475 08A5           E8         FE1F            call	_send
02476 08A8           83C4                   04  add	sp,*4
02477                                           !BCC_EOS
02478                                           ! 978   }
02479                       000008AB            .29:
02480                                           ! 979   send(action, val - (nval * 10) + '0');
02481                       000008AB            .24:
02482                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02483                                           ! Debug: expression subtree swapping
02484 08AB           B8                   000A  mov	ax,*$A
02485 08AE           31DB                       xor	bx,bx
02486 08B0           8D7E         FC            lea	di,-4[bp]
02487 08B3           E8         F833            call	lmulul
02488                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02489 08B6           53                         push	bx
02490 08B7           50                         push	ax
02491 08B8           8B46         06            mov	ax,6[bp]
02492 08BB           8B5E         08            mov	bx,8[bp]
02493 08BE           8D7E         F8            lea	di,-8[bp]
02494 08C1           E8         F81D            call	lsubul
02495 08C4           83C4                   04  add	sp,*4
02496                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02497 08C7           53                         push	bx
02498 08C8           50                         push	ax
02499 08C9           B8                   0030  mov	ax,*$30
02500 08CC           31DB                       xor	bx,bx
02501 08CE           53                         push	bx
02502 08CF           50                         push	ax
02503 08D0           8B46         F8            mov	ax,-8[bp]
02504 08D3           8B5E         FA            mov	bx,-6[bp]
02505 08D6           8D7E         F4            lea	di,-$C[bp]
02506 08D9           E8         F7E7            call	laddul
02507 08DC           83C4                   08  add	sp,*8
02508                                           ! Debug: list unsigned long = bx+0 (used reg = )
02509 08DF           53                         push	bx
02510 08E0           50                         push	ax
02511                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02512 08E1           FF76         04            push	4[bp]
02513                                           ! Debug: func () void = send+0 (used reg = )
02514 08E4           E8         FDE0            call	_send
02515 08E7           83C4                   06  add	sp,*6
02516                                           !BCC_EOS
02517                                           ! 980 }
02518 08EA           89EC                       mov	sp,bp
02519 08EC           5D                         pop	bp
02520 08ED           C3                         ret
02521                                           ! 981 void put_str(action, segment, offset)
02522                                           ! Register BX used in function put_luint
02523                                           ! 982   Bit16u action;
02524                                           export	_put_str
02525                       000008EE            _put_str:
02526                                           !BCC_EOS
02527                                           ! 983   Bit16u segment;
02528                                           !BCC_EOS
02529                                           ! 984   Bit16u offset;
02530                                           !BCC_EOS
02531                                           ! 985 {
02532                                           ! 986   Bit8u c;
02533                                           !BCC_EOS
02534                                           ! 987   while (c = read_byte(segment, offset)) {
02535 08EE           55                         push	bp
02536 08EF           89E5                       mov	bp,sp
02537 08F1           4C                         dec	sp
02538 08F2           4C                         dec	sp
02539 08F3           EB           16            jmp .2C
02540                       000008F5            .2D:
02541                                           ! 988     send(action, c);
02542                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02543 08F5           8A46         FF            mov	al,-1[bp]
02544 08F8           30E4                       xor	ah,ah
02545 08FA           50                         push	ax
02546                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02547 08FB           FF76         04            push	4[bp]
02548                                           ! Debug: func () void = send+0 (used reg = )
02549 08FE           E8         FDC6            call	_send
02550 0901           83C4                   04  add	sp,*4
02551                                           !BCC_EOS
02552                                           ! 989     offset++;
02553                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02554 0904           8B46         08            mov	ax,8[bp]
02555 0907           40                         inc	ax
02556 0908           8946         08            mov	8[bp],ax
02557                                           !BCC_EOS
02558                                           ! 990   }
02559                                           ! 991 }
02560                       0000090B            .2C:
02561                                           ! Debug: list unsigned short offset = [S+4+6] (used reg = )
02562 090B           FF76         08            push	8[bp]
02563                                           ! Debug: list unsigned short segment = [S+6+4] (used reg = )
02564 090E           FF76         06            push	6[bp]
02565                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
02566 0911           E8         FCE0            call	_read_byte
02567 0914           83C4                   04  add	sp,*4
02568                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02569 0917           8846         FF            mov	-1[bp],al
02570 091A           84C0                       test	al,al
02571 091C           75           D7            jne	.2D
02572                       0000091E            .2E:
02573                       0000091E            .2B:
02574 091E           89EC                       mov	sp,bp
02575 0920           5D                         pop	bp
02576 0921           C3                         ret
02577                                           ! 992   void
02578                                           ! 993 delay_ticks(ticks)
02579                                           ! 994   Bit16u ticks;
02580                                           export	_delay_ticks
02581                       00000922            _delay_ticks:
02582                                           !BCC_EOS
02583                                           ! 995 {
02584                                           ! 996   long ticks_to_wait, delta;
02585                                           !BCC_EOS
02586                                           ! 997   Bit32u prev_ticks, t;
02587                                           !BCC_EOS
02588                                           ! 998 #asm
02589 0922           55                         push	bp
02590 0923           89E5                       mov	bp,sp
02591 0925           83C4                   F0  add	sp,*-$10
02592                                           !BCC_EOS
02593                                           !BCC_ASM
02594                       00000014            _delay_ticks.ticks	set	$14
02595                       00000004            .delay_ticks.ticks	set	4
02596                       00000000            _delay_ticks.t	set	0
02597                       FFFFFFF0            .delay_ticks.t	set	-$10
02598                       00000004            _delay_ticks.prev_ticks	set	4
02599                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02600                       00000008            _delay_ticks.delta	set	8
02601                       FFFFFFF8            .delay_ticks.delta	set	-8
02602                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02603                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02604 0928           9C                           pushf
02605 0929           FB                           sti
02606                                           ! 1001 endasm
02607                                           !BCC_ENDASM
02608                                           !BCC_EOS
02609                                           ! 1002   ticks_to_wait = ticks;
02610                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02611 092A           8B46         04            mov	ax,4[bp]
02612 092D           31DB                       xor	bx,bx
02613 092F           8946         FC            mov	-4[bp],ax
02614 0932           895E         FE            mov	-2[bp],bx
02615                                           !BCC_EOS
02616                                           ! 1003   prev_ticks = read_dword(0x0, 0x46c);
02617                                           ! Debug: list int = const $46C (used reg = )
02618 0935           B8                   046C  mov	ax,#$46C
02619 0938           50                         push	ax
02620                                           ! Debug: list int = const 0 (used reg = )
02621 0939           31C0                       xor	ax,ax
02622 093B           50                         push	ax
02623                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02624 093C           E8         F744            call	_read_dword
02625 093F           89D3                       mov	bx,dx
02626 0941           83C4                   04  add	sp,*4
02627                                           ! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02628 0944           8946         F4            mov	-$C[bp],ax
02629 0947           895E         F6            mov	-$A[bp],bx
02630                                           !BCC_EOS
02631                                           ! 1004   do
02632                                           ! 1005   {
02633                       0000094A            .31:
02634                                           ! 1006 #asm
02635                                           !BCC_EOS
02636                                           !BCC_ASM
02637                       00000014            _delay_ticks.ticks	set	$14
02638                       00000004            .delay_ticks.ticks	set	4
02639                       00000000            _delay_ticks.t	set	0
02640                       FFFFFFF0            .delay_ticks.t	set	-$10
02641                       00000004            _delay_ticks.prev_ticks	set	4
02642                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02643                       00000008            _delay_ticks.delta	set	8
02644                       FFFFFFF8            .delay_ticks.delta	set	-8
02645                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02646                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02647 094A           F4                             hlt
02648                                           ! 1008 endasm
02649                                           !BCC_ENDASM
02650                                           !BCC_EOS
02651                                           ! 1009     t = read_dword(0x0, 0x46c);
02652                                           ! Debug: list int = const $46C (used reg = )
02653 094B           B8                   046C  mov	ax,#$46C
02654 094E           50                         push	ax
02655                                           ! Debug: list int = const 0 (used reg = )
02656 094F           31C0                       xor	ax,ax
02657 0951           50                         push	ax
02658                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02659 0952           E8         F72E            call	_read_dword
02660 0955           89D3                       mov	bx,dx
02661 0957           83C4                   04  add	sp,*4
02662                                           ! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
02663 095A           8946         F0            mov	-$10[bp],ax
02664 095D           895E         F2            mov	-$E[bp],bx
02665                                           !BCC_EOS
02666                                           ! 1010     if (t > prev_ticks)
02667                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02668 0960           8B46         F4            mov	ax,-$C[bp]
02669 0963           8B5E         F6            mov	bx,-$A[bp]
02670 0966           8D7E         F0            lea	di,-$10[bp]
02671 0969           E8         F75F            call	lcmpul
02672 096C           73           26            jae 	.32
02673                       0000096E            .33:
02674                                           ! 1011     {
02675                                           ! 1012       delta = t - prev_ticks;
02676                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02677 096E           8B46         F0            mov	ax,-$10[bp]
02678 0971           8B5E         F2            mov	bx,-$E[bp]
02679 0974           8D7E         F4            lea	di,-$C[bp]
02680 0977           E8         F767            call	lsubul
02681                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02682 097A           8946         F8            mov	-8[bp],ax
02683 097D           895E         FA            mov	-6[bp],bx
02684                                           !BCC_EOS
02685                                           ! 1013       ticks_to_wait -= delta;
02686                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02687 0980           8B46         FC            mov	ax,-4[bp]
02688 0983           8B5E         FE            mov	bx,-2[bp]
02689 0986           8D7E         F8            lea	di,-8[bp]
02690 0989           E8         F755            call	lsubl
02691 098C           8946         FC            mov	-4[bp],ax
02692 098F           895E         FE            mov	-2[bp],bx
02693                                           !BCC_EOS
02694                                           ! 1014     }
02695                                           ! 1015     else if (t < prev_ticks)
02696 0992           EB           20            jmp .34
02697                       00000994            .32:
02698                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02699 0994           8B46         F4            mov	ax,-$C[bp]
02700 0997           8B5E         F6            mov	bx,-$A[bp]
02701 099A           8D7E         F0            lea	di,-$10[bp]
02702 099D           E8         F72B            call	lcmpul
02703 09A0           76           12            jbe 	.35
02704                       000009A2            .36:
02705                                           ! 1016     {
02706                                           ! 1017       ticks_to_wait -= t;
02707                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02708 09A2           8B46         FC            mov	ax,-4[bp]
02709 09A5           8B5E         FE            mov	bx,-2[bp]
02710 09A8           8D7E         F0            lea	di,-$10[bp]
02711 09AB           E8         F733            call	lsubul
02712 09AE           8946         FC            mov	-4[bp],ax
02713 09B1           895E         FE            mov	-2[bp],bx
02714                                           !BCC_EOS
02715                                           ! 1018     }
02716                                           ! 1019     prev_ticks = t;
02717                       000009B4            .35:
02718                       000009B4            .34:
02719                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02720 09B4           8B46         F0            mov	ax,-$10[bp]
02721 09B7           8B5E         F2            mov	bx,-$E[bp]
02722 09BA           8946         F4            mov	-$C[bp],ax
02723 09BD           895E         F6            mov	-$A[bp],bx
02724                                           !BCC_EOS
02725                                           ! 1020   } while (ticks_to_wait > 0);
02726                       000009C0            .30:
02727                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02728 09C0           31C0                       xor	ax,ax
02729 09C2           31DB                       xor	bx,bx
02730 09C4           8D7E         FC            lea	di,-4[bp]
02731 09C7           E8         F701            call	lcmpl
02732 09CA         0F8C         FF7C            blt 	.31
02733                       000009CE            .37:
02734                                           !BCC_EOS
02735                                           ! 1021 #asm
02736                       000009CE            .2F:
02737                                           !BCC_EOS
02738                                           !BCC_ASM
02739                       00000014            _delay_ticks.ticks	set	$14
02740                       00000004            .delay_ticks.ticks	set	4
02741                       00000000            _delay_ticks.t	set	0
02742                       FFFFFFF0            .delay_ticks.t	set	-$10
02743                       00000004            _delay_ticks.prev_ticks	set	4
02744                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02745                       00000008            _delay_ticks.delta	set	8
02746                       FFFFFFF8            .delay_ticks.delta	set	-8
02747                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02748                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02749 09CE           FA                           cli
02750 09CF           9D                           popf
02751                                           ! 1024 endasm
02752                                           !BCC_ENDASM
02753                                           !BCC_EOS
02754                                           ! 1025 }
02755 09D0           89EC                       mov	sp,bp
02756 09D2           5D                         pop	bp
02757 09D3           C3                         ret
02758                                           ! 1026   Bit8u
02759                                           ! Register BX used in function delay_ticks
02760                                           ! 1027 check_for_keystroke()
02761                                           ! 1028 {
02762                                           export	_check_for_keystroke
02763                       000009D4            _check_for_keystroke:
02764                                           ! 1029 #asm
02765                                           !BCC_ASM
02766 09D4           B8                   0100    mov ax, #0x100
02767 09D7           CD                     16    int #0x16
02768 09D9           74           04              jz no_key
02769 09DB           B0                     01    mov al, #1
02770 09DD           EB           02              jmp done
02771                       000009DF            no_key:
02772 09DF           30C0                         xor al, al
02773                       000009E1            done:
02774                                           ! 1038 endasm
02775                                           !BCC_ENDASM
02776                                           ! 1039 }
02777 09E1           C3                         ret
02778                                           ! 1040   Bit8u
02779                                           ! 1041 get_keystroke()
02780                                           ! 1042 {
02781                                           export	_get_keystroke
02782                       000009E2            _get_keystroke:
02783                                           ! 1043 #asm
02784                                           !BCC_ASM
02785 09E2           B8                   0000    mov ax, #0x0
02786 09E5           CD                     16    int #0x16
02787 09E7           86C4                         xchg ah, al
02788                                           ! 1047 endasm
02789                                           !BCC_ENDASM
02790                                           ! 1048 }
02791 09E9           C3                         ret
02792                                           ! 1049   void
02793                                           ! 1050 delay_ticks_and_check_for_keystroke(ticks, count)
02794                                           ! 1051   Bit16u ticks, count;
02795                                           export	_delay_ticks_and_check_for_keystroke
02796                       000009EA            _delay_ticks_and_check_for_keystroke:
02797                                           !BCC_EOS
02798                                           ! 1052 {
02799                                           ! 1053   Bit16u i;
02800                                           !BCC_EOS
02801                                           ! 1054   for (i = 1; i <= count; i++) {
02802 09EA           55                         push	bp
02803 09EB           89E5                       mov	bp,sp
02804 09ED           4C                         dec	sp
02805 09EE           4C                         dec	sp
02806                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02807 09EF           B8                   0001  mov	ax,*1
02808 09F2           8946         FE            mov	-2[bp],ax
02809                                           !BCC_EOS
02810                                           !BCC_EOS
02811 09F5           EB           18            jmp .3A
02812                       000009F7            .3B:
02813                                           ! 1055     delay_ticks(ticks)
02814                                           ! 1055 ;
02815                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02816 09F7           FF76         04            push	4[bp]
02817                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02818 09FA           E8         FF25            call	_delay_ticks
02819 09FD           44                         inc	sp
02820 09FE           44                         inc	sp
02821                                           !BCC_EOS
02822                                           ! 1056     if (check_for_keystroke())
02823                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02824 09FF           E8         FFD2            call	_check_for_keystroke
02825 0A02           84C0                       test	al,al
02826 0A04           74           02            je  	.3C
02827                       00000A06            .3D:
02828                                           ! 1057       break;
02829 0A06           EB           0F            jmp .38
02830                                           !BCC_EOS
02831                                           ! 1058   }
02832                       00000A08            .3C:
02833                                           ! 1059 }
02834                       00000A08            .39:
02835                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02836 0A08           8B46         FE            mov	ax,-2[bp]
02837 0A0B           40                         inc	ax
02838 0A0C           8946         FE            mov	-2[bp],ax
02839                       00000A0F            .3A:
02840                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02841 0A0F           8B46         FE            mov	ax,-2[bp]
02842 0A12           3B46         06            cmp	ax,6[bp]
02843 0A15           76           E0            jbe	.3B
02844                       00000A17            .3E:
02845                       00000A17            .38:
02846 0A17           89EC                       mov	sp,bp
02847 0A19           5D                         pop	bp
02848 0A1A           C3                         ret
02849                                           ! 1060   void
02850                                           ! 1061 bios_printf(action, s)
02851                                           ! 1062   Bit16u action;
02852                                           export	_bios_printf
02853                       00000A1B            _bios_printf:
02854                                           !BCC_EOS
02855                                           ! 1063   Bit8u *s;
02856                                           !BCC_EOS
02857                                           ! 1064 {
02858                                           ! 1065   Bit8u c, format_char;
02859                                           !BCC_EOS
02860                                           ! 1066   bx_bool in_format;
02861                                           !BCC_EOS
02862                                           ! 1067   short i;
02863                                           !BCC_EOS
02864                                           ! 1068   Bit16u *arg_ptr;
02865                                           !BCC_EOS
02866                                           ! 1069   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
02867                                           !BCC_EOS
02868                                           ! 1070   arg_ptr = &s;
02869 0A1B           55                         push	bp
02870 0A1C           89E5                       mov	bp,sp
02871 0A1E           83C4                   EA  add	sp,*-$16
02872                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02873 0A21           8D5E         06            lea	bx,6[bp]
02874 0A24           895E         F8            mov	-8[bp],bx
02875                                           !BCC_EOS
02876                                           ! 1071   arg_seg = get_SS();
02877                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
02878 0A27           E8         FC23            call	_get_SS
02879                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
02880 0A2A           8946         F6            mov	-$A[bp],ax
02881                                           !BCC_EOS
02882                                           ! 1072   in_format = 0;
02883                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02884 0A2D           31C0                       xor	ax,ax
02885 0A2F           8946         FC            mov	-4[bp],ax
02886                                           !BCC_EOS
02887                                           ! 1073   format_width = 0;
02888                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02889 0A32           31C0                       xor	ax,ax
02890 0A34           8946         EC            mov	-$14[bp],ax
02891                                           !BCC_EOS
02892                                           ! 1074   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02893                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02894 0A37           8A46         04            mov	al,4[bp]
02895 0A3A           24                     07  and	al,*7
02896                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02897 0A3C           3C                     07  cmp	al,*7
02898 0A3E           75           1B            jne 	.3F
02899                       00000A40            .40:
02900                                           ! 1075     outb(0x401, 0x00);
02901                                           ! Debug: list int = const 0 (used reg = )
02902 0A40           31C0                       xor	ax,ax
02903 0A42           50                         push	ax
02904                                           ! Debug: list int = const $401 (used reg = )
02905 0A43           B8                   0401  mov	ax,#$401
02906 0A46           50                         push	ax
02907                                           ! Debug: func () void = outb+0 (used reg = )
02908 0A47           E8         FB0A            call	_outb
02909 0A4A           83C4                   04  add	sp,*4
02910                                           !BCC_EOS
02911                                           ! 1076     bios_printf (2, "FATAL: ");
02912                                           ! Debug: list * char = .41+0 (used reg = )
02913 0A4D           BB                   D673  mov	bx,#.41
02914 0A50           53                         push	bx
02915                                           ! Debug: list int = const 2 (used reg = )
02916 0A51           B8                   0002  mov	ax,*2
02917 0A54           50                         push	ax
02918                                           ! Debug: func () void = bios_printf+0 (used reg = )
02919 0A55           E8         FFC3            call	_bios_printf
02920 0A58           83C4                   04  add	sp,*4
02921                                           !BCC_EOS
02922                                           ! 1077   }
02923                                           ! 1078   while (c = read_byte(get_CS(), s)) {
02924                       00000A5B            .3F:
02925 0A5B           E9         0369            br 	.43
02926                       00000A5E            .44:
02927                                           ! 1079     if ( c == '%' ) {
02928                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02929 0A5E           8A46         FF            mov	al,-1[bp]
02930 0A61           3C                     25  cmp	al,*$25
02931 0A63           75           0E            jne 	.45
02932                       00000A65            .46:
02933                                           ! 1080       in_format = 1;
02934                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02935 0A65           B8                   0001  mov	ax,*1
02936 0A68           8946         FC            mov	-4[bp],ax
02937                                           !BCC_EOS
02938                                           ! 1081       format_width = 0;
02939                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02940 0A6B           31C0                       xor	ax,ax
02941 0A6D           8946         EC            mov	-$14[bp],ax
02942                                           !BCC_EOS
02943                                           ! 1082       }
02944                                           ! 1083     else if (in_format) {
02945 0A70           E9         034D            br 	.47
02946                       00000A73            .45:
02947 0A73           8B46         FC            mov	ax,-4[bp]
02948 0A76           85C0                       test	ax,ax
02949 0A78         0F84         0335            beq 	.48
02950                       00000A7C            .49:
02951                                           ! 1084       if ( (c>='0') && (c<='9') ) {
02952                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02953 0A7C           8A46         FF            mov	al,-1[bp]
02954 0A7F           3C                     30  cmp	al,*$30
02955 0A81           72           28            jb  	.4A
02956                       00000A83            .4C:
02957                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02958 0A83           8A46         FF            mov	al,-1[bp]
02959 0A86           3C                     39  cmp	al,*$39
02960 0A88           77           21            ja  	.4A
02961                       00000A8A            .4B:
02962                                           ! 1085         format_width = (format_width * 10) + (c - '0');
02963                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02964 0A8A           8A46         FF            mov	al,-1[bp]
02965 0A8D           30E4                       xor	ah,ah
02966 0A8F           05                   FFD0  add	ax,*-$30
02967 0A92           50                         push	ax
02968                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
02969 0A93           8B46         EC            mov	ax,-$14[bp]
02970 0A96           89C2                       mov	dx,ax
02971 0A98           D1E0                       shl	ax,*1
02972 0A9A           D1E0                       shl	ax,*1
02973 0A9C           01D0                       add	ax,dx
02974 0A9E           D1E0                       shl	ax,*1
02975                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02976 0AA0           0346         E8            add	ax,-$18[bp]
02977 0AA3           44                         inc	sp
02978 0AA4           44                         inc	sp
02979                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
02980 0AA5           8946         EC            mov	-$14[bp],ax
02981                                           !BCC_EOS
02982                                           ! 1086         }
02983                                           ! 1087       else {
02984 0AA8           E9         0304            br 	.4D
02985                       00000AAB            .4A:
02986                                           ! 1088         arg_ptr++;
02987                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02988 0AAB           8B5E         F8            mov	bx,-8[bp]
02989 0AAE           43                         inc	bx
02990 0AAF           43                         inc	bx
02991 0AB0           895E         F8            mov	-8[bp],bx
02992                                           !BCC_EOS
02993                                           ! 1089         arg = read_word(arg_seg, arg_ptr);
02994                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02995 0AB3           FF76         F8            push	-8[bp]
02996                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
02997 0AB6           FF76         F6            push	-$A[bp]
02998                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
02999 0AB9           E8         FB4B            call	_read_word
03000 0ABC           83C4                   04  add	sp,*4
03001                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03002 0ABF           8946         F4            mov	-$C[bp],ax
03003                                           !BCC_EOS
03004                                           ! 1090         if (c == 'x' || c == 'X') {
03005                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03006 0AC2           8A46         FF            mov	al,-1[bp]
03007 0AC5           3C                     78  cmp	al,*$78
03008 0AC7           74           07            je  	.4F
03009                       00000AC9            .50:
03010                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03011 0AC9           8A46         FF            mov	al,-1[bp]
03012 0ACC           3C                     58  cmp	al,*$58
03013 0ACE           75           76            jne 	.4E
03014                       00000AD0            .4F:
03015                                           ! 1091           if (format_width == 0)
03016                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03017 0AD0           8B46         EC            mov	ax,-$14[bp]
03018 0AD3           85C0                       test	ax,ax
03019 0AD5           75           06            jne 	.51
03020                       00000AD7            .52:
03021                                           ! 1092             format_width = 4;
03022                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
03023 0AD7           B8                   0004  mov	ax,*4
03024 0ADA           8946         EC            mov	-$14[bp],ax
03025                                           !BCC_EOS
03026                                           ! 1093           if (c == 'x')
03027                       00000ADD            .51:
03028                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03029 0ADD           8A46         FF            mov	al,-1[bp]
03030 0AE0           3C                     78  cmp	al,*$78
03031 0AE2           75           08            jne 	.53
03032                       00000AE4            .54:
03033                                           ! 1094             hexadd = 'a';
03034                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03035 0AE4           B8                   0061  mov	ax,*$61
03036 0AE7           8946         EA            mov	-$16[bp],ax
03037                                           !BCC_EOS
03038                                           ! 1095           else
03039                                           ! 1096             hexadd = 'A';
03040 0AEA           EB           06            jmp .55
03041                       00000AEC            .53:
03042                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03043 0AEC           B8                   0041  mov	ax,*$41
03044 0AEF           8946         EA            mov	-$16[bp],ax
03045                                           !BCC_EOS
03046                                           ! 1097           for (i=format_width-1; i>=0; i--) {
03047                       00000AF2            .55:
03048                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03049 0AF2           8B46         EC            mov	ax,-$14[bp]
03050                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03051 0AF5           48                         dec	ax
03052 0AF6           8946         FA            mov	-6[bp],ax
03053                                           !BCC_EOS
03054                                           !BCC_EOS
03055 0AF9           EB           41            jmp .58
03056                       00000AFB            .59:
03057                                           ! 1098             nibble = (arg >> (4 * i)) & 0x000f;
03058                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03059                                           ! Debug: expression subtree swapping
03060 0AFB           8B46         FA            mov	ax,-6[bp]
03061 0AFE           D1E0                       shl	ax,*1
03062 0B00           D1E0                       shl	ax,*1
03063                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03064 0B02           89C3                       mov	bx,ax
03065 0B04           8B46         F4            mov	ax,-$C[bp]
03066 0B07           89D9                       mov	cx,bx
03067 0B09           D3E8                       shr	ax,cl
03068                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
03069 0B0B           24                     0F  and	al,*$F
03070                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03071 0B0D           30E4                       xor	ah,ah
03072 0B0F           8946         F2            mov	-$E[bp],ax
03073                                           !BCC_EOS
03074                                           ! 1099             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03075                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03076 0B12           8B46         F2            mov	ax,-$E[bp]
03077 0B15           3D                   0009  cmp	ax,*9
03078 0B18           77           08            ja  	.5A
03079                       00000B1A            .5B:
03080                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03081 0B1A           8B46         F2            mov	ax,-$E[bp]
03082 0B1D           05                   0030  add	ax,*$30
03083 0B20           EB           09            jmp .5C
03084                       00000B22            .5A:
03085                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03086 0B22           8B46         F2            mov	ax,-$E[bp]
03087                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03088 0B25           05                   FFF6  add	ax,*-$A
03089 0B28           0346         EA            add	ax,-$16[bp]
03090                       00000B2B            .5C:
03091                                           ! Debug: list unsigned int = ax+0 (used reg = )
03092 0B2B           50                         push	ax
03093                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03094 0B2C           FF76         04            push	4[bp]
03095                                           ! Debug: func () void = send+0 (used reg = )
03096 0B2F           E8         FB95            call	_send
03097 0B32           83C4                   04  add	sp,*4
03098                                           !BCC_EOS
03099                                           ! 1100             }
03100                                           ! 1101           }
03101                       00000B35            .57:
03102                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03103 0B35           8B46         FA            mov	ax,-6[bp]
03104 0B38           48                         dec	ax
03105 0B39           8946         FA            mov	-6[bp],ax
03106                       00000B3C            .58:
03107                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03108 0B3C           8B46         FA            mov	ax,-6[bp]
03109 0B3F           85C0                       test	ax,ax
03110 0B41           7D           B8            jge	.59
03111                       00000B43            .5D:
03112                       00000B43            .56:
03113                                           ! 1102         else if (c == 'u') {
03114 0B43           E9         0264            br 	.5E
03115                       00000B46            .4E:
03116                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03117 0B46           8A46         FF            mov	al,-1[bp]
03118 0B49           3C                     75  cmp	al,*$75
03119 0B4B           75           15            jne 	.5F
03120                       00000B4D            .60:
03121                                           ! 1103           put_uint(action, arg, format_width, 0);
03122                                           ! Debug: list int = const 0 (used reg = )
03123 0B4D           31C0                       xor	ax,ax
03124 0B4F           50                         push	ax
03125                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03126 0B50           FF76         EC            push	-$14[bp]
03127                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03128 0B53           FF76         F4            push	-$C[bp]
03129                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03130 0B56           FF76         04            push	4[bp]
03131                                           ! Debug: func () void = put_uint+0 (used reg = )
03132 0B59           E8         FC58            call	_put_uint
03133 0B5C           83C4                   08  add	sp,*8
03134                                           !BCC_EOS
03135                                           ! 1104           }
03136                                           ! 1105         else if (c == 'l') {
03137 0B5F           E9         0248            br 	.61
03138                       00000B62            .5F:
03139                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03140 0B62           8A46         FF            mov	al,-1[bp]
03141 0B65           3C                     6C  cmp	al,*$6C
03142 0B67         0F85         018F            bne 	.62
03143                       00000B6B            .63:
03144                                           ! 1106           s++;
03145                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03146 0B6B           8B5E         06            mov	bx,6[bp]
03147 0B6E           43                         inc	bx
03148 0B6F           895E         06            mov	6[bp],bx
03149                                           !BCC_EOS
03150                                           ! 1107           c = read_byte(get_CS(), s);
03151                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03152 0B72           FF76         06            push	6[bp]
03153                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03154 0B75           E8         FAD2            call	_get_CS
03155                                           ! Debug: list unsigned short = ax+0 (used reg = )
03156 0B78           50                         push	ax
03157                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03158 0B79           E8         FA78            call	_read_byte
03159 0B7C           83C4                   04  add	sp,*4
03160                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03161 0B7F           8846         FF            mov	-1[bp],al
03162                                           !BCC_EOS
03163                                           ! 1108           arg_ptr++;
03164                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03165 0B82           8B5E         F8            mov	bx,-8[bp]
03166 0B85           43                         inc	bx
03167 0B86           43                         inc	bx
03168 0B87           895E         F8            mov	-8[bp],bx
03169                                           !BCC_EOS
03170                                           ! 1109           hibyte = read_word(arg_seg, arg_ptr);
03171                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03172 0B8A           FF76         F8            push	-8[bp]
03173                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03174 0B8D           FF76         F6            push	-$A[bp]
03175                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03176 0B90           E8         FA74            call	_read_word
03177 0B93           83C4                   04  add	sp,*4
03178                                           ! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
03179 0B96           8946         F0            mov	-$10[bp],ax
03180                                           !BCC_EOS
03181                                           ! 1110           if (c == 'd') {
03182                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03183 0B99           8A46         FF            mov	al,-1[bp]
03184 0B9C           3C                     64  cmp	al,*$64
03185 0B9E         0F85         0073            bne 	.64
03186                       00000BA2            .65:
03187                                           ! 1111             if (hibyte & 0x8000)
03188                                           ! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
03189 0BA2           8B46         F0            mov	ax,-$10[bp]
03190 0BA5           25                   8000  and	ax,#$8000
03191 0BA8           85C0                       test	ax,ax
03192 0BAA           74           3D            je  	.66
03193                       00000BAC            .67:
03194                                           ! 1112               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
03195                                           ! Debug: list int = const 1 (used reg = )
03196 0BAC           B8                   0001  mov	ax,*1
03197 0BAF           50                         push	ax
03198                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03199 0BB0           8B46         EC            mov	ax,-$14[bp]
03200                                           ! Debug: list unsigned int = ax-1 (used reg = )
03201 0BB3           48                         dec	ax
03202 0BB4           50                         push	ax
03203                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03204 0BB5           8B46         F4            mov	ax,-$C[bp]
03205 0BB8           31DB                       xor	bx,bx
03206 0BBA           53                         push	bx
03207 0BBB           50                         push	ax
03208                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03209 0BBC           8B46         F0            mov	ax,-$10[bp]
03210 0BBF           31DB                       xor	bx,bx
03211                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03212 0BC1           93                         xchg	bx,ax
03213 0BC2           31C0                       xor	ax,ax
03214                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03215 0BC4           8D7E         E2            lea	di,-$1E[bp]
03216 0BC7           E8         F53D            call	lorul
03217 0BCA           83C4                   04  add	sp,*4
03218                                           ! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
03219 0BCD           53                         push	bx
03220 0BCE           50                         push	ax
03221 0BCF           31C0                       xor	ax,ax
03222 0BD1           31DB                       xor	bx,bx
03223 0BD3           8D7E         E2            lea	di,-$1E[bp]
03224 0BD6           E8         F508            call	lsubul
03225 0BD9           83C4                   04  add	sp,*4
03226                                           ! Debug: list unsigned long = bx+0 (used reg = )
03227 0BDC           53                         push	bx
03228 0BDD           50                         push	ax
03229                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03230 0BDE           FF76         04            push	4[bp]
03231                                           ! Debug: func () void = put_luint+0 (used reg = )
03232 0BE1           E8         FC53            call	_put_luint
03233 0BE4           83C4                   0A  add	sp,*$A
03234                                           !BCC_EOS
03235                                           ! 1113             else
03236                                           ! 1114               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03237 0BE7           EB           29            jmp .68
03238                       00000BE9            .66:
03239                                           ! Debug: list int = const 0 (used reg = )
03240 0BE9           31C0                       xor	ax,ax
03241 0BEB           50                         push	ax
03242                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03243 0BEC           FF76         EC            push	-$14[bp]
03244                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03245 0BEF           8B46         F4            mov	ax,-$C[bp]
03246 0BF2           31DB                       xor	bx,bx
03247 0BF4           53                         push	bx
03248 0BF5           50                         push	ax
03249                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03250 0BF6           8B46         F0            mov	ax,-$10[bp]
03251 0BF9           31DB                       xor	bx,bx
03252                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03253 0BFB           93                         xchg	bx,ax
03254 0BFC           31C0                       xor	ax,ax
03255                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03256 0BFE           8D7E         E2            lea	di,-$1E[bp]
03257 0C01           E8         F503            call	lorul
03258 0C04           83C4                   04  add	sp,*4
03259                                           ! Debug: list unsigned long = bx+0 (used reg = )
03260 0C07           53                         push	bx
03261 0C08           50                         push	ax
03262                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03263 0C09           FF76         04            push	4[bp]
03264                                           ! Debug: func () void = put_luint+0 (used reg = )
03265 0C0C           E8         FC28            call	_put_luint
03266 0C0F           83C4                   0A  add	sp,*$A
03267                                           !BCC_EOS
03268                                           ! 1115            }
03269                       00000C12            .68:
03270                                           ! 1116           else if (c == 'u') {
03271 0C12           E9         00E2            br 	.69
03272                       00000C15            .64:
03273                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03274 0C15           8A46         FF            mov	al,-1[bp]
03275 0C18           3C                     75  cmp	al,*$75
03276 0C1A           75           2C            jne 	.6A
03277                       00000C1C            .6B:
03278                                           ! 1117             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03279                                           ! Debug: list int = const 0 (used reg = )
03280 0C1C           31C0                       xor	ax,ax
03281 0C1E           50                         push	ax
03282                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03283 0C1F           FF76         EC            push	-$14[bp]
03284                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03285 0C22           8B46         F4            mov	ax,-$C[bp]
03286 0C25           31DB                       xor	bx,bx
03287 0C27           53                         push	bx
03288 0C28           50                         push	ax
03289                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03290 0C29           8B46         F0            mov	ax,-$10[bp]
03291 0C2C           31DB                       xor	bx,bx
03292                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03293 0C2E           93                         xchg	bx,ax
03294 0C2F           31C0                       xor	ax,ax
03295                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03296 0C31           8D7E         E2            lea	di,-$1E[bp]
03297 0C34           E8         F4D0            call	lorul
03298 0C37           83C4                   04  add	sp,*4
03299                                           ! Debug: list unsigned long = bx+0 (used reg = )
03300 0C3A           53                         push	bx
03301 0C3B           50                         push	ax
03302                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03303 0C3C           FF76         04            push	4[bp]
03304                                           ! Debug: func () void = put_luint+0 (used reg = )
03305 0C3F           E8         FBF5            call	_put_luint
03306 0C42           83C4                   0A  add	sp,*$A
03307                                           !BCC_EOS
03308                                           ! 1118            }
03309                                           ! 1119           else if (c == 'x' || c == 'X')
03310 0C45           E9         00AF            br 	.6C
03311                       00000C48            .6A:
03312                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03313 0C48           8A46         FF            mov	al,-1[bp]
03314 0C4B           3C                     78  cmp	al,*$78
03315 0C4D           74           09            je  	.6E
03316                       00000C4F            .6F:
03317                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03318 0C4F           8A46         FF            mov	al,-1[bp]
03319 0C52           3C                     58  cmp	al,*$58
03320 0C54         0F85         009F            bne 	.6D
03321                       00000C58            .6E:
03322                                           ! 1120            {
03323                                           ! 1121             if (format_width == 0)
03324                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03325 0C58           8B46         EC            mov	ax,-$14[bp]
03326 0C5B           85C0                       test	ax,ax
03327 0C5D           75           06            jne 	.70
03328                       00000C5F            .71:
03329                                           ! 1122               format_width = 8;
03330                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
03331 0C5F           B8                   0008  mov	ax,*8
03332 0C62           8946         EC            mov	-$14[bp],ax
03333                                           !BCC_EOS
03334                                           ! 1123             if (c == 'x')
03335                       00000C65            .70:
03336                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03337 0C65           8A46         FF            mov	al,-1[bp]
03338 0C68           3C                     78  cmp	al,*$78
03339 0C6A           75           08            jne 	.72
03340                       00000C6C            .73:
03341                                           ! 1124               hexadd = 'a';
03342                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03343 0C6C           B8                   0061  mov	ax,*$61
03344 0C6F           8946         EA            mov	-$16[bp],ax
03345                                           !BCC_EOS
03346                                           ! 1125             else
03347                                           ! 1126               hexadd = 'A';
03348 0C72           EB           06            jmp .74
03349                       00000C74            .72:
03350                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03351 0C74           B8                   0041  mov	ax,*$41
03352 0C77           8946         EA            mov	-$16[bp],ax
03353                                           !BCC_EOS
03354                                           ! 1127             for (i=format_width-1; i>=0; i--) {
03355                       00000C7A            .74:
03356                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03357 0C7A           8B46         EC            mov	ax,-$14[bp]
03358                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03359 0C7D           48                         dec	ax
03360 0C7E           8946         FA            mov	-6[bp],ax
03361                                           !BCC_EOS
03362                                           !BCC_EOS
03363 0C81           EB           6D            jmp .77
03364                       00000C83            .78:
03365                                           ! 1128             
03366                                           ! 1128   nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
03367                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03368                                           ! Debug: expression subtree swapping
03369 0C83           8B46         FA            mov	ax,-6[bp]
03370 0C86           D1E0                       shl	ax,*1
03371 0C88           D1E0                       shl	ax,*1
03372 0C8A           50                         push	ax
03373                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
03374 0C8B           8B46         F4            mov	ax,-$C[bp]
03375 0C8E           31DB                       xor	bx,bx
03376 0C90           53                         push	bx
03377 0C91           50                         push	ax
03378                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
03379 0C92           8B46         F0            mov	ax,-$10[bp]
03380 0C95           31DB                       xor	bx,bx
03381                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03382 0C97           93                         xchg	bx,ax
03383 0C98           31C0                       xor	ax,ax
03384                                           ! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
03385 0C9A           8D7E         E4            lea	di,-$1C[bp]
03386 0C9D           E8         F467            call	lorul
03387 0CA0           83C4                   04  add	sp,*4
03388                                           ! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
03389 0CA3           8B7E         E8            mov	di,-$18[bp]
03390 0CA6           E8         F480            call	lsrul
03391 0CA9           44                         inc	sp
03392 0CAA           44                         inc	sp
03393                                           ! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
03394 0CAB           53                         push	bx
03395 0CAC           50                         push	ax
03396 0CAD           B8                   000F  mov	ax,*$F
03397 0CB0           31DB                       xor	bx,bx
03398 0CB2           53                         push	bx
03399 0CB3           50                         push	ax
03400 0CB4           8B46         E6            mov	ax,-$1A[bp]
03401 0CB7           8B5E         E8            mov	bx,-$18[bp]
03402 0CBA           8D7E         E2            lea	di,-$1E[bp]
03403 0CBD           E8         F3FB            call	landul
03404 0CC0           83C4                   08  add	sp,*8
03405                                           ! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03406 0CC3           8946         F2            mov	-$E[bp],ax
03407                                           !BCC_EOS
03408                                           ! 1129               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03409                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03410 0CC6           8B46         F2            mov	ax,-$E[bp]
03411 0CC9           3D                   0009  cmp	ax,*9
03412 0CCC           77           08            ja  	.79
03413                       00000CCE            .7A:
03414                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03415 0CCE           8B46         F2            mov	ax,-$E[bp]
03416 0CD1           05                   0030  add	ax,*$30
03417 0CD4           EB           09            jmp .7B
03418                       00000CD6            .79:
03419                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03420 0CD6           8B46         F2            mov	ax,-$E[bp]
03421                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03422 0CD9           05                   FFF6  add	ax,*-$A
03423 0CDC           0346         EA            add	ax,-$16[bp]
03424                       00000CDF            .7B:
03425                                           ! Debug: list unsigned int = ax+0 (used reg = )
03426 0CDF           50                         push	ax
03427                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03428 0CE0           FF76         04            push	4[bp]
03429                                           ! Debug: func () void = send+0 (used reg = )
03430 0CE3           E8         F9E1            call	_send
03431 0CE6           83C4                   04  add	sp,*4
03432                                           !BCC_EOS
03433                                           ! 1130               }
03434                                           ! 1131            }
03435                       00000CE9            .76:
03436                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03437 0CE9           8B46         FA            mov	ax,-6[bp]
03438 0CEC           48                         dec	ax
03439 0CED           8946         FA            mov	-6[bp],ax
03440                       00000CF0            .77:
03441                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03442 0CF0           8B46         FA            mov	ax,-6[bp]
03443 0CF3           85C0                       test	ax,ax
03444 0CF5           7D           8C            jge	.78
03445                       00000CF7            .7C:
03446                       00000CF7            .75:
03447                                           ! 1132           }
03448                       00000CF7            .6D:
03449                       00000CF7            .6C:
03450                       00000CF7            .69:
03451                                           ! 1133         else if (c == 'd') {
03452 0CF7           E9         00B0            br 	.7D
03453                       00000CFA            .62:
03454                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03455 0CFA           8A46         FF            mov	al,-1[bp]
03456 0CFD           3C                     64  cmp	al,*$64
03457 0CFF           75           38            jne 	.7E
03458                       00000D01            .7F:
03459                                           ! 1134           if (arg & 0x8000)
03460                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
03461 0D01           8B46         F4            mov	ax,-$C[bp]
03462 0D04           25                   8000  and	ax,#$8000
03463 0D07           85C0                       test	ax,ax
03464 0D09           74           1A            je  	.80
03465                       00000D0B            .81:
03466                                           ! 1135             put_int(action, -arg, format_width - 1, 1);
03467                                           ! Debug: list int = const 1 (used reg = )
03468 0D0B           B8                   0001  mov	ax,*1
03469 0D0E           50                         push	ax
03470                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03471 0D0F           8B46         EC            mov	ax,-$14[bp]
03472                                           ! Debug: list unsigned int = ax-1 (used reg = )
03473 0D12           48                         dec	ax
03474 0D13           50                         push	ax
03475                                           ! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
03476 0D14           31C0                       xor	ax,ax
03477 0D16           2B46         F4            sub	ax,-$C[bp]
03478                                           ! Debug: list unsigned int = ax+0 (used reg = )
03479 0D19           50                         push	ax
03480                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03481 0D1A           FF76         04            push	4[bp]
03482                                           ! Debug: func () void = put_int+0 (used reg = )
03483 0D1D           E8         FA0F            call	_put_int
03484 0D20           83C4                   08  add	sp,*8
03485                                           !BCC_EOS
03486                                           ! 1136           else
03487                                           ! 1137             put_int(action, arg, format_width, 0);
03488 0D23           EB           12            jmp .82
03489                       00000D25            .80:
03490                                           ! Debug: list int = const 0 (used reg = )
03491 0D25           31C0                       xor	ax,ax
03492 0D27           50                         push	ax
03493                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03494 0D28           FF76         EC            push	-$14[bp]
03495                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03496 0D2B           FF76         F4            push	-$C[bp]
03497                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03498 0D2E           FF76         04            push	4[bp]
03499                                           ! Debug: func () void = put_int+0 (used reg = )
03500 0D31           E8         F9FB            call	_put_int
03501 0D34           83C4                   08  add	sp,*8
03502                                           !BCC_EOS
03503                                           ! 1138           }
03504                       00000D37            .82:
03505                                           ! 1139         else if (c == 's') {
03506 0D37           EB           71            jmp .83
03507                       00000D39            .7E:
03508                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03509 0D39           8A46         FF            mov	al,-1[bp]
03510 0D3C           3C                     73  cmp	al,*$73
03511 0D3E           75           12            jne 	.84
03512                       00000D40            .85:
03513                                           ! 1140           put_str(action, get_CS(), arg);
03514                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03515 0D40           FF76         F4            push	-$C[bp]
03516                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03517 0D43           E8         F904            call	_get_CS
03518                                           ! Debug: list unsigned short = ax+0 (used reg = )
03519 0D46           50                         push	ax
03520                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03521 0D47           FF76         04            push	4[bp]
03522                                           ! Debug: func () void = put_str+0 (used reg = )
03523 0D4A           E8         FBA1            call	_put_str
03524 0D4D           83C4                   06  add	sp,*6
03525                                           !BCC_EOS
03526                                           ! 1141           }
03527                                           ! 1142         else if (c == 'S') {
03528 0D50           EB           58            jmp .86
03529                       00000D52            .84:
03530                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03531 0D52           8A46         FF            mov	al,-1[bp]
03532 0D55           3C                     53  cmp	al,*$53
03533 0D57           75           2E            jne 	.87
03534                       00000D59            .88:
03535                                           ! 1143           hibyte = arg;
03536                                           ! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
03537 0D59           8B46         F4            mov	ax,-$C[bp]
03538 0D5C           8946         F0            mov	-$10[bp],ax
03539                                           !BCC_EOS
03540                                           ! 1144           arg_ptr++;
03541                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03542 0D5F           8B5E         F8            mov	bx,-8[bp]
03543 0D62           43                         inc	bx
03544 0D63           43                         inc	bx
03545 0D64           895E         F8            mov	-8[bp],bx
03546                                           !BCC_EOS
03547                                           ! 1145           arg = read_word(arg_seg, arg_ptr);
03548                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03549 0D67           FF76         F8            push	-8[bp]
03550                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03551 0D6A           FF76         F6            push	-$A[bp]
03552                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03553 0D6D           E8         F897            call	_read_word
03554 0D70           83C4                   04  add	sp,*4
03555                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03556 0D73           8946         F4            mov	-$C[bp],ax
03557                                           !BCC_EOS
03558                                           ! 1146           put_str(action, hibyte, arg);
03559                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03560 0D76           FF76         F4            push	-$C[bp]
03561                                           ! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
03562 0D79           FF76         F0            push	-$10[bp]
03563                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03564 0D7C           FF76         04            push	4[bp]
03565                                           ! Debug: func () void = put_str+0 (used reg = )
03566 0D7F           E8         FB6C            call	_put_str
03567 0D82           83C4                   06  add	sp,*6
03568                                           !BCC_EOS
03569                                           ! 1147           }
03570                                           ! 1148         else if (c == 'c') {
03571 0D85           EB           23            jmp .89
03572                       00000D87            .87:
03573                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03574 0D87           8A46         FF            mov	al,-1[bp]
03575 0D8A           3C                     63  cmp	al,*$63
03576 0D8C           75           0E            jne 	.8A
03577                       00000D8E            .8B:
03578                                           ! 1149           send(action, arg);
03579                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03580 0D8E           FF76         F4            push	-$C[bp]
03581                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03582 0D91           FF76         04            push	4[bp]
03583                                           ! Debug: func () void = send+0 (used reg = )
03584 0D94           E8         F930            call	_send
03585 0D97           83C4                   04  add	sp,*4
03586                                           !BCC_EOS
03587                                           ! 1150           }
03588                                           ! 1151         else
03589                                           ! 1152           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03590 0D9A           EB           0E            jmp .8C
03591                       00000D9C            .8A:
03592                                           ! Debug: list * char = .8D+0 (used reg = )
03593 0D9C           BB                   D656  mov	bx,#.8D
03594 0D9F           53                         push	bx
03595                                           ! Debug: list int = const 7 (used reg = )
03596 0DA0           B8                   0007  mov	ax,*7
03597 0DA3           50                         push	ax
03598                                           ! Debug: func () void = bios_printf+0 (used reg = )
03599 0DA4           E8         FC74            call	_bios_printf
03600 0DA7           83C4                   04  add	sp,*4
03601                                           !BCC_EOS
03602                                           ! 1153           in_format = 0;
03603                       00000DAA            .8C:
03604                       00000DAA            .89:
03605                       00000DAA            .86:
03606                       00000DAA            .83:
03607                       00000DAA            .7D:
03608                       00000DAA            .61:
03609                       00000DAA            .5E:
03610                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03611 0DAA           31C0                       xor	ax,ax
03612 0DAC           8946         FC            mov	-4[bp],ax
03613                                           !BCC_EOS
03614                                           ! 1154         }
03615                                           ! 1155       }
03616                       00000DAF            .4D:
03617                                           ! 1156     else {
03618 0DAF           EB           0F            jmp .8E
03619                       00000DB1            .48:
03620                                           ! 1157       send(action, c);
03621                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03622 0DB1           8A46         FF            mov	al,-1[bp]
03623 0DB4           30E4                       xor	ah,ah
03624 0DB6           50                         push	ax
03625                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03626 0DB7           FF76         04            push	4[bp]
03627                                           ! Debug: func () void = send+0 (used reg = )
03628 0DBA           E8         F90A            call	_send
03629 0DBD           83C4                   04  add	sp,*4
03630                                           !BCC_EOS
03631                                           ! 1158       }
03632                                           ! 1159     s ++;
03633                       00000DC0            .8E:
03634                       00000DC0            .47:
03635                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03636 0DC0           8B5E         06            mov	bx,6[bp]
03637 0DC3           43                         inc	bx
03638 0DC4           895E         06            mov	6[bp],bx
03639                                           !BCC_EOS
03640                                           ! 1160     }
03641                                           ! 1161   if (action & 1) {
03642                       00000DC7            .43:
03643                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03644 0DC7           FF76         06            push	6[bp]
03645                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03646 0DCA           E8         F87D            call	_get_CS
03647                                           ! Debug: list unsigned short = ax+0 (used reg = )
03648 0DCD           50                         push	ax
03649                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03650 0DCE           E8         F823            call	_read_byte
03651 0DD1           83C4                   04  add	sp,*4
03652                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03653 0DD4           8846         FF            mov	-1[bp],al
03654 0DD7           84C0                       test	al,al
03655 0DD9         0F85         FC81            bne 	.44
03656                       00000DDD            .8F:
03657                       00000DDD            .42:
03658                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03659 0DDD           8A46         04            mov	al,4[bp]
03660 0DE0           24                     01  and	al,*1
03661 0DE2           84C0                       test	al,al
03662 0DE4           74           04            je  	.90
03663                       00000DE6            .91:
03664                                           ! 1162 #asm
03665                                           !BCC_EOS
03666                                           !BCC_ASM
03667                       00000002            _bios_printf.format_width	set	2
03668                       FFFFFFEC            .bios_printf.format_width	set	-$14
03669                       00000014            _bios_printf.format_char	set	$14
03670                       FFFFFFFE            .bios_printf.format_char	set	-2
03671                       00000006            _bios_printf.hibyte	set	6
03672                       FFFFFFF0            .bios_printf.hibyte	set	-$10
03673                       0000000E            _bios_printf.arg_ptr	set	$E
03674                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03675                       0000001A            _bios_printf.action	set	$1A
03676                       00000004            .bios_printf.action	set	4
03677                       00000010            _bios_printf.i	set	$10
03678                       FFFFFFFA            .bios_printf.i	set	-6
03679                       0000000C            _bios_printf.arg_seg	set	$C
03680                       FFFFFFF6            .bios_printf.arg_seg	set	-$A
03681                       00000004            _bios_printf.shift_count	set	4
03682                       FFFFFFEE            .bios_printf.shift_count	set	-$12
03683                       00000012            _bios_printf.in_format	set	$12
03684                       FFFFFFFC            .bios_printf.in_format	set	-4
03685                       0000001C            _bios_printf.s	set	$1C
03686                       00000006            .bios_printf.s	set	6
03687                       00000008            _bios_printf.nibble	set	8
03688                       FFFFFFF2            .bios_printf.nibble	set	-$E
03689                       00000015            _bios_printf.c	set	$15
03690                       FFFFFFFF            .bios_printf.c	set	-1
03691                       00000000            _bios_printf.hexadd	set	0
03692                       FFFFFFEA            .bios_printf.hexadd	set	-$16
03693                       0000000A            _bios_printf.arg	set	$A
03694                       FFFFFFF4            .bios_printf.arg	set	-$C
03695 0DE6           FA                             cli
03696                       00000DE7             halt2_loop:
03697 0DE7           F4                             hlt
03698 0DE8           EB           FD                jmp halt2_loop
03699                                           ! 1167 endasm
03700                                           !BCC_ENDASM
03701                                           !BCC_EOS
03702                                           ! 1168     }
03703                                           ! 1169 }
03704                       00000DEA            .90:
03705 0DEA           89EC                       mov	sp,bp
03706 0DEC           5D                         pop	bp
03707 0DED           C3                         ret
03708                                           ! 1170   void
03709                                           ! Register BX used in function bios_printf
03710                                           ! 1171 keyboard_init()
03711                                           ! 1172 {
03712                                           export	_keyboard_init
03713                       00000DEE            _keyboard_init:
03714                                           ! 1173     Bit16u max;
03715                                           !BCC_EOS
03716                                           ! 1174     max=0xffff;
03717 0DEE           55                         push	bp
03718 0DEF           89E5                       mov	bp,sp
03719 0DF1           4C                         dec	sp
03720 0DF2           4C                         dec	sp
03721                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03722 0DF3           B8                   FFFF  mov	ax,#$FFFF
03723 0DF6           8946         FE            mov	-2[bp],ax
03724                                           !BCC_EOS
03725                                           ! 1175     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03726 0DF9           EB           0D            jmp .93
03727                       00000DFB            .94:
03728                                           ! Debug: list int = const 0 (used reg = )
03729 0DFB           31C0                       xor	ax,ax
03730 0DFD           50                         push	ax
03731                                           ! Debug: list int = const $80 (used reg = )
03732 0DFE           B8                   0080  mov	ax,#$80
03733 0E01           50                         push	ax
03734                                           ! Debug: func () void = outb+0 (used reg = )
03735 0E02           E8         F74F            call	_outb
03736 0E05           83C4                   04  add	sp,*4
03737                                           !BCC_EOS
03738                                           ! 1176     max=2;
03739                       00000E08            .93:
03740                                           ! Debug: list int = const $64 (used reg = )
03741 0E08           B8                   0064  mov	ax,*$64
03742 0E0B           50                         push	ax
03743                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03744 0E0C           E8         F72F            call	_inb
03745 0E0F           44                         inc	sp
03746 0E10           44                         inc	sp
03747                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03748 0E11           24                     02  and	al,*2
03749 0E13           84C0                       test	al,al
03750 0E15           74           0B            je  	.95
03751                       00000E17            .96:
03752                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03753 0E17           8B46         FE            mov	ax,-2[bp]
03754 0E1A           48                         dec	ax
03755 0E1B           8946         FE            mov	-2[bp],ax
03756                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03757 0E1E           85C0                       test	ax,ax
03758 0E20           75           D9            jne	.94
03759                       00000E22            .95:
03760                       00000E22            .92:
03761                                           ! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
03762 0E22           B8                   0002  mov	ax,*2
03763 0E25           8946         FE            mov	-2[bp],ax
03764                                           !BCC_EOS
03765                                           ! 1177     while (--max > 0) {
03766 0E28           EB           2B            jmp .98
03767                       00000E2A            .99:
03768                                           ! 1178         outb(0x80, 0x00);
03769                                           ! Debug: list int = const 0 (used reg = )
03770 0E2A           31C0                       xor	ax,ax
03771 0E2C           50                         push	ax
03772                                           ! Debug: list int = const $80 (used reg = )
03773 0E2D           B8                   0080  mov	ax,#$80
03774 0E30           50                         push	ax
03775                                           ! Debug: func () void = outb+0 (used reg = )
03776 0E31           E8         F720            call	_outb
03777 0E34           83C4                   04  add	sp,*4
03778                                           !BCC_EOS
03779                                           ! 1179         if (inb(0x64) & 0x01) {
03780                                           ! Debug: list int = const $64 (used reg = )
03781 0E37           B8                   0064  mov	ax,*$64
03782 0E3A           50                         push	ax
03783                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03784 0E3B           E8         F700            call	_inb
03785 0E3E           44                         inc	sp
03786 0E3F           44                         inc	sp
03787                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03788 0E40           24                     01  and	al,*1
03789 0E42           84C0                       test	al,al
03790 0E44           74           0F            je  	.9A
03791                       00000E46            .9B:
03792                                           ! 1180             inb(0x60);
03793                                           ! Debug: list int = const $60 (used reg = )
03794 0E46           B8                   0060  mov	ax,*$60
03795 0E49           50                         push	ax
03796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03797 0E4A           E8         F6F1            call	_inb
03798 0E4D           44                         inc	sp
03799 0E4E           44                         inc	sp
03800                                           !BCC_EOS
03801                                           ! 1181             max = 2;
03802                                           ! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
03803 0E4F           B8                   0002  mov	ax,*2
03804 0E52           8946         FE            mov	-2[bp],ax
03805                                           !BCC_EOS
03806                                           ! 1182             }
03807                                           ! 1183         }
03808                       00000E55            .9A:
03809                                           ! 1184     outb(0x64, 0xaa);
03810                       00000E55            .98:
03811                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03812 0E55           8B46         FE            mov	ax,-2[bp]
03813 0E58           48                         dec	ax
03814 0E59           8946         FE            mov	-2[bp],ax
03815                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03816 0E5C           85C0                       test	ax,ax
03817 0E5E           75           CA            jne	.99
03818                       00000E60            .9C:
03819                       00000E60            .97:
03820                                           ! Debug: list int = const $AA (used reg = )
03821 0E60           B8                   00AA  mov	ax,#$AA
03822 0E63           50                         push	ax
03823                                           ! Debug: list int = const $64 (used reg = )
03824 0E64           B8                   0064  mov	ax,*$64
03825 0E67           50                         push	ax
03826                                           ! Debug: func () void = outb+0 (used reg = )
03827 0E68           E8         F6E9            call	_outb
03828 0E6B           83C4                   04  add	sp,*4
03829                                           !BCC_EOS
03830                                           ! 1185     max=0xffff;
03831                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03832 0E6E           B8                   FFFF  mov	ax,#$FFFF
03833 0E71           8946         FE            mov	-2[bp],ax
03834                                           !BCC_EOS
03835                                           ! 1186     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03836 0E74           EB           0D            jmp .9E
03837                       00000E76            .9F:
03838                                           ! Debug: list int = const 0 (used reg = )
03839 0E76           31C0                       xor	ax,ax
03840 0E78           50                         push	ax
03841                                           ! Debug: list int = const $80 (used reg = )
03842 0E79           B8                   0080  mov	ax,#$80
03843 0E7C           50                         push	ax
03844                                           ! Debug: func () void = outb+0 (used reg = )
03845 0E7D           E8         F6D4            call	_outb
03846 0E80           83C4                   04  add	sp,*4
03847                                           !BCC_EOS
03848                                           ! 1187     if (max==0x0) keyboard_panic(00);
03849                       00000E83            .9E:
03850                                           ! Debug: list int = const $64 (used reg = )
03851 0E83           B8                   0064  mov	ax,*$64
03852 0E86           50                         push	ax
03853                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03854 0E87           E8         F6B4            call	_inb
03855 0E8A           44                         inc	sp
03856 0E8B           44                         inc	sp
03857                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03858 0E8C           24                     02  and	al,*2
03859 0E8E           84C0                       test	al,al
03860 0E90           74           0B            je  	.A0
03861                       00000E92            .A1:
03862                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03863 0E92           8B46         FE            mov	ax,-2[bp]
03864 0E95           48                         dec	ax
03865 0E96           8946         FE            mov	-2[bp],ax
03866                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03867 0E99           85C0                       test	ax,ax
03868 0E9B           75           D9            jne	.9F
03869                       00000E9D            .A0:
03870                       00000E9D            .9D:
03871                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03872 0E9D           8B46         FE            mov	ax,-2[bp]
03873 0EA0           85C0                       test	ax,ax
03874 0EA2           75           08            jne 	.A2
03875                       00000EA4            .A3:
03876                                           ! Debug: list int = const 0 (used reg = )
03877 0EA4           31C0                       xor	ax,ax
03878 0EA6           50                         push	ax
03879                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03880 0EA7           E8         0408            call	_keyboard_panic
03881 0EAA           44                         inc	sp
03882 0EAB           44                         inc	sp
03883                                           !BCC_EOS
03884                                           ! 1188     max=0xffff;
03885                       00000EAC            .A2:
03886                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03887 0EAC           B8                   FFFF  mov	ax,#$FFFF
03888 0EAF           8946         FE            mov	-2[bp],ax
03889                                           !BCC_EOS
03890                                           ! 1189     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
03891 0EB2           EB           0E            jmp .A5
03892                       00000EB4            .A6:
03893                                           ! Debug: list int = const 1 (used reg = )
03894 0EB4           B8                   0001  mov	ax,*1
03895 0EB7           50                         push	ax
03896                                           ! Debug: list int = const $80 (used reg = )
03897 0EB8           B8                   0080  mov	ax,#$80
03898 0EBB           50                         push	ax
03899                                           ! Debug: func () void = outb+0 (used reg = )
03900 0EBC           E8         F695            call	_outb
03901 0EBF           83C4                   04  add	sp,*4
03902                                           !BCC_EOS
03903                                           ! 1190     if (max==0x0) keyboard_panic(01);
03904                       00000EC2            .A5:
03905                                           ! Debug: list int = const $64 (used reg = )
03906 0EC2           B8                   0064  mov	ax,*$64
03907 0EC5           50                         push	ax
03908                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03909 0EC6           E8         F675            call	_inb
03910 0EC9           44                         inc	sp
03911 0ECA           44                         inc	sp
03912                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03913 0ECB           24                     01  and	al,*1
03914                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03915 0ECD           84C0                       test	al,al
03916 0ECF           75           0B            jne 	.A7
03917                       00000ED1            .A8:
03918                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03919 0ED1           8B46         FE            mov	ax,-2[bp]
03920 0ED4           48                         dec	ax
03921 0ED5           8946         FE            mov	-2[bp],ax
03922                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03923 0ED8           85C0                       test	ax,ax
03924 0EDA           75           D8            jne	.A6
03925                       00000EDC            .A7:
03926                       00000EDC            .A4:
03927                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03928 0EDC           8B46         FE            mov	ax,-2[bp]
03929 0EDF           85C0                       test	ax,ax
03930 0EE1           75           09            jne 	.A9
03931                       00000EE3            .AA:
03932                                           ! Debug: list int = const 1 (used reg = )
03933 0EE3           B8                   0001  mov	ax,*1
03934 0EE6           50                         push	ax
03935                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03936 0EE7           E8         03C8            call	_keyboard_panic
03937 0EEA           44                         inc	sp
03938 0EEB           44                         inc	sp
03939                                           !BCC_EOS
03940                                           ! 1191     if ((inb(0x60) != 0x55)){
03941                       00000EEC            .A9:
03942                                           ! Debug: list int = const $60 (used reg = )
03943 0EEC           B8                   0060  mov	ax,*$60
03944 0EEF           50                         push	ax
03945                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03946 0EF0           E8         F64B            call	_inb
03947 0EF3           44                         inc	sp
03948 0EF4           44                         inc	sp
03949                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03950 0EF5           3C                     55  cmp	al,*$55
03951 0EF7           74           09            je  	.AB
03952                       00000EF9            .AC:
03953                                           ! 1192         keyboard_panic(991);
03954                                           ! Debug: list int = const $3DF (used reg = )
03955 0EF9           B8                   03DF  mov	ax,#$3DF
03956 0EFC           50                         push	ax
03957                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03958 0EFD           E8         03B2            call	_keyboard_panic
03959 0F00           44                         inc	sp
03960 0F01           44                         inc	sp
03961                                           !BCC_EOS
03962                                           ! 1193     }
03963                                           ! 1194     outb(0x64,0xab);
03964                       00000F02            .AB:
03965                                           ! Debug: list int = const $AB (used reg = )
03966 0F02           B8                   00AB  mov	ax,#$AB
03967 0F05           50                         push	ax
03968                                           ! Debug: list int = const $64 (used reg = )
03969 0F06           B8                   0064  mov	ax,*$64
03970 0F09           50                         push	ax
03971                                           ! Debug: func () void = outb+0 (used reg = )
03972 0F0A           E8         F647            call	_outb
03973 0F0D           83C4                   04  add	sp,*4
03974                                           !BCC_EOS
03975                                           ! 1195     max=0xffff;
03976                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03977 0F10           B8                   FFFF  mov	ax,#$FFFF
03978 0F13           8946         FE            mov	-2[bp],ax
03979                                           !BCC_EOS
03980                                           ! 1196     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
03981 0F16           EB           0E            jmp .AE
03982                       00000F18            .AF:
03983                                           ! Debug: list int = const $10 (used reg = )
03984 0F18           B8                   0010  mov	ax,*$10
03985 0F1B           50                         push	ax
03986                                           ! Debug: list int = const $80 (used reg = )
03987 0F1C           B8                   0080  mov	ax,#$80
03988 0F1F           50                         push	ax
03989                                           ! Debug: func () void = outb+0 (used reg = )
03990 0F20           E8         F631            call	_outb
03991 0F23           83C4                   04  add	sp,*4
03992                                           !BCC_EOS
03993                                           ! 1197     if (max==0x0) keyboard_panic(10);
03994                       00000F26            .AE:
03995                                           ! Debug: list int = const $64 (used reg = )
03996 0F26           B8                   0064  mov	ax,*$64
03997 0F29           50                         push	ax
03998                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03999 0F2A           E8         F611            call	_inb
04000 0F2D           44                         inc	sp
04001 0F2E           44                         inc	sp
04002                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04003 0F2F           24                     02  and	al,*2
04004 0F31           84C0                       test	al,al
04005 0F33           74           0B            je  	.B0
04006                       00000F35            .B1:
04007                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04008 0F35           8B46         FE            mov	ax,-2[bp]
04009 0F38           48                         dec	ax
04010 0F39           8946         FE            mov	-2[bp],ax
04011                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04012 0F3C           85C0                       test	ax,ax
04013 0F3E           75           D8            jne	.AF
04014                       00000F40            .B0:
04015                       00000F40            .AD:
04016                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04017 0F40           8B46         FE            mov	ax,-2[bp]
04018 0F43           85C0                       test	ax,ax
04019 0F45           75           09            jne 	.B2
04020                       00000F47            .B3:
04021                                           ! Debug: list int = const $A (used reg = )
04022 0F47           B8                   000A  mov	ax,*$A
04023 0F4A           50                         push	ax
04024                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04025 0F4B           E8         0364            call	_keyboard_panic
04026 0F4E           44                         inc	sp
04027 0F4F           44                         inc	sp
04028                                           !BCC_EOS
04029                                           ! 1198     max=0xffff;
04030                       00000F50            .B2:
04031                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04032 0F50           B8                   FFFF  mov	ax,#$FFFF
04033 0F53           8946         FE            mov	-2[bp],ax
04034                                           !BCC_EOS
04035                                           ! 1199     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
04036 0F56           EB           0E            jmp .B5
04037                       00000F58            .B6:
04038                                           ! Debug: list int = const $11 (used reg = )
04039 0F58           B8                   0011  mov	ax,*$11
04040 0F5B           50                         push	ax
04041                                           ! Debug: list int = const $80 (used reg = )
04042 0F5C           B8                   0080  mov	ax,#$80
04043 0F5F           50                         push	ax
04044                                           ! Debug: func () void = outb+0 (used reg = )
04045 0F60           E8         F5F1            call	_outb
04046 0F63           83C4                   04  add	sp,*4
04047                                           !BCC_EOS
04048                                           ! 1200     if (max==0x0) keyboard_panic(11);
04049                       00000F66            .B5:
04050                                           ! Debug: list int = const $64 (used reg = )
04051 0F66           B8                   0064  mov	ax,*$64
04052 0F69           50                         push	ax
04053                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04054 0F6A           E8         F5D1            call	_inb
04055 0F6D           44                         inc	sp
04056 0F6E           44                         inc	sp
04057                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04058 0F6F           24                     01  and	al,*1
04059                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04060 0F71           84C0                       test	al,al
04061 0F73           75           0B            jne 	.B7
04062                       00000F75            .B8:
04063                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04064 0F75           8B46         FE            mov	ax,-2[bp]
04065 0F78           48                         dec	ax
04066 0F79           8946         FE            mov	-2[bp],ax
04067                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04068 0F7C           85C0                       test	ax,ax
04069 0F7E           75           D8            jne	.B6
04070                       00000F80            .B7:
04071                       00000F80            .B4:
04072                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04073 0F80           8B46         FE            mov	ax,-2[bp]
04074 0F83           85C0                       test	ax,ax
04075 0F85           75           09            jne 	.B9
04076                       00000F87            .BA:
04077                                           ! Debug: list int = const $B (used reg = )
04078 0F87           B8                   000B  mov	ax,*$B
04079 0F8A           50                         push	ax
04080                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04081 0F8B           E8         0324            call	_keyboard_panic
04082 0F8E           44                         inc	sp
04083 0F8F           44                         inc	sp
04084                                           !BCC_EOS
04085                                           ! 1201     if ((inb(0x60) != 0x00)) {
04086                       00000F90            .B9:
04087                                           ! Debug: list int = const $60 (used reg = )
04088 0F90           B8                   0060  mov	ax,*$60
04089 0F93           50                         push	ax
04090                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04091 0F94           E8         F5A7            call	_inb
04092 0F97           44                         inc	sp
04093 0F98           44                         inc	sp
04094                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
04095 0F99           84C0                       test	al,al
04096 0F9B           74           09            je  	.BB
04097                       00000F9D            .BC:
04098                                           ! 1202         keyboard_panic(992);
04099                                           ! Debug: list int = const $3E0 (used reg = )
04100 0F9D           B8                   03E0  mov	ax,#$3E0
04101 0FA0           50                         push	ax
04102                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04103 0FA1           E8         030E            call	_keyboard_panic
04104 0FA4           44                         inc	sp
04105 0FA5           44                         inc	sp
04106                                           !BCC_EOS
04107                                           ! 1203     }
04108                                           ! 1204     outb(0x64,0xae);
04109                       00000FA6            .BB:
04110                                           ! Debug: list int = const $AE (used reg = )
04111 0FA6           B8                   00AE  mov	ax,#$AE
04112 0FA9           50                         push	ax
04113                                           ! Debug: list int = const $64 (used reg = )
04114 0FAA           B8                   0064  mov	ax,*$64
04115 0FAD           50                         push	ax
04116                                           ! Debug: func () void = outb+0 (used reg = )
04117 0FAE           E8         F5A3            call	_outb
04118 0FB1           83C4                   04  add	sp,*4
04119                                           !BCC_EOS
04120                                           ! 1205     outb(0x64,0xa8);
04121                                           ! Debug: list int = const $A8 (used reg = )
04122 0FB4           B8                   00A8  mov	ax,#$A8
04123 0FB7           50                         push	ax
04124                                           ! Debug: list int = const $64 (used reg = )
04125 0FB8           B8                   0064  mov	ax,*$64
04126 0FBB           50                         push	ax
04127                                           ! Debug: func () void = outb+0 (used reg = )
04128 0FBC           E8         F595            call	_outb
04129 0FBF           83C4                   04  add	sp,*4
04130                                           !BCC_EOS
04131                                           ! 1206     outb(0x60, 0xff);
04132                                           ! Debug: list int = const $FF (used reg = )
04133 0FC2           B8                   00FF  mov	ax,#$FF
04134 0FC5           50                         push	ax
04135                                           ! Debug: list int = const $60 (used reg = )
04136 0FC6           B8                   0060  mov	ax,*$60
04137 0FC9           50                         push	ax
04138                                           ! Debug: func () void = outb+0 (used reg = )
04139 0FCA           E8         F587            call	_outb
04140 0FCD           83C4                   04  add	sp,*4
04141                                           !BCC_EOS
04142                                           ! 1207     max=0xffff;
04143                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04144 0FD0           B8                   FFFF  mov	ax,#$FFFF
04145 0FD3           8946         FE            mov	-2[bp],ax
04146                                           !BCC_EOS
04147                                           ! 1208     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20)
04148 0FD6           EB           0E            jmp .BE
04149                       00000FD8            .BF:
04150                                           ! 1208 ;
04151                                           ! Debug: list int = const $20 (used reg = )
04152 0FD8           B8                   0020  mov	ax,*$20
04153 0FDB           50                         push	ax
04154                                           ! Debug: list int = const $80 (used reg = )
04155 0FDC           B8                   0080  mov	ax,#$80
04156 0FDF           50                         push	ax
04157                                           ! Debug: func () void = outb+0 (used reg = )
04158 0FE0           E8         F571            call	_outb
04159 0FE3           83C4                   04  add	sp,*4
04160                                           !BCC_EOS
04161                                           ! 1209     if (max==0x0) keyboard_panic(20);
04162                       00000FE6            .BE:
04163                                           ! Debug: list int = const $64 (used reg = )
04164 0FE6           B8                   0064  mov	ax,*$64
04165 0FE9           50                         push	ax
04166                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04167 0FEA           E8         F551            call	_inb
04168 0FED           44                         inc	sp
04169 0FEE           44                         inc	sp
04170                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04171 0FEF           24                     02  and	al,*2
04172 0FF1           84C0                       test	al,al
04173 0FF3           74           0B            je  	.C0
04174                       00000FF5            .C1:
04175                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04176 0FF5           8B46         FE            mov	ax,-2[bp]
04177 0FF8           48                         dec	ax
04178 0FF9           8946         FE            mov	-2[bp],ax
04179                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04180 0FFC           85C0                       test	ax,ax
04181 0FFE           75           D8            jne	.BF
04182                       00001000            .C0:
04183                       00001000            .BD:
04184                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04185 1000           8B46         FE            mov	ax,-2[bp]
04186 1003           85C0                       test	ax,ax
04187 1005           75           09            jne 	.C2
04188                       00001007            .C3:
04189                                           ! Debug: list int = const $14 (used reg = )
04190 1007           B8                   0014  mov	ax,*$14
04191 100A           50                         push	ax
04192                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04193 100B           E8         02A4            call	_keyboard_panic
04194 100E           44                         inc	sp
04195 100F           44                         inc	sp
04196                                           !BCC_EOS
04197                                           ! 1210     max=0xffff;
04198                       00001010            .C2:
04199                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04200 1010           B8                   FFFF  mov	ax,#$FFFF
04201 1013           8946         FE            mov	-2[bp],ax
04202                                           !BCC_EOS
04203                                           ! 1211     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
04204 1016           EB           0E            jmp .C5
04205                       00001018            .C6:
04206                                           ! Debug: list int = const $21 (used reg = )
04207 1018           B8                   0021  mov	ax,*$21
04208 101B           50                         push	ax
04209                                           ! Debug: list int = const $80 (used reg = )
04210 101C           B8                   0080  mov	ax,#$80
04211 101F           50                         push	ax
04212                                           ! Debug: func () void = outb+0 (used reg = )
04213 1020           E8         F531            call	_outb
04214 1023           83C4                   04  add	sp,*4
04215                                           !BCC_EOS
04216                                           ! 1212     if (max==0x0) keyboard_panic(21);
04217                       00001026            .C5:
04218                                           ! Debug: list int = const $64 (used reg = )
04219 1026           B8                   0064  mov	ax,*$64
04220 1029           50                         push	ax
04221                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04222 102A           E8         F511            call	_inb
04223 102D           44                         inc	sp
04224 102E           44                         inc	sp
04225                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04226 102F           24                     01  and	al,*1
04227                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04228 1031           84C0                       test	al,al
04229 1033           75           0B            jne 	.C7
04230                       00001035            .C8:
04231                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04232 1035           8B46         FE            mov	ax,-2[bp]
04233 1038           48                         dec	ax
04234 1039           8946         FE            mov	-2[bp],ax
04235                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04236 103C           85C0                       test	ax,ax
04237 103E           75           D8            jne	.C6
04238                       00001040            .C7:
04239                       00001040            .C4:
04240                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04241 1040           8B46         FE            mov	ax,-2[bp]
04242 1043           85C0                       test	ax,ax
04243 1045           75           09            jne 	.C9
04244                       00001047            .CA:
04245                                           ! Debug: list int = const $15 (used reg = )
04246 1047           B8                   0015  mov	ax,*$15
04247 104A           50                         push	ax
04248                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04249 104B           E8         0264            call	_keyboard_panic
04250 104E           44                         inc	sp
04251 104F           44                         inc	sp
04252                                           !BCC_EOS
04253                                           ! 1213     if ((inb(0x60) != 0xfa)) {
04254                       00001050            .C9:
04255                                           ! Debug: list int = const $60 (used reg = )
04256 1050           B8                   0060  mov	ax,*$60
04257 1053           50                         push	ax
04258                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04259 1054           E8         F4E7            call	_inb
04260 1057           44                         inc	sp
04261 1058           44                         inc	sp
04262                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04263 1059           3C                     FA  cmp	al,#$FA
04264 105B           74           09            je  	.CB
04265                       0000105D            .CC:
04266                                           ! 1214         keyboard_panic(993);
04267                                           ! Debug: list int = const $3E1 (used reg = )
04268 105D           B8                   03E1  mov	ax,#$3E1
04269 1060           50                         push	ax
04270                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04271 1061           E8         024E            call	_keyboard_panic
04272 1064           44                         inc	sp
04273 1065           44                         inc	sp
04274                                           !BCC_EOS
04275                                           ! 1215     }
04276                                           ! 1216     max=0xffff;
04277                       00001066            .CB:
04278                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04279 1066           B8                   FFFF  mov	ax,#$FFFF
04280 1069           8946         FE            mov	-2[bp],ax
04281                                           !BCC_EOS
04282                                           ! 1217     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
04283 106C           EB           0E            jmp .CE
04284                       0000106E            .CF:
04285                                           ! Debug: list int = const $31 (used reg = )
04286 106E           B8                   0031  mov	ax,*$31
04287 1071           50                         push	ax
04288                                           ! Debug: list int = const $80 (used reg = )
04289 1072           B8                   0080  mov	ax,#$80
04290 1075           50                         push	ax
04291                                           ! Debug: func () void = outb+0 (used reg = )
04292 1076           E8         F4DB            call	_outb
04293 1079           83C4                   04  add	sp,*4
04294                                           !BCC_EOS
04295                                           ! 1218     if (max==0x0) keyboard_panic(31);
04296                       0000107C            .CE:
04297                                           ! Debug: list int = const $64 (used reg = )
04298 107C           B8                   0064  mov	ax,*$64
04299 107F           50                         push	ax
04300                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04301 1080           E8         F4BB            call	_inb
04302 1083           44                         inc	sp
04303 1084           44                         inc	sp
04304                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04305 1085           24                     01  and	al,*1
04306                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04307 1087           84C0                       test	al,al
04308 1089           75           0B            jne 	.D0
04309                       0000108B            .D1:
04310                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04311 108B           8B46         FE            mov	ax,-2[bp]
04312 108E           48                         dec	ax
04313 108F           8946         FE            mov	-2[bp],ax
04314                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04315 1092           85C0                       test	ax,ax
04316 1094           75           D8            jne	.CF
04317                       00001096            .D0:
04318                       00001096            .CD:
04319                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04320 1096           8B46         FE            mov	ax,-2[bp]
04321 1099           85C0                       test	ax,ax
04322 109B           75           09            jne 	.D2
04323                       0000109D            .D3:
04324                                           ! Debug: list int = const $1F (used reg = )
04325 109D           B8                   001F  mov	ax,*$1F
04326 10A0           50                         push	ax
04327                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04328 10A1           E8         020E            call	_keyboard_panic
04329 10A4           44                         inc	sp
04330 10A5           44                         inc	sp
04331                                           !BCC_EOS
04332                                           ! 1219     if ((inb(0x60) != 0xaa)) {
04333                       000010A6            .D2:
04334                                           ! Debug: list int = const $60 (used reg = )
04335 10A6           B8                   0060  mov	ax,*$60
04336 10A9           50                         push	ax
04337                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04338 10AA           E8         F491            call	_inb
04339 10AD           44                         inc	sp
04340 10AE           44                         inc	sp
04341                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04342 10AF           3C                     AA  cmp	al,#$AA
04343 10B1           74           09            je  	.D4
04344                       000010B3            .D5:
04345                                           ! 1220         keyboard_panic(994);
04346                                           ! Debug: list int = const $3E2 (used reg = )
04347 10B3           B8                   03E2  mov	ax,#$3E2
04348 10B6           50                         push	ax
04349                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04350 10B7           E8         01F8            call	_keyboard_panic
04351 10BA           44                         inc	sp
04352 10BB           44                         inc	sp
04353                                           !BCC_EOS
04354                                           ! 1221     }
04355                                           ! 1222     outb(0x60, 0xf5);
04356                       000010BC            .D4:
04357                                           ! Debug: list int = const $F5 (used reg = )
04358 10BC           B8                   00F5  mov	ax,#$F5
04359 10BF           50                         push	ax
04360                                           ! Debug: list int = const $60 (used reg = )
04361 10C0           B8                   0060  mov	ax,*$60
04362 10C3           50                         push	ax
04363                                           ! Debug: func () void = outb+0 (used reg = )
04364 10C4           E8         F48D            call	_outb
04365 10C7           83C4                   04  add	sp,*4
04366                                           !BCC_EOS
04367                                           ! 1223     max=0xffff;
04368                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04369 10CA           B8                   FFFF  mov	ax,#$FFFF
04370 10CD           8946         FE            mov	-2[bp],ax
04371                                           !BCC_EOS
04372                                           ! 1224     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
04373 10D0           EB           0E            jmp .D7
04374                       000010D2            .D8:
04375                                           ! Debug: list int = const $40 (used reg = )
04376 10D2           B8                   0040  mov	ax,*$40
04377 10D5           50                         push	ax
04378                                           ! Debug: list int = const $80 (used reg = )
04379 10D6           B8                   0080  mov	ax,#$80
04380 10D9           50                         push	ax
04381                                           ! Debug: func () void = outb+0 (used reg = )
04382 10DA           E8         F477            call	_outb
04383 10DD           83C4                   04  add	sp,*4
04384                                           !BCC_EOS
04385                                           ! 1225     if (max==0x0) keyboard_panic(40);
04386                       000010E0            .D7:
04387                                           ! Debug: list int = const $64 (used reg = )
04388 10E0           B8                   0064  mov	ax,*$64
04389 10E3           50                         push	ax
04390                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04391 10E4           E8         F457            call	_inb
04392 10E7           44                         inc	sp
04393 10E8           44                         inc	sp
04394                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04395 10E9           24                     02  and	al,*2
04396 10EB           84C0                       test	al,al
04397 10ED           74           0B            je  	.D9
04398                       000010EF            .DA:
04399                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04400 10EF           8B46         FE            mov	ax,-2[bp]
04401 10F2           48                         dec	ax
04402 10F3           8946         FE            mov	-2[bp],ax
04403                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04404 10F6           85C0                       test	ax,ax
04405 10F8           75           D8            jne	.D8
04406                       000010FA            .D9:
04407                       000010FA            .D6:
04408                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04409 10FA           8B46         FE            mov	ax,-2[bp]
04410 10FD           85C0                       test	ax,ax
04411 10FF           75           09            jne 	.DB
04412                       00001101            .DC:
04413                                           ! Debug: list int = const $28 (used reg = )
04414 1101           B8                   0028  mov	ax,*$28
04415 1104           50                         push	ax
04416                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04417 1105           E8         01AA            call	_keyboard_panic
04418 1108           44                         inc	sp
04419 1109           44                         inc	sp
04420                                           !BCC_EOS
04421                                           ! 1226     max=0xffff;
04422                       0000110A            .DB:
04423                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04424 110A           B8                   FFFF  mov	ax,#$FFFF
04425 110D           8946         FE            mov	-2[bp],ax
04426                                           !BCC_EOS
04427                                           ! 1227     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
04428 1110           EB           0E            jmp .DE
04429                       00001112            .DF:
04430                                           ! Debug: list int = const $41 (used reg = )
04431 1112           B8                   0041  mov	ax,*$41
04432 1115           50                         push	ax
04433                                           ! Debug: list int = const $80 (used reg = )
04434 1116           B8                   0080  mov	ax,#$80
04435 1119           50                         push	ax
04436                                           ! Debug: func () void = outb+0 (used reg = )
04437 111A           E8         F437            call	_outb
04438 111D           83C4                   04  add	sp,*4
04439                                           !BCC_EOS
04440                                           ! 1228     if (max==0x0) keyboard_panic(41);
04441                       00001120            .DE:
04442                                           ! Debug: list int = const $64 (used reg = )
04443 1120           B8                   0064  mov	ax,*$64
04444 1123           50                         push	ax
04445                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04446 1124           E8         F417            call	_inb
04447 1127           44                         inc	sp
04448 1128           44                         inc	sp
04449                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04450 1129           24                     01  and	al,*1
04451                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04452 112B           84C0                       test	al,al
04453 112D           75           0B            jne 	.E0
04454                       0000112F            .E1:
04455                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04456 112F           8B46         FE            mov	ax,-2[bp]
04457 1132           48                         dec	ax
04458 1133           8946         FE            mov	-2[bp],ax
04459                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04460 1136           85C0                       test	ax,ax
04461 1138           75           D8            jne	.DF
04462                       0000113A            .E0:
04463                       0000113A            .DD:
04464                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04465 113A           8B46         FE            mov	ax,-2[bp]
04466 113D           85C0                       test	ax,ax
04467 113F           75           09            jne 	.E2
04468                       00001141            .E3:
04469                                           ! Debug: list int = const $29 (used reg = )
04470 1141           B8                   0029  mov	ax,*$29
04471 1144           50                         push	ax
04472                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04473 1145           E8         016A            call	_keyboard_panic
04474 1148           44                         inc	sp
04475 1149           44                         inc	sp
04476                                           !BCC_EOS
04477                                           ! 1229     if ((inb(0x60) != 0xfa)) {
04478                       0000114A            .E2:
04479                                           ! Debug: list int = const $60 (used reg = )
04480 114A           B8                   0060  mov	ax,*$60
04481 114D           50                         push	ax
04482                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04483 114E           E8         F3ED            call	_inb
04484 1151           44                         inc	sp
04485 1152           44                         inc	sp
04486                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04487 1153           3C                     FA  cmp	al,#$FA
04488 1155           74           09            je  	.E4
04489                       00001157            .E5:
04490                                           ! 1230         keyboard_panic(995);
04491                                           ! Debug: list int = const $3E3 (used reg = )
04492 1157           B8                   03E3  mov	ax,#$3E3
04493 115A           50                         push	ax
04494                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04495 115B           E8         0154            call	_keyboard_panic
04496 115E           44                         inc	sp
04497 115F           44                         inc	sp
04498                                           !BCC_EOS
04499                                           ! 1231     }
04500                                           ! 1232     outb(0x64, 0x60);
04501                       00001160            .E4:
04502                                           ! Debug: list int = const $60 (used reg = )
04503 1160           B8                   0060  mov	ax,*$60
04504 1163           50                         push	ax
04505                                           ! Debug: list int = const $64 (used reg = )
04506 1164           B8                   0064  mov	ax,*$64
04507 1167           50                         push	ax
04508                                           ! Debug: func () void = outb+0 (used reg = )
04509 1168           E8         F3E9            call	_outb
04510 116B           83C4                   04  add	sp,*4
04511                                           !BCC_EOS
04512                                           ! 1233     max=0xffff;
04513                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04514 116E           B8                   FFFF  mov	ax,#$FFFF
04515 1171           8946         FE            mov	-2[bp],ax
04516                                           !BCC_EOS
04517                                           ! 1234     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
04518 1174           EB           0E            jmp .E7
04519                       00001176            .E8:
04520                                           ! Debug: list int = const $50 (used reg = )
04521 1176           B8                   0050  mov	ax,*$50
04522 1179           50                         push	ax
04523                                           ! Debug: list int = const $80 (used reg = )
04524 117A           B8                   0080  mov	ax,#$80
04525 117D           50                         push	ax
04526                                           ! Debug: func () void = outb+0 (used reg = )
04527 117E           E8         F3D3            call	_outb
04528 1181           83C4                   04  add	sp,*4
04529                                           !BCC_EOS
04530                                           ! 1235     if (max==0x0) keyboard_panic(50);
04531                       00001184            .E7:
04532                                           ! Debug: list int = const $64 (used reg = )
04533 1184           B8                   0064  mov	ax,*$64
04534 1187           50                         push	ax
04535                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04536 1188           E8         F3B3            call	_inb
04537 118B           44                         inc	sp
04538 118C           44                         inc	sp
04539                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04540 118D           24                     02  and	al,*2
04541 118F           84C0                       test	al,al
04542 1191           74           0B            je  	.E9
04543                       00001193            .EA:
04544                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04545 1193           8B46         FE            mov	ax,-2[bp]
04546 1196           48                         dec	ax
04547 1197           8946         FE            mov	-2[bp],ax
04548                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04549 119A           85C0                       test	ax,ax
04550 119C           75           D8            jne	.E8
04551                       0000119E            .E9:
04552                       0000119E            .E6:
04553                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04554 119E           8B46         FE            mov	ax,-2[bp]
04555 11A1           85C0                       test	ax,ax
04556 11A3           75           09            jne 	.EB
04557                       000011A5            .EC:
04558                                           ! Debug: list int = const $32 (used reg = )
04559 11A5           B8                   0032  mov	ax,*$32
04560 11A8           50                         push	ax
04561                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04562 11A9           E8         0106            call	_keyboard_panic
04563 11AC           44                         inc	sp
04564 11AD           44                         inc	sp
04565                                           !BCC_EOS
04566                                           ! 1236     outb(0x60, 0x61);
04567                       000011AE            .EB:
04568                                           ! Debug: list int = const $61 (used reg = )
04569 11AE           B8                   0061  mov	ax,*$61
04570 11B1           50                         push	ax
04571                                           ! Debug: list int = const $60 (used reg = )
04572 11B2           B8                   0060  mov	ax,*$60
04573 11B5           50                         push	ax
04574                                           ! Debug: func () void = outb+0 (used reg = )
04575 11B6           E8         F39B            call	_outb
04576 11B9           83C4                   04  add	sp,*4
04577                                           !BCC_EOS
04578                                           ! 1237     max=0xffff;
04579                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04580 11BC           B8                   FFFF  mov	ax,#$FFFF
04581 11BF           8946         FE            mov	-2[bp],ax
04582                                           !BCC_EOS
04583                                           ! 1238     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
04584 11C2           EB           0E            jmp .EE
04585                       000011C4            .EF:
04586                                           ! Debug: list int = const $60 (used reg = )
04587 11C4           B8                   0060  mov	ax,*$60
04588 11C7           50                         push	ax
04589                                           ! Debug: list int = const $80 (used reg = )
04590 11C8           B8                   0080  mov	ax,#$80
04591 11CB           50                         push	ax
04592                                           ! Debug: func () void = outb+0 (used reg = )
04593 11CC           E8         F385            call	_outb
04594 11CF           83C4                   04  add	sp,*4
04595                                           !BCC_EOS
04596                                           ! 1239     if (max==0x0) keyboard_panic(60);
04597                       000011D2            .EE:
04598                                           ! Debug: list int = const $64 (used reg = )
04599 11D2           B8                   0064  mov	ax,*$64
04600 11D5           50                         push	ax
04601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04602 11D6           E8         F365            call	_inb
04603 11D9           44                         inc	sp
04604 11DA           44                         inc	sp
04605                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04606 11DB           24                     02  and	al,*2
04607 11DD           84C0                       test	al,al
04608 11DF           74           0B            je  	.F0
04609                       000011E1            .F1:
04610                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04611 11E1           8B46         FE            mov	ax,-2[bp]
04612 11E4           48                         dec	ax
04613 11E5           8946         FE            mov	-2[bp],ax
04614                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04615 11E8           85C0                       test	ax,ax
04616 11EA           75           D8            jne	.EF
04617                       000011EC            .F0:
04618                       000011EC            .ED:
04619                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04620 11EC           8B46         FE            mov	ax,-2[bp]
04621 11EF           85C0                       test	ax,ax
04622 11F1           75           09            jne 	.F2
04623                       000011F3            .F3:
04624                                           ! Debug: list int = const $3C (used reg = )
04625 11F3           B8                   003C  mov	ax,*$3C
04626 11F6           50                         push	ax
04627                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04628 11F7           E8         00B8            call	_keyboard_panic
04629 11FA           44                         inc	sp
04630 11FB           44                         inc	sp
04631                                           !BCC_EOS
04632                                           ! 1240     outb(0x60, 0xf4);
04633                       000011FC            .F2:
04634                                           ! Debug: list int = const $F4 (used reg = )
04635 11FC           B8                   00F4  mov	ax,#$F4
04636 11FF           50                         push	ax
04637                                           ! Debug: list int = const $60 (used reg = )
04638 1200           B8                   0060  mov	ax,*$60
04639 1203           50                         push	ax
04640                                           ! Debug: func () void = outb+0 (used reg = )
04641 1204           E8         F34D            call	_outb
04642 1207           83C4                   04  add	sp,*4
04643                                           !BCC_EOS
04644                                           ! 1241     max=0xffff;
04645                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04646 120A           B8                   FFFF  mov	ax,#$FFFF
04647 120D           8946         FE            mov	-2[bp],ax
04648                                           !BCC_EOS
04649                                           ! 1242     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
04650 1210           EB           0E            jmp .F5
04651                       00001212            .F6:
04652                                           ! Debug: list int = const $70 (used reg = )
04653 1212           B8                   0070  mov	ax,*$70
04654 1215           50                         push	ax
04655                                           ! Debug: list int = const $80 (used reg = )
04656 1216           B8                   0080  mov	ax,#$80
04657 1219           50                         push	ax
04658                                           ! Debug: func () void = outb+0 (used reg = )
04659 121A           E8         F337            call	_outb
04660 121D           83C4                   04  add	sp,*4
04661                                           !BCC_EOS
04662                                           ! 1243     if (max==0x0) keyboard_panic(70);
04663                       00001220            .F5:
04664                                           ! Debug: list int = const $64 (used reg = )
04665 1220           B8                   0064  mov	ax,*$64
04666 1223           50                         push	ax
04667                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04668 1224           E8         F317            call	_inb
04669 1227           44                         inc	sp
04670 1228           44                         inc	sp
04671                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04672 1229           24                     02  and	al,*2
04673 122B           84C0                       test	al,al
04674 122D           74           0B            je  	.F7
04675                       0000122F            .F8:
04676                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04677 122F           8B46         FE            mov	ax,-2[bp]
04678 1232           48                         dec	ax
04679 1233           8946         FE            mov	-2[bp],ax
04680                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04681 1236           85C0                       test	ax,ax
04682 1238           75           D8            jne	.F6
04683                       0000123A            .F7:
04684                       0000123A            .F4:
04685                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04686 123A           8B46         FE            mov	ax,-2[bp]
04687 123D           85C0                       test	ax,ax
04688 123F           75           09            jne 	.F9
04689                       00001241            .FA:
04690                                           ! Debug: list int = const $46 (used reg = )
04691 1241           B8                   0046  mov	ax,*$46
04692 1244           50                         push	ax
04693                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04694 1245           E8         006A            call	_keyboard_panic
04695 1248           44                         inc	sp
04696 1249           44                         inc	sp
04697                                           !BCC_EOS
04698                                           ! 1244     max=0xffff;
04699                       0000124A            .F9:
04700                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04701 124A           B8                   FFFF  mov	ax,#$FFFF
04702 124D           8946         FE            mov	-2[bp],ax
04703                                           !BCC_EOS
04704                                           ! 1245     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
04705 1250           EB           0E            jmp .FC
04706                       00001252            .FD:
04707                                           ! Debug: list int = const $71 (used reg = )
04708 1252           B8                   0071  mov	ax,*$71
04709 1255           50                         push	ax
04710                                           ! Debug: list int = const $80 (used reg = )
04711 1256           B8                   0080  mov	ax,#$80
04712 1259           50                         push	ax
04713                                           ! Debug: func () void = outb+0 (used reg = )
04714 125A           E8         F2F7            call	_outb
04715 125D           83C4                   04  add	sp,*4
04716                                           !BCC_EOS
04717                                           ! 1246     if (max==0x0) keyboard_panic(70);
04718                       00001260            .FC:
04719                                           ! Debug: list int = const $64 (used reg = )
04720 1260           B8                   0064  mov	ax,*$64
04721 1263           50                         push	ax
04722                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04723 1264           E8         F2D7            call	_inb
04724 1267           44                         inc	sp
04725 1268           44                         inc	sp
04726                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04727 1269           24                     01  and	al,*1
04728                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04729 126B           84C0                       test	al,al
04730 126D           75           0B            jne 	.FE
04731                       0000126F            .FF:
04732                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04733 126F           8B46         FE            mov	ax,-2[bp]
04734 1272           48                         dec	ax
04735 1273           8946         FE            mov	-2[bp],ax
04736                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04737 1276           85C0                       test	ax,ax
04738 1278           75           D8            jne	.FD
04739                       0000127A            .FE:
04740                       0000127A            .FB:
04741                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04742 127A           8B46         FE            mov	ax,-2[bp]
04743 127D           85C0                       test	ax,ax
04744 127F           75           09            jne 	.100
04745                       00001281            .101:
04746                                           ! Debug: list int = const $46 (used reg = )
04747 1281           B8                   0046  mov	ax,*$46
04748 1284           50                         push	ax
04749                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04750 1285           E8         002A            call	_keyboard_panic
04751 1288           44                         inc	sp
04752 1289           44                         inc	sp
04753                                           !BCC_EOS
04754                                           ! 1247     if ((inb(0x60) != 0xfa)) {
04755                       0000128A            .100:
04756                                           ! Debug: list int = const $60 (used reg = )
04757 128A           B8                   0060  mov	ax,*$60
04758 128D           50                         push	ax
04759                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04760 128E           E8         F2AD            call	_inb
04761 1291           44                         inc	sp
04762 1292           44                         inc	sp
04763                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04764 1293           3C                     FA  cmp	al,#$FA
04765 1295           74           09            je  	.102
04766                       00001297            .103:
04767                                           ! 1248         keyboard_panic(996);
04768                                           ! Debug: list int = const $3E4 (used reg = )
04769 1297           B8                   03E4  mov	ax,#$3E4
04770 129A           50                         push	ax
04771                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04772 129B           E8         0014            call	_keyboard_panic
04773 129E           44                         inc	sp
04774 129F           44                         inc	sp
04775                                           !BCC_EOS
04776                                           ! 1249     }
04777                                           ! 1250     outb(0x80, 0x77);
04778                       000012A0            .102:
04779                                           ! Debug: list int = const $77 (used reg = )
04780 12A0           B8                   0077  mov	ax,*$77
04781 12A3           50                         push	ax
04782                                           ! Debug: list int = const $80 (used reg = )
04783 12A4           B8                   0080  mov	ax,#$80
04784 12A7           50                         push	ax
04785                                           ! Debug: func () void = outb+0 (used reg = )
04786 12A8           E8         F2A9            call	_outb
04787 12AB           83C4                   04  add	sp,*4
04788                                           !BCC_EOS
04789                                           ! 1251 }
04790 12AE           89EC                       mov	sp,bp
04791 12B0           5D                         pop	bp
04792 12B1           C3                         ret
04793                                           ! 1252   void
04794                                           ! 1253 keyboard_panic(status)
04795                                           ! 1254   Bit16u status;
04796                                           export	_keyboard_panic
04797                       000012B2            _keyboard_panic:
04798                                           !BCC_EOS
04799                                           ! 1255 {
04800                                           ! 1256   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04801 12B2           55                         push	bp
04802 12B3           89E5                       mov	bp,sp
04803                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04804 12B5           FF76         04            push	4[bp]
04805                                           ! Debug: list * char = .104+0 (used reg = )
04806 12B8           BB                   D643  mov	bx,#.104
04807 12BB           53                         push	bx
04808                                           ! Debug: list int = const 7 (used reg = )
04809 12BC           B8                   0007  mov	ax,*7
04810 12BF           50                         push	ax
04811                                           ! Debug: func () void = bios_printf+0 (used reg = )
04812 12C0           E8         F758            call	_bios_printf
04813 12C3           89EC                       mov	sp,bp
04814                                           !BCC_EOS
04815                                           ! 1257 }
04816 12C5           5D                         pop	bp
04817 12C6           C3                         ret
04818                                           ! 1258   void
04819                                           ! Register BX used in function keyboard_panic
04820                                           ! 1259 machine_reset()
04821                                           ! 1260 {
04822                                           export	_machine_reset
04823                       000012C7            _machine_reset:
04824                                           ! 1261 #asm
04825                                           !BCC_ASM
04826                                           ;we must check whether 0xFE is set or not
04827                                           ;if it is s3 resume, just jmp back to normal Post Entry
04828                                           ;below port io will prevent s3 resume
04829 12C7           B0                     0F    mov al, #0x0f
04830 12C9           E6                     70    out 0x70, al
04831 12CB           E4                     71    in al, 0x71
04832 12CD           3C                     FE    cmp al, #0xFE
04833 12CF   7503    E9         CD87              jz post
04834                                           ! 1270 endasm
04835                                           !BCC_ENDASM
04836                                           ! 1271   outb(0x64, 0x60);
04837 12D4           55                         push	bp
04838 12D5           89E5                       mov	bp,sp
04839                                           ! Debug: list int = const $60 (used reg = )
04840 12D7           B8                   0060  mov	ax,*$60
04841 12DA           50                         push	ax
04842                                           ! Debug: list int = const $64 (used reg = )
04843 12DB           B8                   0064  mov	ax,*$64
04844 12DE           50                         push	ax
04845                                           ! Debug: func () void = outb+0 (used reg = )
04846 12DF           E8         F272            call	_outb
04847 12E2           89EC                       mov	sp,bp
04848                                           !BCC_EOS
04849                                           ! 1272   outb(0x60, 0x14);
04850                                           ! Debug: list int = const $14 (used reg = )
04851 12E4           B8                   0014  mov	ax,*$14
04852 12E7           50                         push	ax
04853                                           ! Debug: list int = const $60 (used reg = )
04854 12E8           B8                   0060  mov	ax,*$60
04855 12EB           50                         push	ax
04856                                           ! Debug: func () void = outb+0 (used reg = )
04857 12EC           E8         F265            call	_outb
04858 12EF           89EC                       mov	sp,bp
04859                                           !BCC_EOS
04860                                           ! 1273   outb(0x64, 0xfe);
04861                                           ! Debug: list int = const $FE (used reg = )
04862 12F1           B8                   00FE  mov	ax,#$FE
04863 12F4           50                         push	ax
04864                                           ! Debug: list int = const $64 (used reg = )
04865 12F5           B8                   0064  mov	ax,*$64
04866 12F8           50                         push	ax
04867                                           ! Debug: func () void = outb+0 (used reg = )
04868 12F9           E8         F258            call	_outb
04869 12FC           89EC                       mov	sp,bp
04870                                           !BCC_EOS
04871                                           ! 1274   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
04872                                           ! Debug: list * char = .105+0 (used reg = )
04873 12FE           BB                   D627  mov	bx,#.105
04874 1301           53                         push	bx
04875                                           ! Debug: list int = const 7 (used reg = )
04876 1302           B8                   0007  mov	ax,*7
04877 1305           50                         push	ax
04878                                           ! Debug: func () void = bios_printf+0 (used reg = )
04879 1306           E8         F712            call	_bios_printf
04880 1309           89EC                       mov	sp,bp
04881                                           !BCC_EOS
04882                                           ! 1275 }
04883 130B           5D                         pop	bp
04884 130C           C3                         ret
04885                                           ! 1276   void
04886                                           ! Register BX used in function machine_reset
04887                                           ! 1277 clobber_entry_point()
04888                                           ! 1278 {
04889                                           export	_clobber_entry_point
04890                       0000130D            _clobber_entry_point:
04891                                           ! 1279     write_word(0xffff, 0x0001, machine_reset);
04892 130D           55                         push	bp
04893 130E           89E5                       mov	bp,sp
04894                                           ! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
04895                                           ! Debug: list * () void = machine_reset+0 (used reg = )
04896 1310           BB                   12C7  mov	bx,#_machine_reset
04897 1313           53                         push	bx
04898                                           ! Debug: list int = const 1 (used reg = )
04899 1314           B8                   0001  mov	ax,*1
04900 1317           50                         push	ax
04901                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04902 1318           B8                   FFFF  mov	ax,#$FFFF
04903 131B           50                         push	ax
04904                                           ! Debug: func () void = write_word+0 (used reg = )
04905 131C           E8         F313            call	_write_word
04906 131F           89EC                       mov	sp,bp
04907                                           !BCC_EOS
04908                                           ! 1280 }
04909 1321           5D                         pop	bp
04910 1322           C3                         ret
04911                                           ! 1281   void
04912                                           ! Register BX used in function clobber_entry_point
04913                                           ! 1282 shutdown_status_panic(status)
04914                                           ! 1283   Bit16u status;
04915                                           export	_shutdown_status_panic
04916                       00001323            _shutdown_status_panic:
04917                                           !BCC_EOS
04918                                           ! 1284 {
04919                                           ! 1285   bios_printf((2 | 4 | 1), "Unimplemented shutdown statu
04920 1323           55                         push	bp
04921 1324           89E5                       mov	bp,sp
04922                                           ! 1285 s: %02x\n",(Bit8u)status);
04923                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04924 1326           8A46         04            mov	al,4[bp]
04925 1329           30E4                       xor	ah,ah
04926 132B           50                         push	ax
04927                                           ! Debug: list * char = .106+0 (used reg = )
04928 132C           BB                   D602  mov	bx,#.106
04929 132F           53                         push	bx
04930                                           ! Debug: list int = const 7 (used reg = )
04931 1330           B8                   0007  mov	ax,*7
04932 1333           50                         push	ax
04933                                           ! Debug: func () void = bios_printf+0 (used reg = )
04934 1334           E8         F6E4            call	_bios_printf
04935 1337           89EC                       mov	sp,bp
04936                                           !BCC_EOS
04937                                           ! 1286 }
04938 1339           5D                         pop	bp
04939 133A           C3                         ret
04940                                           ! 1287 void s3_resume_panic()
04941                                           ! Register BX used in function shutdown_status_panic
04942                                           ! 1288 {
04943                                           export	_s3_resume_panic
04944                       0000133B            _s3_resume_panic:
04945                                           ! 1289   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04946 133B           55                         push	bp
04947 133C           89E5                       mov	bp,sp
04948                                           ! Debug: list * char = .107+0 (used reg = )
04949 133E           BB                   D5E8  mov	bx,#.107
04950 1341           53                         push	bx
04951                                           ! Debug: list int = const 7 (used reg = )
04952 1342           B8                   0007  mov	ax,*7
04953 1345           50                         push	ax
04954                                           ! Debug: func () void = bios_printf+0 (used reg = )
04955 1346           E8         F6D2            call	_bios_printf
04956 1349           89EC                       mov	sp,bp
04957                                           !BCC_EOS
04958                                           ! 1290 }
04959 134B           5D                         pop	bp
04960 134C           C3                         ret
04961                                           ! 1291 void
04962                                           ! Register BX used in function s3_resume_panic
04963                                           ! 1292 print_bios_banner()
04964                                           ! 1293 {
04965                                           export	_print_bios_banner
04966                       0000134D            _print_bios_banner:
04967                                           ! 1294   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "06/23/99", bios_cvs_version_string);
04968 134D           55                         push	bp
04969 134E           89E5                       mov	bp,sp
04970                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
04971 1350           BB                   0194  mov	bx,#_bios_cvs_version_string
04972 1353           53                         push	bx
04973                                           ! Debug: list * char = .109+0 (used reg = )
04974 1354           BB                   D5BB  mov	bx,#.109
04975 1357           53                         push	bx
04976                                           ! Debug: list * char = .108+0 (used reg = )
04977 1358           BB                   D5C4  mov	bx,#.108
04978 135B           53                         push	bx
04979                                           ! Debug: list int = const 2 (used reg = )
04980 135C           B8                   0002  mov	ax,*2
04981 135F           50                         push	ax
04982                                           ! Debug: func () void = bios_printf+0 (used reg = )
04983 1360           E8         F6B8            call	_bios_printf
04984 1363           89EC                       mov	sp,bp
04985                                           !BCC_EOS
04986                                           ! 1295   bios_printf(2, "apmbios " "pcibios " "eltorito " "PMM " "\n\n");
04987                                           ! Debug: list * char = .10A+0 (used reg = )
04988 1365           BB                   D59B  mov	bx,#.10A
04989 1368           53                         push	bx
04990                                           ! Debug: list int = const 2 (used reg = )
04991 1369           B8                   0002  mov	ax,*2
04992 136C           50                         push	ax
04993                                           ! Debug: func () void = bios_printf+0 (used reg = )
04994 136D           E8         F6AB            call	_bios_printf
04995 1370           89EC                       mov	sp,bp
04996                                           !BCC_EOS
04997                                           ! 1296 }
04998 1372           5D                         pop	bp
04999 1373           C3                         ret
05000                                           ! 1297 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
05001                                           ! Register BX used in function print_bios_banner
05002                                           
05003                       00001374            _drivetypes:
05004                       00001374            .10B:
05005 1374                        00            .byte	0
05006 1375                  00000009            .blkb	9
05007                       0000137E            .10C:
05008 137E                        46            .ascii	"Floppy"
05009 1384                        00            .byte	0
05010 1385                  00000003            .blkb	3
05011                       00001388            .10D:
05012 1388                        48            .ascii	"Hard Disk"
05013 1391                        00            .byte	0
05014                       00001392            .10E:
05015 1392                        43            .ascii	"CD-Rom"
05016 1398                        00            .byte	0
05017 1399                  00000003            .blkb	3
05018                       0000139C            .10F:
05019 139C                        4E            .ascii	"Network"
05020 13A3                        00            .byte	0
05021 13A4                  00000002            .blkb	2
05022                                           !BCC_EOS
05023                                           ! 1298 static void
05024                                           ! 1299 init_boot_vectors()
05025                                           ! 1300 {
05026                                           
05027                       000013A6            _init_boot_vectors:
05028                                           ! 1301   ipl_entry_t e;
05029                                           !BCC_EOS
05030                                           ! 1302   Bit16u count = 0;
05031 13A6           55                         push	bp
05032 13A7           89E5                       mov	bp,sp
05033 13A9           83C4                   EE  add	sp,*-$12
05034                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
05035 13AC           31C0                       xor	ax,ax
05036 13AE           8946         EE            mov	-$12[bp],ax
05037                                           !BCC_EOS
05038                                           ! 1303   Bit16u ss = get_SS();
05039 13B1           4C                         dec	sp
05040 13B2           4C                         dec	sp
05041                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05042 13B3           E8         F297            call	_get_SS
05043                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
05044 13B6           8946         EC            mov	-$14[bp],ax
05045                                           !BCC_EOS
05046                                           ! 1304   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05047 13B9           4C                         dec	sp
05048 13BA           4C                         dec	sp
05049                                           ! Debug: list int = const $E (used reg = )
05050 13BB           B8                   000E  mov	ax,*$E
05051 13BE           50                         push	ax
05052                                           ! Debug: list int = const $40 (used reg = )
05053 13BF           B8                   0040  mov	ax,*$40
05054 13C2           50                         push	ax
05055                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05056 13C3           E8         F241            call	_read_word
05057 13C6           83C4                   04  add	sp,*4
05058                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$18-$18] (used reg = )
05059 13C9           8946         EA            mov	-$16[bp],ax
05060                                           !BCC_EOS
05061                                           ! 1305   memsetb(ebda_seg, 0x0300, 0, 0xff);
05062                                           ! Debug: list int = const $FF (used reg = )
05063 13CC           B8                   00FF  mov	ax,#$FF
05064 13CF           50                         push	ax
05065                                           ! Debug: list int = const 0 (used reg = )
05066 13D0           31C0                       xor	ax,ax
05067 13D2           50                         push	ax
05068                                           ! Debug: list int = const $300 (used reg = )
05069 13D3           B8                   0300  mov	ax,#$300
05070 13D6           50                         push	ax
05071                                           ! Debug: list unsigned short ebda_seg = [S+$1E-$18] (used reg = )
05072 13D7           FF76         EA            push	-$16[bp]
05073                                           ! Debug: func () void = memsetb+0 (used reg = )
05074 13DA           E8         EC23            call	_memsetb
05075 13DD           83C4                   08  add	sp,*8
05076                                           !BCC_EOS
05077                                           ! 1306   write_word(ebda_seg, 0x0384, 0xFFFF);
05078                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05079 13E0           B8                   FFFF  mov	ax,#$FFFF
05080 13E3           50                         push	ax
05081                                           ! Debug: list int = const $384 (used reg = )
05082 13E4           B8                   0384  mov	ax,#$384
05083 13E7           50                         push	ax
05084                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05085 13E8           FF76         EA            push	-$16[bp]
05086                                           ! Debug: func () void = write_word+0 (used reg = )
05087 13EB           E8         F244            call	_write_word
05088 13EE           83C4                   06  add	sp,*6
05089                                           !BCC_EOS
05090                                           ! 1307   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05091                                           ! Debug: eq int = const 1 to unsigned short e = [S+$18-$12] (used reg = )
05092 13F1           B8                   0001  mov	ax,*1
05093 13F4           8946         F0            mov	-$10[bp],ax
05094                                           !BCC_EOS
05095                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05096 13F7           31C0                       xor	ax,ax
05097 13F9           8946         F2            mov	-$E[bp],ax
05098                                           !BCC_EOS
05099                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05100 13FC           31C0                       xor	ax,ax
05101 13FE           31DB                       xor	bx,bx
05102 1400           8946         F4            mov	-$C[bp],ax
05103 1403           895E         F6            mov	-$A[bp],bx
05104                                           !BCC_EOS
05105                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05106 1406           31C0                       xor	ax,ax
05107 1408           31DB                       xor	bx,bx
05108 140A           8946         F8            mov	-8[bp],ax
05109 140D           895E         FA            mov	-6[bp],bx
05110                                           !BCC_EOS
05111                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05112 1410           31C0                       xor	ax,ax
05113 1412           31DB                       xor	bx,bx
05114 1414           8946         FC            mov	-4[bp],ax
05115 1417           895E         FE            mov	-2[bp],bx
05116                                           !BCC_EOS
05117                                           ! 1308   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05118                                           ! Debug: list int = const $10 (used reg = )
05119 141A           B8                   0010  mov	ax,*$10
05120 141D           50                         push	ax
05121                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05122 141E           8D5E         F0            lea	bx,-$10[bp]
05123 1421           53                         push	bx
05124                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05125 1422           FF76         EC            push	-$14[bp]
05126                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05127 1425           8B46         EE            mov	ax,-$12[bp]
05128 1428           B1                     04  mov	cl,*4
05129 142A           D3E0                       shl	ax,cl
05130                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05131                                           ! Debug: expression subtree swapping
05132                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05133 142C           05                   0300  add	ax,#$300
05134 142F           50                         push	ax
05135                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05136 1430           FF76         EA            push	-$16[bp]
05137                                           ! Debug: func () void = memcpyb+0 (used reg = )
05138 1433           E8         EBEE            call	_memcpyb
05139 1436           83C4                   0A  add	sp,*$A
05140                                           !BCC_EOS
05141                                           ! 1309   count++;
05142                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05143 1439           8B46         EE            mov	ax,-$12[bp]
05144 143C           40                         inc	ax
05145 143D           8946         EE            mov	-$12[bp],ax
05146                                           !BCC_EOS
05147                                           ! 1310   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05148                                           ! Debug: eq int = const 2 to unsigned short e = [S+$18-$12] (used reg = )
05149 1440           B8                   0002  mov	ax,*2
05150 1443           8946         F0            mov	-$10[bp],ax
05151                                           !BCC_EOS
05152                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05153 1446           31C0                       xor	ax,ax
05154 1448           8946         F2            mov	-$E[bp],ax
05155                                           !BCC_EOS
05156                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05157 144B           31C0                       xor	ax,ax
05158 144D           31DB                       xor	bx,bx
05159 144F           8946         F4            mov	-$C[bp],ax
05160 1452           895E         F6            mov	-$A[bp],bx
05161                                           !BCC_EOS
05162                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05163 1455           31C0                       xor	ax,ax
05164 1457           31DB                       xor	bx,bx
05165 1459           8946         F8            mov	-8[bp],ax
05166 145C           895E         FA            mov	-6[bp],bx
05167                                           !BCC_EOS
05168                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05169 145F           31C0                       xor	ax,ax
05170 1461           31DB                       xor	bx,bx
05171 1463           8946         FC            mov	-4[bp],ax
05172 1466           895E         FE            mov	-2[bp],bx
05173                                           !BCC_EOS
05174                                           ! 1311   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05175                                           ! Debug: list int = const $10 (used reg = )
05176 1469           B8                   0010  mov	ax,*$10
05177 146C           50                         push	ax
05178                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05179 146D           8D5E         F0            lea	bx,-$10[bp]
05180 1470           53                         push	bx
05181                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05182 1471           FF76         EC            push	-$14[bp]
05183                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05184 1474           8B46         EE            mov	ax,-$12[bp]
05185 1477           B1                     04  mov	cl,*4
05186 1479           D3E0                       shl	ax,cl
05187                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05188                                           ! Debug: expression subtree swapping
05189                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05190 147B           05                   0300  add	ax,#$300
05191 147E           50                         push	ax
05192                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05193 147F           FF76         EA            push	-$16[bp]
05194                                           ! Debug: func () void = memcpyb+0 (used reg = )
05195 1482           E8         EB9F            call	_memcpyb
05196 1485           83C4                   0A  add	sp,*$A
05197                                           !BCC_EOS
05198                                           ! 1312   count++;
05199                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05200 1488           8B46         EE            mov	ax,-$12[bp]
05201 148B           40                         inc	ax
05202 148C           8946         EE            mov	-$12[bp],ax
05203                                           !BCC_EOS
05204                                           ! 1313   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05205                                           ! Debug: eq int = const 3 to unsigned short e = [S+$18-$12] (used reg = )
05206 148F           B8                   0003  mov	ax,*3
05207 1492           8946         F0            mov	-$10[bp],ax
05208                                           !BCC_EOS
05209                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05210 1495           31C0                       xor	ax,ax
05211 1497           8946         F2            mov	-$E[bp],ax
05212                                           !BCC_EOS
05213                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05214 149A           31C0                       xor	ax,ax
05215 149C           31DB                       xor	bx,bx
05216 149E           8946         F4            mov	-$C[bp],ax
05217 14A1           895E         F6            mov	-$A[bp],bx
05218                                           !BCC_EOS
05219                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05220 14A4           31C0                       xor	ax,ax
05221 14A6           31DB                       xor	bx,bx
05222 14A8           8946         F8            mov	-8[bp],ax
05223 14AB           895E         FA            mov	-6[bp],bx
05224                                           !BCC_EOS
05225                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05226 14AE           31C0                       xor	ax,ax
05227 14B0           31DB                       xor	bx,bx
05228 14B2           8946         FC            mov	-4[bp],ax
05229 14B5           895E         FE            mov	-2[bp],bx
05230                                           !BCC_EOS
05231                                           ! 1314   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05232                                           ! Debug: list int = const $10 (used reg = )
05233 14B8           B8                   0010  mov	ax,*$10
05234 14BB           50                         push	ax
05235                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05236 14BC           8D5E         F0            lea	bx,-$10[bp]
05237 14BF           53                         push	bx
05238                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05239 14C0           FF76         EC            push	-$14[bp]
05240                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05241 14C3           8B46         EE            mov	ax,-$12[bp]
05242 14C6           B1                     04  mov	cl,*4
05243 14C8           D3E0                       shl	ax,cl
05244                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05245                                           ! Debug: expression subtree swapping
05246                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05247 14CA           05                   0300  add	ax,#$300
05248 14CD           50                         push	ax
05249                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05250 14CE           FF76         EA            push	-$16[bp]
05251                                           ! Debug: func () void = memcpyb+0 (used reg = )
05252 14D1           E8         EB50            call	_memcpyb
05253 14D4           83C4                   0A  add	sp,*$A
05254                                           !BCC_EOS
05255                                           ! 1315   count++;
05256                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05257 14D7           8B46         EE            mov	ax,-$12[bp]
05258 14DA           40                         inc	ax
05259 14DB           8946         EE            mov	-$12[bp],ax
05260                                           !BCC_EOS
05261                                           ! 1316   write_word(ebda_seg, 0x0380, count);
05262                                           ! Debug: list unsigned short count = [S+$18-$14] (used reg = )
05263 14DE           FF76         EE            push	-$12[bp]
05264                                           ! Debug: list int = const $380 (used reg = )
05265 14E1           B8                   0380  mov	ax,#$380
05266 14E4           50                         push	ax
05267                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05268 14E5           FF76         EA            push	-$16[bp]
05269                                           ! Debug: func () void = write_word+0 (used reg = )
05270 14E8           E8         F147            call	_write_word
05271 14EB           83C4                   06  add	sp,*6
05272                                           !BCC_EOS
05273                                           ! 1317   write_word(ebda_seg, 0x0382, 0xffff);
05274                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05275 14EE           B8                   FFFF  mov	ax,#$FFFF
05276 14F1           50                         push	ax
05277                                           ! Debug: list int = const $382 (used reg = )
05278 14F2           B8                   0382  mov	ax,#$382
05279 14F5           50                         push	ax
05280                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05281 14F6           FF76         EA            push	-$16[bp]
05282                                           ! Debug: func () void = write_word+0 (used reg = )
05283 14F9           E8         F136            call	_write_word
05284 14FC           83C4                   06  add	sp,*6
05285                                           !BCC_EOS
05286                                           ! 1318 }
05287 14FF           89EC                       mov	sp,bp
05288 1501           5D                         pop	bp
05289 1502           C3                         ret
05290                                           ! 1319 static Bit8u
05291                                           ! Register BX used in function init_boot_vectors
05292                                           ! 1320 get_boot_vector(i, e)
05293                                           ! 1321 Bit16u i; ipl_entry_t *e;
05294                       00001503            _get_boot_vector:
05295                                           !BCC_EOS
05296                                           !BCC_EOS
05297                                           ! 1322 {
05298                                           ! 1323   Bit16u count;
05299                                           !BCC_EOS
05300                                           ! 1324   Bit16u ss = get_SS();
05301 1503           55                         push	bp
05302 1504           89E5                       mov	bp,sp
05303 1506           83C4                   FC  add	sp,*-4
05304                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05305 1509           E8         F141            call	_get_SS
05306                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05307 150C           8946         FC            mov	-4[bp],ax
05308                                           !BCC_EOS
05309                                           ! 1325   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05310 150F           4C                         dec	sp
05311 1510           4C                         dec	sp
05312                                           ! Debug: list int = const $E (used reg = )
05313 1511           B8                   000E  mov	ax,*$E
05314 1514           50                         push	ax
05315                                           ! Debug: list int = const $40 (used reg = )
05316 1515           B8                   0040  mov	ax,*$40
05317 1518           50                         push	ax
05318                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05319 1519           E8         F0EB            call	_read_word
05320 151C           83C4                   04  add	sp,*4
05321                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
05322 151F           8946         FA            mov	-6[bp],ax
05323                                           !BCC_EOS
05324                                           ! 1326   count = read_word(ebda_seg, 0x0380);
05325                                           ! Debug: list int = const $380 (used reg = )
05326 1522           B8                   0380  mov	ax,#$380
05327 1525           50                         push	ax
05328                                           ! Debug: list unsigned short ebda_seg = [S+$A-8] (used reg = )
05329 1526           FF76         FA            push	-6[bp]
05330                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05331 1529           E8         F0DB            call	_read_word
05332 152C           83C4                   04  add	sp,*4
05333                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+8-4] (used reg = )
05334 152F           8946         FE            mov	-2[bp],ax
05335                                           !BCC_EOS
05336                                           ! 1327   if (i >= count) return 0;
05337                                           ! Debug: ge unsigned short count = [S+8-4] to unsigned short i = [S+8+2] (used reg = )
05338 1532           8B46         04            mov	ax,4[bp]
05339 1535           3B46         FE            cmp	ax,-2[bp]
05340 1538           72           06            jb  	.110
05341                       0000153A            .111:
05342 153A           30C0                       xor	al,al
05343 153C           89EC                       mov	sp,bp
05344 153E           5D                         pop	bp
05345 153F           C3                         ret
05346                                           !BCC_EOS
05347                                           ! 1328   memcpyb(ss, e, ebda_seg, 0x0300 + i * sizeof (*e), sizeof (*e));
05348                       00001540            .110:
05349                                           ! Debug: list int = const $10 (used reg = )
05350 1540           B8                   0010  mov	ax,*$10
05351 1543           50                         push	ax
05352                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05353 1544           8B46         04            mov	ax,4[bp]
05354 1547           B1                     04  mov	cl,*4
05355 1549           D3E0                       shl	ax,cl
05356                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05357                                           ! Debug: expression subtree swapping
05358                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05359 154B           05                   0300  add	ax,#$300
05360 154E           50                         push	ax
05361                                           ! Debug: list unsigned short ebda_seg = [S+$C-8] (used reg = )
05362 154F           FF76         FA            push	-6[bp]
05363                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05364 1552           FF76         06            push	6[bp]
05365                                           ! Debug: list unsigned short ss = [S+$10-6] (used reg = )
05366 1555           FF76         FC            push	-4[bp]
05367                                           ! Debug: func () void = memcpyb+0 (used reg = )
05368 1558           E8         EAC9            call	_memcpyb
05369 155B           83C4                   0A  add	sp,*$A
05370                                           !BCC_EOS
05371                                           ! 1329   return 1;
05372 155E           B0                     01  mov	al,*1
05373 1560           89EC                       mov	sp,bp
05374 1562           5D                         pop	bp
05375 1563           C3                         ret
05376                                           !BCC_EOS
05377                                           ! 1330 }
05378                                           ! 1331   void
05379                                           ! 1332 interactive_bootkey()
05380                                           ! 1333 {
05381                                           export	_interactive_bootkey
05382                       00001564            _interactive_bootkey:
05383                                           ! 1334   ipl_entry_t e;
05384                                           !BCC_EOS
05385                                           ! 1335   Bit16u count;
05386                                           !BCC_EOS
05387                                           ! 1336   char description[33];
05388                                           !BCC_EOS
05389                                           ! 1337   Bit8u scan_code;
05390                                           !BCC_EOS
05391                                           ! 1338   Bit8u i;
05392                                           !BCC_EOS
05393                                           ! 1339   Bit16u ss = get_SS();
05394 1564           55                         push	bp
05395 1565           89E5                       mov	bp,sp
05396 1567           83C4                   C8  add	sp,*-$38
05397                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05398 156A           E8         F0E0            call	_get_SS
05399                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05400 156D           8946         C8            mov	-$38[bp],ax
05401                                           !BCC_EOS
05402                                           ! 1340   Bit16u valid_choice = 0;
05403 1570           4C                         dec	sp
05404 1571           4C                         dec	sp
05405                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05406 1572           31C0                       xor	ax,ax
05407 1574           8946         C6            mov	-$3A[bp],ax
05408                                           !BCC_EOS
05409                                           ! 1341   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05410 1577           4C                         dec	sp
05411 1578           4C                         dec	sp
05412                                           ! Debug: list int = const $E (used reg = )
05413 1579           B8                   000E  mov	ax,*$E
05414 157C           50                         push	ax
05415                                           ! Debug: list int = const $40 (used reg = )
05416 157D           B8                   0040  mov	ax,*$40
05417 1580           50                         push	ax
05418                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05419 1581           E8         F083            call	_read_word
05420 1584           83C4                   04  add	sp,*4
05421                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$3E-$3E] (used reg = )
05422 1587           8946         C4            mov	-$3C[bp],ax
05423                                           !BCC_EOS
05424                                           ! 1342   bios_printf(2, "\n\nPress F12 for boot menu.\n\n");
05425                                           ! Debug: list * char = .112+0 (used reg = )
05426 158A           BB                   D57E  mov	bx,#.112
05427 158D           53                         push	bx
05428                                           ! Debug: list int = const 2 (used reg = )
05429 158E           B8                   0002  mov	ax,*2
05430 1591           50                         push	ax
05431                                           ! Debug: func () void = bios_printf+0 (used reg = )
05432 1592           E8         F486            call	_bios_printf
05433 1595           83C4                   04  add	sp,*4
05434                                           !BCC_EOS
05435                                           ! 1343   while (check_for_keystroke())
05436                                           ! 1344   {
05437 1598           E9         01B4            br 	.114
05438                       0000159B            .115:
05439                                           ! 1345     scan_code = get_keystroke();
05440                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05441 159B           E8         F444            call	_get_keystroke
05442                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05443 159E           8846         CC            mov	-$34[bp],al
05444                                           !BCC_EOS
05445                                           ! 1346     if (scan_code != 0x86)
05446                                           ! Debug: ne int = const $86 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05447 15A1           8A46         CC            mov	al,-$34[bp]
05448 15A4           3C                     86  cmp	al,#$86
05449 15A6           74           03            je  	.116
05450                       000015A8            .117:
05451                                           ! 1347       continue;
05452 15A8           E9         01A4            br 	.114
05453                                           !BCC_EOS
05454                                           ! 1348     while (check_for_keystroke())
05455                       000015AB            .116:
05456                                           ! 1349       get_keystroke();
05457 15AB           EB           03            jmp .119
05458                       000015AD            .11A:
05459                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05460 15AD           E8         F432            call	_get_keystroke
05461                                           !BCC_EOS
05462                                           ! 1350     bios_printf(2, "Select boot device:\n\n");
05463                       000015B0            .119:
05464                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05465 15B0           E8         F421            call	_check_for_keystroke
05466 15B3           84C0                       test	al,al
05467 15B5           75           F6            jne	.11A
05468                       000015B7            .11B:
05469                       000015B7            .118:
05470                                           ! Debug: list * char = .11C+0 (used reg = )
05471 15B7           BB                   D568  mov	bx,#.11C
05472 15BA           53                         push	bx
05473                                           ! Debug: list int = const 2 (used reg = )
05474 15BB           B8                   0002  mov	ax,*2
05475 15BE           50                         push	ax
05476                                           ! Debug: func () void = bios_printf+0 (used reg = )
05477 15BF           E8         F459            call	_bios_printf
05478 15C2           83C4                   04  add	sp,*4
05479                                           !BCC_EOS
05480                                           ! 1351     count = read_word(ebda_seg, 0x0380);
05481                                           ! Debug: list int = const $380 (used reg = )
05482 15C5           B8                   0380  mov	ax,#$380
05483 15C8           50                         push	ax
05484                                           ! Debug: list unsigned short ebda_seg = [S+$40-$3E] (used reg = )
05485 15C9           FF76         C4            push	-$3C[bp]
05486                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05487 15CC           E8         F038            call	_read_word
05488 15CF           83C4                   04  add	sp,*4
05489                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3E-$14] (used reg = )
05490 15D2           8946         EE            mov	-$12[bp],ax
05491                                           !BCC_EOS
05492                                           ! 1352     for (i = 0; i < count; i++)
05493                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3E-$37] (used reg = )
05494 15D5           30C0                       xor	al,al
05495 15D7           8846         CB            mov	-$35[bp],al
05496                                           !BCC_EOS
05497                                           !BCC_EOS
05498                                           ! 1353     {
05499 15DA           E9         00FE            br 	.11F
05500                       000015DD            .120:
05501                                           ! 1354       memcpyb(ss, &
05502                                           ! 1354 e, ebda_seg, 0x0300 + i * sizeof (e), sizeof (e));
05503                                           ! Debug: list int = const $10 (used reg = )
05504 15DD           B8                   0010  mov	ax,*$10
05505 15E0           50                         push	ax
05506                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05507 15E1           8A46         CB            mov	al,-$35[bp]
05508 15E4           30E4                       xor	ah,ah
05509 15E6           B1                     04  mov	cl,*4
05510 15E8           D3E0                       shl	ax,cl
05511                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05512                                           ! Debug: expression subtree swapping
05513                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05514 15EA           05                   0300  add	ax,#$300
05515 15ED           50                         push	ax
05516                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05517 15EE           FF76         C4            push	-$3C[bp]
05518                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05519 15F1           8D5E         F0            lea	bx,-$10[bp]
05520 15F4           53                         push	bx
05521                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05522 15F5           FF76         C8            push	-$38[bp]
05523                                           ! Debug: func () void = memcpyb+0 (used reg = )
05524 15F8           E8         EA29            call	_memcpyb
05525 15FB           83C4                   0A  add	sp,*$A
05526                                           !BCC_EOS
05527                                           ! 1355       bios_printf(2, "%d. ", i+1);
05528                                           ! Debug: add int = const 1 to unsigned char i = [S+$3E-$37] (used reg = )
05529 15FE           8A46         CB            mov	al,-$35[bp]
05530 1601           30E4                       xor	ah,ah
05531                                           ! Debug: list unsigned int = ax+1 (used reg = )
05532 1603           40                         inc	ax
05533 1604           50                         push	ax
05534                                           ! Debug: list * char = .121+0 (used reg = )
05535 1605           BB                   D563  mov	bx,#.121
05536 1608           53                         push	bx
05537                                           ! Debug: list int = const 2 (used reg = )
05538 1609           B8                   0002  mov	ax,*2
05539 160C           50                         push	ax
05540                                           ! Debug: func () void = bios_printf+0 (used reg = )
05541 160D           E8         F40B            call	_bios_printf
05542 1610           83C4                   06  add	sp,*6
05543                                           !BCC_EOS
05544                                           ! 1356       switch(e.type)
05545 1613           8B46         F0            mov	ax,-$10[bp]
05546                                           ! 1357       {
05547 1616           E9         009F            br 	.124
05548                                           ! 1358         case 0x01:
05549                                           ! 1359         case 0x02:
05550                       00001619            .125:
05551                                           ! 1360         case 0x03:
05552                       00001619            .126:
05553                                           ! 1361           bios_printf(2, "%s\n", drivetypes[e.type]);
05554                       00001619            .127:
05555                                           ! Debug: ptradd unsigned short e = [S+$3E-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05556 1619           8B5E         F0            mov	bx,-$10[bp]
05557 161C           89DA                       mov	dx,bx
05558 161E           D1E3                       shl	bx,*1
05559 1620           D1E3                       shl	bx,*1
05560 1622           01D3                       add	bx,dx
05561 1624           D1E3                       shl	bx,*1
05562                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05563                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05564 1626           81C3                 1374  add	bx,#_drivetypes
05565 162A           53                         push	bx
05566                                           ! Debug: list * char = .128+0 (used reg = )
05567 162B           BB                   D55F  mov	bx,#.128
05568 162E           53                         push	bx
05569                                           ! Debug: list int = const 2 (used reg = )
05570 162F           B8                   0002  mov	ax,*2
05571 1632           50                         push	ax
05572                                           ! Debug: func () void = bios_printf+0 (used reg = )
05573 1633           E8         F3E5            call	_bios_printf
05574 1636           83C4                   06  add	sp,*6
05575                                           !BCC_EOS
05576                                           ! 1362           break;
05577 1639           E9         0098            br 	.122
05578                                           !BCC_EOS
05579                                           ! 1363         case 0x80:
05580                                           ! 1364           bios_printf(2, "%s", drivetypes[4]);
05581                       0000163C            .129:
05582                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05583 163C           BB                   139C  mov	bx,#_drivetypes+$28
05584 163F           53                         push	bx
05585                                           ! Debug: list * char = .12A+0 (used reg = )
05586 1640           BB                   D55C  mov	bx,#.12A
05587 1643           53                         push	bx
05588                                           ! Debug: list int = const 2 (used reg = )
05589 1644           B8                   0002  mov	ax,*2
05590 1647           50                         push	ax
05591                                           ! Debug: func () void = bios_printf+0 (used reg = )
05592 1648           E8         F3D0            call	_bios_printf
05593 164B           83C4                   06  add	sp,*6
05594                                           !BCC_EOS
05595                                           ! 1365           if (e.description != 0)
05596                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3E-$A] (used reg = )
05597                                           ! Debug: expression subtree swapping
05598 164E           31C0                       xor	ax,ax
05599 1650           31DB                       xor	bx,bx
05600 1652           53                         push	bx
05601 1653           50                         push	ax
05602 1654           8B46         F8            mov	ax,-8[bp]
05603 1657           8B5E         FA            mov	bx,-6[bp]
05604 165A           8D7E         C0            lea	di,-2+..FFFF[bp]
05605 165D           E8         EA6B            call	lcmpul
05606 1660           8D66         C4            lea	sp,2+..FFFF[bp]
05607 1663           74           41            je  	.12B
05608                       00001665            .12C:
05609                                           ! 1366           {
05610                                           ! 1367             memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
05611                                           ! Debug: list int = const $20 (used reg = )
05612 1665           B8                   0020  mov	ax,*$20
05613 1668           50                         push	ax
05614                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$40-$A] (used reg = )
05615                                           ! Debug: expression subtree swapping
05616 1669           B8                   FFFF  mov	ax,#$FFFF
05617 166C           31DB                       xor	bx,bx
05618 166E           8D7E         F8            lea	di,-8[bp]
05619 1671           E8         EA47            call	landul
05620                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05621                                           ! Debug: list unsigned short = ax+0 (used reg = )
05622 1674           50                         push	ax
05623                                           ! Debug: sr int = const $10 to unsigned long e = [S+$42-$A] (used reg = )
05624 1675           8B46         F8            mov	ax,-8[bp]
05625 1678           8B5E         FA            mov	bx,-6[bp]
05626 167B           93                         xchg	bx,ax
05627 167C           31DB                       xor	bx,bx
05628                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05629                                           ! Debug: list unsigned short = ax+0 (used reg = )
05630 167E           50                         push	ax
05631                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05632 167F           8D5E         CD            lea	bx,-$33[bp]
05633 1682           53                         push	bx
05634                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05635 1683           FF76         C8            push	-$38[bp]
05636                                           ! Debug: func () void = memcpyb+0 (used reg = )
05637 1686           E8         E99B            call	_memcpyb
05638 1689           83C4                   0A  add	sp,*$A
05639                                           !BCC_EOS
05640                                           ! 1368             description[32] = 0;
05641                                           ! Debug: eq int = const 0 to char description = [S+$3E-$15] (used reg = )
05642 168C           30C0                       xor	al,al
05643 168E           8846         ED            mov	-$13[bp],al
05644                                           !BCC_EOS
05645                                           ! 1369             bios_printf(2, " [%S]", ss, description);
05646                                           ! Debug: list * char description = S+$3E-$35 (used reg = )
05647 1691           8D5E         CD            lea	bx,-$33[bp]
05648 1694           53                         push	bx
05649                                           ! Debug: list unsigned short ss = [S+$40-$3A] (used reg = )
05650 1695           FF76         C8            push	-$38[bp]
05651                                           ! Debug: list * char = .12D+0 (used reg = )
05652 1698           BB                   D556  mov	bx,#.12D
05653 169B           53                         push	bx
05654                                           ! Debug: list int = const 2 (used reg = )
05655 169C           B8                   0002  mov	ax,*2
05656 169F           50                         push	ax
05657                                           ! Debug: func () void = bios_printf+0 (used reg = )
05658 16A0           E8         F378            call	_bios_printf
05659 16A3           83C4                   08  add	sp,*8
05660                                           !BCC_EOS
05661                                           ! 1370          }
05662                                           ! 1371          bios_printf(2, "\n");
05663                       000016A6            .12B:
05664                                           ! Debug: list * char = .12E+0 (used reg = )
05665 16A6           BB                   D554  mov	bx,#.12E
05666 16A9           53                         push	bx
05667                                           ! Debug: list int = const 2 (used reg = )
05668 16AA           B8                   0002  mov	ax,*2
05669 16AD           50                         push	ax
05670                                           ! Debug: func () void = bios_printf+0 (used reg = )
05671 16AE           E8         F36A            call	_bios_printf
05672 16B1           83C4                   04  add	sp,*4
05673                                           !BCC_EOS
05674                                           ! 1372          break;
05675 16B4           EB           1E            jmp .122
05676                                           !BCC_EOS
05677                                           ! 1373       }
05678                                           ! 1374     }
05679 16B6           EB           1C            jmp .122
05680                       000016B8            .124:
05681 16B8           2D                   0001  sub	ax,*1
05682 16BB         0F84         FF5A            beq 	.125
05683 16BF           2D                   0001  sub	ax,*1
05684 16C2         0F84         FF53            beq 	.126
05685 16C6           2D                   0001  sub	ax,*1
05686 16C9         0F84         FF4C            beq 	.127
05687 16CD           2D                   007D  sub	ax,*$7D
05688 16D0         0F84         FF68            beq 	.129
05689                       000016D4            .122:
05690                       FFFFFFC2            ..FFFF	=	-$3E
05691                                           ! 1375     count++;
05692                       000016D4            .11E:
05693                                           ! Debug: postinc unsigned char i = [S+$3E-$37] (used reg = )
05694 16D4           8A46         CB            mov	al,-$35[bp]
05695 16D7           40                         inc	ax
05696 16D8           8846         CB            mov	-$35[bp],al
05697                       000016DB            .11F:
05698                                           ! Debug: lt unsigned short count = [S+$3E-$14] to unsigned char i = [S+$3E-$37] (used reg = )
05699 16DB           8A46         CB            mov	al,-$35[bp]
05700 16DE           30E4                       xor	ah,ah
05701 16E0           3B46         EE            cmp	ax,-$12[bp]
05702 16E3         0F82         FEF6            blo 	.120
05703                       000016E7            .12F:
05704                       000016E7            .11D:
05705                                           ! Debug: postinc unsigned short count = [S+$3E-$14] (used reg = )
05706 16E7           8B46         EE            mov	ax,-$12[bp]
05707 16EA           40                         inc	ax
05708 16EB           8946         EE            mov	-$12[bp],ax
05709                                           !BCC_EOS
05710                                           ! 1376     while (!valid_choice) {
05711 16EE           EB           48            jmp .131
05712                       000016F0            .132:
05713                                           ! 1377       scan_code = get_keystroke();
05714                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05715 16F0           E8         F2EF            call	_get_keystroke
05716                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05717 16F3           8846         CC            mov	-$34[bp],al
05718                                           !BCC_EOS
05719                                           ! 1378       if (scan_code == 0x01 || scan_code == 0x58)
05720                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05721 16F6           8A46         CC            mov	al,-$34[bp]
05722 16F9           3C                     01  cmp	al,*1
05723 16FB           74           07            je  	.134
05724                       000016FD            .135:
05725                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05726 16FD           8A46         CC            mov	al,-$34[bp]
05727 1700           3C                     58  cmp	al,*$58
05728 1702           75           08            jne 	.133
05729                       00001704            .134:
05730                                           ! 1379       {
05731                                           ! 1380         valid_choice = 1;
05732                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05733 1704           B8                   0001  mov	ax,*1
05734 1707           8946         C6            mov	-$3A[bp],ax
05735                                           !BCC_EOS
05736                                           ! 1381       }
05737                                           ! 1382       else if (scan_code <= count)
05738 170A           EB           2C            jmp .136
05739                       0000170C            .133:
05740                                           ! Debug: le unsigned short count = [S+$3E-$14] to unsigned char scan_code = [S+$3E-$36] (used reg = )
05741 170C           8A46         CC            mov	al,-$34[bp]
05742 170F           30E4                       xor	ah,ah
05743 1711           3B46         EE            cmp	ax,-$12[bp]
05744 1714           77           22            ja  	.137
05745                       00001716            .138:
05746                                           ! 1383       {
05747                                           ! 1384         valid_choice = 1;
05748                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05749 1716           B8                   0001  mov	ax,*1
05750 1719           8946         C6            mov	-$3A[bp],ax
05751                                           !BCC_EOS
05752                                           ! 1385         scan_code -= 1;
05753                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05754 171C           8A46         CC            mov	al,-$34[bp]
05755 171F           30E4                       xor	ah,ah
05756 1721           48                         dec	ax
05757 1722           8846         CC            mov	-$34[bp],al
05758                                           !BCC_EOS
05759                                           ! 1386         write_word(ebda_seg, 0x0384, scan_code);
05760                                           ! Debug: list unsigned char scan_code = [S+$3E-$36] (used reg = )
05761 1725           8A46         CC            mov	al,-$34[bp]
05762 1728           30E4                       xor	ah,ah
05763 172A           50                         push	ax
05764                                           ! Debug: list int = const $384 (used reg = )
05765 172B           B8                   0384  mov	ax,#$384
05766 172E           50                         push	ax
05767                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05768 172F           FF76         C4            push	-$3C[bp]
05769                                           ! Debug: func () void = write_word+0 (used reg = )
05770 1732           E8         EEFD            call	_write_word
05771 1735           83C4                   06  add	sp,*6
05772                                           !BCC_EOS
05773                                           ! 1387       }
05774                                           ! 1388     }
05775                       00001738            .137:
05776                       00001738            .136:
05777                                           ! 1389     bios_printf(2, "\n");
05778                       00001738            .131:
05779 1738           8B46         C6            mov	ax,-$3A[bp]
05780 173B           85C0                       test	ax,ax
05781 173D           74           B1            je 	.132
05782                       0000173F            .139:
05783                       0000173F            .130:
05784                                           ! Debug: list * char = .13A+0 (used reg = )
05785 173F           BB                   D552  mov	bx,#.13A
05786 1742           53                         push	bx
05787                                           ! Debug: list int = const 2 (used reg = )
05788 1743           B8                   0002  mov	ax,*2
05789 1746           50                         push	ax
05790                                           ! Debug: func () void = bios_printf+0 (used reg = )
05791 1747           E8         F2D1            call	_bios_printf
05792 174A           83C4                   04  add	sp,*4
05793                                           !BCC_EOS
05794                                           ! 1390     break;
05795 174D           EB           09            jmp .113
05796                                           !BCC_EOS
05797                                           ! 1391   }
05798                                           ! 1392 }
05799                       0000174F            .114:
05800                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05801 174F           E8         F282            call	_check_for_keystroke
05802 1752           84C0                       test	al,al
05803 1754         0F85         FE43            bne 	.115
05804                       00001758            .13B:
05805                       00001758            .113:
05806 1758           89EC                       mov	sp,bp
05807 175A           5D                         pop	bp
05808 175B           C3                         ret
05809                                           ! 1393 void
05810                                           ! Register BX used in function interactive_bootkey
05811                                           ! 1394 print_boot_device(type, desc)
05812                                           ! 1395   Bit16u type; Bit32u desc;
05813                                           export	_print_boot_device
05814                       0000175C            _print_boot_device:
05815                                           !BCC_EOS
05816                                           !BCC_EOS
05817                                           ! 1396 {
05818                                           ! 1397   char description[33];
05819                                           !BCC_EOS
05820                                           ! 1398   Bit16u ss = get_SS();
05821 175C           55                         push	bp
05822 175D           89E5                       mov	bp,sp
05823 175F           83C4                   DC  add	sp,*-$24
05824                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05825 1762           E8         EEE8            call	_get_SS
05826                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$26-$26] (used reg = )
05827 1765           8946         DC            mov	-$24[bp],ax
05828                                           !BCC_EOS
05829                                           ! 1399   if (type == 0x80) type = 0x4;
05830                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$26+2] (used reg = )
05831 1768           8B46         04            mov	ax,4[bp]
05832 176B           3D                   0080  cmp	ax,#$80
05833 176E           75           06            jne 	.13C
05834                       00001770            .13D:
05835                                           ! Debug: eq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05836 1770           B8                   0004  mov	ax,*4
05837 1773           8946         04            mov	4[bp],ax
05838                                           !BCC_EOS
05839                                           ! 1400   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05840                       00001776            .13C:
05841                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$26+2] (used reg = )
05842 1776           8B46         04            mov	ax,4[bp]
05843 1779           85C0                       test	ax,ax
05844 177B           74           08            je  	.13F
05845                       0000177D            .140:
05846                                           ! Debug: gt int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05847 177D           8B46         04            mov	ax,4[bp]
05848 1780           3D                   0004  cmp	ax,*4
05849 1783           76           0E            jbe 	.13E
05850                       00001785            .13F:
05851                                           ! Debug: list * char = .141+0 (used reg = )
05852 1785           BB                   D542  mov	bx,#.141
05853 1788           53                         push	bx
05854                                           ! Debug: list int = const 7 (used reg = )
05855 1789           B8                   0007  mov	ax,*7
05856 178C           50                         push	ax
05857                                           ! Debug: func () void = bios_printf+0 (used reg = )
05858 178D           E8         F28B            call	_bios_printf
05859 1790           83C4                   04  add	sp,*4
05860                                           !BCC_EOS
05861                                           ! 1401   bios_printf(2, "Booting from %s", drivetypes[type]);
05862                       00001793            .13E:
05863                                           ! Debug: ptradd unsigned short type = [S+$26+2] to [5] [$A] char = drivetypes+0 (used reg = )
05864 1793           8B5E         04            mov	bx,4[bp]
05865 1796           89DA                       mov	dx,bx
05866 1798           D1E3                       shl	bx,*1
05867 179A           D1E3                       shl	bx,*1
05868 179C           01D3                       add	bx,dx
05869 179E           D1E3                       shl	bx,*1
05870                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05871                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05872 17A0           81C3                 1374  add	bx,#_drivetypes
05873 17A4           53                         push	bx
05874                                           ! Debug: list * char = .142+0 (used reg = )
05875 17A5           BB                   D532  mov	bx,#.142
05876 17A8           53                         push	bx
05877                                           ! Debug: list int = const 2 (used reg = )
05878 17A9           B8                   0002  mov	ax,*2
05879 17AC           50                         push	ax
05880                                           ! Debug: func () void = bios_printf+0 (used reg = )
05881 17AD           E8         F26B            call	_bios_printf
05882 17B0           83C4                   06  add	sp,*6
05883                                           !BCC_EOS
05884                                           ! 1402   if (type == 4 && desc != 0) {
05885                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05886 17B3           8B46         04            mov	ax,4[bp]
05887 17B6           3D                   0004  cmp	ax,*4
05888 17B9           75           58            jne 	.143
05889                       000017BB            .145:
05890                                           ! Debug: ne unsigned long = const 0 to unsigned long desc = [S+$26+4] (used reg = )
05891                                           ! Debug: expression subtree swapping
05892 17BB           31C0                       xor	ax,ax
05893 17BD           31DB                       xor	bx,bx
05894 17BF           53                         push	bx
05895 17C0           50                         push	ax
05896 17C1           8B46         06            mov	ax,6[bp]
05897 17C4           8B5E         08            mov	bx,8[bp]
05898 17C7           8D7E         D8            lea	di,-$28[bp]
05899 17CA           E8         E8FE            call	lcmpul
05900 17CD           8D66         DC            lea	sp,-$24[bp]
05901 17D0           74           41            je  	.143
05902                       000017D2            .144:
05903                                           ! 1403     memcpyb(ss, &description, (Bit16u)(desc >> 16), (Bit16u)(desc & 0xffff), 32);
05904                                           ! Debug: list int = const $20 (used reg = )
05905 17D2           B8                   0020  mov	ax,*$20
05906 17D5           50                         push	ax
05907                                           ! Debug: and unsigned long = const $FFFF to unsigned long desc = [S+$28+4] (used reg = )
05908                                           ! Debug: expression subtree swapping
05909 17D6           B8                   FFFF  mov	ax,#$FFFF
05910 17D9           31DB                       xor	bx,bx
05911 17DB           8D7E         06            lea	di,6[bp]
05912 17DE           E8         E8DA            call	landul
05913                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05914                                           ! Debug: list unsigned short = ax+0 (used reg = )
05915 17E1           50                         push	ax
05916                                           ! Debug: sr int = const $10 to unsigned long desc = [S+$2A+4] (used reg = )
05917 17E2           8B46         06            mov	ax,6[bp]
05918 17E5           8B5E         08            mov	bx,8[bp]
05919 17E8           93                         xchg	bx,ax
05920 17E9           31DB                       xor	bx,bx
05921                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05922                                           ! Debug: list unsigned short = ax+0 (used reg = )
05923 17EB           50                         push	ax
05924                                           ! Debug: list * [$21] char description = S+$2C-$23 (used reg = )
05925 17EC           8D5E         DF            lea	bx,-$21[bp]
05926 17EF           53                         push	bx
05927                                           ! Debug: list unsigned short ss = [S+$2E-$26] (used reg = )
05928 17F0           FF76         DC            push	-$24[bp]
05929                                           ! Debug: func () void = memcpyb+0 (used reg = )
05930 17F3           E8         E82E            call	_memcpyb
05931 17F6           83C4                   0A  add	sp,*$A
05932                                           !BCC_EOS
05933                                           ! 1404     description[32] = 0;
05934                                           ! Debug: eq int = const 0 to char description = [S+$26-3] (used reg = )
05935 17F9           30C0                       xor	al,al
05936 17FB           8846         FF            mov	-1[bp],al
05937                                           !BCC_EOS
05938                                           ! 1405     bios_printf(2, " [%S]", ss, description);
05939                                           ! Debug: list * char description = S+$26-$23 (used reg = )
05940 17FE           8D5E         DF            lea	bx,-$21[bp]
05941 1801           53                         push	bx
05942                                           ! Debug: list unsigned short ss = [S+$28-$26] (used reg = )
05943 1802           FF76         DC            push	-$24[bp]
05944                                           ! Debug: list * char = .146+0 (used reg = )
05945 1805           BB                   D52C  mov	bx,#.146
05946 1808           53                         push	bx
05947                                           ! Debug: list int = const 2 (used reg = )
05948 1809           B8                   0002  mov	ax,*2
05949 180C           50                         push	ax
05950                                           ! Debug: func () void = bios_printf+0 (used reg = )
05951 180D           E8         F20B            call	_bios_printf
05952 1810           83C4                   08  add	sp,*8
05953                                           !BCC_EOS
05954                                           ! 1406   }
05955                                           ! 1407   bios_printf(2, "...\n");
05956                       00001813            .143:
05957                                           ! Debug: list * char = .147+0 (used reg = )
05958 1813           BB                   D527  mov	bx,#.147
05959 1816           53                         push	bx
05960                                           ! Debug: list int = const 2 (used reg = )
05961 1817           B8                   0002  mov	ax,*2
05962 181A           50                         push	ax
05963                                           ! Debug: func () void = bios_printf+0 (used reg = )
05964 181B           E8         F1FD            call	_bios_printf
05965 181E           83C4                   04  add	sp,*4
05966                                           !BCC_EOS
05967                                           ! 1408 }
05968 1821           89EC                       mov	sp,bp
05969 1823           5D                         pop	bp
05970 1824           C3                         ret
05971                                           ! 1409   void
05972                                           ! Register BX used in function print_boot_device
05973                                           ! 1410 print_boot_failure(type, reason)
05974                                           ! 1411   Bit16u type; Bit8u reason;
05975                                           export	_print_boot_failure
05976                       00001825            _print_boot_failure:
05977                                           !BCC_EOS
05978                                           !BCC_EOS
05979                                           ! 1412 {
05980                                           ! 1413   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05981 1825           55                         push	bp
05982 1826           89E5                       mov	bp,sp
05983                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05984 1828           8B46         04            mov	ax,4[bp]
05985 182B           85C0                       test	ax,ax
05986 182D           74           08            je  	.149
05987                       0000182F            .14A:
05988                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05989 182F           8B46         04            mov	ax,4[bp]
05990 1832           3D                   0003  cmp	ax,*3
05991 1835           76           0D            jbe 	.148
05992                       00001837            .149:
05993                                           ! Debug: list * char = .14B+0 (used reg = )
05994 1837           BB                   D517  mov	bx,#.14B
05995 183A           53                         push	bx
05996                                           ! Debug: list int = const 7 (used reg = )
05997 183B           B8                   0007  mov	ax,*7
05998 183E           50                         push	ax
05999                                           ! Debug: func () void = bios_printf+0 (used reg = )
06000 183F           E8         F1D9            call	_bios_printf
06001 1842           89EC                       mov	sp,bp
06002                                           !BCC_EOS
06003                                           ! 1414   bios_printf(2, "Boot from %s failed", drivetypes[type]);
06004                       00001844            .148:
06005                                           ! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
06006 1844           8B5E         04            mov	bx,4[bp]
06007 1847           89DA                       mov	dx,bx
06008 1849           D1E3                       shl	bx,*1
06009 184B           D1E3                       shl	bx,*1
06010 184D           01D3                       add	bx,dx
06011 184F           D1E3                       shl	bx,*1
06012                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
06013                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
06014 1851           81C3                 1374  add	bx,#_drivetypes
06015 1855           53                         push	bx
06016                                           ! Debug: list * char = .14C+0 (used reg = )
06017 1856           BB                   D503  mov	bx,#.14C
06018 1859           53                         push	bx
06019                                           ! Debug: list int = const 2 (used reg = )
06020 185A           B8                   0002  mov	ax,*2
06021 185D           50                         push	ax
06022                                           ! Debug: func () void = bios_printf+0 (used reg = )
06023 185E           E8         F1BA            call	_bios_printf
06024 1861           89EC                       mov	sp,bp
06025                                           !BCC_EOS
06026                                           ! 1415   if (type < 4) {
06027                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
06028 1863           8B46         04            mov	ax,4[bp]
06029 1866           3D                   0004  cmp	ax,*4
06030 1869           73           23            jae 	.14D
06031                       0000186B            .14E:
06032                                           ! 1416     if (reason==0)
06033                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
06034 186B           8A46         06            mov	al,6[bp]
06035 186E           84C0                       test	al,al
06036 1870           75           0F            jne 	.14F
06037                       00001872            .150:
06038                                           ! 1417       bios_printf(2, ": not a bootable disk");
06039                                           ! Debug: list * char = .151+0 (used reg = )
06040 1872           BB                   D4ED  mov	bx,#.151
06041 1875           53                         push	bx
06042                                           ! Debug: list int = const 2 (used reg = )
06043 1876           B8                   0002  mov	ax,*2
06044 1879           50                         push	ax
06045                                           ! Debug: func () void = bios_printf+0 (used reg = )
06046 187A           E8         F19E            call	_bios_printf
06047 187D           89EC                       mov	sp,bp
06048                                           !BCC_EOS
06049                                           ! 1418     else
06050                                           ! 1419       bios_printf(2, ": could not read the boot disk");
06051 187F           EB           0D            jmp .152
06052                       00001881            .14F:
06053                                           ! Debug: list * char = .153+0 (used reg = )
06054 1881           BB                   D4CE  mov	bx,#.153
06055 1884           53                         push	bx
06056                                           ! Debug: list int = const 2 (used reg = )
06057 1885           B8                   0002  mov	ax,*2
06058 1888           50                         push	ax
06059                                           ! Debug: func () void = bios_printf+0 (used reg = )
06060 1889           E8         F18F            call	_bios_printf
06061 188C           89EC                       mov	sp,bp
06062                                           !BCC_EOS
06063                                           ! 1420   }
06064                       0000188E            .152:
06065                                           ! 1421   bios_printf(2, "\n\n");
06066                       0000188E            .14D:
06067                                           ! Debug: list * char = .154+0 (used reg = )
06068 188E           BB                   D4CB  mov	bx,#.154
06069 1891           53                         push	bx
06070                                           ! Debug: list int = const 2 (used reg = )
06071 1892           B8                   0002  mov	ax,*2
06072 1895           50                         push	ax
06073                                           ! Debug: func () void = bios_printf+0 (used reg = )
06074 1896           E8         F182            call	_bios_printf
06075 1899           89EC                       mov	sp,bp
06076                                           !BCC_EOS
06077                                           ! 1422 }
06078 189B           5D                         pop	bp
06079 189C           C3                         ret
06080                                           ! 1423   void
06081                                           ! Register BX used in function print_boot_failure
06082                                           ! 1424 print_cdromboot_failure( code )
06083                                           ! 1425   Bit16u code;
06084                                           export	_print_cdromboot_failure
06085                       0000189D            _print_cdromboot_failure:
06086                                           !BCC_EOS
06087                                           ! 1426 {
06088                                           ! 1427   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
06089 189D           55                         push	bp
06090 189E           89E5                       mov	bp,sp
06091                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
06092 18A0           FF76         04            push	4[bp]
06093                                           ! Debug: list * char = .155+0 (used reg = )
06094 18A3           BB                   D4AB  mov	bx,#.155
06095 18A6           53                         push	bx
06096                                           ! Debug: list int = const 6 (used reg = )
06097 18A7           B8                   0006  mov	ax,*6
06098 18AA           50                         push	ax
06099                                           ! Debug: func () void = bios_printf+0 (used reg = )
06100 18AB           E8         F16D            call	_bios_printf
06101 18AE           89EC                       mov	sp,bp
06102                                           !BCC_EOS
06103                                           ! 1428   return;
06104 18B0           5D                         pop	bp
06105 18B1           C3                         ret
06106                                           !BCC_EOS
06107                                           ! 1429 }
06108                                           ! 1430 void
06109                                           ! Register BX used in function print_cdromboot_failure
06110                                           ! 1431 nmi_handler_msg()
06111                                           ! 1432 {
06112                                           export	_nmi_handler_msg
06113                       000018B2            _nmi_handler_msg:
06114                                           ! 1433   bios_printf((2 | 4
06115 18B2           55                         push	bp
06116 18B3           89E5                       mov	bp,sp
06117                                           ! 1433  | 1), "NMI Handler called\n");
06118                                           ! Debug: list * char = .156+0 (used reg = )
06119 18B5           BB                   D497  mov	bx,#.156
06120 18B8           53                         push	bx
06121                                           ! Debug: list int = const 7 (used reg = )
06122 18B9           B8                   0007  mov	ax,*7
06123 18BC           50                         push	ax
06124                                           ! Debug: func () void = bios_printf+0 (used reg = )
06125 18BD           E8         F15B            call	_bios_printf
06126 18C0           89EC                       mov	sp,bp
06127                                           !BCC_EOS
06128                                           ! 1434 }
06129 18C2           5D                         pop	bp
06130 18C3           C3                         ret
06131                                           ! 1435 void
06132                                           ! Register BX used in function nmi_handler_msg
06133                                           ! 1436 int18_panic_msg()
06134                                           ! 1437 {
06135                                           export	_int18_panic_msg
06136                       000018C4            _int18_panic_msg:
06137                                           ! 1438   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
06138 18C4           55                         push	bp
06139 18C5           89E5                       mov	bp,sp
06140                                           ! Debug: list * char = .157+0 (used reg = )
06141 18C7           BB                   D482  mov	bx,#.157
06142 18CA           53                         push	bx
06143                                           ! Debug: list int = const 7 (used reg = )
06144 18CB           B8                   0007  mov	ax,*7
06145 18CE           50                         push	ax
06146                                           ! Debug: func () void = bios_printf+0 (used reg = )
06147 18CF           E8         F149            call	_bios_printf
06148 18D2           89EC                       mov	sp,bp
06149                                           !BCC_EOS
06150                                           ! 1439 }
06151 18D4           5D                         pop	bp
06152 18D5           C3                         ret
06153                                           ! 1440 void
06154                                           ! Register BX used in function int18_panic_msg
06155                                           ! 1441 log_bios_start()
06156                                           ! 1442 {
06157                                           export	_log_bios_start
06158                       000018D6            _log_bios_start:
06159                                           ! 1443   ;
06160 18D6           55                         push	bp
06161 18D7           89E5                       mov	bp,sp
06162                                           !BCC_EOS
06163                                           ! 1444 }
06164 18D9           5D                         pop	bp
06165 18DA           C3                         ret
06166                                           ! 1445   bx_bool
06167                                           ! 1446 set_enable_a20(val)
06168                                           ! 1447   bx_bool val;
06169                                           export	_set_enable_a20
06170                       000018DB            _set_enable_a20:
06171                                           !BCC_EOS
06172                                           ! 1448 {
06173                                           ! 1449   Bit8u oldval;
06174                                           !BCC_EOS
06175                                           ! 1450   oldval = inb(0x92);
06176 18DB           55                         push	bp
06177 18DC           89E5                       mov	bp,sp
06178 18DE           4C                         dec	sp
06179 18DF           4C                         dec	sp
06180                                           ! Debug: list int = const $92 (used reg = )
06181 18E0           B8                   0092  mov	ax,#$92
06182 18E3           50                         push	ax
06183                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06184 18E4           E8         EC57            call	_inb
06185 18E7           44                         inc	sp
06186 18E8           44                         inc	sp
06187                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
06188 18E9           8846         FF            mov	-1[bp],al
06189                                           !BCC_EOS
06190                                           ! 1451   if (val)
06191 18EC           8B46         04            mov	ax,4[bp]
06192 18EF           85C0                       test	ax,ax
06193 18F1           74           14            je  	.158
06194                       000018F3            .159:
06195                                           ! 1452     outb(0x92, oldval | 0x02);
06196                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06197 18F3           8A46         FF            mov	al,-1[bp]
06198 18F6           0C                     02  or	al,*2
06199                                           ! Debug: list unsigned char = al+0 (used reg = )
06200 18F8           30E4                       xor	ah,ah
06201 18FA           50                         push	ax
06202                                           ! Debug: list int = const $92 (used reg = )
06203 18FB           B8                   0092  mov	ax,#$92
06204 18FE           50                         push	ax
06205                                           ! Debug: func () void = outb+0 (used reg = )
06206 18FF           E8         EC52            call	_outb
06207 1902           83C4                   04  add	sp,*4
06208                                           !BCC_EOS
06209                                           ! 1453   else
06210                                           ! 1454     outb(0x92, oldval & 0xfd);
06211 1905           EB           12            jmp .15A
06212                       00001907            .158:
06213                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06214 1907           8A46         FF            mov	al,-1[bp]
06215 190A           24                     FD  and	al,#$FD
06216                                           ! Debug: list unsigned char = al+0 (used reg = )
06217 190C           30E4                       xor	ah,ah
06218 190E           50                         push	ax
06219                                           ! Debug: list int = const $92 (used reg = )
06220 190F           B8                   0092  mov	ax,#$92
06221 1912           50                         push	ax
06222                                           ! Debug: func () void = outb+0 (used reg = )
06223 1913           E8         EC3E            call	_outb
06224 1916           83C4                   04  add	sp,*4
06225                                           !BCC_EOS
06226                                           ! 1455   return((oldval & 0x02) != 0);
06227                       00001919            .15A:
06228                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06229 1919           8A46         FF            mov	al,-1[bp]
06230 191C           24                     02  and	al,*2
06231                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06232 191E           84C0                       test	al,al
06233 1920           74           04            je 	.15B
06234 1922           B0                     01  mov	al,*1
06235 1924           EB           02            jmp	.15C
06236                       00001926            .15B:
06237 1926           30C0                       xor	al,al
06238                       00001928            .15C:
06239                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06240 1928           30E4                       xor	ah,ah
06241 192A           89EC                       mov	sp,bp
06242 192C           5D                         pop	bp
06243 192D           C3                         ret
06244                                           !BCC_EOS
06245                                           ! 1456 }
06246                                           ! 1457   void
06247                                           ! 1458 debugger_on()
06248                                           ! 1459 {
06249                                           export	_debugger_on
06250                       0000192E            _debugger_on:
06251                                           ! 1460   outb(0xfedc, 0x01);
06252 192E           55                         push	bp
06253 192F           89E5                       mov	bp,sp
06254                                           ! Debug: list int = const 1 (used reg = )
06255 1931           B8                   0001  mov	ax,*1
06256 1934           50                         push	ax
06257                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06258 1935           B8                   FEDC  mov	ax,#$FEDC
06259 1938           50                         push	ax
06260                                           ! Debug: func () void = outb+0 (used reg = )
06261 1939           E8         EC18            call	_outb
06262 193C           89EC                       mov	sp,bp
06263                                           !BCC_EOS
06264                                           ! 1461 }
06265 193E           5D                         pop	bp
06266 193F           C3                         ret
06267                                           ! 1462   void
06268                                           ! 1463 debugger_off()
06269                                           ! 1464 {
06270                                           export	_debugger_off
06271                       00001940            _debugger_off:
06272                                           ! 1465   outb(0xfedc, 0x00);
06273 1940           55                         push	bp
06274 1941           89E5                       mov	bp,sp
06275                                           ! Debug: list int = const 0 (used reg = )
06276 1943           31C0                       xor	ax,ax
06277 1945           50                         push	ax
06278                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06279 1946           B8                   FEDC  mov	ax,#$FEDC
06280 1949           50                         push	ax
06281                                           ! Debug: func () void = outb+0 (used reg = )
06282 194A           E8         EC07            call	_outb
06283 194D           89EC                       mov	sp,bp
06284                                           !BCC_EOS
06285                                           ! 1466 }
06286 194F           5D                         pop	bp
06287 1950           C3                         ret
06288                                           ! 1467 int
06289                                           ! 1468 s3_resume()
06290                                           ! 1469 {
06291                                           export	_s3_resume
06292                       00001951            _s3_resume:
06293                                           ! 1470     Bit32u s3_wakeup_vector;
06294                                           !BCC_EOS
06295                                           ! 1471     Bit8u s3_resume_flag;
06296                                           !BCC_EOS
06297                                           ! 1472     s3_resume_flag = read_byte(0x40, 0xb0);
06298 1951           55                         push	bp
06299 1952           89E5                       mov	bp,sp
06300 1954           83C4                   FA  add	sp,*-6
06301                                           ! Debug: list int = const $B0 (used reg = )
06302 1957           B8                   00B0  mov	ax,#$B0
06303 195A           50                         push	ax
06304                                           ! Debug: list int = const $40 (used reg = )
06305 195B           B8                   0040  mov	ax,*$40
06306 195E           50                         push	ax
06307                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
06308 195F           E8         EC92            call	_read_byte
06309 1962           83C4                   04  add	sp,*4
06310                                           ! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06311 1965           8846         FB            mov	-5[bp],al
06312                                           !BCC_EOS
06313                                           ! 1473     s3_wakeup_vector = get_s3_waking_vector();
06314                                           ! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
06315 1968           E8         9670            call	_get_s3_waking_vector
06316 196B           89D3                       mov	bx,dx
06317                                           ! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06318 196D           8946         FC            mov	-4[bp],ax
06319 1970           895E         FE            mov	-2[bp],bx
06320                                           !BCC_EOS
06321                                           ! 1474     ;
06322                                           !BCC_EOS
06323                                           ! 1475     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06324                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06325 1973           8A46         FB            mov	al,-5[bp]
06326 1976           3C                     FE  cmp	al,#$FE
06327 1978           75           0B            jne 	.15E
06328                       0000197A            .15F:
06329 197A           8B46         FC            mov	ax,-4[bp]
06330 197D           8B5E         FE            mov	bx,-2[bp]
06331 1980           E8         E791            call	ltstl
06332 1983           75           06            jne 	.15D
06333                       00001985            .15E:
06334                                           ! 1476      return 0;
06335 1985           31C0                       xor	ax,ax
06336 1987           89EC                       mov	sp,bp
06337 1989           5D                         pop	bp
06338 198A           C3                         ret
06339                                           !BCC_EOS
06340                                           ! 1477     write_byte(0x40, 0xb0, 0);
06341                       0000198B            .15D:
06342                                           ! Debug: list int = const 0 (used reg = )
06343 198B           31C0                       xor	ax,ax
06344 198D           50                         push	ax
06345                                           ! Debug: list int = const $B0 (used reg = )
06346 198E           B8                   00B0  mov	ax,#$B0
06347 1991           50                         push	ax
06348                                           ! Debug: list int = const $40 (used reg = )
06349 1992           B8                   0040  mov	ax,*$40
06350 1995           50                         push	ax
06351                                           ! Debug: func () void = write_byte+0 (used reg = )
06352 1996           E8         EC81            call	_write_byte
06353 1999           83C4                   06  add	sp,*6
06354                                           !BCC_EOS
06355                                           ! 1478     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
06356                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06357                                           ! Debug: expression subtree swapping
06358 199C           B8                   000F  mov	ax,*$F
06359 199F           31DB                       xor	bx,bx
06360 19A1           8D7E         FC            lea	di,-4[bp]
06361 19A4           E8         E714            call	landul
06362                                           ! Debug: list unsigned long = bx+0 (used reg = )
06363 19A7           53                         push	bx
06364 19A8           50                         push	ax
06365                                           ! Debug: list int = const $B6 (used reg = )
06366 19A9           B8                   00B6  mov	ax,#$B6
06367 19AC           50                         push	ax
06368                                           ! Debug: list int = const $40 (used reg = )
06369 19AD           B8                   0040  mov	ax,*$40
06370 19B0           50                         push	ax
06371                                           ! Debug: func () void = write_word+0 (used reg = )
06372 19B1           E8         EC7E            call	_write_word
06373 19B4           83C4                   08  add	sp,*8
06374                                           !BCC_EOS
06375                                           ! 1479     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
06376                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06377 19B7           8B46         FC            mov	ax,-4[bp]
06378 19BA           8B5E         FE            mov	bx,-2[bp]
06379 19BD           BF                   0004  mov	di,*4
06380 19C0           E8         E766            call	lsrul
06381                                           ! Debug: list unsigned long = bx+0 (used reg = )
06382 19C3           53                         push	bx
06383 19C4           50                         push	ax
06384                                           ! Debug: list int = const $B8 (used reg = )
06385 19C5           B8                   00B8  mov	ax,#$B8
06386 19C8           50                         push	ax
06387                                           ! Debug: list int = const $40 (used reg = )
06388 19C9           B8                   0040  mov	ax,*$40
06389 19CC           50                         push	ax
06390                                           ! Debug: func () void = write_word+0 (used reg = )
06391 19CD           E8         EC62            call	_write_word
06392 19D0           83C4                   08  add	sp,*8
06393                                           !BCC_EOS
06394                                           ! 1480     ;
06395                                           !BCC_EOS
06396                                           ! 1481 #asm
06397                                           !BCC_EOS
06398                                           !BCC_ASM
06399                       00000001            _s3_resume.s3_resume_flag	set	1
06400                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06401                       00000002            _s3_resume.s3_wakeup_vector	set	2
06402                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06403 19D3           FF2E       04B6                jmpf [0x04b6]
06404                                           ! 1483 endasm
06405                                           !BCC_ENDASM
06406                                           !BCC_EOS
06407                                           ! 1484     return 1;
06408 19D7           B8                   0001  mov	ax,*1
06409 19DA           89EC                       mov	sp,bp
06410 19DC           5D                         pop	bp
06411 19DD           C3                         ret
06412                                           !BCC_EOS
06413                                           ! 1485 }
06414                                           ! 1486 void ata_init( )
06415                                           ! Register BX used in function s3_resume
06416                                           ! 1487 {
06417                                           export	_ata_init
06418                       000019DE            _ata_init:
06419                                           ! 1488   Bit16u ebda_seg=read_word(0x0040,0x000E);
06420 19DE           55                         push	bp
06421 19DF           89E5                       mov	bp,sp
06422 19E1           4C                         dec	sp
06423 19E2           4C                         dec	sp
06424                                           ! Debug: list int = const $E (used reg = )
06425 19E3           B8                   000E  mov	ax,*$E
06426 19E6           50                         push	ax
06427                                           ! Debug: list int = const $40 (used reg = )
06428 19E7           B8                   0040  mov	ax,*$40
06429 19EA           50                         push	ax
06430                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06431 19EB           E8         EC19            call	_read_word
06432 19EE           83C4                   04  add	sp,*4
06433                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
06434 19F1           8946         FE            mov	-2[bp],ax
06435                                           !BCC_EOS
06436                                           ! 1489   Bit8u channel, device;
06437                                           !BCC_EOS
06438                                           ! 1490   for (channel=0; channel<4; channel++) {
06439 19F4           4C                         dec	sp
06440 19F5           4C                         dec	sp
06441                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
06442 19F6           30C0                       xor	al,al
06443 19F8           8846         FD            mov	-3[bp],al
06444                                           !BCC_EOS
06445                                           !BCC_EOS
06446 19FB           E9         0077            br 	.162
06447                       000019FE            .163:
06448                                           ! 1491     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
06449                                           ! Debug: list int = const 0 (used reg = )
06450 19FE           31C0                       xor	ax,ax
06451 1A00           50                         push	ax
06452                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06453 1A01           8A46         FD            mov	al,-3[bp]
06454 1A04           30E4                       xor	ah,ah
06455 1A06           B1                     03  mov	cl,*3
06456 1A08           D3E0                       shl	ax,cl
06457 1A0A           89C3                       mov	bx,ax
06458                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06459                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
06460 1A0C           81C3                 0122  add	bx,#$122
06461 1A10           53                         push	bx
06462                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06463 1A11           FF76         FE            push	-2[bp]
06464                                           ! Debug: func () void = write_byte+0 (used reg = )
06465 1A14           E8         EC03            call	_write_byte
06466 1A17           83C4                   06  add	sp,*6
06467                                           !BCC_EOS
06468                                           ! 1492     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
06469                                           ! Debug: list int = const 0 (used reg = )
06470 1A1A           31C0                       xor	ax,ax
06471 1A1C           50                         push	ax
06472                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06473 1A1D           8A46         FD            mov	al,-3[bp]
06474 1A20           30E4                       xor	ah,ah
06475 1A22           B1                     03  mov	cl,*3
06476 1A24           D3E0                       shl	ax,cl
06477 1A26           89C3                       mov	bx,ax
06478                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06479                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
06480 1A28           81C3                 0124  add	bx,#$124
06481 1A2C           53                         push	bx
06482                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06483 1A2D           FF76         FE            push	-2[bp]
06484                                           ! Debug: func () void = write_word+0 (used reg = )
06485 1A30           E8         EBFF            call	_write_word
06486 1A33           83C4                   06  add	sp,*6
06487                                           !BCC_EOS
06488                                           ! 1493     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
06489                                           ! Debug: list int = const 0 (used reg = )
06490 1A36           31C0                       xor	ax,ax
06491 1A38           50                         push	ax
06492                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06493 1A39           8A46         FD            mov	al,-3[bp]
06494 1A3C           30E4                       xor	ah,ah
06495 1A3E           B1                     03  mov	cl,*3
06496 1A40           D3E0                       shl	ax,cl
06497 1A42           89C3                       mov	bx,ax
06498                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06499                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
06500 1A44           81C3                 0126  add	bx,#$126
06501 1A48           53                         push	bx
06502                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06503 1A49           FF76         FE            push	-2[bp]
06504                                           ! Debug: func () void = write_word+0 (used reg = )
06505 1A4C           E8         EBE3            call	_write_word
06506 1A4F           83C4                   06  add	sp,*6
06507                                           !BCC_EOS
06508                                           ! 1494     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
06509                                           ! Debug: list int = const 0 (used reg = )
06510 1A52           31C0                       xor	ax,ax
06511 1A54           50                         push	ax
06512                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06513 1A55           8A46         FD            mov	al,-3[bp]
06514 1A58           30E4                       xor	ah,ah
06515 1A5A           B1                     03  mov	cl,*3
06516 1A5C           D3E0                       shl	ax,cl
06517 1A5E           89C3                       mov	bx,ax
06518                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06519                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
06520 1A60           81C3                 0128  add	bx,#$128
06521 1A64           53                         push	bx
06522                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06523 1A65           FF76         FE            push	-2[bp]
06524                                           ! Debug: func () void = write_byte+0 (used reg = )
06525 1A68           E8         EBAF            call	_write_byte
06526 1A6B           83C4                   06  add	sp,*6
06527                                           !BCC_EOS
06528                                           ! 1495     }
06529                                           ! 1496   for (device=0; device<(4*2); device++) {
06530                       00001A6E            .161:
06531                                           ! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
06532 1A6E           8A46         FD            mov	al,-3[bp]
06533 1A71           40                         inc	ax
06534 1A72           8846         FD            mov	-3[bp],al
06535                       00001A75            .162:
06536                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
06537 1A75           8A46         FD            mov	al,-3[bp]
06538 1A78           3C                     04  cmp	al,*4
06539 1A7A           72           82            jb 	.163
06540                       00001A7C            .164:
06541                       00001A7C            .160:
06542                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06543 1A7C           30C0                       xor	al,al
06544 1A7E           8846         FC            mov	-4[bp],al
06545                                           !BCC_EOS
06546                                           !BCC_EOS
06547 1A81           E9         01C0            br 	.167
06548                       00001A84            .168:
06549                                           ! 1497     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
06550                                           ! Debug: list int = const 0 (used reg = )
06551 1A84           31C0                       xor	ax,ax
06552 1A86           50                         push	ax
06553                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06554 1A87           8A46         FC            mov	al,-4[bp]
06555 1A8A           30E4                       xor	ah,ah
06556 1A8C           B9                   001E  mov	cx,*$1E
06557 1A8F           F7E9                       imul	cx
06558 1A91           89C3                       mov	bx,ax
06559                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06560                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06561 1A93           81C3                 0142  add	bx,#$142
06562 1A97           53                         push	bx
06563                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06564 1A98           FF76         FE            push	-2[bp]
06565                                           ! Debug: func () void = write_byte+0 (used reg = )
06566 1A9B           E8         EB7C            call	_write_byte
06567 1A9E           83C4                   06  add	sp,*6
06568                                           !BCC_EOS
06569                                           ! 1498     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
06570                                           ! Debug: list int = const 0 (used reg = )
06571 1AA1           31C0                       xor	ax,ax
06572 1AA3           50                         push	ax
06573                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06574 1AA4           8A46         FC            mov	al,-4[bp]
06575 1AA7           30E4                       xor	ah,ah
06576 1AA9           B9                   001E  mov	cx,*$1E
06577 1AAC           F7E9                       imul	cx
06578 1AAE           89C3                       mov	bx,ax
06579                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06580                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
06581 1AB0           81C3                 0143  add	bx,#$143
06582 1AB4           53                         push	bx
06583                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06584 1AB5           FF76         FE            push	-2[bp]
06585                                           ! Debug: func () void = write_byte+0 (used reg = )
06586 1AB8           E8         EB5F            call	_write_byte
06587 1ABB           83C4                   06  add	sp,*6
06588                                           !BCC_EOS
06589                                           ! 1499     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
06590                                           ! Debug: list int = const 0 (used reg = )
06591 1ABE           31C0                       xor	ax,ax
06592 1AC0           50                         push	ax
06593                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06594 1AC1           8A46         FC            mov	al,-4[bp]
06595 1AC4           30E4                       xor	ah,ah
06596 1AC6           B9                   001E  mov	cx,*$1E
06597 1AC9           F7E9                       imul	cx
06598 1ACB           89C3                       mov	bx,ax
06599                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06600                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
06601 1ACD           81C3                 0144  add	bx,#$144
06602 1AD1           53                         push	bx
06603                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06604 1AD2           FF76         FE            push	-2[bp]
06605                                           ! Debug: func () void = write_byte+0 (used reg = )
06606 1AD5           E8         EB42            call	_write_byte
06607 1AD8           83C4                   06  add	sp,*6
06608                                           !BCC_EOS
06609                                           ! 1500     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
06610                                           ! Debug: list int = const 0 (used reg = )
06611 1ADB           31C0                       xor	ax,ax
06612 1ADD           50                         push	ax
06613                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06614 1ADE           8A46         FC            mov	al,-4[bp]
06615 1AE1           30E4                       xor	ah,ah
06616 1AE3           B9                   001E  mov	cx,*$1E
06617 1AE6           F7E9                       imul	cx
06618 1AE8           89C3                       mov	bx,ax
06619                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06620                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
06621 1AEA           81C3                 0145  add	bx,#$145
06622 1AEE           53                         push	bx
06623                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06624 1AEF           FF76         FE            push	-2[bp]
06625                                           ! Debug: func () void = write_byte+0 (used reg = )
06626 1AF2           E8         EB25            call	_write_byte
06627 1AF5           83C4                   06  add	sp,*6
06628                                           !BCC_EOS
06629                                           ! 1501     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
06630                                           ! Debug: list int = const 0 (used reg = )
06631 1AF8           31C0                       xor	ax,ax
06632 1AFA           50                         push	ax
06633                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06634 1AFB           8A46         FC            mov	al,-4[bp]
06635 1AFE           30E4                       xor	ah,ah
06636 1B00           B9                   001E  mov	cx,*$1E
06637 1B03           F7E9                       imul	cx
06638 1B05           89C3                       mov	bx,ax
06639                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06640                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
06641 1B07           81C3                 0146  add	bx,#$146
06642 1B0B           53                         push	bx
06643                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06644 1B0C           FF76         FE            push	-2[bp]
06645                                           ! Debug: func () void = write_byte+0 (used reg = )
06646 1B0F           E8         EB08            call	_write_byte
06647 1B12           83C4                   06  add	sp,*6
06648                                           !BCC_EOS
06649                                           ! 1502     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
06650                                           ! Debug: list int = const 0 (used reg = )
06651 1B15           31C0                       xor	ax,ax
06652 1B17           50                         push	ax
06653                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06654 1B18           8A46         FC            mov	al,-4[bp]
06655 1B1B           30E4                       xor	ah,ah
06656 1B1D           B9                   001E  mov	cx,*$1E
06657 1B20           F7E9                       imul	cx
06658 1B22           89C3                       mov	bx,ax
06659                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06660                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
06661 1B24           81C3                 0148  add	bx,#$148
06662 1B28           53                         push	bx
06663                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06664 1B29           FF76         FE            push	-2[bp]
06665                                           ! Debug: func () void = write_word+0 (used reg = )
06666 1B2C           E8         EB03            call	_write_word
06667 1B2F           83C4                   06  add	sp,*6
06668                                           !BCC_EOS
06669                                           ! 1503     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
06670                                           ! Debug: list int = const 0 (used reg = )
06671 1B32           31C0                       xor	ax,ax
06672 1B34           50                         push	ax
06673                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06674 1B35           8A46         FC            mov	al,-4[bp]
06675 1B38           30E4                       xor	ah,ah
06676 1B3A           B9                   001E  mov	cx,*$1E
06677 1B3D           F7E9                       imul	cx
06678 1B3F           89C3                       mov	bx,ax
06679                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06680                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
06681 1B41           81C3                 014A  add	bx,#$14A
06682 1B45           53                         push	bx
06683                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06684 1B46           FF76         FE            push	-2[bp]
06685                                           ! Debug: func () void = write_byte+0 (used reg = )
06686 1B49           E8         EACE            call	_write_byte
06687 1B4C           83C4                   06  add	sp,*6
06688                                           !BCC_EOS
06689                                           ! 1504     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
06690                                           ! Debug: list int = const 0 (used reg = )
06691 1B4F           31C0                       xor	ax,ax
06692 1B51           50                         push	ax
06693                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06694 1B52           8A46         FC            mov	al,-4[bp]
06695 1B55           30E4                       xor	ah,ah
06696 1B57           B9                   001E  mov	cx,*$1E
06697 1B5A           F7E9                       imul	cx
06698 1B5C           89C3                       mov	bx,ax
06699                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06700                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
06701 1B5E           81C3                 014C  add	bx,#$14C
06702 1B62           53                         push	bx
06703                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06704 1B63           FF76         FE            push	-2[bp]
06705                                           ! Debug: func () void = write_word+0 (used reg = )
06706 1B66           E8         EAC9            call	_write_word
06707 1B69           83C4                   06  add	sp,*6
06708                                           !BCC_EOS
06709                                           ! 1505     write_word(ebda_seg,&((ebda_data_t *) 0)->ata
06710                                           ! 1505 .devices[device].lchs.cylinders,0);
06711                                           ! Debug: list int = const 0 (used reg = )
06712 1B6C           31C0                       xor	ax,ax
06713 1B6E           50                         push	ax
06714                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06715 1B6F           8A46         FC            mov	al,-4[bp]
06716 1B72           30E4                       xor	ah,ah
06717 1B74           B9                   001E  mov	cx,*$1E
06718 1B77           F7E9                       imul	cx
06719 1B79           89C3                       mov	bx,ax
06720                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06721                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
06722 1B7B           81C3                 014E  add	bx,#$14E
06723 1B7F           53                         push	bx
06724                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06725 1B80           FF76         FE            push	-2[bp]
06726                                           ! Debug: func () void = write_word+0 (used reg = )
06727 1B83           E8         EAAC            call	_write_word
06728 1B86           83C4                   06  add	sp,*6
06729                                           !BCC_EOS
06730                                           ! 1506     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
06731                                           ! Debug: list int = const 0 (used reg = )
06732 1B89           31C0                       xor	ax,ax
06733 1B8B           50                         push	ax
06734                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06735 1B8C           8A46         FC            mov	al,-4[bp]
06736 1B8F           30E4                       xor	ah,ah
06737 1B91           B9                   001E  mov	cx,*$1E
06738 1B94           F7E9                       imul	cx
06739 1B96           89C3                       mov	bx,ax
06740                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06741                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
06742 1B98           81C3                 0150  add	bx,#$150
06743 1B9C           53                         push	bx
06744                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06745 1B9D           FF76         FE            push	-2[bp]
06746                                           ! Debug: func () void = write_word+0 (used reg = )
06747 1BA0           E8         EA8F            call	_write_word
06748 1BA3           83C4                   06  add	sp,*6
06749                                           !BCC_EOS
06750                                           ! 1507     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
06751                                           ! Debug: list int = const 0 (used reg = )
06752 1BA6           31C0                       xor	ax,ax
06753 1BA8           50                         push	ax
06754                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06755 1BA9           8A46         FC            mov	al,-4[bp]
06756 1BAC           30E4                       xor	ah,ah
06757 1BAE           B9                   001E  mov	cx,*$1E
06758 1BB1           F7E9                       imul	cx
06759 1BB3           89C3                       mov	bx,ax
06760                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06761                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
06762 1BB5           81C3                 0152  add	bx,#$152
06763 1BB9           53                         push	bx
06764                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06765 1BBA           FF76         FE            push	-2[bp]
06766                                           ! Debug: func () void = write_word+0 (used reg = )
06767 1BBD           E8         EA72            call	_write_word
06768 1BC0           83C4                   06  add	sp,*6
06769                                           !BCC_EOS
06770                                           ! 1508     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
06771                                           ! Debug: list int = const 0 (used reg = )
06772 1BC3           31C0                       xor	ax,ax
06773 1BC5           50                         push	ax
06774                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06775 1BC6           8A46         FC            mov	al,-4[bp]
06776 1BC9           30E4                       xor	ah,ah
06777 1BCB           B9                   001E  mov	cx,*$1E
06778 1BCE           F7E9                       imul	cx
06779 1BD0           89C3                       mov	bx,ax
06780                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06781                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
06782 1BD2           81C3                 0154  add	bx,#$154
06783 1BD6           53                         push	bx
06784                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06785 1BD7           FF76         FE            push	-2[bp]
06786                                           ! Debug: func () void = write_word+0 (used reg = )
06787 1BDA           E8         EA55            call	_write_word
06788 1BDD           83C4                   06  add	sp,*6
06789                                           !BCC_EOS
06790                                           ! 1509     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
06791                                           ! Debug: list int = const 0 (used reg = )
06792 1BE0           31C0                       xor	ax,ax
06793 1BE2           50                         push	ax
06794                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06795 1BE3           8A46         FC            mov	al,-4[bp]
06796 1BE6           30E4                       xor	ah,ah
06797 1BE8           B9                   001E  mov	cx,*$1E
06798 1BEB           F7E9                       imul	cx
06799 1BED           89C3                       mov	bx,ax
06800                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06801                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
06802 1BEF           81C3                 0156  add	bx,#$156
06803 1BF3           53                         push	bx
06804                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06805 1BF4           FF76         FE            push	-2[bp]
06806                                           ! Debug: func () void = write_word+0 (used reg = )
06807 1BF7           E8         EA38            call	_write_word
06808 1BFA           83C4                   06  add	sp,*6
06809                                           !BCC_EOS
06810                                           ! 1510     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
06811                                           ! Debug: list long = const 0 (used reg = )
06812 1BFD           31C0                       xor	ax,ax
06813 1BFF           31DB                       xor	bx,bx
06814 1C01           53                         push	bx
06815 1C02           50                         push	ax
06816                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06817 1C03           8A46         FC            mov	al,-4[bp]
06818 1C06           30E4                       xor	ah,ah
06819 1C08           B9                   001E  mov	cx,*$1E
06820 1C0B           F7E9                       imul	cx
06821 1C0D           89C3                       mov	bx,ax
06822                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06823                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
06824 1C0F           81C3                 0158  add	bx,#$158
06825 1C13           53                         push	bx
06826                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06827 1C14           FF76         FE            push	-2[bp]
06828                                           ! Debug: func () void = write_dword+0 (used reg = )
06829 1C17           E8         E481            call	_write_dword
06830 1C1A           83C4                   08  add	sp,*8
06831                                           !BCC_EOS
06832                                           ! 1511     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
06833                                           ! Debug: list long = const 0 (used reg = )
06834 1C1D           31C0                       xor	ax,ax
06835 1C1F           31DB                       xor	bx,bx
06836 1C21           53                         push	bx
06837 1C22           50                         push	ax
06838                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06839 1C23           8A46         FC            mov	al,-4[bp]
06840 1C26           30E4                       xor	ah,ah
06841 1C28           B9                   001E  mov	cx,*$1E
06842 1C2B           F7E9                       imul	cx
06843 1C2D           89C3                       mov	bx,ax
06844                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06845                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
06846 1C2F           81C3                 015C  add	bx,#$15C
06847 1C33           53                         push	bx
06848                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06849 1C34           FF76         FE            push	-2[bp]
06850                                           ! Debug: func () void = write_dword+0 (used reg = )
06851 1C37           E8         E461            call	_write_dword
06852 1C3A           83C4                   08  add	sp,*8
06853                                           !BCC_EOS
06854                                           ! 1512     }
06855                                           ! 1513   for (device=0; device<(4*2); device++) {
06856                       00001C3D            .166:
06857                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06858 1C3D           8A46         FC            mov	al,-4[bp]
06859 1C40           40                         inc	ax
06860 1C41           8846         FC            mov	-4[bp],al
06861                       00001C44            .167:
06862                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06863 1C44           8A46         FC            mov	al,-4[bp]
06864 1C47           3C                     08  cmp	al,*8
06865 1C49         0F82         FE37            blo 	.168
06866                       00001C4D            .169:
06867                       00001C4D            .165:
06868                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06869 1C4D           30C0                       xor	al,al
06870 1C4F           8846         FC            mov	-4[bp],al
06871                                           !BCC_EOS
06872                                           !BCC_EOS
06873 1C52           EB           39            jmp .16C
06874                       00001C54            .16D:
06875                                           ! 1514     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
06876                                           ! Debug: list int = const 8 (used reg = )
06877 1C54           B8                   0008  mov	ax,*8
06878 1C57           50                         push	ax
06879                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
06880 1C58           8A46         FC            mov	al,-4[bp]
06881 1C5B           30E4                       xor	ah,ah
06882 1C5D           89C3                       mov	bx,ax
06883                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06884                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
06885 1C5F           81C3                 0233  add	bx,#$233
06886 1C63           53                         push	bx
06887                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06888 1C64           FF76         FE            push	-2[bp]
06889                                           ! Debug: func () void = write_byte+0 (used reg = )
06890 1C67           E8         E9B0            call	_write_byte
06891 1C6A           83C4                   06  add	sp,*6
06892                                           !BCC_EOS
06893                                           ! 1515     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
06894                                           ! Debug: list int = const 8 (used reg = )
06895 1C6D           B8                   0008  mov	ax,*8
06896 1C70           50                         push	ax
06897                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
06898 1C71           8A46         FC            mov	al,-4[bp]
06899 1C74           30E4                       xor	ah,ah
06900 1C76           89C3                       mov	bx,ax
06901                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06902                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
06903 1C78           81C3                 023C  add	bx,#$23C
06904 1C7C           53                         push	bx
06905                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06906 1C7D           FF76         FE            push	-2[bp]
06907                                           ! Debug: func () void = write_byte+0 (used reg = )
06908 1C80           E8         E997            call	_write_byte
06909 1C83           83C4                   06  add	sp,*6
06910                                           !BCC_EOS
06911                                           ! 1516     }
06912                                           ! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
06913                       00001C86            .16B:
06914                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06915 1C86           8A46         FC            mov	al,-4[bp]
06916 1C89           40                         inc	ax
06917 1C8A           8846         FC            mov	-4[bp],al
06918                       00001C8D            .16C:
06919                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06920 1C8D           8A46         FC            mov	al,-4[bp]
06921 1C90           3C                     08  cmp	al,*8
06922 1C92           72           C0            jb 	.16D
06923                       00001C94            .16E:
06924                       00001C94            .16A:
06925                                           ! Debug: list int = const 0 (used reg = )
06926 1C94           31C0                       xor	ax,ax
06927 1C96           50                         push	ax
06928                                           ! Debug: list * unsigned char = const $232 (used reg = )
06929 1C97           B8                   0232  mov	ax,#$232
06930 1C9A           50                         push	ax
06931                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06932 1C9B           FF76         FE            push	-2[bp]
06933                                           ! Debug: func () void = write_byte+0 (used reg = )
06934 1C9E           E8         E979            call	_write_byte
06935 1CA1           83C4                   06  add	sp,*6
06936                                           !BCC_EOS
06937                                           ! 1518   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
06938                                           ! Debug: list int = const 0 (used reg = )
06939 1CA4           31C0                       xor	ax,ax
06940 1CA6           50                         push	ax
06941                                           ! Debug: list * unsigned char = const $23B (used reg = )
06942 1CA7           B8                   023B  mov	ax,#$23B
06943 1CAA           50                         push	ax
06944                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06945 1CAB           FF76         FE            push	-2[bp]
06946                                           ! Debug: func () void = write_byte+0 (used reg = )
06947 1CAE           E8         E969            call	_write_byte
06948 1CB1           83C4                   06  add	sp,*6
06949                                           !BCC_EOS
06950                                           ! 1519 }
06951 1CB4           89EC                       mov	sp,bp
06952 1CB6           5D                         pop	bp
06953 1CB7           C3                         ret
06954                                           ! 1520 Bit8u await_ide();
06955                                           ! Register BX used in function ata_init
06956                                           !BCC_EOS
06957                                           ! 1521 static Bit8u await_ide(when_done,base,timeout)
06958                                           ! 1522   Bit8u when_done;
06959                       00001CB8            _await_ide:
06960                                           !BCC_EOS
06961                                           ! 1523   Bit16u base;
06962                                           !BCC_EOS
06963                                           ! 1524   Bit16u timeout;
06964                                           !BCC_EOS
06965                                           ! 1525 {
06966                                           ! 1526   Bit32u time=0,last=0;
06967 1CB8           55                         push	bp
06968 1CB9           89E5                       mov	bp,sp
06969 1CBB           83C4                   FC  add	sp,*-4
06970                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06971 1CBE           31C0                       xor	ax,ax
06972 1CC0           31DB                       xor	bx,bx
06973 1CC2           8946         FC            mov	-4[bp],ax
06974 1CC5           895E         FE            mov	-2[bp],bx
06975 1CC8           83C4                   FC  add	sp,*-4
06976                                           ! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
06977 1CCB           31C0                       xor	ax,ax
06978 1CCD           31DB                       xor	bx,bx
06979 1CCF           8946         F8            mov	-8[bp],ax
06980 1CD2           895E         FA            mov	-6[bp],bx
06981                                           !BCC_EOS
06982                                           ! 1527   Bit8u status;
06983                                           !BCC_EOS
06984                                           ! 1528   Bit8u result;
06985                                           !BCC_EOS
06986                                           ! 1529   for(;;) {
06987 1CD5           4C                         dec	sp
06988 1CD6           4C                         dec	sp
06989                                           !BCC_EOS
06990                                           !BCC_EOS
06991                       00001CD7            .171:
06992                                           ! 1530     status = inb(base+7);
06993                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06994 1CD7           8B46         06            mov	ax,6[bp]
06995                                           ! Debug: list unsigned int = ax+7 (used reg = )
06996 1CDA           05                   0007  add	ax,*7
06997 1CDD           50                         push	ax
06998                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06999 1CDE           E8         E85D            call	_inb
07000 1CE1           44                         inc	sp
07001 1CE2           44                         inc	sp
07002                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$C-$B] (used reg = )
07003 1CE3           8846         F7            mov	-9[bp],al
07004                                           !BCC_EOS
07005                                           ! 1531     time++;
07006                                           ! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
07007 1CE6           8B46         FC            mov	ax,-4[bp]
07008 1CE9           8B76         FE            mov	si,-2[bp]
07009 1CEC           8D5E         FC            lea	bx,-4[bp]
07010 1CEF           E8         E41D            call	lincl
07011                                           !BCC_EOS
07012                                           ! 1532     if (when_done == 1)
07013                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
07014 1CF2           8A46         04            mov	al,4[bp]
07015 1CF5           3C                     01  cmp	al,*1
07016 1CF7           75           0B            jne 	.172
07017                       00001CF9            .173:
07018                                           ! 1533       result = status & 0x80;
07019                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07020 1CF9           8A46         F7            mov	al,-9[bp]
07021 1CFC           24                     80  and	al,#$80
07022                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07023 1CFE           8846         F6            mov	-$A[bp],al
07024                                           !BCC_EOS
07025                                           ! 1534     else if (when_done == 2)
07026 1D01           E9         0094            br 	.174
07027                       00001D04            .172:
07028                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
07029 1D04           8A46         04            mov	al,4[bp]
07030 1D07           3C                     02  cmp	al,*2
07031 1D09           75           15            jne 	.175
07032                       00001D0B            .176:
07033                                           ! 1535       result = !(status & 0x80);
07034                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07035 1D0B           8A46         F7            mov	al,-9[bp]
07036 1D0E           24                     80  and	al,#$80
07037 1D10           84C0                       test	al,al
07038 1D12           75           04            jne 	.177
07039                       00001D14            .178:
07040 1D14           B0                     01  mov	al,*1
07041 1D16           EB           02            jmp	.179
07042                       00001D18            .177:
07043 1D18           30C0                       xor	al,al
07044                       00001D1A            .179:
07045                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07046 1D1A           8846         F6            mov	-$A[bp],al
07047                                           !BCC_EOS
07048                                           ! 1536     else if (when_done == 3)
07049 1D1D           E9         0078            br 	.17A
07050                       00001D20            .175:
07051                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
07052 1D20           8A46         04            mov	al,4[bp]
07053 1D23           3C                     03  cmp	al,*3
07054 1D25           75           1D            jne 	.17B
07055                       00001D27            .17C:
07056                                           ! 1537       result = !(status & 0x80) && (status & 0x08);
07057                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07058 1D27           8A46         F7            mov	al,-9[bp]
07059 1D2A           24                     80  and	al,#$80
07060 1D2C           84C0                       test	al,al
07061 1D2E           75           0D            jne 	.17D
07062                       00001D30            .17F:
07063                                           ! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
07064 1D30           8A46         F7            mov	al,-9[bp]
07065 1D33           24                     08  and	al,*8
07066 1D35           84C0                       test	al,al
07067 1D37           74           04            je  	.17D
07068                       00001D39            .17E:
07069 1D39           B0                     01  mov	al,*1
07070 1D3B           EB           02            jmp	.180
07071                       00001D3D            .17D:
07072 1D3D           30C0                       xor	al,al
07073                       00001D3F            .180:
07074                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07075 1D3F           8846         F6            mov	-$A[bp],al
07076                                           !BCC_EOS
07077                                           ! 1538     else if (when_done == 4)
07078 1D42           EB           54            jmp .181
07079                       00001D44            .17B:
07080                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
07081 1D44           8A46         04            mov	al,4[bp]
07082 1D47           3C                     04  cmp	al,*4
07083 1D49           75           1D            jne 	.182
07084                       00001D4B            .183:
07085                                           ! 1539       result = !(status & 0x80) && !(status & 0x08);
07086                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07087 1D4B           8A46         F7            mov	al,-9[bp]
07088 1D4E           24                     80  and	al,#$80
07089 1D50           84C0                       test	al,al
07090 1D52           75           0D            jne 	.184
07091                       00001D54            .186:
07092                                           ! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
07093 1D54           8A46         F7            mov	al,-9[bp]
07094 1D57           24                     08  and	al,*8
07095 1D59           84C0                       test	al,al
07096 1D5B           75           04            jne 	.184
07097                       00001D5D            .185:
07098 1D5D           B0                     01  mov	al,*1
07099 1D5F           EB           02            jmp	.187
07100                       00001D61            .184:
07101 1D61           30C0                       xor	al,al
07102                       00001D63            .187:
07103                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07104 1D63           8846         F6            mov	-$A[bp],al
07105                                           !BCC_EOS
07106                                           ! 1540     else if (when_done == 5)
07107 1D66           EB           30            jmp .188
07108                       00001D68            .182:
07109                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
07110 1D68           8A46         04            mov	al,4[bp]
07111 1D6B           3C                     05  cmp	al,*5
07112 1D6D           75           1D            jne 	.189
07113                       00001D6F            .18A:
07114                                           ! 1541       result = !(status & 0x80) && (status & 0x40);
07115                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07116 1D6F           8A46         F7            mov	al,-9[bp]
07117 1D72           24                     80  and	al,#$80
07118 1D74           84C0                       test	al,al
07119 1D76           75           0D            jne 	.18B
07120                       00001D78            .18D:
07121                                           ! Debug: and int = const $40 to unsigned char status = [S+$C-$B] (used reg = )
07122 1D78           8A46         F7            mov	al,-9[bp]
07123 1D7B           24                     40  and	al,*$40
07124 1D7D           84C0                       test	al,al
07125 1D7F           74           04            je  	.18B
07126                       00001D81            .18C:
07127 1D81           B0                     01  mov	al,*1
07128 1D83           EB           02            jmp	.18E
07129                       00001D85            .18B:
07130 1D85           30C0                       xor	al,al
07131                       00001D87            .18E:
07132                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07133 1D87           8846         F6            mov	-$A[bp],al
07134                                           !BCC_EOS
07135                                           ! 1542     else if (when_done == 0)
07136 1D8A           EB           0C            jmp .18F
07137                       00001D8C            .189:
07138                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
07139 1D8C           8A46         04            mov	al,4[bp]
07140 1D8F           84C0                       test	al,al
07141 1D91           75           05            jne 	.190
07142                       00001D93            .191:
07143                                           ! 1543       result = 0;
07144                                           ! Debug: eq int = const 0 to unsigned char result = [S+$C-$C] (used reg = )
07145 1D93           30C0                       xor	al,al
07146 1D95           8846         F6            mov	-$A[bp],al
07147                                           !BCC_EOS
07148                                           ! 1544     if (result) return status;
07149                       00001D98            .190:
07150                       00001D98            .18F:
07151                       00001D98            .188:
07152                       00001D98            .181:
07153                       00001D98            .17A:
07154                       00001D98            .174:
07155 1D98           8A46         F6            mov	al,-$A[bp]
07156 1D9B           84C0                       test	al,al
07157 1D9D           74           07            je  	.192
07158                       00001D9F            .193:
07159 1D9F           8A46         F7            mov	al,-9[bp]
07160 1DA2           89EC                       mov	sp,bp
07161 1DA4           5D                         pop	bp
07162 1DA5           C3                         ret
07163                                           !BCC_EOS
07164                                           ! 1545     if (time>>16 != last)
07165                       00001DA6            .192:
07166                                           ! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
07167 1DA6           8B46         FC            mov	ax,-4[bp]
07168 1DA9           8B5E         FE            mov	bx,-2[bp]
07169 1DAC           93                         xchg	bx,ax
07170 1DAD           31DB                       xor	bx,bx
07171                                           ! Debug: ne unsigned long last = [S+$C-$A] to unsigned long = bx+0 (used reg = )
07172 1DAF           8D7E         F8            lea	di,-8[bp]
07173 1DB2           E8         E316            call	lcmpul
07174 1DB5           74           0F            je  	.194
07175                       00001DB7            .195:
07176                                           ! 1546     {
07177                                           ! 1547       last = time >>16;
07178                                           ! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
07179 1DB7           8B46         FC            mov	ax,-4[bp]
07180 1DBA           8B5E         FE            mov	bx,-2[bp]
07181 1DBD           93                         xchg	bx,ax
07182 1DBE           31DB                       xor	bx,bx
07183                                           ! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$C-$A] (used reg = )
07184 1DC0           8946         F8            mov	-8[bp],ax
07185 1DC3           895E         FA            mov	-6[bp],bx
07186                                           !BCC_EOS
07187                                           ! 1548       ;
07188                                           !BCC_EOS
07189                                           ! 1549     }
07190                                           ! 1550     if (status & 0x01)
07191                       00001DC6            .194:
07192                                           ! Debug: and int = const 1 to unsigned char status = [S+$C-$B] (used reg = )
07193 1DC6           8A46         F7            mov	al,-9[bp]
07194 1DC9           24                     01  and	al,*1
07195 1DCB           84C0                       test	al,al
07196 1DCD           74           07            je  	.196
07197                       00001DCF            .197:
07198                                           ! 1551     {
07199                                           ! 1552       ;
07200                                           !BCC_EOS
07201                                           ! 1553       return status;
07202 1DCF           8A46         F7            mov	al,-9[bp]
07203 1DD2           89EC                       mov	sp,bp
07204 1DD4           5D                         pop	bp
07205 1DD5           C3                         ret
07206                                           !BCC_EOS
07207                                           ! 1554     }
07208                                           ! 1555     if ((timeout == 0) || ((time>>11) > timeout)) break;
07209                       00001DD6            .196:
07210                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
07211 1DD6           8B46         08            mov	ax,8[bp]
07212 1DD9           85C0                       test	ax,ax
07213 1DDB           74           26            je  	.199
07214                       00001DDD            .19A:
07215                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
07216 1DDD           8B46         08            mov	ax,8[bp]
07217 1DE0           31DB                       xor	bx,bx
07218 1DE2           53                         push	bx
07219 1DE3           50                         push	ax
07220                                           ! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
07221 1DE4           8B46         FC            mov	ax,-4[bp]
07222 1DE7           8B5E         FE            mov	bx,-2[bp]
07223 1DEA           88E0                       mov	al,ah
07224 1DEC           88DC                       mov	ah,bl
07225 1DEE           88FB                       mov	bl,bh
07226 1DF0           28FF                       sub	bh,bh
07227 1DF2           BF                   0003  mov	di,*3
07228 1DF5           E8         E331            call	lsrul
07229                                           ! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
07230 1DF8           8D7E         F2            lea	di,-$E[bp]
07231 1DFB           E8         E2CD            call	lcmpul
07232 1DFE           8D66         F6            lea	sp,-$A[bp]
07233 1E01           76           02            jbe 	.198
07234                       00001E03            .199:
07235 1E03           EB           03            jmp .16F
07236                                           !BCC_EOS
07237                                           ! 1556   }
07238                       00001E05            .198:
07239                                           ! 1557   ;
07240                       00001E05            .170:
07241 1E05           E9         FECF            br 	.171
07242                       00001E08            .16F:
07243                                           !BCC_EOS
07244                                           ! 1558   return status;
07245 1E08           8A46         F7            mov	al,-9[bp]
07246 1E0B           89EC                       mov	sp,bp
07247 1E0D           5D                         pop	bp
07248 1E0E           C3                         ret
07249                                           !BCC_EOS
07250                                           ! 1559 }
07251                                           ! 1560 void ata_detect( )
07252                                           ! Register BX used in function await_ide
07253                                           ! 1561 {
07254                                           export	_ata_detect
07255                       00001E0F            _ata_detect:
07256                                           ! 1562   Bit16u ebda_seg=read_word(0x0040,0x000E);
07257 1E0F           55                         push	bp
07258 1E10           89E5                       mov	bp,sp
07259 1E12           4C                         dec	sp
07260 1E13           4C                         dec	sp
07261                                           ! Debug: list int = const $E (used reg = )
07262 1E14           B8                   000E  mov	ax,*$E
07263 1E17           50                         push	ax
07264                                           ! Debug: list int = const $40 (used reg = )
07265 1E18           B8                   0040  mov	ax,*$40
07266 1E1B           50                         push	ax
07267                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07268 1E1C           E8         E7E8            call	_read_word
07269 1E1F           83C4                   04  add	sp,*4
07270                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
07271 1E22           8946         FE            mov	-2[bp],ax
07272                                           !BCC_EOS
07273                                           ! 1563   Bit8u hdcount, cdcount, device, type;
07274                                           !BCC_EOS
07275                                           ! 1564   Bit8u buffer[0x0200];
07276                                           !BCC_EOS
07277                                           ! 1565   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
07278 1E25           81C4                 FDFC  add	sp,#-$204
07279                                           ! Debug: list int = const 0 (used reg = )
07280 1E29           31C0                       xor	ax,ax
07281 1E2B           50                         push	ax
07282                                           ! Debug: list * unsigned char = const $122 (used reg = )
07283 1E2C           B8                   0122  mov	ax,#$122
07284 1E2F           50                         push	ax
07285                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07286 1E30           FF76         FE            push	-2[bp]
07287                                           ! Debug: func () void = write_byte+0 (used reg = )
07288 1E33           E8         E7E4            call	_write_byte
07289 1E36           83C4                   06  add	sp,*6
07290                                           !BCC_EOS
07291                                           ! 1566   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
07292                                           ! Debug: list int = const $1F0 (used reg = )
07293 1E39           B8                   01F0  mov	ax,#$1F0
07294 1E3C           50                         push	ax
07295                                           ! Debug: list * unsigned short = const $124 (used reg = )
07296 1E3D           B8                   0124  mov	ax,#$124
07297 1E40           50                         push	ax
07298                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07299 1E41           FF76         FE            push	-2[bp]
07300                                           ! Debug: func () void = write_word+0 (used reg = )
07301 1E44           E8         E7EB            call	_write_word
07302 1E47           83C4                   06  add	sp,*6
07303                                           !BCC_EOS
07304                                           ! 1567   write_word(ebda_seg,&((ebda_data
07305                                           ! 1567 _t *) 0)->ata.channels[0].iobase2,0x3f0);
07306                                           ! Debug: list int = const $3F0 (used reg = )
07307 1E4A           B8                   03F0  mov	ax,#$3F0
07308 1E4D           50                         push	ax
07309                                           ! Debug: list * unsigned short = const $126 (used reg = )
07310 1E4E           B8                   0126  mov	ax,#$126
07311 1E51           50                         push	ax
07312                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07313 1E52           FF76         FE            push	-2[bp]
07314                                           ! Debug: func () void = write_word+0 (used reg = )
07315 1E55           E8         E7DA            call	_write_word
07316 1E58           83C4                   06  add	sp,*6
07317                                           !BCC_EOS
07318                                           ! 1568   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
07319                                           ! Debug: list int = const $E (used reg = )
07320 1E5B           B8                   000E  mov	ax,*$E
07321 1E5E           50                         push	ax
07322                                           ! Debug: list * unsigned char = const $128 (used reg = )
07323 1E5F           B8                   0128  mov	ax,#$128
07324 1E62           50                         push	ax
07325                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07326 1E63           FF76         FE            push	-2[bp]
07327                                           ! Debug: func () void = write_byte+0 (used reg = )
07328 1E66           E8         E7B1            call	_write_byte
07329 1E69           83C4                   06  add	sp,*6
07330                                           !BCC_EOS
07331                                           ! 1569   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
07332                                           ! Debug: list int = const 0 (used reg = )
07333 1E6C           31C0                       xor	ax,ax
07334 1E6E           50                         push	ax
07335                                           ! Debug: list * unsigned char = const $12A (used reg = )
07336 1E6F           B8                   012A  mov	ax,#$12A
07337 1E72           50                         push	ax
07338                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07339 1E73           FF76         FE            push	-2[bp]
07340                                           ! Debug: func () void = write_byte+0 (used reg = )
07341 1E76           E8         E7A1            call	_write_byte
07342 1E79           83C4                   06  add	sp,*6
07343                                           !BCC_EOS
07344                                           ! 1570   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
07345                                           ! Debug: list int = const $170 (used reg = )
07346 1E7C           B8                   0170  mov	ax,#$170
07347 1E7F           50                         push	ax
07348                                           ! Debug: list * unsigned short = const $12C (used reg = )
07349 1E80           B8                   012C  mov	ax,#$12C
07350 1E83           50                         push	ax
07351                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07352 1E84           FF76         FE            push	-2[bp]
07353                                           ! Debug: func () void = write_word+0 (used reg = )
07354 1E87           E8         E7A8            call	_write_word
07355 1E8A           83C4                   06  add	sp,*6
07356                                           !BCC_EOS
07357                                           ! 1571   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
07358                                           ! Debug: list int = const $370 (used reg = )
07359 1E8D           B8                   0370  mov	ax,#$370
07360 1E90           50                         push	ax
07361                                           ! Debug: list * unsigned short = const $12E (used reg = )
07362 1E91           B8                   012E  mov	ax,#$12E
07363 1E94           50                         push	ax
07364                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07365 1E95           FF76         FE            push	-2[bp]
07366                                           ! Debug: func () void = write_word+0 (used reg = )
07367 1E98           E8         E797            call	_write_word
07368 1E9B           83C4                   06  add	sp,*6
07369                                           !BCC_EOS
07370                                           ! 1572   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
07371                                           ! Debug: list int = const $F (used reg = )
07372 1E9E           B8                   000F  mov	ax,*$F
07373 1EA1           50                         push	ax
07374                                           ! Debug: list * unsigned char = const $130 (used reg = )
07375 1EA2           B8                   0130  mov	ax,#$130
07376 1EA5           50                         push	ax
07377                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07378 1EA6           FF76         FE            push	-2[bp]
07379                                           ! Debug: func () void = write_byte+0 (used reg = )
07380 1EA9           E8         E76E            call	_write_byte
07381 1EAC           83C4                   06  add	sp,*6
07382                                           !BCC_EOS
07383                                           ! 1573   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
07384                                           ! Debug: list int = const 0 (used reg = )
07385 1EAF           31C0                       xor	ax,ax
07386 1EB1           50                         push	ax
07387                                           ! Debug: list * unsigned char = const $132 (used reg = )
07388 1EB2           B8                   0132  mov	ax,#$132
07389 1EB5           50                         push	ax
07390                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07391 1EB6           FF76         FE            push	-2[bp]
07392                                           ! Debug: func () void = write_byte+0 (used reg = )
07393 1EB9           E8         E75E            call	_write_byte
07394 1EBC           83C4                   06  add	sp,*6
07395                                           !BCC_EOS
07396                                           ! 1574   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
07397                                           ! Debug: list int = const $1E8 (used reg = )
07398 1EBF           B8                   01E8  mov	ax,#$1E8
07399 1EC2           50                         push	ax
07400                                           ! Debug: list * unsigned short = const $134 (used reg = )
07401 1EC3           B8                   0134  mov	ax,#$134
07402 1EC6           50                         push	ax
07403                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07404 1EC7           FF76         FE            push	-2[bp]
07405                                           ! Debug: func () void = write_word+0 (used reg = )
07406 1ECA           E8         E765            call	_write_word
07407 1ECD           83C4                   06  add	sp,*6
07408                                           !BCC_EOS
07409                                           ! 1575   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
07410                                           ! Debug: list int = const $3E0 (used reg = )
07411 1ED0           B8                   03E0  mov	ax,#$3E0
07412 1ED3           50                         push	ax
07413                                           ! Debug: list * unsigned short = const $136 (used reg = )
07414 1ED4           B8                   0136  mov	ax,#$136
07415 1ED7           50                         push	ax
07416                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07417 1ED8           FF76         FE            push	-2[bp]
07418                                           ! Debug: func () void = write_word+0 (used reg = )
07419 1EDB           E8         E754            call	_write_word
07420 1EDE           83C4                   06  add	sp,*6
07421                                           !BCC_EOS
07422                                           ! 1576   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
07423                                           ! Debug: list int = const $C (used reg = )
07424 1EE1           B8                   000C  mov	ax,*$C
07425 1EE4           50                         push	ax
07426                                           ! Debug: list * unsigned char = const $138 (used reg = )
07427 1EE5           B8                   0138  mov	ax,#$138
07428 1EE8           50                         push	ax
07429                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07430 1EE9           FF76         FE            push	-2[bp]
07431                                           ! Debug: func () void = write_byte+0 (used reg = )
07432 1EEC           E8         E72B            call	_write_byte
07433 1EEF           83C4                   06  add	sp,*6
07434                                           !BCC_EOS
07435                                           ! 1577   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
07436                                           ! Debug: list int = const 0 (used reg = )
07437 1EF2           31C0                       xor	ax,ax
07438 1EF4           50                         push	ax
07439                                           ! Debug: list * unsigned char = const $13A (used reg = )
07440 1EF5           B8                   013A  mov	ax,#$13A
07441 1EF8           50                         push	ax
07442                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07443 1EF9           FF76         FE            push	-2[bp]
07444                                           ! Debug: func () void = write_byte+0 (used reg = )
07445 1EFC           E8         E71B            call	_write_byte
07446 1EFF           83C4                   06  add	sp,*6
07447                                           !BCC_EOS
07448                                           ! 1578   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
07449                                           ! Debug: list int = const $168 (used reg = )
07450 1F02           B8                   0168  mov	ax,#$168
07451 1F05           50                         push	ax
07452                                           ! Debug: list * unsigned short = const $13C (used reg = )
07453 1F06           B8                   013C  mov	ax,#$13C
07454 1F09           50                         push	ax
07455                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07456 1F0A           FF76         FE            push	-2[bp]
07457                                           ! Debug: func () void = write_word+0 (used reg = )
07458 1F0D           E8         E722            call	_write_word
07459 1F10           83C4                   06  add	sp,*6
07460                                           !BCC_EOS
07461                                           ! 1579   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
07462                                           ! Debug: list int = const $360 (used reg = )
07463 1F13           B8                   0360  mov	ax,#$360
07464 1F16           50                         push	ax
07465                                           ! Debug: list * unsigned short = const $13E (used reg = )
07466 1F17           B8                   013E  mov	ax,#$13E
07467 1F1A           50                         push	ax
07468                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07469 1F1B           FF76         FE            push	-2[bp]
07470                                           ! Debug: func () void = write_word+0 (used reg = )
07471 1F1E           E8         E711            call	_write_word
07472 1F21           83C4                   06  add	sp,*6
07473                                           !BCC_EOS
07474                                           ! 1580   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
07475                                           ! Debug: list int = const $B (used reg = )
07476 1F24           B8                   000B  mov	ax,*$B
07477 1F27           50                         push	ax
07478                                           ! Debug: list * unsigned char = const $140 (used reg = )
07479 1F28           B8                   0140  mov	ax,#$140
07480 1F2B           50                         push	ax
07481                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07482 1F2C           FF76         FE            push	-2[bp]
07483                                           ! Debug: func () void = write_byte+0 (used reg = )
07484 1F2F           E8         E6E8            call	_write_byte
07485 1F32           83C4                   06  add	sp,*6
07486                                           !BCC_EOS
07487                                           ! 1581   hdcount=cdcount=0;
07488                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
07489 1F35           30C0                       xor	al,al
07490 1F37           8846         FC            mov	-4[bp],al
07491                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
07492 1F3A           8846         FD            mov	-3[bp],al
07493                                           !BCC_EOS
07494                                           ! 1582   for(device=0; device<(4*2); device++) {
07495                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
07496 1F3D           30C0                       xor	al,al
07497 1F3F           8846         FB            mov	-5[bp],al
07498                                           !BCC_EOS
07499                                           !BCC_EOS
07500 1F42           E9         0D39            br 	.19D
07501                       00001F45            .19E:
07502                                           ! 1583     Bit16u iobase1, iobase2;
07503                                           !BCC_EOS
07504                                           ! 1584     Bit8u channel, slave, shift;
07505                                           !BCC_EOS
07506                                           ! 1585     Bit8u sc, sn, cl, ch, st;
07507                                           !BCC_EOS
07508                                           ! 1586     channel = device / 2;
07509 1F45           83C4                   F4  add	sp,*-$C
07510                                           ! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07511 1F48           8A46         FB            mov	al,-5[bp]
07512 1F4B           30E4                       xor	ah,ah
07513 1F4D           D1E8                       shr	ax,*1
07514                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
07515 1F4F           8886       FDF5            mov	-$20B[bp],al
07516                                           !BCC_EOS
07517                                           ! 1587     slave = device % 2;
07518                                           ! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07519 1F53           8A46         FB            mov	al,-5[bp]
07520 1F56           30E4                       xor	ah,ah
07521 1F58           24                     01  and	al,*1
07522                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
07523 1F5A           8886       FDF4            mov	-$20C[bp],al
07524                                           !BCC_EOS
07525                                           ! 1588     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
07526                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07527 1F5E           8A86       FDF5            mov	al,-$20B[bp]
07528 1F62           30E4                       xor	ah,ah
07529 1F64           B1                     03  mov	cl,*3
07530 1F66           D3E0                       shl	ax,cl
07531 1F68           89C3                       mov	bx,ax
07532                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07533                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
07534 1F6A           81C3                 0124  add	bx,#$124
07535 1F6E           53                         push	bx
07536                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07537 1F6F           FF76         FE            push	-2[bp]
07538                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07539 1F72           E8         E692            call	_read_word
07540 1F75           83C4                   04  add	sp,*4
07541                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07542 1F78           8986       FDF8            mov	-$208[bp],ax
07543                                           !BCC_EOS
07544                                           ! 1589     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
07545                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07546 1F7C           8A86       FDF5            mov	al,-$20B[bp]
07547 1F80           30E4                       xor	ah,ah
07548 1F82           B1                     03  mov	cl,*3
07549 1F84           D3E0                       shl	ax,cl
07550 1F86           89C3                       mov	bx,ax
07551                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07552                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
07553 1F88           81C3                 0126  add	bx,#$126
07554 1F8C           53                         push	bx
07555                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07556 1F8D           FF76         FE            push	-2[bp]
07557                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07558 1F90           E8         E674            call	_read_word
07559 1F93           83C4                   04  add	sp,*4
07560                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
07561 1F96           8986       FDF6            mov	-$20A[bp],ax
07562                                           !BCC_EOS
07563                                           ! 1590     outb(iobase2+6, 0x08 | 0x02);
07564                                           ! Debug: list int = const $A (used reg = )
07565 1F9A           B8                   000A  mov	ax,*$A
07566 1F9D           50                         push	ax
07567                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07568 1F9E           8B86       FDF6            mov	ax,-$20A[bp]
07569                                           ! Debug: list unsigned int = ax+6 (used reg = )
07570 1FA2           05                   0006  add	ax,*6
07571 1FA5           50                         push	ax
07572                                           ! Debug: func () void = outb+0 (used reg = )
07573 1FA6           E8         E5AB            call	_outb
07574 1FA9           83C4                   04  add	sp,*4
07575                                           !BCC_EOS
07576                                           ! 1591     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07577 1FAC           8A86       FDF4            mov	al,-$20C[bp]
07578 1FB0           84C0                       test	al,al
07579 1FB2           74           04            je  	.19F
07580                       00001FB4            .1A0:
07581 1FB4           B0                     B0  mov	al,#$B0
07582 1FB6           EB           02            jmp .1A1
07583                       00001FB8            .19F:
07584 1FB8           B0                     A0  mov	al,#$A0
07585                       00001FBA            .1A1:
07586                                           ! Debug: list char = al+0 (used reg = )
07587 1FBA           30E4                       xor	ah,ah
07588 1FBC           50                         push	ax
07589                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07590 1FBD           8B86       FDF8            mov	ax,-$208[bp]
07591                                           ! Debug: list unsigned int = ax+6 (used reg = )
07592 1FC1           05                   0006  add	ax,*6
07593 1FC4           50                         push	ax
07594                                           ! Debug: func () void = outb+0 (used reg = )
07595 1FC5           E8         E58C            call	_outb
07596 1FC8           83C4                   04  add	sp,*4
07597                                           !BCC_EOS
07598                                           ! 1592     outb(iobase1+2, 0x55);
07599                                           ! Debug: list int = const $55 (used reg = )
07600 1FCB           B8                   0055  mov	ax,*$55
07601 1FCE           50                         push	ax
07602                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07603 1FCF           8B86       FDF8            mov	ax,-$208[bp]
07604                                           ! Debug: list unsigned int = ax+2 (used reg = )
07605 1FD3           40                         inc	ax
07606 1FD4           40                         inc	ax
07607 1FD5           50                         push	ax
07608                                           ! Debug: func () void = outb+0 (used reg = )
07609 1FD6           E8         E57B            call	_outb
07610 1FD9           83C4                   04  add	sp,*4
07611                                           !BCC_EOS
07612                                           ! 1593     outb(iobase1+3, 0xaa);
07613                                           ! Debug: list int = const $AA (used reg = )
07614 1FDC           B8                   00AA  mov	ax,#$AA
07615 1FDF           50                         push	ax
07616                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07617 1FE0           8B86       FDF8            mov	ax,-$208[bp]
07618                                           ! Debug: list unsigned int = ax+3 (used reg = )
07619 1FE4           05                   0003  add	ax,*3
07620 1FE7           50                         push	ax
07621                                           ! Debug: func () void = outb+0 (used reg = )
07622 1FE8           E8         E569            call	_outb
07623 1FEB           83C4                   04  add	sp,*4
07624                                           !BCC_EOS
07625                                           ! 1594     outb(iobase1+2, 0xaa);
07626                                           ! Debug: list int = const $AA (used reg = )
07627 1FEE           B8                   00AA  mov	ax,#$AA
07628 1FF1           50                         push	ax
07629                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07630 1FF2           8B86       FDF8            mov	ax,-$208[bp]
07631                                           ! Debug: list unsigned int = ax+2 (used reg = )
07632 1FF6           40                         inc	ax
07633 1FF7           40                         inc	ax
07634 1FF8           50                         push	ax
07635                                           ! Debug: func () void = outb+0 (used reg = )
07636 1FF9           E8         E558            call	_outb
07637 1FFC           83C4                   04  add	sp,*4
07638                                           !BCC_EOS
07639                                           ! 1595     outb(iobase1+3, 0x55);
07640                                           ! Debug: list int = const $55 (used reg = )
07641 1FFF           B8                   0055  mov	ax,*$55
07642 2002           50                         push	ax
07643                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07644 2003           8B86       FDF8            mov	ax,-$208[bp]
07645                                           ! Debug: list unsigned int = ax+3 (used reg = )
07646 2007           05                   0003  add	ax,*3
07647 200A           50                         push	ax
07648                                           ! Debug: func () void = outb+0 (used reg = )
07649 200B           E8         E546            call	_outb
07650 200E           83C4                   04  add	sp,*4
07651                                           !BCC_EOS
07652                                           ! 1596     outb(iobase1+2, 0x55);
07653                                           ! Debug: list int = const $55 (used reg = )
07654 2011           B8                   0055  mov	ax,*$55
07655 2014           50                         push	ax
07656                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07657 2015           8B86       FDF8            mov	ax,-$208[bp]
07658                                           ! Debug: list unsigned int = ax+2 (used reg = )
07659 2019           40                         inc	ax
07660 201A           40                         inc	ax
07661 201B           50                         push	ax
07662                                           ! Debug: func () void = outb+0 (used reg = )
07663 201C           E8         E535            call	_outb
07664 201F           83C4                   04  add	sp,*4
07665                                           !BCC_EOS
07666                                           ! 1597     outb(iobase1+3, 0xaa);
07667                                           ! Debug: list int = const $AA (used reg = )
07668 2022           B8                   00AA  mov	ax,#$AA
07669 2025           50                         push	ax
07670                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07671 2026           8B86       FDF8            mov	ax,-$208[bp]
07672                                           ! Debug: list unsigned int = ax+3 (used reg = )
07673 202A           05                   0003  add	ax,*3
07674 202D           50                         push	ax
07675                                           ! Debug: func () void = outb+0 (used reg = )
07676 202E           E8         E523            call	_outb
07677 2031           83C4                   04  add	sp,*4
07678                                           !BCC_EOS
07679                                           ! 1598     sc = inb(iobase1+2);
07680                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07681 2034           8B86       FDF8            mov	ax,-$208[bp]
07682                                           ! Debug: list unsigned int = ax+2 (used reg = )
07683 2038           40                         inc	ax
07684 2039           40                         inc	ax
07685 203A           50                         push	ax
07686                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07687 203B           E8         E500            call	_inb
07688 203E           44                         inc	sp
07689 203F           44                         inc	sp
07690                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07691 2040           8886       FDF2            mov	-$20E[bp],al
07692                                           !BCC_EOS
07693                                           ! 1599     sn = inb(iobase1+3);
07694                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07695 2044           8B86       FDF8            mov	ax,-$208[bp]
07696                                           ! Debug: list unsigned int = ax+3 (used reg = )
07697 2048           05                   0003  add	ax,*3
07698 204B           50                         push	ax
07699                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07700 204C           E8         E4EF            call	_inb
07701 204F           44                         inc	sp
07702 2050           44                         inc	sp
07703                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07704 2051           8886       FDF1            mov	-$20F[bp],al
07705                                           !BCC_EOS
07706                                           ! 1600     if ( (sc == 0x55) && (sn == 0xaa) ) {
07707                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
07708 2055           8A86       FDF2            mov	al,-$20E[bp]
07709 2059           3C                     55  cmp	al,*$55
07710 205B         0F85         014F            bne 	.1A2
07711                       0000205F            .1A4:
07712                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
07713 205F           8A86       FDF1            mov	al,-$20F[bp]
07714 2063           3C                     AA  cmp	al,#$AA
07715 2065         0F85         0145            bne 	.1A2
07716                       00002069            .1A3:
07717                                           ! 1601       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
07718                                           ! Debug: list int = const 1 (used reg = )
07719 2069           B8                   0001  mov	ax,*1
07720 206C           50                         push	ax
07721                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07722 206D           8A46         FB            mov	al,-5[bp]
07723 2070           30E4                       xor	ah,ah
07724 2072           B9                   001E  mov	cx,*$1E
07725 2075           F7E9                       imul	cx
07726 2077           89C3                       mov	bx,ax
07727                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07728                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07729 2079           81C3                 0142  add	bx,#$142
07730 207D           53                         push	bx
07731                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07732 207E           FF76         FE            push	-2[bp]
07733                                           ! Debug: func () void = write_byte+0 (used reg = )
07734 2081           E8         E596            call	_write_byte
07735 2084           83C4                   06  add	sp,*6
07736                                           !BCC_EOS
07737                                           ! 1602       ata_reset(device);
07738                                           ! Debug: list unsigned char device = [S+$214-7] (used reg = )
07739 2087           8A46         FB            mov	al,-5[bp]
07740 208A           30E4                       xor	ah,ah
07741 208C           50                         push	ax
07742                                           ! Debug: func () void = ata_reset+0 (used reg = )
07743 208D           E8         0C43            call	_ata_reset
07744 2090           44                         inc	sp
07745 2091           44                         inc	sp
07746                                           !BCC_EOS
07747                                           ! 1603       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07748 2092           8A86       FDF4            mov	al,-$20C[bp]
07749 2096           84C0                       test	al,al
07750 2098           74           04            je  	.1A5
07751                       0000209A            .1A6:
07752 209A           B0                     B0  mov	al,#$B0
07753 209C           EB           02            jmp .1A7
07754                       0000209E            .1A5:
07755 209E           B0                     A0  mov	al,#$A0
07756                       000020A0            .1A7:
07757                                           ! Debug: list char = al+0 (used reg = )
07758 20A0           30E4                       xor	ah,ah
07759 20A2           50                         push	ax
07760                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07761 20A3           8B86       FDF8            mov	ax,-$208[bp]
07762                                           ! Debug: list unsigned int = ax+6 (used reg = )
07763 20A7           05                   0006  add	ax,*6
07764 20AA           50                         push	ax
07765                                           ! Debug: func () void = outb+0 (used reg = )
07766 20AB           E8         E4A6            call	_outb
07767 20AE           83C4                   04  add	sp,*4
07768                                           !BCC_EOS
07769                                           ! 1604       sc = inb(iobase1+2);
07770                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07771 20B1           8B86       FDF8            mov	ax,-$208[bp]
07772                                           ! Debug: list unsigned int = ax+2 (used reg = )
07773 20B5           40                         inc	ax
07774 20B6           40                         inc	ax
07775 20B7           50                         push	ax
07776                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07777 20B8           E8         E483            call	_inb
07778 20BB           44                         inc	sp
07779 20BC           44                         inc	sp
07780                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07781 20BD           8886       FDF2            mov	-$20E[bp],al
07782                                           !BCC_EOS
07783                                           ! 1605       sn = inb(iobase1+3);
07784                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07785 20C1           8B86       FDF8            mov	ax,-$208[bp]
07786                                           ! Debug: list unsigned int = ax+3 (used reg = )
07787 20C5           05                   0003  add	ax,*3
07788 20C8           50                         push	ax
07789                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07790 20C9           E8         E472            call	_inb
07791 20CC           44                         inc	sp
07792 20CD           44                         inc	sp
07793                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07794 20CE           8886       FDF1            mov	-$20F[bp],al
07795                                           !BCC_EOS
07796                                           ! 1606       if ((sc==0x01) && (sn==0x01)) {
07797                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
07798 20D2           8A86       FDF2            mov	al,-$20E[bp]
07799 20D6           3C                     01  cmp	al,*1
07800 20D8         0F85         00D2            bne 	.1A8
07801                       000020DC            .1AA:
07802                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
07803 20DC           8A86       FDF1            mov	al,-$20F[bp]
07804 20E0           3C                     01  cmp	al,*1
07805 20E2         0F85         00C8            bne 	.1A8
07806                       000020E6            .1A9:
07807                                           ! 1607         cl = inb(iobase1+4);
07808                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07809 20E6           8B86       FDF8            mov	ax,-$208[bp]
07810                                           ! Debug: list unsigned int = ax+4 (used reg = )
07811 20EA           05                   0004  add	ax,*4
07812 20ED           50                         push	ax
07813                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07814 20EE           E8         E44D            call	_inb
07815 20F1           44                         inc	sp
07816 20F2           44                         inc	sp
07817                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
07818 20F3           8886       FDF0            mov	-$210[bp],al
07819                                           !BCC_EOS
07820                                           ! 1608         ch = inb(iobase1+5);
07821                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07822 20F7           8B86       FDF8            mov	ax,-$208[bp]
07823                                           ! Debug: list unsigned int = ax+5 (used reg = )
07824 20FB           05                   0005  add	ax,*5
07825 20FE           50                         push	ax
07826                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07827 20FF           E8         E43C            call	_inb
07828 2102           44                         inc	sp
07829 2103           44                         inc	sp
07830                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
07831 2104           8886       FDEF            mov	-$211[bp],al
07832                                           !BCC_EOS
07833                                           ! 1609         st = inb(iobase1+7);
07834                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07835 2108           8B86       FDF8            mov	ax,-$208[bp]
07836                                           ! Debug: list unsigned int = ax+7 (used reg = )
07837 210C           05                   0007  add	ax,*7
07838 210F           50                         push	ax
07839                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07840 2110           E8         E42B            call	_inb
07841 2113           44                         inc	sp
07842 2114           44                         inc	sp
07843                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
07844 2115           8886       FDEE            mov	-$212[bp],al
07845                                           !BCC_EOS
07846                                           ! 1610         if ((cl==0x1
07847                                           ! 1610 4) && (ch==0xeb)) {
07848                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
07849 2119           8A86       FDF0            mov	al,-$210[bp]
07850 211D           3C                     14  cmp	al,*$14
07851 211F           75           28            jne 	.1AB
07852                       00002121            .1AD:
07853                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
07854 2121           8A86       FDEF            mov	al,-$211[bp]
07855 2125           3C                     EB  cmp	al,#$EB
07856 2127           75           20            jne 	.1AB
07857                       00002129            .1AC:
07858                                           ! 1611           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
07859                                           ! Debug: list int = const 3 (used reg = )
07860 2129           B8                   0003  mov	ax,*3
07861 212C           50                         push	ax
07862                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07863 212D           8A46         FB            mov	al,-5[bp]
07864 2130           30E4                       xor	ah,ah
07865 2132           B9                   001E  mov	cx,*$1E
07866 2135           F7E9                       imul	cx
07867 2137           89C3                       mov	bx,ax
07868                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07869                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07870 2139           81C3                 0142  add	bx,#$142
07871 213D           53                         push	bx
07872                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07873 213E           FF76         FE            push	-2[bp]
07874                                           ! Debug: func () void = write_byte+0 (used reg = )
07875 2141           E8         E4D6            call	_write_byte
07876 2144           83C4                   06  add	sp,*6
07877                                           !BCC_EOS
07878                                           ! 1612         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07879 2147           EB           65            jmp .1AE
07880                       00002149            .1AB:
07881                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
07882 2149           8A86       FDF0            mov	al,-$210[bp]
07883 214D           84C0                       test	al,al
07884 214F           75           30            jne 	.1AF
07885                       00002151            .1B2:
07886                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
07887 2151           8A86       FDEF            mov	al,-$211[bp]
07888 2155           84C0                       test	al,al
07889 2157           75           28            jne 	.1AF
07890                       00002159            .1B1:
07891                                           ! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
07892 2159           8A86       FDEE            mov	al,-$212[bp]
07893 215D           84C0                       test	al,al
07894 215F           74           20            je  	.1AF
07895                       00002161            .1B0:
07896                                           ! 1613           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
07897                                           ! Debug: list int = const 2 (used reg = )
07898 2161           B8                   0002  mov	ax,*2
07899 2164           50                         push	ax
07900                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07901 2165           8A46         FB            mov	al,-5[bp]
07902 2168           30E4                       xor	ah,ah
07903 216A           B9                   001E  mov	cx,*$1E
07904 216D           F7E9                       imul	cx
07905 216F           89C3                       mov	bx,ax
07906                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07907                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07908 2171           81C3                 0142  add	bx,#$142
07909 2175           53                         push	bx
07910                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07911 2176           FF76         FE            push	-2[bp]
07912                                           ! Debug: func () void = write_byte+0 (used reg = )
07913 2179           E8         E49E            call	_write_byte
07914 217C           83C4                   06  add	sp,*6
07915                                           !BCC_EOS
07916                                           ! 1614         } else if ((cl==0xff) && (ch==0xff)) {
07917 217F           EB           2D            jmp .1B3
07918                       00002181            .1AF:
07919                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
07920 2181           8A86       FDF0            mov	al,-$210[bp]
07921 2185           3C                     FF  cmp	al,#$FF
07922 2187           75           25            jne 	.1B4
07923                       00002189            .1B6:
07924                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
07925 2189           8A86       FDEF            mov	al,-$211[bp]
07926 218D           3C                     FF  cmp	al,#$FF
07927 218F           75           1D            jne 	.1B4
07928                       00002191            .1B5:
07929                                           ! 1615           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
07930                                           ! Debug: list int = const 0 (used reg = )
07931 2191           31C0                       xor	ax,ax
07932 2193           50                         push	ax
07933                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07934 2194           8A46         FB            mov	al,-5[bp]
07935 2197           30E4                       xor	ah,ah
07936 2199           B9                   001E  mov	cx,*$1E
07937 219C           F7E9                       imul	cx
07938 219E           89C3                       mov	bx,ax
07939                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07940                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07941 21A0           81C3                 0142  add	bx,#$142
07942 21A4           53                         push	bx
07943                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07944 21A5           FF76         FE            push	-2[bp]
07945                                           ! Debug: func () void = write_byte+0 (used reg = )
07946 21A8           E8         E46F            call	_write_byte
07947 21AB           83C4                   06  add	sp,*6
07948                                           !BCC_EOS
07949                                           ! 1616         }
07950                                           ! 1617       }
07951                       000021AE            .1B4:
07952                       000021AE            .1B3:
07953                       000021AE            .1AE:
07954                                           ! 1618     }
07955                       000021AE            .1A8:
07956                                           ! 1619     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
07957                       000021AE            .1A2:
07958                                           ! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
07959 21AE           8A46         FB            mov	al,-5[bp]
07960 21B1           30E4                       xor	ah,ah
07961 21B3           B9                   001E  mov	cx,*$1E
07962 21B6           F7E9                       imul	cx
07963 21B8           89C3                       mov	bx,ax
07964                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07965                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07966 21BA           81C3                 0142  add	bx,#$142
07967 21BE           53                         push	bx
07968                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07969 21BF           FF76         FE            push	-2[bp]
07970                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07971 21C2           E8         E42F            call	_read_byte
07972 21C5           83C4                   04  add	sp,*4
07973                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
07974 21C8           8846         FA            mov	-6[bp],al
07975                                           !BCC_EOS
07976                                           ! 1620     if(type == 0x02) {
07977                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
07978 21CB           8A46         FA            mov	al,-6[bp]
07979 21CE           3C                     02  cmp	al,*2
07980 21D0         0F85         0535            bne 	.1B7
07981                       000021D4            .1B8:
07982                                           ! 1621       Bit32u sectors_low, sectors_high;
07983                                           !BCC_EOS
07984                                           ! 1622       Bit16u cylinders, heads, spt, blksize;
07985                                           !BCC_EOS
07986                                           ! 1623       Bit8u translation, removable, mode;
07987                                           !BCC_EOS
07988                                           ! 1624       mode = 0x00;
07989 21D4           83C4                   EC  add	sp,*-$14
07990                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$228-$227] (used reg = )
07991 21D7           30C0                       xor	al,al
07992 21D9           8886       FDDB            mov	-$225[bp],al
07993                                           !BCC_EOS
07994                                           ! 1625       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
07995                                           ! Debug: list int = const $FF (used reg = )
07996 21DD           B8                   00FF  mov	ax,#$FF
07997 21E0           50                         push	ax
07998                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
07999 21E1           8A46         FB            mov	al,-5[bp]
08000 21E4           30E4                       xor	ah,ah
08001 21E6           B9                   001E  mov	cx,*$1E
08002 21E9           F7E9                       imul	cx
08003 21EB           89C3                       mov	bx,ax
08004                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08005                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08006 21ED           81C3                 0143  add	bx,#$143
08007 21F1           53                         push	bx
08008                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08009 21F2           FF76         FE            push	-2[bp]
08010                                           ! Debug: func () void = write_byte+0 (used reg = )
08011 21F5           E8         E422            call	_write_byte
08012 21F8           83C4                   06  add	sp,*6
08013                                           !BCC_EOS
08014                                           ! 1626       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08015                                           ! Debug: list int = const 0 (used reg = )
08016 21FB           31C0                       xor	ax,ax
08017 21FD           50                         push	ax
08018                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08019 21FE           8A46         FB            mov	al,-5[bp]
08020 2201           30E4                       xor	ah,ah
08021 2203           B9                   001E  mov	cx,*$1E
08022 2206           F7E9                       imul	cx
08023 2208           89C3                       mov	bx,ax
08024                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08025                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08026 220A           81C3                 0146  add	bx,#$146
08027 220E           53                         push	bx
08028                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08029 220F           FF76         FE            push	-2[bp]
08030                                           ! Debug: func () void = write_byte+0 (used reg = )
08031 2212           E8         E405            call	_write_byte
08032 2215           83C4                   06  add	sp,*6
08033                                           !BCC_EOS
08034                                           ! 1627       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
08035                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08036 2218           8D9E       FDFA            lea	bx,-$206[bp]
08037 221C           53                         push	bx
08038                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08039 221D           E8         E42D            call	_get_SS
08040                                           ! Debug: list unsigned short = ax+0 (used reg = )
08041 2220           50                         push	ax
08042                                           ! Debug: list long = const 0 (used reg = )
08043 2221           31C0                       xor	ax,ax
08044 2223           31DB                       xor	bx,bx
08045 2225           53                         push	bx
08046 2226           50                         push	ax
08047                                           ! Debug: list long = const 0 (used reg = )
08048 2227           31C0                       xor	ax,ax
08049 2229           31DB                       xor	bx,bx
08050 222B           53                         push	bx
08051 222C           50                         push	ax
08052                                           ! Debug: list int = const 0 (used reg = )
08053 222D           31C0                       xor	ax,ax
08054 222F           50                         push	ax
08055                                           ! Debug: list int = const 0 (used reg = )
08056 2230           31C0                       xor	ax,ax
08057 2232           50                         push	ax
08058                                           ! Debug: list int = const 0 (used reg = )
08059 2233           31C0                       xor	ax,ax
08060 2235           50                         push	ax
08061                                           ! Debug: list int = const 1 (used reg = )
08062 2236           B8                   0001  mov	ax,*1
08063 2239           50                         push	ax
08064                                           ! Debug: list int = const $EC (used reg = )
08065 223A           B8                   00EC  mov	ax,#$EC
08066 223D           50                         push	ax
08067                                           ! Debug: list unsigned char device = [S+$23E-7] (used reg = )
08068 223E           8A46         FB            mov	al,-5[bp]
08069 2241           30E4                       xor	ah,ah
08070 2243           50                         push	ax
08071                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08072 2244           E8         0BE0            call	_ata_cmd_data_in
08073 2247           83C4                   18  add	sp,*$18
08074                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08075 224A           85C0                       test	ax,ax
08076 224C           74           0E            je  	.1B9
08077                       0000224E            .1BA:
08078                                           ! 1628         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
08079                                           ! Debug: list * char = .1BB+0 (used reg = )
08080 224E           BB                   D459  mov	bx,#.1BB
08081 2251           53                         push	bx
08082                                           ! Debug: list int = const 7 (used reg = )
08083 2252           B8                   0007  mov	ax,*7
08084 2255           50                         push	ax
08085                                           ! Debug: func () void = bios_printf+0 (used reg = )
08086 2256           E8         E7C2            call	_bios_printf
08087 2259           83C4                   04  add	sp,*4
08088                                           !BCC_EOS
08089                                           ! 1629       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
08090                       0000225C            .1B9:
08091                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08092 225C           8D9E       FDFA            lea	bx,-$206[bp]
08093 2260           53                         push	bx
08094                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08095 2261           E8         E3E9            call	_get_SS
08096                                           ! Debug: list unsigned short = ax+0 (used reg = )
08097 2264           50                         push	ax
08098                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08099 2265           E8         E38C            call	_read_byte
08100 2268           83C4                   04  add	sp,*4
08101                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08102 226B           24                     80  and	al,#$80
08103 226D           84C0                       test	al,al
08104 226F           74           04            je  	.1BC
08105                       00002271            .1BD:
08106 2271           B0                     01  mov	al,*1
08107 2273           EB           02            jmp .1BE
08108                       00002275            .1BC:
08109 2275           30C0                       xor	al,al
08110                       00002277            .1BE:
08111                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
08112 2277           8886       FDDC            mov	-$224[bp],al
08113                                           !BCC_EOS
08114                                           ! 1630       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
08115                                           ! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
08116 227B           8D9E       FE5A            lea	bx,-$1A6[bp]
08117 227F           53                         push	bx
08118                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08119 2280           E8         E3CA            call	_get_SS
08120                                           ! Debug: list unsigned short = ax+0 (used reg = )
08121 2283           50                         push	ax
08122                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08123 2284           E8         E36D            call	_read_byte
08124 2287           83C4                   04  add	sp,*4
08125 228A           84C0                       test	al,al
08126 228C           74           04            je  	.1BF
08127                       0000228E            .1C0:
08128 228E           B0                     01  mov	al,*1
08129 2290           EB           02            jmp .1C1
08130                       00002292            .1BF:
08131 2292           30C0                       xor	al,al
08132                       00002294            .1C1:
08133                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
08134 2294           8886       FDDB            mov	-$225[bp],al
08135                                           !BCC_EOS
08136                                           ! 1631       blksize = read_word(get_SS(),buffer+10);
08137                                           ! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
08138 2298           8D9E       FE04            lea	bx,-$1FC[bp]
08139 229C           53                         push	bx
08140                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08141 229D           E8         E3AD            call	_get_SS
08142                                           ! Debug: list unsigned short = ax+0 (used reg = )
08143 22A0           50                         push	ax
08144                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08145 22A1           E8         E363            call	_read_word
08146 22A4           83C4                   04  add	sp,*4
08147                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
08148 22A7           8986       FDDE            mov	-$222[bp],ax
08149                                           !BCC_EOS
08150                                           ! 1632       cylinders = read_word(get_SS(),buffer+(1*2));
08151                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
08152 22AB           8D9E       FDFC            lea	bx,-$204[bp]
08153 22AF           53                         push	bx
08154                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08155 22B0           E8         E39A            call	_get_SS
08156                                           ! Debug: list unsigned short = ax+0 (used reg = )
08157 22B3           50                         push	ax
08158                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08159 22B4           E8         E350            call	_read_word
08160 22B7           83C4                   04  add	sp,*4
08161                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08162 22BA           8986       FDE4            mov	-$21C[bp],ax
08163                                           !BCC_EOS
08164                                           ! 1633       heads = read_word(get_SS(),buffer+(3*2));
08165                                           ! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
08166 22BE           8D9E       FE00            lea	bx,-$200[bp]
08167 22C2           53                         push	bx
08168                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08169 22C3           E8         E387            call	_get_SS
08170                                           ! Debug: list unsigned short = ax+0 (used reg = )
08171 22C6           50                         push	ax
08172                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08173 22C7           E8         E33D            call	_read_word
08174 22CA           83C4                   04  add	sp,*4
08175                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
08176 22CD           8986       FDE2            mov	-$21E[bp],ax
08177                                           !BCC_EOS
08178                                           ! 1634       spt = read_word(get_SS(),buffer+(6*2));
08179                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
08180 22D1           8D9E       FE06            lea	bx,-$1FA[bp]
08181 22D5           53                         push	bx
08182                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08183 22D6           E8         E374            call	_get_SS
08184                                           ! Debug: list unsigned short = ax+0 (used reg = )
08185 22D9           50                         push	ax
08186                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08187 22DA           E8         E32A            call	_read_word
08188 22DD           83C4                   04  add	sp,*4
08189                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
08190 22E0           8986       FDE0            mov	-$220[bp],ax
08191                                           !BCC_EOS
08192                                           ! 1635       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
08193                                           ! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
08194 22E4           8D9E       FEA0            lea	bx,-$160[bp]
08195 22E8           53                         push	bx
08196                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08197 22E9           E8         E361            call	_get_SS
08198                                           ! Debug: list unsigned short = ax+0 (used reg = )
08199 22EC           50                         push	ax
08200                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08201 22ED           E8         E317            call	_read_word
08202 22F0           83C4                   04  add	sp,*4
08203                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
08204 22F3           25                   0400  and	ax,#$400
08205 22F6           85C0                       test	ax,ax
08206 22F8           74           34            je  	.1C2
08207                       000022FA            .1C3:
08208                                           ! 1636         sectors_low = read_dword(get_SS(),buffer+(100*2));
08209                                           ! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
08210 22FA           8D9E       FEC2            lea	bx,-$13E[bp]
08211 22FE           53                         push	bx
08212                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08213 22FF           E8         E34B            call	_get_SS
08214                                           ! Debug: list unsigned short = ax+0 (used reg = )
08215 2302           50                         push	ax
08216                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08217 2303           E8         DD7D            call	_read_dword
08218 2306           89D3                       mov	bx,dx
08219 2308           83C4                   04  add	sp,*4
08220                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08221 230B           8986       FDEA            mov	-$216[bp],ax
08222 230F           899E       FDEC            mov	-$214[bp],bx
08223                                           !BCC_EOS
08224                                           ! 1637         sectors_high = read_dword(get_SS(),buffer+(102*2));
08225                                           ! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
08226 2313           8D9E       FEC6            lea	bx,-$13A[bp]
08227 2317           53                         push	bx
08228                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08229 2318           E8         E332            call	_get_SS
08230                                           ! Debug: list unsigned short = ax+0 (used reg = )
08231 231B           50                         push	ax
08232                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08233 231C           E8         DD64            call	_read_dword
08234 231F           89D3                       mov	bx,dx
08235 2321           83C4                   04  add	sp,*4
08236                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08237 2324           8986       FDE6            mov	-$21A[bp],ax
08238 2328           899E       FDE8            mov	-$218[bp],bx
08239                                           !BCC_EOS
08240                                           ! 1638       } else {
08241 232C           EB           25            jmp .1C4
08242                       0000232E            .1C2:
08243                                           ! 1639         sectors_low = read_dword(get_SS(),buffer+(60*2));
08244                                           ! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
08245 232E           8D9E       FE72            lea	bx,-$18E[bp]
08246 2332           53                         push	bx
08247                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08248 2333           E8         E317            call	_get_SS
08249                                           ! Debug: list unsigned short = ax+0 (used reg = )
08250 2336           50                         push	ax
08251                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08252 2337           E8         DD49            call	_read_dword
08253 233A           89D3                       mov	bx,dx
08254 233C           83C4                   04  add	sp,*4
08255                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08256 233F           8986       FDEA            mov	-$216[bp],ax
08257 2343           899E       FDEC            mov	-$214[bp],bx
08258                                           !BCC_EOS
08259                                           ! 1640         sectors_high = 0;
08260                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08261 2347           31C0                       xor	ax,ax
08262 2349           31DB                       xor	bx,bx
08263 234B           8986       FDE6            mov	-$21A[bp],ax
08264 234F           899E       FDE8            mov	-$218[bp],bx
08265                                           !BCC_EOS
08266                                           ! 1641       }
08267                                           ! 1642       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
08268                       00002353            .1C4:
08269                                           ! Debug: list int = const $FF (used reg = )
08270 2353           B8                   00FF  mov	ax,#$FF
08271 2356           50                         push	ax
08272                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08273 2357           8A46         FB            mov	al,-5[bp]
08274 235A           30E4                       xor	ah,ah
08275 235C           B9                   001E  mov	cx,*$1E
08276 235F           F7E9                       imul	cx
08277 2361           89C3                       mov	bx,ax
08278                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08279                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08280 2363           81C3                 0143  add	bx,#$143
08281 2367           53                         push	bx
08282                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08283 2368           FF76         FE            push	-2[bp]
08284                                           ! Debug: func () void = write_byte+0 (used reg = )
08285 236B           E8         E2AC            call	_write_byte
08286 236E           83C4                   06  add	sp,*6
08287                                           !BCC_EOS
08288                                           ! 1643       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
08289                                           ! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
08290 2371           8A86       FDDC            mov	al,-$224[bp]
08291 2375           30E4                       xor	ah,ah
08292 2377           50                         push	ax
08293                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08294 2378           8A46         FB            mov	al,-5[bp]
08295 237B           30E4                       xor	ah,ah
08296 237D           B9                   001E  mov	cx,*$1E
08297 2380           F7E9                       imul	cx
08298 2382           89C3                       mov	bx,ax
08299                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08300                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
08301 2384           81C3                 0144  add	bx,#$144
08302 2388           53                         push	bx
08303                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08304 2389           FF76         FE            push	-2[bp]
08305                                           ! Debug: func () void = write_byte+0 (used reg = )
08306 238C           E8         E28B            call	_write_byte
08307 238F           83C4                   06  add	sp,*6
08308                                           !BCC_EOS
08309                                           ! 1644       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
08310                                           ! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
08311 2392           8A86       FDDB            mov	al,-$225[bp]
08312 2396           30E4                       xor	ah,ah
08313 2398           50                         push	ax
08314                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08315 2399           8A46         FB            mov	al,-5[bp]
08316 239C           30E4                       xor	ah,ah
08317 239E           B9                   001E  mov	cx,*$1E
08318 23A1           F7E9                       imul	cx
08319 23A3           89C3                       mov	bx,ax
08320                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08321                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08322 23A5           81C3                 0146  add	bx,#$146
08323 23A9           53                         push	bx
08324                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08325 23AA           FF76         FE            push	-2[bp]
08326                                           ! Debug: func () void = write_byte+0 (used reg = )
08327 23AD           E8         E26A            call	_write_byte
08328 23B0           83C4                   06  add	sp,*6
08329                                           !BCC_EOS
08330                                           ! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
08331                                           ! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
08332 23B3           FFB6       FDDE            push	-$222[bp]
08333                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08334 23B7           8A46         FB            mov	al,-5[bp]
08335 23BA           30E4                       xor	ah,ah
08336 23BC           B9                   001E  mov	cx,*$1E
08337 23BF           F7E9                       imul	cx
08338 23C1           89C3                       mov	bx,ax
08339                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08340                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
08341 23C3           81C3                 0148  add	bx,#$148
08342 23C7           53                         push	bx
08343                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08344 23C8           FF76         FE            push	-2[bp]
08345                                           ! Debug: func () void = write_word+0 (used reg = )
08346 23CB           E8         E264            call	_write_word
08347 23CE           83C4                   06  add	sp,*6
08348                                           !BCC_EOS
08349                                           ! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
08350                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08351 23D1           FFB6       FDE2            push	-$21E[bp]
08352                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08353 23D5           8A46         FB            mov	al,-5[bp]
08354 23D8           30E4                       xor	ah,ah
08355 23DA           B9                   001E  mov	cx,*$1E
08356 23DD           F7E9                       imul	cx
08357 23DF           89C3                       mov	bx,ax
08358                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
08359                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
08360 23E1           81C3                 0152  add	bx,#$152
08361 23E5           53                         push	bx
08362                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08363 23E6           FF76         FE            push	-2[bp]
08364                                           ! Debug: func () void = write_word+0 (used reg = )
08365 23E9           E8         E246            call	_write_word
08366 23EC           83C4                   06  add	sp,*6
08367                                           !BCC_EOS
08368                                           ! 1647       write_word(ebda_seg,&((ebda_data_t *) 
08369                                           ! 1647 0)->ata.devices[device].pchs.cylinders, cylinders);
08370                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08371 23EF           FFB6       FDE4            push	-$21C[bp]
08372                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08373 23F3           8A46         FB            mov	al,-5[bp]
08374 23F6           30E4                       xor	ah,ah
08375 23F8           B9                   001E  mov	cx,*$1E
08376 23FB           F7E9                       imul	cx
08377 23FD           89C3                       mov	bx,ax
08378                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
08379                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
08380 23FF           81C3                 0154  add	bx,#$154
08381 2403           53                         push	bx
08382                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08383 2404           FF76         FE            push	-2[bp]
08384                                           ! Debug: func () void = write_word+0 (used reg = )
08385 2407           E8         E228            call	_write_word
08386 240A           83C4                   06  add	sp,*6
08387                                           !BCC_EOS
08388                                           ! 1648       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
08389                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08390 240D           FFB6       FDE0            push	-$220[bp]
08391                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08392 2411           8A46         FB            mov	al,-5[bp]
08393 2414           30E4                       xor	ah,ah
08394 2416           B9                   001E  mov	cx,*$1E
08395 2419           F7E9                       imul	cx
08396 241B           89C3                       mov	bx,ax
08397                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
08398                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
08399 241D           81C3                 0156  add	bx,#$156
08400 2421           53                         push	bx
08401                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08402 2422           FF76         FE            push	-2[bp]
08403                                           ! Debug: func () void = write_word+0 (used reg = )
08404 2425           E8         E20A            call	_write_word
08405 2428           83C4                   06  add	sp,*6
08406                                           !BCC_EOS
08407                                           ! 1649       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
08408                                           ! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
08409 242B           FFB6       FDEC            push	-$214[bp]
08410 242F           FFB6       FDEA            push	-$216[bp]
08411                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08412 2433           8A46         FB            mov	al,-5[bp]
08413 2436           30E4                       xor	ah,ah
08414 2438           B9                   001E  mov	cx,*$1E
08415 243B           F7E9                       imul	cx
08416 243D           89C3                       mov	bx,ax
08417                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08418                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
08419 243F           81C3                 0158  add	bx,#$158
08420 2443           53                         push	bx
08421                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08422 2444           FF76         FE            push	-2[bp]
08423                                           ! Debug: func () void = write_dword+0 (used reg = )
08424 2447           E8         DC51            call	_write_dword
08425 244A           83C4                   08  add	sp,*8
08426                                           !BCC_EOS
08427                                           ! 1650       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
08428                                           ! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
08429 244D           FFB6       FDE8            push	-$218[bp]
08430 2451           FFB6       FDE6            push	-$21A[bp]
08431                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08432 2455           8A46         FB            mov	al,-5[bp]
08433 2458           30E4                       xor	ah,ah
08434 245A           B9                   001E  mov	cx,*$1E
08435 245D           F7E9                       imul	cx
08436 245F           89C3                       mov	bx,ax
08437                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08438                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
08439 2461           81C3                 015C  add	bx,#$15C
08440 2465           53                         push	bx
08441                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08442 2466           FF76         FE            push	-2[bp]
08443                                           ! Debug: func () void = write_dword+0 (used reg = )
08444 2469           E8         DC2F            call	_write_dword
08445 246C           83C4                   08  add	sp,*8
08446                                           !BCC_EOS
08447                                           ! 1651       ;
08448                                           !BCC_EOS
08449                                           ! 1652       translation = inb_cmos(0x39 + channel/2);
08450                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
08451 246F           8A86       FDF5            mov	al,-$20B[bp]
08452 2473           30E4                       xor	ah,ah
08453 2475           D1E8                       shr	ax,*1
08454                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
08455                                           ! Debug: expression subtree swapping
08456                                           ! Debug: list unsigned int = ax+$39 (used reg = )
08457 2477           05                   0039  add	ax,*$39
08458 247A           50                         push	ax
08459                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
08460 247B           E8         E105            call	_inb_cmos
08461 247E           44                         inc	sp
08462 247F           44                         inc	sp
08463                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
08464 2480           8886       FDDD            mov	-$223[bp],al
08465                                           !BCC_EOS
08466                                           ! 1653       for (shift=device%4; shift>0; shift--) translation >>= 2;
08467                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
08468 2484           8A46         FB            mov	al,-5[bp]
08469 2487           30E4                       xor	ah,ah
08470 2489           24                     03  and	al,*3
08471                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
08472 248B           8886       FDF3            mov	-$20D[bp],al
08473                                           !BCC_EOS
08474                                           !BCC_EOS
08475 248F           EB           17            jmp .1C7
08476                       00002491            .1C8:
08477                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
08478 2491           8A86       FDDD            mov	al,-$223[bp]
08479 2495           30E4                       xor	ah,ah
08480 2497           D1E8                       shr	ax,*1
08481 2499           D1E8                       shr	ax,*1
08482 249B           8886       FDDD            mov	-$223[bp],al
08483                                           !BCC_EOS
08484                                           ! 1654       translation &= 0x03;
08485                       0000249F            .1C6:
08486                                           ! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
08487 249F           8A86       FDF3            mov	al,-$20D[bp]
08488 24A3           48                         dec	ax
08489 24A4           8886       FDF3            mov	-$20D[bp],al
08490                       000024A8            .1C7:
08491                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
08492 24A8           8A86       FDF3            mov	al,-$20D[bp]
08493 24AC           84C0                       test	al,al
08494 24AE           75           E1            jne	.1C8
08495                       000024B0            .1C9:
08496                       000024B0            .1C5:
08497                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
08498 24B0           8A86       FDDD            mov	al,-$223[bp]
08499 24B4           24                     03  and	al,*3
08500 24B6           8886       FDDD            mov	-$223[bp],al
08501                                           !BCC_EOS
08502                                           ! 1655       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
08503                                           ! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
08504 24BA           8A86       FDDD            mov	al,-$223[bp]
08505 24BE           30E4                       xor	ah,ah
08506 24C0           50                         push	ax
08507                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08508 24C1           8A46         FB            mov	al,-5[bp]
08509 24C4           30E4                       xor	ah,ah
08510 24C6           B9                   001E  mov	cx,*$1E
08511 24C9           F7E9                       imul	cx
08512 24CB           89C3                       mov	bx,ax
08513                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
08514                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
08515 24CD           81C3                 014A  add	bx,#$14A
08516 24D1           53                         push	bx
08517                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08518 24D2           FF76         FE            push	-2[bp]
08519                                           ! Debug: func () void = write_byte+0 (used reg = )
08520 24D5           E8         E142            call	_write_byte
08521 24D8           83C4                   06  add	sp,*6
08522                                           !BCC_EOS
08523                                           ! 1656       switch (translation) {
08524 24DB           8A86       FDDD            mov	al,-$223[bp]
08525 24DF           EB           0A            jmp .1CC
08526                                           ! 1657         case 0:
08527                                           ! 1658           ;
08528                       000024E1            .1CD:
08529                                           !BCC_EOS
08530                                           ! 1659           break;
08531 24E1           EB           18            jmp .1CA
08532                                           !BCC_EOS
08533                                           ! 1660         case 1:
08534                                           ! 1661           ;
08535                       000024E3            .1CE:
08536                                           !BCC_EOS
08537                                           ! 1662           break;
08538 24E3           EB           16            jmp .1CA
08539                                           !BCC_EOS
08540                                           ! 1663         case 2:
08541                                           ! 1664           ;
08542                       000024E5            .1CF:
08543                                           !BCC_EOS
08544                                           ! 1665           break;
08545 24E5           EB           14            jmp .1CA
08546                                           !BCC_EOS
08547                                           ! 1666         case 3:
08548                                           ! 1667           ;
08549                       000024E7            .1D0:
08550                                           !BCC_EOS
08551                                           ! 1668           break;
08552 24E7           EB           12            jmp .1CA
08553                                           !BCC_EOS
08554                                           ! 1669         }
08555                                           ! 1670       switch (translation) {
08556 24E9           EB           10            jmp .1CA
08557                       000024EB            .1CC:
08558 24EB           2C                     00  sub	al,*0
08559 24ED           74           F2            je 	.1CD
08560 24EF           2C                     01  sub	al,*1
08561 24F1           74           F0            je 	.1CE
08562 24F3           2C                     01  sub	al,*1
08563 24F5           74           EE            je 	.1CF
08564 24F7           2C                     01  sub	al,*1
08565 24F9           74           EC            je 	.1D0
08566                       000024FB            .1CA:
08567                       FFFFFDD8            ..FFFE	=	-$228
08568 24FB           8A86       FDDD            mov	al,-$223[bp]
08569 24FF           E9         0162            br 	.1D3
08570                                           ! 1671         case 0:
08571                                           ! 1672           break;
08572                       00002502            .1D4:
08573 2502           E9         0175            br 	.1D1
08574                                           !BCC_EOS
08575                                           ! 1673         case 1:
08576                                           ! 1674           spt = 63;
08577                       00002505            .1D5:
08578                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
08579 2505           B8                   003F  mov	ax,*$3F
08580 2508           8986       FDE0            mov	-$220[bp],ax
08581                                           !BCC_EOS
08582                                           ! 1675           sectors_low /= 63;
08583                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
08584 250C           B8                   003F  mov	ax,*$3F
08585 250F           31DB                       xor	bx,bx
08586 2511           53                         push	bx
08587 2512           50                         push	ax
08588 2513           8B86       FDEA            mov	ax,-$216[bp]
08589 2517           8B9E       FDEC            mov	bx,-$214[bp]
08590 251B           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08591 251F           E8         DC4C            call	ldivul
08592 2522           8986       FDEA            mov	-$216[bp],ax
08593 2526           899E       FDEC            mov	-$214[bp],bx
08594 252A           83C4                   04  add	sp,*4
08595                                           !BCC_EOS
08596                                           ! 1676           heads = sectors_low / 1024;
08597                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08598 252D           B8                   0400  mov	ax,#$400
08599 2530           31DB                       xor	bx,bx
08600 2532           53                         push	bx
08601 2533           50                         push	ax
08602 2534           8B86       FDEA            mov	ax,-$216[bp]
08603 2538           8B9E       FDEC            mov	bx,-$214[bp]
08604 253C           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08605 2540           E8         DC2B            call	ldivul
08606 2543           83C4                   04  add	sp,*4
08607                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
08608 2546           8986       FDE2            mov	-$21E[bp],ax
08609                                           !BCC_EOS
08610                                           ! 1677           if (heads>128) heads = 255;
08611                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08612 254A           8B86       FDE2            mov	ax,-$21E[bp]
08613 254E           3D                   0080  cmp	ax,#$80
08614 2551           76           09            jbe 	.1D6
08615                       00002553            .1D7:
08616                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
08617 2553           B8                   00FF  mov	ax,#$FF
08618 2556           8986       FDE2            mov	-$21E[bp],ax
08619                                           !BCC_EOS
08620                                           ! 1678           else if (heads>64) heads = 128;
08621 255A           EB           3D            jmp .1D8
08622                       0000255C            .1D6:
08623                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08624 255C           8B86       FDE2            mov	ax,-$21E[bp]
08625 2560           3D                   0040  cmp	ax,*$40
08626 2563           76           09            jbe 	.1D9
08627                       00002565            .1DA:
08628                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08629 2565           B8                   0080  mov	ax,#$80
08630 2568           8986       FDE2            mov	-$21E[bp],ax
08631                                           !BCC_EOS
08632                                           ! 1679           else if (heads>32) heads = 64;
08633 256C           EB           2B            jmp .1DB
08634                       0000256E            .1D9:
08635                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08636 256E           8B86       FDE2            mov	ax,-$21E[bp]
08637 2572           3D                   0020  cmp	ax,*$20
08638 2575           76           09            jbe 	.1DC
08639                       00002577            .1DD:
08640                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08641 2577           B8                   0040  mov	ax,*$40
08642 257A           8986       FDE2            mov	-$21E[bp],ax
08643                                           !BCC_EOS
08644                                           ! 1680           else if (heads>16) heads = 32;
08645 257E           EB           19            jmp .1DE
08646                       00002580            .1DC:
08647                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08648 2580           8B86       FDE2            mov	ax,-$21E[bp]
08649 2584           3D                   0010  cmp	ax,*$10
08650 2587           76           09            jbe 	.1DF
08651                       00002589            .1E0:
08652                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08653 2589           B8                   0020  mov	ax,*$20
08654 258C           8986       FDE2            mov	-$21E[bp],ax
08655                                           !BCC_EOS
08656                                           ! 1681           else heads=16;
08657 2590           EB           07            jmp .1E1
08658                       00002592            .1DF:
08659                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08660 2592           B8                   0010  mov	ax,*$10
08661 2595           8986       FDE2            mov	-$21E[bp],ax
08662                                           !BCC_EOS
08663                                           ! 1682           cylinders = sectors_low / heads;
08664                       00002599            .1E1:
08665                       00002599            .1DE:
08666                       00002599            .1DB:
08667                       00002599            .1D8:
08668                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
08669 2599           8B86       FDE2            mov	ax,-$21E[bp]
08670 259D           31DB                       xor	bx,bx
08671                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08672 259F           53                         push	bx
08673 25A0           50                         push	ax
08674 25A1           8B86       FDEA            mov	ax,-$216[bp]
08675 25A5           8B9E       FDEC            mov	bx,-$214[bp]
08676 25A9           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08677 25AD           E8         DBBE            call	ldivul
08678 25B0           83C4                   04  add	sp,*4
08679                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08680 25B3           8986       FDE4            mov	-$21C[bp],ax
08681                                           !BCC_EOS
08682                                           ! 1683           break;
08683 25B7           E9         00C0            br 	.1D1
08684                                           !BCC_EOS
08685                                           ! 1684         case 3:
08686                                           ! 1685           if (heads==16) {
08687                       000025BA            .1E2:
08688                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08689 25BA           8B86       FDE2            mov	ax,-$21E[bp]
08690 25BE           3D                   0010  cmp	ax,*$10
08691 25C1           75           72            jne 	.1E3
08692                       000025C3            .1E4:
08693                                           ! 1686             if(cylinders>61439) cylinders=61439;
08694                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08695 25C3           8B86       FDE4            mov	ax,-$21C[bp]
08696 25C7           31DB                       xor	bx,bx
08697                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08698 25C9           53                         push	bx
08699 25CA           50                         push	ax
08700 25CB           B8                   EFFF  mov	ax,#$EFFF
08701 25CE           31DB                       xor	bx,bx
08702 25D0           53                         push	bx
08703 25D1           50                         push	ax
08704 25D2           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08705 25D6           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08706 25DA           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08707 25DE           E8         DAEA            call	lcmpul
08708 25E1           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08709 25E5           76           07            jbe 	.1E5
08710                       000025E7            .1E6:
08711                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
08712 25E7           B8                   EFFF  mov	ax,#$EFFF
08713 25EA           8986       FDE4            mov	-$21C[bp],ax
08714                                           !BCC_EOS
08715                                           ! 1687             heads=15;
08716                       000025EE            .1E5:
08717                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
08718 25EE           B8                   000F  mov	ax,*$F
08719 25F1           8986       FDE2            mov	-$21E[bp],ax
08720                                           !BCC_EOS
08721                                           ! 1688             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08722                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08723 25F5           8B86       FDE4            mov	ax,-$21C[bp]
08724 25F9           31DB                       xor	bx,bx
08725                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08726 25FB           53                         push	bx
08727 25FC           50                         push	ax
08728 25FD           B8                   0010  mov	ax,*$10
08729 2600           31DB                       xor	bx,bx
08730 2602           53                         push	bx
08731 2603           50                         push	ax
08732 2604           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08733 2608           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08734 260C           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08735 2610           E8         DAD6            call	lmulul
08736 2613           83C4                   08  add	sp,*8
08737                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08738 2616           53                         push	bx
08739 2617           50                         push	ax
08740 2618           B8                   000F  mov	ax,*$F
08741 261B           31DB                       xor	bx,bx
08742 261D           53                         push	bx
08743 261E           50                         push	ax
08744 261F           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08745 2623           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08746 2627           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08747 262B           E8         DB40            call	ldivul
08748 262E           83C4                   08  add	sp,*8
08749                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08750                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08751 2631           8986       FDE4            mov	-$21C[bp],ax
08752                                           !BCC_EOS
08753                                           ! 1689             }
08754                                           ! 1690         case 2:
08755                       00002635            .1E3:
08756                                           ! 1691           while(cylinders > 1024) {
08757                       00002635            .1E7:
08758 2635           E9         001F            br 	.1E9
08759                       00002638            .1EA:
08760                                           ! 1692             cylinders >>= 1;
08761                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08762 2638           8B86       FDE4            mov	ax,-$21C[bp]
08763 263C           D1E8                       shr	ax,*1
08764 263E           8986       FDE4            mov	-$21C[bp],ax
08765                                           !BCC_EOS
08766                                           ! 1693             heads <<= 1;
08767                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
08768 2642           8B86       FDE2            mov	ax,-$21E[bp]
08769 2646           D1E0                       shl	ax,*1
08770 2648           8986       FDE2            mov	-$21E[bp],ax
08771                                           !BCC_EOS
08772                                           ! 1694             if (heads > 127) break;
08773                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
08774 264C           8B86       FDE2            mov	ax,-$21E[bp]
08775 2650           3D                   007F  cmp	ax,*$7F
08776 2653           76           02            jbe 	.1EB
08777                       00002655            .1EC:
08778 2655           EB           09            jmp .1E8
08779                                           !BCC_EOS
08780                                           ! 1695           }
08781                       00002657            .1EB:
08782                                           ! 1696           break;
08783                       00002657            .1E9:
08784                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08785 2657           8B86       FDE4            mov	ax,-$21C[bp]
08786 265B           3D                   0400  cmp	ax,#$400
08787 265E           77           D8            ja 	.1EA
08788                       00002660            .1ED:
08789                       00002660            .1E8:
08790 2660           EB           18            jmp .1D1
08791                                           !BCC_EOS
08792                                           ! 1697         }
08793                                           ! 1698       if (cylinders > 1024) cylinders=1024;
08794 2662           EB           16            jmp .1D1
08795                       00002664            .1D3:
08796 2664           2C                     00  sub	al,*0
08797 2666         0F84         FE98            beq 	.1D4
08798 266A           2C                     01  sub	al,*1
08799 266C         0F84         FE95            beq 	.1D5
08800 2670           2C                     01  sub	al,*1
08801 2672           74           C1            je 	.1E7
08802 2674           2C                     01  sub	al,*1
08803 2676         0F84         FF40            beq 	.1E2
08804                       0000267A            .1D1:
08805                       FFFFFDD8            ..FFFD	=	-$228
08806                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08807 267A           8B86       FDE4            mov	ax,-$21C[bp]
08808 267E           3D                   0400  cmp	ax,#$400
08809 2681           76           07            jbe 	.1EE
08810                       00002683            .1EF:
08811                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08812 2683           B8                   0400  mov	ax,#$400
08813 2686           8986       FDE4            mov	-$21C[bp],ax
08814                                           !BCC_EOS
08815                                           ! 1699       ;
08816                       0000268A            .1EE:
08817                                           !BCC_EOS
08818                                           ! 1700       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
08819                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08820 268A           FFB6       FDE2            push	-$21E[bp]
08821                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08822 268E           8A46         FB            mov	al,-5[bp]
08823 2691           30E4                       xor	ah,ah
08824 2693           B9                   001E  mov	cx,*$1E
08825 2696           F7E9                       imul	cx
08826 2698           89C3                       mov	bx,ax
08827                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08828                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
08829 269A           81C3                 014C  add	bx,#$14C
08830 269E           53                         push	bx
08831                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08832 269F           FF76         FE            push	-2[bp]
08833                                           ! Debug: func () void = write_word+0 (used reg = )
08834 26A2           E8         DF8D            call	_write_word
08835 26A5           83C4                   06  add	sp,*6
08836                                           !BCC_EOS
08837                                           ! 1701       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
08838                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08839 26A8           FFB6       FDE4            push	-$21C[bp]
08840                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08841 26AC           8A46         FB            mov	al,-5[bp]
08842 26AF           30E4                       xor	ah,ah
08843 26B1           B9                   001E  mov	cx,*$1E
08844 26B4           F7E9                       imul	cx
08845 26B6           89C3                       mov	bx,ax
08846                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08847                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
08848 26B8           81C3                 014E  add	bx,#$14E
08849 26BC           53                         push	bx
08850                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08851 26BD           FF76         FE            push	-2[bp]
08852                                           ! Debug: func () void = write_word+0 (used reg = )
08853 26C0           E8         DF6F            call	_write_word
08854 26C3           83C4                   06  add	sp,*6
08855                                           !BCC_EOS
08856                                           ! 1702       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
08857                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08858 26C6           FFB6       FDE0            push	-$220[bp]
08859                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08860 26CA           8A46         FB            mov	al,-5[bp]
08861 26CD           30E4                       xor	ah,ah
08862 26CF           B9                   001E  mov	cx,*$1E
08863 26D2           F7E9                       imul	cx
08864 26D4           89C3                       mov	bx,ax
08865                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08866                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
08867 26D6           81C3                 0150  add	bx,#$150
08868 26DA           53                         push	bx
08869                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08870 26DB           FF76         FE            push	-2[bp]
08871                                           ! Debug: func () void = write_word+0 (used reg = )
08872 26DE           E8         DF51            call	_write_word
08873 26E1           83C4                   06  add	sp,*6
08874                                           !BCC_EOS
08875                                           ! 1703       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
08876                                           ! Debug: list unsigned char device = [S+$228-7] (used reg = )
08877 26E4           8A46         FB            mov	al,-5[bp]
08878 26E7           30E4                       xor	ah,ah
08879 26E9           50                         push	ax
08880                                           ! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
08881 26EA           8A46         FD            mov	al,-3[bp]
08882 26ED           30E4                       xor	ah,ah
08883 26EF           89C3                       mov	bx,ax
08884                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08885                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
08886 26F1           81C3                 0233  add	bx,#$233
08887 26F5           53                         push	bx
08888                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08889 26F6           FF76         FE            push	-2[bp]
08890                                           ! Debug: func () void = write_byte+0 (used reg = )
08891 26F9           E8         DF1E            call	_write_byte
08892 26FC           83C4                   06  add	sp,*6
08893                                           !BCC_EOS
08894                                           ! 1704       hdcount++;
08895                                           ! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
08896 26FF           8A46         FD            mov	al,-3[bp]
08897 2702           40                         inc	ax
08898 2703           8846         FD            mov	-3[bp],al
08899                                           !BCC_EOS
08900                                           ! 1705       }
08901 2706           83C4                   14  add	sp,*$14
08902                                           ! 1706     if(type == 0x03) {
08903                       00002709            .1B7:
08904                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
08905 2709           8A46         FA            mov	al,-6[bp]
08906 270C           3C                     03  cmp	al,*3
08907 270E         0F85         0186            bne 	.1F0
08908                       00002712            .1F1:
08909                                           ! 1707       Bit8u type, removable,
08910                                           ! 1707  mode;
08911                                           !BCC_EOS
08912                                           ! 1708       Bit16u blksize;
08913                                           !BCC_EOS
08914                                           ! 1709       mode = 0x00;
08915 2712           83C4                   FA  add	sp,*-6
08916                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
08917 2715           30C0                       xor	al,al
08918 2717           8886       FDEB            mov	-$215[bp],al
08919                                           !BCC_EOS
08920                                           ! 1710       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
08921                                           ! Debug: list int = const 5 (used reg = )
08922 271B           B8                   0005  mov	ax,*5
08923 271E           50                         push	ax
08924                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08925 271F           8A46         FB            mov	al,-5[bp]
08926 2722           30E4                       xor	ah,ah
08927 2724           B9                   001E  mov	cx,*$1E
08928 2727           F7E9                       imul	cx
08929 2729           89C3                       mov	bx,ax
08930                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08931                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08932 272B           81C3                 0143  add	bx,#$143
08933 272F           53                         push	bx
08934                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08935 2730           FF76         FE            push	-2[bp]
08936                                           ! Debug: func () void = write_byte+0 (used reg = )
08937 2733           E8         DEE4            call	_write_byte
08938 2736           83C4                   06  add	sp,*6
08939                                           !BCC_EOS
08940                                           ! 1711       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08941                                           ! Debug: list int = const 0 (used reg = )
08942 2739           31C0                       xor	ax,ax
08943 273B           50                         push	ax
08944                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08945 273C           8A46         FB            mov	al,-5[bp]
08946 273F           30E4                       xor	ah,ah
08947 2741           B9                   001E  mov	cx,*$1E
08948 2744           F7E9                       imul	cx
08949 2746           89C3                       mov	bx,ax
08950                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08951                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08952 2748           81C3                 0146  add	bx,#$146
08953 274C           53                         push	bx
08954                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08955 274D           FF76         FE            push	-2[bp]
08956                                           ! Debug: func () void = write_byte+0 (used reg = )
08957 2750           E8         DEC7            call	_write_byte
08958 2753           83C4                   06  add	sp,*6
08959                                           !BCC_EOS
08960                                           ! 1712       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08961                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08962 2756           8D9E       FDFA            lea	bx,-$206[bp]
08963 275A           53                         push	bx
08964                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08965 275B           E8         DEEF            call	_get_SS
08966                                           ! Debug: list unsigned short = ax+0 (used reg = )
08967 275E           50                         push	ax
08968                                           ! Debug: list long = const 0 (used reg = )
08969 275F           31C0                       xor	ax,ax
08970 2761           31DB                       xor	bx,bx
08971 2763           53                         push	bx
08972 2764           50                         push	ax
08973                                           ! Debug: list long = const 0 (used reg = )
08974 2765           31C0                       xor	ax,ax
08975 2767           31DB                       xor	bx,bx
08976 2769           53                         push	bx
08977 276A           50                         push	ax
08978                                           ! Debug: list int = const 0 (used reg = )
08979 276B           31C0                       xor	ax,ax
08980 276D           50                         push	ax
08981                                           ! Debug: list int = const 0 (used reg = )
08982 276E           31C0                       xor	ax,ax
08983 2770           50                         push	ax
08984                                           ! Debug: list int = const 0 (used reg = )
08985 2771           31C0                       xor	ax,ax
08986 2773           50                         push	ax
08987                                           ! Debug: list int = const 1 (used reg = )
08988 2774           B8                   0001  mov	ax,*1
08989 2777           50                         push	ax
08990                                           ! Debug: list int = const $A1 (used reg = )
08991 2778           B8                   00A1  mov	ax,#$A1
08992 277B           50                         push	ax
08993                                           ! Debug: list unsigned char device = [S+$230-7] (used reg = )
08994 277C           8A46         FB            mov	al,-5[bp]
08995 277F           30E4                       xor	ah,ah
08996 2781           50                         push	ax
08997                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08998 2782           E8         06A2            call	_ata_cmd_data_in
08999 2785           83C4                   18  add	sp,*$18
09000                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
09001 2788           85C0                       test	ax,ax
09002 278A           74           0E            je  	.1F2
09003                       0000278C            .1F3:
09004                                           ! 1713         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
09005                                           ! Debug: list * char = .1F4+0 (used reg = )
09006 278C           BB                   D42E  mov	bx,#.1F4
09007 278F           53                         push	bx
09008                                           ! Debug: list int = const 7 (used reg = )
09009 2790           B8                   0007  mov	ax,*7
09010 2793           50                         push	ax
09011                                           ! Debug: func () void = bios_printf+0 (used reg = )
09012 2794           E8         E284            call	_bios_printf
09013 2797           83C4                   04  add	sp,*4
09014                                           !BCC_EOS
09015                                           ! 1714       type = read_byte(get_SS(),buffer+1) & 0x1f;
09016                       0000279A            .1F2:
09017                                           ! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
09018 279A           8D9E       FDFB            lea	bx,-$205[bp]
09019 279E           53                         push	bx
09020                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09021 279F           E8         DEAB            call	_get_SS
09022                                           ! Debug: list unsigned short = ax+0 (used reg = )
09023 27A2           50                         push	ax
09024                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09025 27A3           E8         DE4E            call	_read_byte
09026 27A6           83C4                   04  add	sp,*4
09027                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
09028 27A9           24                     1F  and	al,*$1F
09029                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
09030 27AB           8886       FDED            mov	-$213[bp],al
09031                                           !BCC_EOS
09032                                           ! 1715       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
09033                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
09034 27AF           8D9E       FDFA            lea	bx,-$206[bp]
09035 27B3           53                         push	bx
09036                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09037 27B4           E8         DE96            call	_get_SS
09038                                           ! Debug: list unsigned short = ax+0 (used reg = )
09039 27B7           50                         push	ax
09040                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09041 27B8           E8         DE39            call	_read_byte
09042 27BB           83C4                   04  add	sp,*4
09043                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
09044 27BE           24                     80  and	al,#$80
09045 27C0           84C0                       test	al,al
09046 27C2           74           04            je  	.1F5
09047                       000027C4            .1F6:
09048 27C4           B0                     01  mov	al,*1
09049 27C6           EB           02            jmp .1F7
09050                       000027C8            .1F5:
09051 27C8           30C0                       xor	al,al
09052                       000027CA            .1F7:
09053                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
09054 27CA           8886       FDEC            mov	-$214[bp],al
09055                                           !BCC_EOS
09056                                           ! 1716       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
09057                                           ! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
09058 27CE           8D9E       FE5A            lea	bx,-$1A6[bp]
09059 27D2           53                         push	bx
09060                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09061 27D3           E8         DE77            call	_get_SS
09062                                           ! Debug: list unsigned short = ax+0 (used reg = )
09063 27D6           50                         push	ax
09064                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09065 27D7           E8         DE1A            call	_read_byte
09066 27DA           83C4                   04  add	sp,*4
09067 27DD           84C0                       test	al,al
09068 27DF           74           04            je  	.1F8
09069                       000027E1            .1F9:
09070 27E1           B0                     01  mov	al,*1
09071 27E3           EB           02            jmp .1FA
09072                       000027E5            .1F8:
09073 27E5           30C0                       xor	al,al
09074                       000027E7            .1FA:
09075                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
09076 27E7           8886       FDEB            mov	-$215[bp],al
09077                                           !BCC_EOS
09078                                           ! 1717       blksize = 2048;
09079                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
09080 27EB           B8                   0800  mov	ax,#$800
09081 27EE           8986       FDE8            mov	-$218[bp],ax
09082                                           !BCC_EOS
09083                                           ! 1718       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
09084                                           ! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
09085 27F2           8A86       FDED            mov	al,-$213[bp]
09086 27F6           30E4                       xor	ah,ah
09087 27F8           50                         push	ax
09088                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09089 27F9           8A46         FB            mov	al,-5[bp]
09090 27FC           30E4                       xor	ah,ah
09091 27FE           B9                   001E  mov	cx,*$1E
09092 2801           F7E9                       imul	cx
09093 2803           89C3                       mov	bx,ax
09094                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09095                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09096 2805           81C3                 0143  add	bx,#$143
09097 2809           53                         push	bx
09098                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09099 280A           FF76         FE            push	-2[bp]
09100                                           ! Debug: func () void = write_byte+0 (used reg = )
09101 280D           E8         DE0A            call	_write_byte
09102 2810           83C4                   06  add	sp,*6
09103                                           !BCC_EOS
09104                                           ! 1719       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
09105                                           ! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
09106 2813           8A86       FDEC            mov	al,-$214[bp]
09107 2817           30E4                       xor	ah,ah
09108 2819           50                         push	ax
09109                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09110 281A           8A46         FB            mov	al,-5[bp]
09111 281D           30E4                       xor	ah,ah
09112 281F           B9                   001E  mov	cx,*$1E
09113 2822           F7E9                       imul	cx
09114 2824           89C3                       mov	bx,ax
09115                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
09116                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
09117 2826           81C3                 0144  add	bx,#$144
09118 282A           53                         push	bx
09119                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09120 282B           FF76         FE            push	-2[bp]
09121                                           ! Debug: func () void = write_byte+0 (used reg = )
09122 282E           E8         DDE9            call	_write_byte
09123 2831           83C4                   06  add	sp,*6
09124                                           !BCC_EOS
09125                                           ! 1720       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
09126                                           ! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
09127 2834           8A86       FDEB            mov	al,-$215[bp]
09128 2838           30E4                       xor	ah,ah
09129 283A           50                         push	ax
09130                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09131 283B           8A46         FB            mov	al,-5[bp]
09132 283E           30E4                       xor	ah,ah
09133 2840           B9                   001E  mov	cx,*$1E
09134 2843           F7E9                       imul	cx
09135 2845           89C3                       mov	bx,ax
09136                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09137                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09138 2847           81C3                 0146  add	bx,#$146
09139 284B           53                         push	bx
09140                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09141 284C           FF76         FE            push	-2[bp]
09142                                           ! Debug: func () void = write_byte+0 (used reg = )
09143 284F           E8         DDC8            call	_write_byte
09144 2852           83C4                   06  add	sp,*6
09145                                           !BCC_EOS
09146                                           ! 1721       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
09147                                           ! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
09148 2855           FFB6       FDE8            push	-$218[bp]
09149                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09150 2859           8A46         FB            mov	al,-5[bp]
09151 285C           30E4                       xor	ah,ah
09152 285E           B9                   001E  mov	cx,*$1E
09153 2861           F7E9                       imul	cx
09154 2863           89C3                       mov	bx,ax
09155                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09156                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
09157 2865           81C3                 0148  add	bx,#$148
09158 2869           53                         push	bx
09159                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09160 286A           FF76         FE            push	-2[bp]
09161                                           ! Debug: func () void = write_word+0 (used reg = )
09162 286D           E8         DDC2            call	_write_word
09163 2870           83C4                   06  add	sp,*6
09164                                           !BCC_EOS
09165                                           ! 1722       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
09166                                           ! Debug: list unsigned char device = [S+$21A-7] (used reg = )
09167 2873           8A46         FB            mov	al,-5[bp]
09168 2876           30E4                       xor	ah,ah
09169 2878           50                         push	ax
09170                                           ! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
09171 2879           8A46         FC            mov	al,-4[bp]
09172 287C           30E4                       xor	ah,ah
09173 287E           89C3                       mov	bx,ax
09174                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
09175                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
09176 2880           81C3                 023C  add	bx,#$23C
09177 2884           53                         push	bx
09178                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09179 2885           FF76         FE            push	-2[bp]
09180                                           ! Debug: func () void = write_byte+0 (used reg = )
09181 2888           E8         DD8F            call	_write_byte
09182 288B           83C4                   06  add	sp,*6
09183                                           !BCC_EOS
09184                                           ! 1723       cdcount++;
09185                                           ! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
09186 288E           8A46         FC            mov	al,-4[bp]
09187 2891           40                         inc	ax
09188 2892           8846         FC            mov	-4[bp],al
09189                                           !BCC_EOS
09190                                           ! 1724       }
09191 2895           83C4                   06  add	sp,*6
09192                                           ! 1725       {
09193                       00002898            .1F0:
09194                                           ! 1726       Bit32u sizeinmb;
09195                                           !BCC_EOS
09196                                           ! 1727       Bit16u ataversion;
09197                                           !BCC_EOS
09198                                           ! 1728       Bit8u c, i, version, model[41];
09199                                           !BCC_EOS
09200                                           ! 1729       switch (type) {
09201 2898           83C4                   CE  add	sp,*-$32
09202 289B           8A46         FA            mov	al,-6[bp]
09203 289E           E9         020C            br 	.1FD
09204                                           ! 1730         case 0x02:
09205                                           ! 1731           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
09206                       000028A1            .1FE:
09207                                           ! 1732             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
09208                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09209 28A1           8A46         FB            mov	al,-5[bp]
09210 28A4           30E4                       xor	ah,ah
09211 28A6           B9                   001E  mov	cx,*$1E
09212 28A9           F7E9                       imul	cx
09213 28AB           89C3                       mov	bx,ax
09214                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
09215                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
09216 28AD           81C3                 0158  add	bx,#$158
09217 28B1           53                         push	bx
09218                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09219 28B2           FF76         FE            push	-2[bp]
09220                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09221 28B5           E8         D7CB            call	_read_dword
09222 28B8           89D3                       mov	bx,dx
09223 28BA           83C4                   04  add	sp,*4
09224                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
09225 28BD           88E0                       mov	al,ah
09226 28BF           88DC                       mov	ah,bl
09227 28C1           88FB                       mov	bl,bh
09228 28C3           28FF                       sub	bh,bh
09229 28C5           BF                   0003  mov	di,*3
09230 28C8           E8         D85E            call	lsrul
09231 28CB           53                         push	bx
09232 28CC           50                         push	ax
09233                                           ! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
09234 28CD           8A46         FB            mov	al,-5[bp]
09235 28D0           30E4                       xor	ah,ah
09236 28D2           B9                   001E  mov	cx,*$1E
09237 28D5           F7E9                       imul	cx
09238 28D7           89C3                       mov	bx,ax
09239                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
09240                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
09241 28D9           81C3                 015C  add	bx,#$15C
09242 28DD           53                         push	bx
09243                                           ! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
09244 28DE           FF76         FE            push	-2[bp]
09245                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09246 28E1           E8         D79F            call	_read_dword
09247 28E4           89D3                       mov	bx,dx
09248 28E6           83C4                   04  add	sp,*4
09249                                           ! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
09250 28E9           B1                     05  mov	cl,*5
09251 28EB           D3E0                       shl	ax,cl
09252 28ED           93                         xchg	bx,ax
09253 28EE           31C0                       xor	ax,ax
09254                                           ! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
09255 28F0           8DBE       FDB8            lea	di,-2+..FFFC[bp]
09256 28F4           E8         D810            call	lorul
09257 28F7           83C4                   04  add	sp,*4
09258                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09259 28FA           8986       FDEA            mov	-$216[bp],ax
09260 28FE           899E       FDEC            mov	-$214[bp],bx
09261                                           !BCC_EOS
09262                                           ! 1733         case 0x03:
09263                                           ! 1734           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
09264                       00002902            .1FF:
09265                                           ! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
09266 2902           8D9E       FE9A            lea	bx,-$166[bp]
09267 2906           53                         push	bx
09268                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09269 2907           E8         DD43            call	_get_SS
09270                                           ! Debug: list unsigned short = ax+0 (used reg = )
09271 290A           50                         push	ax
09272                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09273 290B           E8         DCE6            call	_read_byte
09274 290E           83C4                   04  add	sp,*4
09275 2911           50                         push	ax
09276                                           ! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
09277 2912           8D9E       FE9B            lea	bx,-$165[bp]
09278 2916           53                         push	bx
09279                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09280 2917           E8         DD33            call	_get_SS
09281                                           ! Debug: list unsigned short = ax+0 (used reg = )
09282 291A           50                         push	ax
09283                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09284 291B           E8         DCD6            call	_read_byte
09285 291E           83C4                   04  add	sp,*4
09286                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
09287 2921           30E4                       xor	ah,ah
09288                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
09289 2923           88C4                       mov	ah,al
09290 2925           30C0                       xor	al,al
09291                                           ! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
09292 2927           0A86       FDBA            or	al,0+..FFFC[bp]
09293 292B           44                         inc	sp
09294 292C           44                         inc	sp
09295                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09296 292D           8986       FDE8            mov	-$218[bp],ax
09297                                           !BCC_EOS
09298                                           ! 1735           for(version=15;version>0;version--) {
09299                                           ! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
09300 2931           B0                     0F  mov	al,*$F
09301 2933           8886       FDE5            mov	-$21B[bp],al
09302                                           !BCC_EOS
09303                                           !BCC_EOS
09304 2937           EB           22            jmp .202
09305                       00002939            .203:
09306                                           ! 1736             if((ataversion&(1<<version))!=0)
09307                                           ! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
09308 2939           8A86       FDE5            mov	al,-$21B[bp]
09309 293D           30E4                       xor	ah,ah
09310 293F           89C3                       mov	bx,ax
09311 2941           B8                   0001  mov	ax,*1
09312 2944           89D9                       mov	cx,bx
09313 2946           D3E0                       shl	ax,cl
09314                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09315                                           ! Debug: expression subtree swapping
09316 2948           2386       FDE8            and	ax,-$218[bp]
09317                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
09318 294C           85C0                       test	ax,ax
09319 294E           74           02            je  	.204
09320                       00002950            .205:
09321                                           ! 1737             break;
09322 2950           EB           11            jmp .200
09323                                           !BCC_EOS
09324                                           ! 1738             }
09325                       00002952            .204:
09326                                           ! 1739           for(i=0;i<20;i++){
09327                       00002952            .201:
09328                                           ! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
09329 2952           8A86       FDE5            mov	al,-$21B[bp]
09330 2956           48                         dec	ax
09331 2957           8886       FDE5            mov	-$21B[bp],al
09332                       0000295B            .202:
09333                                           ! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
09334 295B           8A86       FDE5            mov	al,-$21B[bp]
09335 295F           84C0                       test	al,al
09336 2961           75           D6            jne	.203
09337                       00002963            .206:
09338                       00002963            .200:
09339                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09340 2963           30C0                       xor	al,al
09341 2965           8886       FDE6            mov	-$21A[bp],al
09342                                           !BCC_EOS
09343                                           !BCC_EOS
09344 2969           E9         007B            br 	.209
09345                       0000296C            .20A:
09346                                           ! 1740             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
09347                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09348 296C           8A86       FDE6            mov	al,-$21A[bp]
09349 2970           30E4                       xor	ah,ah
09350 2972           D1E0                       shl	ax,*1
09351                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09352 2974           89EB                       mov	bx,bp
09353 2976           01C3                       add	bx,ax
09354                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09355                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
09356                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
09357                                           ! Debug: list * unsigned char = bx-$1CF (used reg = )
09358 2978           81C3                 FE31  add	bx,#-$1CF
09359 297C           53                         push	bx
09360                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09361 297D           E8         DCCD            call	_get_SS
09362                                           ! Debug: list unsigned short = ax+0 (used reg = )
09363 2980           50                         push	ax
09364                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09365 2981           E8         DC70            call	_read_byte
09366 2984           83C4                   04  add	sp,*4
09367                                           ! Debug: list unsigned char = al+0 (used reg = )
09368 2987           30E4                       xor	ah,ah
09369 2989           50                         push	ax
09370                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09371 298A           8A86       FDE6            mov	al,-$21A[bp]
09372 298E           30E4                       xor	ah,ah
09373 2990           D1E0                       shl	ax,*1
09374                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09375 2992           89EB                       mov	bx,bp
09376 2994           01C3                       add	bx,ax
09377                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09378                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09379 2996           81C3                 FDBC  add	bx,#-$244
09380 299A           53                         push	bx
09381                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09382 299B           E8         DCAF            call	_get_SS
09383                                           ! Debug: list unsigned short = ax+0 (used reg = )
09384 299E           50                         push	ax
09385                                           ! Debug: func () void = write_byte+0 (used reg = )
09386 299F           E8         DC78            call	_write_byte
09387 29A2           83C4                   06  add	sp,*6
09388                                           !BCC_EOS
09389                                           ! 1741             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
09390                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09391 29A5           8A86       FDE6            mov	al,-$21A[bp]
09392 29A9           30E4                       xor	ah,ah
09393 29AB           D1E0                       shl	ax,*1
09394                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09395 29AD           89EB                       mov	bx,bp
09396 29AF           01C3                       add	bx,ax
09397                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09398                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
09399                                           ! Debug: list * unsigned char = bx-$1D0 (used reg = )
09400 29B1           81C3                 FE30  add	bx,#-$1D0
09401 29B5           53                         push	bx
09402                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09403 29B6           E8         DC94            call	_get_SS
09404                                           ! Debug: list unsigned short = ax+0 (used reg = )
09405 29B9           50                         push	ax
09406                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09407 29BA           E8         DC37            call	_read_byte
09408 29BD           83C4                   04  add	sp,*4
09409                                           ! Debug: list unsigned char = al+0 (used reg = )
09410 29C0           30E4                       xor	ah,ah
09411 29C2           50                         push	ax
09412                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09413 29C3           8A86       FDE6            mov	al,-$21A[bp]
09414 29C7           30E4                       xor	ah,ah
09415 29C9           D1E0                       shl	ax,*1
09416                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09417 29CB           89EB                       mov	bx,bp
09418 29CD           01C3                       add	bx,ax
09419                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
09420                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
09421                                           ! Debug: list * unsigned char = bx-$243 (used reg = )
09422 29CF           81C3                 FDBD  add	bx,#-$243
09423 29D3           53                         push	bx
09424                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09425 29D4           E8         DC76            call	_get_SS
09426                                           ! Debug: list unsigned short = ax+0 (used reg = )
09427 29D7           50                         push	ax
09428                                           ! Debug: func () void = write_byte+0 (used reg = )
09429 29D8           E8         DC3F            call	_write_byte
09430 29DB           83C4                   06  add	sp,*6
09431                                           !BCC_EOS
09432                                           ! 1742           }
09433                                           ! 1743           write_byte(get_SS(),model+40,0x00);
09434                       000029DE            .208:
09435                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09436 29DE           8A86       FDE6            mov	al,-$21A[bp]
09437 29E2           40                         inc	ax
09438 29E3           8886       FDE6            mov	-$21A[bp],al
09439                       000029E7            .209:
09440                                           ! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
09441 29E7           8A86       FDE6            mov	al,-$21A[bp]
09442 29EB           3C                     14  cmp	al,*$14
09443 29ED         0F82         FF7B            blo 	.20A
09444                       000029F1            .20B:
09445                       000029F1            .207:
09446                                           ! Debug: list int = const 0 (used reg = )
09447 29F1           31C0                       xor	ax,ax
09448 29F3           50                         push	ax
09449                                           ! Debug: list * unsigned char model = S+$248-$21E (used reg = )
09450 29F4           8D9E       FDE4            lea	bx,-$21C[bp]
09451 29F8           53                         push	bx
09452                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09453 29F9           E8         DC51            call	_get_SS
09454                                           ! Debug: list unsigned short = ax+0 (used reg = )
09455 29FC           50                         push	ax
09456                                           ! Debug: func () void = write_byte+0 (used reg = )
09457 29FD           E8         DC1A            call	_write_byte
09458 2A00           83C4                   06  add	sp,*6
09459                                           !BCC_EOS
09460                                           ! 1744           for(i=39;i>0;i--){
09461                                           ! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
09462 2A03           B0                     27  mov	al,*$27
09463 2A05           8886       FDE6            mov	-$21A[bp],al
09464                                           !BCC_EOS
09465                                           !BCC_EOS
09466 2A09           EB           46            jmp .20E
09467                       00002A0B            .20F:
09468                                           ! 1745             if(read_byte(get_SS(),model+i)==0x20)
09469                                           ! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
09470 2A0B           8A86       FDE6            mov	al,-$21A[bp]
09471 2A0F           30E4                       xor	ah,ah
09472 2A11           89EB                       mov	bx,bp
09473 2A13           01C3                       add	bx,ax
09474                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09475                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09476 2A15           81C3                 FDBC  add	bx,#-$244
09477 2A19           53                         push	bx
09478                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09479 2A1A           E8         DC30            call	_get_SS
09480                                           ! Debug: list unsigned short = ax+0 (used reg = )
09481 2A1D           50                         push	ax
09482                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09483 2A1E           E8         DBD3            call	_read_byte
09484 2A21           83C4                   04  add	sp,*4
09485                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
09486 2A24           3C                     20  cmp	al,*$20
09487 2A26           75           1E            jne 	.210
09488                       00002A28            .211:
09489                                           ! 1746               write_byte(get_SS(),model+i,0x00);
09490                                           ! Debug: list int = const 0 (used reg = )
09491 2A28           31C0                       xor	ax,ax
09492 2A2A           50                         push	ax
09493                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09494 2A2B           8A86       FDE6            mov	al,-$21A[bp]
09495 2A2F           30E4                       xor	ah,ah
09496 2A31           89EB                       mov	bx,bp
09497 2A33           01C3                       add	bx,ax
09498                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09499                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09500 2A35           81C3                 FDBC  add	bx,#-$244
09501 2A39           53                         push	bx
09502                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09503 2A3A           E8         DC10            call	_get_SS
09504                                           ! Debug: list unsigned short = ax+0 (used reg = )
09505 2A3D           50                         push	ax
09506                                           ! Debug: func () void = write_byte+0 (used reg = )
09507 2A3E           E8         DBD9            call	_write_byte
09508 2A41           83C4                   06  add	sp,*6
09509                                           !BCC_EOS
09510                                           ! 1747             else break;
09511 2A44           EB           02            jmp .212
09512                       00002A46            .210:
09513 2A46           EB           11            jmp .20C
09514                                           !BCC_EOS
09515                                           ! 1748           }
09516                       00002A48            .212:
09517                                           ! 1749           if (i>36) {
09518                       00002A48            .20D:
09519                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09520 2A48           8A86       FDE6            mov	al,-$21A[bp]
09521 2A4C           48                         dec	ax
09522 2A4D           8886       FDE6            mov	-$21A[bp],al
09523                       00002A51            .20E:
09524                                           ! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09525 2A51           8A86       FDE6            mov	al,-$21A[bp]
09526 2A55           84C0                       test	al,al
09527 2A57           75           B2            jne	.20F
09528                       00002A59            .213:
09529                       00002A59            .20C:
09530                                           ! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
09531 2A59           8A86       FDE6            mov	al,-$21A[bp]
09532 2A5D           3C                     24  cmp	al,*$24
09533 2A5F           76           48            jbe 	.214
09534                       00002A61            .215:
09535                                           ! 1750           
09536                                           ! 1750   write_byte(get_SS(),model+36,0x00);
09537                                           ! Debug: list int = const 0 (used reg = )
09538 2A61           31C0                       xor	ax,ax
09539 2A63           50                         push	ax
09540                                           ! Debug: list * unsigned char model = S+$248-$222 (used reg = )
09541 2A64           8D9E       FDE0            lea	bx,-$220[bp]
09542 2A68           53                         push	bx
09543                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09544 2A69           E8         DBE1            call	_get_SS
09545                                           ! Debug: list unsigned short = ax+0 (used reg = )
09546 2A6C           50                         push	ax
09547                                           ! Debug: func () void = write_byte+0 (used reg = )
09548 2A6D           E8         DBAA            call	_write_byte
09549 2A70           83C4                   06  add	sp,*6
09550                                           !BCC_EOS
09551                                           ! 1751             for(i=35;i>32;i--){
09552                                           ! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
09553 2A73           B0                     23  mov	al,*$23
09554 2A75           8886       FDE6            mov	-$21A[bp],al
09555                                           !BCC_EOS
09556                                           !BCC_EOS
09557 2A79           EB           26            jmp .218
09558                       00002A7B            .219:
09559                                           ! 1752               write_byte(get_SS(),model+i,0x2E);
09560                                           ! Debug: list int = const $2E (used reg = )
09561 2A7B           B8                   002E  mov	ax,*$2E
09562 2A7E           50                         push	ax
09563                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09564 2A7F           8A86       FDE6            mov	al,-$21A[bp]
09565 2A83           30E4                       xor	ah,ah
09566 2A85           89EB                       mov	bx,bp
09567 2A87           01C3                       add	bx,ax
09568                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09569                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09570 2A89           81C3                 FDBC  add	bx,#-$244
09571 2A8D           53                         push	bx
09572                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09573 2A8E           E8         DBBC            call	_get_SS
09574                                           ! Debug: list unsigned short = ax+0 (used reg = )
09575 2A91           50                         push	ax
09576                                           ! Debug: func () void = write_byte+0 (used reg = )
09577 2A92           E8         DB85            call	_write_byte
09578 2A95           83C4                   06  add	sp,*6
09579                                           !BCC_EOS
09580                                           ! 1753             }
09581                                           ! 1754           }
09582                       00002A98            .217:
09583                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09584 2A98           8A86       FDE6            mov	al,-$21A[bp]
09585 2A9C           48                         dec	ax
09586 2A9D           8886       FDE6            mov	-$21A[bp],al
09587                       00002AA1            .218:
09588                                           ! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
09589 2AA1           8A86       FDE6            mov	al,-$21A[bp]
09590 2AA5           3C                     20  cmp	al,*$20
09591 2AA7           77           D2            ja 	.219
09592                       00002AA9            .21A:
09593                       00002AA9            .216:
09594                                           ! 1755           break;
09595                       00002AA9            .214:
09596 2AA9           EB           0E            jmp .1FB
09597                                           !BCC_EOS
09598                                           ! 1756         }
09599                                           ! 1757       switch (type) {
09600 2AAB           EB           0C            jmp .1FB
09601                       00002AAD            .1FD:
09602 2AAD           2C                     02  sub	al,*2
09603 2AAF         0F84         FDEE            beq 	.1FE
09604 2AB3           2C                     01  sub	al,*1
09605 2AB5         0F84         FE49            beq 	.1FF
09606                       00002AB9            .1FB:
09607                       FFFFFDBA            ..FFFC	=	-$246
09608 2AB9           8A46         FA            mov	al,-6[bp]
09609 2ABC           E9         01A2            br 	.21D
09610                                           ! 1758         case 0x02:
09611                                           ! 1759           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09612                       00002ABF            .21E:
09613 2ABF           8A86       FDF4            mov	al,-$20C[bp]
09614 2AC3           84C0                       test	al,al
09615 2AC5           74           05            je  	.222
09616                       00002AC7            .223:
09617 2AC7           BB                   D41C  mov	bx,#.220
09618 2ACA           EB           03            jmp .224
09619                       00002ACC            .222:
09620 2ACC           BB                   D415  mov	bx,#.221
09621                       00002ACF            .224:
09622                                           ! Debug: list * char = bx+0 (used reg = )
09623 2ACF           53                         push	bx
09624                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09625 2AD0           8A86       FDF5            mov	al,-$20B[bp]
09626 2AD4           30E4                       xor	ah,ah
09627 2AD6           50                         push	ax
09628                                           ! Debug: list * char = .21F+0 (used reg = )
09629 2AD7           BB                   D423  mov	bx,#.21F
09630 2ADA           53                         push	bx
09631                                           ! Debug: list int = const 2 (used reg = )
09632 2ADB           B8                   0002  mov	ax,*2
09633 2ADE           50                         push	ax
09634                                           ! Debug: func () void = bios_printf+0 (used reg = )
09635 2ADF           E8         DF39            call	_bios_printf
09636 2AE2           83C4                   08  add	sp,*8
09637                                           !BCC_EOS
09638                                           ! 1760           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09639                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09640 2AE5           30C0                       xor	al,al
09641 2AE7           8886       FDE6            mov	-$21A[bp],al
09642                                           !BCC_EOS
09643 2AEB           EB           15            jmp .226
09644                       00002AED            .227:
09645                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09646 2AED           8A86       FDE7            mov	al,-$219[bp]
09647 2AF1           30E4                       xor	ah,ah
09648 2AF3           50                         push	ax
09649                                           ! Debug: list * char = .228+0 (used reg = )
09650 2AF4           BB                   D412  mov	bx,#.228
09651 2AF7           53                         push	bx
09652                                           ! Debug: list int = const 2 (used reg = )
09653 2AF8           B8                   0002  mov	ax,*2
09654 2AFB           50                         push	ax
09655                                           ! Debug: func () void = bios_printf+0 (used reg = )
09656 2AFC           E8         DF1C            call	_bios_printf
09657 2AFF           83C4                   06  add	sp,*6
09658                                           !BCC_EOS
09659                                           ! 1761    if (sizeinmb < (1UL<<16))
09660                       00002B02            .226:
09661                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09662 2B02           8A86       FDE6            mov	al,-$21A[bp]
09663 2B06           40                         inc	ax
09664 2B07           8886       FDE6            mov	-$21A[bp],al
09665                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09666 2B0B           48                         dec	ax
09667 2B0C           30E4                       xor	ah,ah
09668 2B0E           89EB                       mov	bx,bp
09669 2B10           01C3                       add	bx,ax
09670                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09671                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09672 2B12           81C3                 FDBC  add	bx,#-$244
09673 2B16           53                         push	bx
09674                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09675 2B17           E8         DB33            call	_get_SS
09676                                           ! Debug: list unsigned short = ax+0 (used reg = )
09677 2B1A           50                         push	ax
09678                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09679 2B1B           E8         DAD6            call	_read_byte
09680 2B1E           83C4                   04  add	sp,*4
09681                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09682 2B21           8886       FDE7            mov	-$219[bp],al
09683 2B25           84C0                       test	al,al
09684 2B27           75           C4            jne	.227
09685                       00002B29            .229:
09686                       00002B29            .225:
09687                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09688 2B29           31C0                       xor	ax,ax
09689 2B2B           BB                   0001  mov	bx,*1
09690 2B2E           8DBE       FDEA            lea	di,-$216[bp]
09691 2B32           E8         D596            call	lcmpul
09692 2B35           76           1B            jbe 	.22A
09693                       00002B37            .22B:
09694                                           ! 1762             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09695                                           ! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
09696 2B37           FFB6       FDEA            push	-$216[bp]
09697                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09698 2B3B           8A86       FDE5            mov	al,-$21B[bp]
09699 2B3F           30E4                       xor	ah,ah
09700 2B41           50                         push	ax
09701                                           ! Debug: list * char = .22C+0 (used reg = )
09702 2B42           BB                   D3F2  mov	bx,#.22C
09703 2B45           53                         push	bx
09704                                           ! Debug: list int = const 2 (used reg = )
09705 2B46           B8                   0002  mov	ax,*2
09706 2B49           50                         push	ax
09707                                           ! Debug: func () void = bios_printf+0 (used reg = )
09708 2B4A           E8         DECE            call	_bios_printf
09709 2B4D           83C4                   08  add	sp,*8
09710                                           !BCC_EOS
09711                                           ! 1763    else
09712                                           ! 1764             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09713 2B50           EB           2C            jmp .22D
09714                       00002B52            .22A:
09715                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09716 2B52           8B86       FDEA            mov	ax,-$216[bp]
09717 2B56           8B9E       FDEC            mov	bx,-$214[bp]
09718 2B5A           88E0                       mov	al,ah
09719 2B5C           88DC                       mov	ah,bl
09720 2B5E           88FB                       mov	bl,bh
09721 2B60           28FF                       sub	bh,bh
09722 2B62           BF                   0002  mov	di,*2
09723 2B65           E8         D5C1            call	lsrul
09724                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09725                                           ! Debug: list unsigned short = ax+0 (used reg = )
09726 2B68           50                         push	ax
09727                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09728 2B69           8A86       FDE5            mov	al,-$21B[bp]
09729 2B6D           30E4                       xor	ah,ah
09730 2B6F           50                         push	ax
09731                                           ! Debug: list * char = .22E+0 (used reg = )
09732 2B70           BB                   D3D2  mov	bx,#.22E
09733 2B73           53                         push	bx
09734                                           ! Debug: list int = const 2 (used reg = )
09735 2B74           B8                   0002  mov	ax,*2
09736 2B77           50                         push	ax
09737                                           ! Debug: func () void = bios_printf+0 (used reg = )
09738 2B78           E8         DEA0            call	_bios_printf
09739 2B7B           83C4                   08  add	sp,*8
09740                                           !BCC_EOS
09741                                           ! 1765           break;
09742                       00002B7E            .22D:
09743 2B7E           E9         00F0            br 	.21B
09744                                           !BCC_EOS
09745                                           ! 1766         case 0x03:
09746                                           ! 1767           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09747                       00002B81            .22F:
09748 2B81           8A86       FDF4            mov	al,-$20C[bp]
09749 2B85           84C0                       test	al,al
09750 2B87           74           05            je  	.233
09751                       00002B89            .234:
09752 2B89           BB                   D3C0  mov	bx,#.231
09753 2B8C           EB           03            jmp .235
09754                       00002B8E            .233:
09755 2B8E           BB                   D3B9  mov	bx,#.232
09756                       00002B91            .235:
09757                                           ! Debug: list * char = bx+0 (used reg = )
09758 2B91           53                         push	bx
09759                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09760 2B92           8A86       FDF5            mov	al,-$20B[bp]
09761 2B96           30E4                       xor	ah,ah
09762 2B98           50                         push	ax
09763                                           ! Debug: list * char = .230+0 (used reg = )
09764 2B99           BB                   D3C7  mov	bx,#.230
09765 2B9C           53                         push	bx
09766                                           ! Debug: list int = const 2 (used reg = )
09767 2B9D           B8                   0002  mov	ax,*2
09768 2BA0           50                         push	ax
09769                                           ! Debug: func () void = bios_printf+0 (used reg = )
09770 2BA1           E8         DE77            call	_bios_printf
09771 2BA4           83C4                   08  add	sp,*8
09772                                           !BCC_EOS
09773                                           ! 1768           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09774                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09775 2BA7           30C0                       xor	al,al
09776 2BA9           8886       FDE6            mov	-$21A[bp],al
09777                                           !BCC_EOS
09778 2BAD           EB           15            jmp .237
09779                       00002BAF            .238:
09780                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09781 2BAF           8A86       FDE7            mov	al,-$219[bp]
09782 2BB3           30E4                       xor	ah,ah
09783 2BB5           50                         push	ax
09784                                           ! Debug: list * char = .239+0 (used reg = )
09785 2BB6           BB                   D3B6  mov	bx,#.239
09786 2BB9           53                         push	bx
09787                                           ! Debug: list int = const 2 (used reg = )
09788 2BBA           B8                   0002  mov	ax,*2
09789 2BBD           50                         push	ax
09790                                           ! Debug: func () void = bios_printf+0 (used reg = )
09791 2BBE           E8         DE5A            call	_bios_printf
09792 2BC1           83C4                   06  add	sp,*6
09793                                           !BCC_EOS
09794                                           ! 1769           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
09795                       00002BC4            .237:
09796                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09797 2BC4           8A86       FDE6            mov	al,-$21A[bp]
09798 2BC8           40                         inc	ax
09799 2BC9           8886       FDE6            mov	-$21A[bp],al
09800                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09801 2BCD           48                         dec	ax
09802 2BCE           30E4                       xor	ah,ah
09803 2BD0           89EB                       mov	bx,bp
09804 2BD2           01C3                       add	bx,ax
09805                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09806                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09807 2BD4           81C3                 FDBC  add	bx,#-$244
09808 2BD8           53                         push	bx
09809                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09810 2BD9           E8         DA71            call	_get_SS
09811                                           ! Debug: list unsigned short = ax+0 (used reg = )
09812 2BDC           50                         push	ax
09813                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09814 2BDD           E8         DA14            call	_read_byte
09815 2BE0           83C4                   04  add	sp,*4
09816                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09817 2BE3           8886       FDE7            mov	-$219[bp],al
09818 2BE7           84C0                       test	al,al
09819 2BE9           75           C4            jne	.238
09820                       00002BEB            .23A:
09821                       00002BEB            .236:
09822                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09823 2BEB           8A46         FB            mov	al,-5[bp]
09824 2BEE           30E4                       xor	ah,ah
09825 2BF0           B9                   001E  mov	cx,*$1E
09826 2BF3           F7E9                       imul	cx
09827 2BF5           89C3                       mov	bx,ax
09828                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09829                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09830 2BF7           81C3                 0143  add	bx,#$143
09831 2BFB           53                         push	bx
09832                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09833 2BFC           FF76         FE            push	-2[bp]
09834                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09835 2BFF           E8         D9F2            call	_read_byte
09836 2C02           83C4                   04  add	sp,*4
09837                                           ! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
09838 2C05           3C                     05  cmp	al,*5
09839 2C07           75           17            jne 	.23B
09840                       00002C09            .23C:
09841                                           ! 1770             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09842                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09843 2C09           8A86       FDE5            mov	al,-$21B[bp]
09844 2C0D           30E4                       xor	ah,ah
09845 2C0F           50                         push	ax
09846                                           ! Debug: list * char = .23D+0 (used reg = )
09847 2C10           BB                   D39C  mov	bx,#.23D
09848 2C13           53                         push	bx
09849                                           ! Debug: list int = const 2 (used reg = )
09850 2C14           B8                   0002  mov	ax,*2
09851 2C17           50                         push	ax
09852                                           ! Debug: func () void = bios_printf+0 (used reg = )
09853 2C18           E8         DE00            call	_bios_printf
09854 2C1B           83C4                   06  add	sp,*6
09855                                           !BCC_EOS
09856                                           ! 1771           else
09857                                           ! 1772             bios_printf(2, " ATAPI-%d Device\n",version);
09858 2C1E           EB           15            jmp .23E
09859                       00002C20            .23B:
09860                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09861 2C20           8A86       FDE5            mov	al,-$21B[bp]
09862 2C24           30E4                       xor	ah,ah
09863 2C26           50                         push	ax
09864                                           ! Debug: list * char = .23F+0 (used reg = )
09865 2C27           BB                   D38A  mov	bx,#.23F
09866 2C2A           53                         push	bx
09867                                           ! Debug: list int = const 2 (used reg = )
09868 2C2B           B8                   0002  mov	ax,*2
09869 2C2E           50                         push	ax
09870                                           ! Debug: func () void = bios_printf+0 (used reg = )
09871 2C2F           E8         DDE9            call	_bios_printf
09872 2C32           83C4                   06  add	sp,*6
09873                                           !BCC_EOS
09874                                           ! 1773           break;
09875                       00002C35            .23E:
09876 2C35           EB           3A            jmp .21B
09877                                           !BCC_EOS
09878                                           ! 1774         case 0x01:
09879                                           ! 1775           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
09880                       00002C37            .240:
09881 2C37           8A86       FDF4            mov	al,-$20C[bp]
09882 2C3B           84C0                       test	al,al
09883 2C3D           74           05            je  	.244
09884                       00002C3F            .245:
09885 2C3F           BB                   D369  mov	bx,#.242
09886 2C42           EB           03            jmp .246
09887                       00002C44            .244:
09888 2C44           BB                   D362  mov	bx,#.243
09889                       00002C47            .246:
09890                                           ! Debug: list * char = bx+0 (used reg = )
09891 2C47           53                         push	bx
09892                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09893 2C48           8A86       FDF5            mov	al,-$20B[bp]
09894 2C4C           30E4                       xor	ah,ah
09895 2C4E           50                         push	ax
09896                                           ! Debug: list * char = .241+0 (used reg = )
09897 2C4F           BB                   D370  mov	bx,#.241
09898 2C52           53                         push	bx
09899                                           ! Debug: list int = const 2 (used reg = )
09900 2C53           B8                   0002  mov	ax,*2
09901 2C56           50                         push	ax
09902                                           ! Debug: func () void = bios_printf+0 (used reg = )
09903 2C57           E8         DDC1            call	_bios_printf
09904 2C5A           83C4                   08  add	sp,*8
09905                                           !BCC_EOS
09906                                           ! 1776           break;
09907 2C5D           EB           12            jmp .21B
09908                                           !BCC_EOS
09909                                           ! 1777         }
09910                                           ! 1778       }
09911 2C5F           EB           10            jmp .21B
09912                       00002C61            .21D:
09913 2C61           2C                     01  sub	al,*1
09914 2C63           74           D2            je 	.240
09915 2C65           2C                     01  sub	al,*1
09916 2C67         0F84         FE54            beq 	.21E
09917 2C6B           2C                     01  sub	al,*1
09918 2C6D         0F84         FF10            beq 	.22F
09919                       00002C71            .21B:
09920                       FFFFFDBA            ..FFFB	=	-$246
09921 2C71           83C4                   32  add	sp,*$32
09922                                           ! 1779     }
09923 2C74           83C4                   0C  add	sp,*$C
09924                                           ! 1780   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
09925                       00002C77            .19C:
09926                                           ! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
09927 2C77           8A46         FB            mov	al,-5[bp]
09928 2C7A           40                         inc	ax
09929 2C7B           8846         FB            mov	-5[bp],al
09930                       00002C7E            .19D:
09931                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
09932 2C7E           8A46         FB            mov	al,-5[bp]
09933 2C81           3C                     08  cmp	al,*8
09934 2C83         0F82         F2BE            blo 	.19E
09935                       00002C87            .247:
09936                       00002C87            .19B:
09937                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09938 2C87           8A46         FD            mov	al,-3[bp]
09939 2C8A           30E4                       xor	ah,ah
09940 2C8C           50                         push	ax
09941                                           ! Debug: list * unsigned char = const $232 (used reg = )
09942 2C8D           B8                   0232  mov	ax,#$232
09943 2C90           50                         push	ax
09944                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09945 2C91           FF76         FE            push	-2[bp]
09946                                           ! Debug: func () void = write_byte+0 (used reg = )
09947 2C94           E8         D983            call	_write_byte
09948 2C97           83C4                   06  add	sp,*6
09949                                           !BCC_EOS
09950                                           ! 1781   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
09951                                           ! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
09952 2C9A           8A46         FC            mov	al,-4[bp]
09953 2C9D           30E4                       xor	ah,ah
09954 2C9F           50                         push	ax
09955                                           ! Debug: list * unsigned char = const $23B (used reg = )
09956 2CA0           B8                   023B  mov	ax,#$23B
09957 2CA3           50                         push	ax
09958                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09959 2CA4           FF76         FE            push	-2[bp]
09960                                           ! Debug: func () void = write_byte+0 (used reg = )
09961 2CA7           E8         D970            call	_write_byte
09962 2CAA           83C4                   06  add	sp,*6
09963                                           !BCC_EOS
09964                                           ! 1782   write_byte(0x40,0x75, hdcount);
09965                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09966 2CAD           8A46         FD            mov	al,-3[bp]
09967 2CB0           30E4                       xor	ah,ah
09968 2CB2           50                         push	ax
09969                                           ! Debug: list int = const $75 (used reg = )
09970 2CB3           B8                   0075  mov	ax,*$75
09971 2CB6           50                         push	ax
09972                                           ! Debug: list int = const $40 (used reg = )
09973 2CB7           B8                   0040  mov	ax,*$40
09974 2CBA           50                         push	ax
09975                                           ! Debug: func () void = write_byte+0 (used reg = )
09976 2CBB           E8         D95C            call	_write_byte
09977 2CBE           83C4                   06  add	sp,*6
09978                                           !BCC_EOS
09979                                           ! 1783   bios_printf(2, "\n");
09980                                           ! Debug: list * char = .248+0 (used reg = )
09981 2CC1           BB                   D360  mov	bx,#.248
09982 2CC4           53                         push	bx
09983                                           ! Debug: list int = const 2 (used reg = )
09984 2CC5           B8                   0002  mov	ax,*2
09985 2CC8           50                         push	ax
09986                                           ! Debug: func () void = bios_printf+0 (used reg = )
09987 2CC9           E8         DD4F            call	_bios_printf
09988 2CCC           83C4                   04  add	sp,*4
09989                                           !BCC_EOS
09990                                           ! 1784 }
09991 2CCF           89EC                       mov	sp,bp
09992 2CD1           5D                         pop	bp
09993 2CD2           C3                         ret
09994                                           ! 1785 void ata_reset(device)
09995                                           ! Register BX used in function ata_detect
09996                                           ! 1786 Bit16u device;
09997                                           export	_ata_reset
09998                       00002CD3            _ata_reset:
09999                                           !BCC_EOS
10000                                           ! 1787 {
10001                                           ! 1788   Bit16u ebda_seg=read_word(0x0040,0x000E);
10002 2CD3           55                         push	bp
10003 2CD4           89E5                       mov	bp,sp
10004 2CD6           4C                         dec	sp
10005 2CD7           4C                         dec	sp
10006                                           ! Debug: list int = const $E (used reg = )
10007 2CD8           B8                   000E  mov	ax,*$E
10008 2CDB           50                         push	ax
10009                                           ! Debug: list int = const $40 (used reg = )
10010 2CDC           B8                   0040  mov	ax,*$40
10011 2CDF           50                         push	ax
10012                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10013 2CE0           E8         D924            call	_read_word
10014 2CE3           83C4                   04  add	sp,*4
10015                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10016 2CE6           8946         FE            mov	-2[bp],ax
10017                                           !BCC_EOS
10018                                           ! 1789   Bit16u iobase1, iobase2;
10019                                           !BCC_EOS
10020                                           ! 1790   Bit8u channel, slave, sn, sc;
10021                                           !BCC_EOS
10022                                           ! 1791   Bit8u type;
10023                                           !BCC_EOS
10024                                           ! 1792   Bit16u max;
10025                                           !BCC_EOS
10026                                           ! 1793   channel = device / 2;
10027 2CE9           83C4                   F4  add	sp,*-$C
10028                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10029 2CEC           8B46         04            mov	ax,4[bp]
10030 2CEF           D1E8                       shr	ax,*1
10031                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
10032 2CF1           8846         F9            mov	-7[bp],al
10033                                           !BCC_EOS
10034                                           ! 1794   slave = device % 2;
10035                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10036 2CF4           8B46         04            mov	ax,4[bp]
10037 2CF7           24                     01  and	al,*1
10038                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
10039 2CF9           8846         F8            mov	-8[bp],al
10040                                           !BCC_EOS
10041                                           ! 1795   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10042                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
10043 2CFC           8A46         F9            mov	al,-7[bp]
10044 2CFF           30E4                       xor	ah,ah
10045 2D01           B1                     03  mov	cl,*3
10046 2D03           D3E0                       shl	ax,cl
10047 2D05           89C3                       mov	bx,ax
10048                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10049                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10050 2D07           81C3                 0124  add	bx,#$124
10051 2D0B           53                         push	bx
10052                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10053 2D0C           FF76         FE            push	-2[bp]
10054                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10055 2D0F           E8         D8F5            call	_read_word
10056 2D12           83C4                   04  add	sp,*4
10057                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10058 2D15           8946         FC            mov	-4[bp],ax
10059                                           !BCC_EOS
10060                                           ! 1796   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10061                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
10062 2D18           8A46         F9            mov	al,-7[bp]
10063 2D1B           30E4                       xor	ah,ah
10064 2D1D           B1                     03  mov	cl,*3
10065 2D1F           D3E0                       shl	ax,cl
10066 2D21           89C3                       mov	bx,ax
10067                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10068                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10069 2D23           81C3                 0126  add	bx,#$126
10070 2D27           53                         push	bx
10071                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10072 2D28           FF76         FE            push	-2[bp]
10073                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10074 2D2B           E8         D8D9            call	_read_word
10075 2D2E           83C4                   04  add	sp,*4
10076                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10077 2D31           8946         FA            mov	-6[bp],ax
10078                                           !BCC_EOS
10079                                           ! 1797   outb(iobase2+6, 0x08 | 0x02 | 0x04);
10080                                           ! Debug: list int = const $E (used reg = )
10081 2D34           B8                   000E  mov	ax,*$E
10082 2D37           50                         push	ax
10083                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10084 2D38           8B46         FA            mov	ax,-6[bp]
10085                                           ! Debug: list unsigned int = ax+6 (used reg = )
10086 2D3B           05                   0006  add	ax,*6
10087 2D3E           50                         push	ax
10088                                           ! Debug: func () void = outb+0 (used reg = )
10089 2D3F           E8         D812            call	_outb
10090 2D42           83C4                   04  add	sp,*4
10091                                           !BCC_EOS
10092                                           ! 1798   outb(0x80, 0x00);
10093                                           ! Debug: list int = const 0 (used reg = )
10094 2D45           31C0                       xor	ax,ax
10095 2D47           50                         push	ax
10096                                           ! Debug: list int = const $80 (used reg = )
10097 2D48           B8                   0080  mov	ax,#$80
10098 2D4B           50                         push	ax
10099                                           ! Debug: func () void = outb+0 (used reg = )
10100 2D4C           E8         D805            call	_outb
10101 2D4F           83C4                   04  add	sp,*4
10102                                           !BCC_EOS
10103                                           ! 1799   outb(iobase2+6, 0x08 | 0x02);
10104                                           ! Debug: list int = const $A (used reg = )
10105 2D52           B8                   000A  mov	ax,*$A
10106 2D55           50                         push	ax
10107                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10108 2D56           8B46         FA            mov	ax,-6[bp]
10109                                           ! Debug: list unsigned int = ax+6 (used reg = )
10110 2D59           05                   0006  add	ax,*6
10111 2D5C           50                         push	ax
10112                                           ! Debug: func () void = outb+0 (used reg = )
10113 2D5D           E8         D7F4            call	_outb
10114 2D60           83C4                   04  add	sp,*4
10115                                           !BCC_EOS
10116                                           ! 1800   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
10117                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10118 2D63           8B46         04            mov	ax,4[bp]
10119 2D66           B9                   001E  mov	cx,*$1E
10120 2D69           F7E9                       imul	cx
10121 2D6B           89C3                       mov	bx,ax
10122                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
10123                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
10124 2D6D           81C3                 0142  add	bx,#$142
10125 2D71           53                         push	bx
10126                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10127 2D72           FF76         FE            push	-2[bp]
10128                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10129 2D75           E8         D87C            call	_read_byte
10130 2D78           83C4                   04  add	sp,*4
10131                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
10132 2D7B           8846         F5            mov	-$B[bp],al
10133                                           !BCC_EOS
10134                                           ! 1801   if (type != 0x00) {
10135                                           ! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
10136 2D7E           8A46         F5            mov	al,-$B[bp]
10137 2D81           84C0                       test	al,al
10138 2D83         0F84         0084            beq 	.249
10139                       00002D87            .24A:
10140                                           ! 1802     outb(iobase1+6, slave?0xb0:0xa0);
10141 2D87           8A46         F8            mov	al,-8[bp]
10142 2D8A           84C0                       test	al,al
10143 2D8C           74           04            je  	.24B
10144                       00002D8E            .24C:
10145 2D8E           B0                     B0  mov	al,#$B0
10146 2D90           EB           02            jmp .24D
10147                       00002D92            .24B:
10148 2D92           B0                     A0  mov	al,#$A0
10149                       00002D94            .24D:
10150                                           ! Debug: list char = al+0 (used reg = )
10151 2D94           30E4                       xor	ah,ah
10152 2D96           50                         push	ax
10153                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10154 2D97           8B46         FC            mov	ax,-4[bp]
10155                                           ! Debug: list unsigned int = ax+6 (used reg = )
10156 2D9A           05                   0006  add	ax,*6
10157 2D9D           50                         push	ax
10158                                           ! Debug: func () void = outb+0 (used reg = )
10159 2D9E           E8         D7B3            call	_outb
10160 2DA1           83C4                   04  add	sp,*4
10161                                           !BCC_EOS
10162                                           ! 1803     sc = inb(iobase1+2);
10163                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
10164 2DA4           8B46         FC            mov	ax,-4[bp]
10165                                           ! Debug: list unsigned int = ax+2 (used reg = )
10166 2DA7           40                         inc	ax
10167 2DA8           40                         inc	ax
10168 2DA9           50                         push	ax
10169                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10170 2DAA           E8         D791            call	_inb
10171 2DAD           44                         inc	sp
10172 2DAE           44                         inc	sp
10173                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
10174 2DAF           8846         F6            mov	-$A[bp],al
10175                                           !BCC_EOS
10176                                           ! 1804     sn = inb(iobase1+3);
10177                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
10178 2DB2           8B46         FC            mov	ax,-4[bp]
10179                                           ! Debug: list unsigned int = ax+3 (used reg = )
10180 2DB5           05                   0003  add	ax,*3
10181 2DB8           50                         push	ax
10182                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10183 2DB9           E8         D782            call	_inb
10184 2DBC           44                         inc	sp
10185 2DBD           44                         inc	sp
10186                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
10187 2DBE           8846         F7            mov	-9[bp],al
10188                                           !BCC_EOS
10189                                           ! 1805     if ( (sc==0x01) &&
10190                                           ! 1805  (sn==0x01) ) {
10191                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
10192 2DC1           8A46         F6            mov	al,-$A[bp]
10193 2DC4           3C                     01  cmp	al,*1
10194 2DC6           75           32            jne 	.24E
10195                       00002DC8            .250:
10196                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
10197 2DC8           8A46         F7            mov	al,-9[bp]
10198 2DCB           3C                     01  cmp	al,*1
10199 2DCD           75           2B            jne 	.24E
10200                       00002DCF            .24F:
10201                                           ! 1806       if (type == 0x02)
10202                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
10203 2DCF           8A46         F5            mov	al,-$B[bp]
10204 2DD2           3C                     02  cmp	al,*2
10205 2DD4           75           13            jne 	.251
10206                       00002DD6            .252:
10207                                           ! 1807         await_ide(5, iobase1, 32000u);
10208                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10209 2DD6           B8                   7D00  mov	ax,#$7D00
10210 2DD9           50                         push	ax
10211                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10212 2DDA           FF76         FC            push	-4[bp]
10213                                           ! Debug: list int = const 5 (used reg = )
10214 2DDD           B8                   0005  mov	ax,*5
10215 2DE0           50                         push	ax
10216                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10217 2DE1           E8         EED4            call	_await_ide
10218 2DE4           83C4                   06  add	sp,*6
10219                                           !BCC_EOS
10220                                           ! 1808       else
10221                                           ! 1809         await_ide(2, iobase1, 32000u);
10222 2DE7           EB           11            jmp .253
10223                       00002DE9            .251:
10224                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10225 2DE9           B8                   7D00  mov	ax,#$7D00
10226 2DEC           50                         push	ax
10227                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10228 2DED           FF76         FC            push	-4[bp]
10229                                           ! Debug: list int = const 2 (used reg = )
10230 2DF0           B8                   0002  mov	ax,*2
10231 2DF3           50                         push	ax
10232                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10233 2DF4           E8         EEC1            call	_await_ide
10234 2DF7           83C4                   06  add	sp,*6
10235                                           !BCC_EOS
10236                                           ! 1810     }
10237                       00002DFA            .253:
10238                                           ! 1811     await_ide(2, iobase1, 32000u);
10239                       00002DFA            .24E:
10240                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10241 2DFA           B8                   7D00  mov	ax,#$7D00
10242 2DFD           50                         push	ax
10243                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10244 2DFE           FF76         FC            push	-4[bp]
10245                                           ! Debug: list int = const 2 (used reg = )
10246 2E01           B8                   0002  mov	ax,*2
10247 2E04           50                         push	ax
10248                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10249 2E05           E8         EEB0            call	_await_ide
10250 2E08           83C4                   06  add	sp,*6
10251                                           !BCC_EOS
10252                                           ! 1812   }
10253                                           ! 1813   outb(iobase2+6, 0x08);
10254                       00002E0B            .249:
10255                                           ! Debug: list int = const 8 (used reg = )
10256 2E0B           B8                   0008  mov	ax,*8
10257 2E0E           50                         push	ax
10258                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10259 2E0F           8B46         FA            mov	ax,-6[bp]
10260                                           ! Debug: list unsigned int = ax+6 (used reg = )
10261 2E12           05                   0006  add	ax,*6
10262 2E15           50                         push	ax
10263                                           ! Debug: func () void = outb+0 (used reg = )
10264 2E16           E8         D73B            call	_outb
10265 2E19           83C4                   04  add	sp,*4
10266                                           !BCC_EOS
10267                                           ! 1814 }
10268 2E1C           89EC                       mov	sp,bp
10269 2E1E           5D                         pop	bp
10270 2E1F           C3                         ret
10271                                           ! 1815 Bit16u ata_cmd_non_data()
10272                                           ! Register BX used in function ata_reset
10273                                           ! 1816 {return 0;}
10274                                           export	_ata_cmd_non_data
10275                       00002E20            _ata_cmd_non_data:
10276 2E20           55                         push	bp
10277 2E21           89E5                       mov	bp,sp
10278 2E23           31C0                       xor	ax,ax
10279 2E25           5D                         pop	bp
10280 2E26           C3                         ret
10281                                           !BCC_EOS
10282                                           ! 1817 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
10283                                           ! 1818 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10284                                           export	_ata_cmd_data_in
10285                       00002E27            _ata_cmd_data_in:
10286                                           !BCC_EOS
10287                                           ! 1819 Bit32u lba_low, lba_high;
10288                                           !BCC_EOS
10289                                           ! 1820 {
10290                                           ! 1821   Bit16u ebda_seg=read_word(0x0040,0x000E);
10291 2E27           55                         push	bp
10292 2E28           89E5                       mov	bp,sp
10293 2E2A           4C                         dec	sp
10294 2E2B           4C                         dec	sp
10295                                           ! Debug: list int = const $E (used reg = )
10296 2E2C           B8                   000E  mov	ax,*$E
10297 2E2F           50                         push	ax
10298                                           ! Debug: list int = const $40 (used reg = )
10299 2E30           B8                   0040  mov	ax,*$40
10300 2E33           50                         push	ax
10301                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10302 2E34           E8         D7D0            call	_read_word
10303 2E37           83C4                   04  add	sp,*4
10304                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10305 2E3A           8946         FE            mov	-2[bp],ax
10306                                           !BCC_EOS
10307                                           ! 1822   Bit16u iobase1, iobase2, blksize;
10308                                           !BCC_EOS
10309                                           ! 1823   Bit8u channel, slave;
10310                                           !BCC_EOS
10311                                           ! 1824   Bit8u status, current, mode;
10312                                           !BCC_EOS
10313                                           ! 1825   channel = device / 2;
10314 2E3D           83C4                   F4  add	sp,*-$C
10315                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10316 2E40           8B46         04            mov	ax,4[bp]
10317 2E43           D1E8                       shr	ax,*1
10318                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10319 2E45           8846         F7            mov	-9[bp],al
10320                                           !BCC_EOS
10321                                           ! 1826   slave = device % 2;
10322                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10323 2E48           8B46         04            mov	ax,4[bp]
10324 2E4B           24                     01  and	al,*1
10325                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
10326 2E4D           8846         F6            mov	-$A[bp],al
10327                                           !BCC_EOS
10328                                           ! 1827   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10329                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10330 2E50           8A46         F7            mov	al,-9[bp]
10331 2E53           30E4                       xor	ah,ah
10332 2E55           B1                     03  mov	cl,*3
10333 2E57           D3E0                       shl	ax,cl
10334 2E59           89C3                       mov	bx,ax
10335                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10336                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10337 2E5B           81C3                 0124  add	bx,#$124
10338 2E5F           53                         push	bx
10339                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10340 2E60           FF76         FE            push	-2[bp]
10341                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10342 2E63           E8         D7A1            call	_read_word
10343 2E66           83C4                   04  add	sp,*4
10344                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10345 2E69           8946         FC            mov	-4[bp],ax
10346                                           !BCC_EOS
10347                                           ! 1828   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10348                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10349 2E6C           8A46         F7            mov	al,-9[bp]
10350 2E6F           30E4                       xor	ah,ah
10351 2E71           B1                     03  mov	cl,*3
10352 2E73           D3E0                       shl	ax,cl
10353 2E75           89C3                       mov	bx,ax
10354                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10355                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10356 2E77           81C3                 0126  add	bx,#$126
10357 2E7B           53                         push	bx
10358                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10359 2E7C           FF76         FE            push	-2[bp]
10360                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10361 2E7F           E8         D785            call	_read_word
10362 2E82           83C4                   04  add	sp,*4
10363                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10364 2E85           8946         FA            mov	-6[bp],ax
10365                                           !BCC_EOS
10366                                           ! 1829   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
10367                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10368 2E88           8B46         04            mov	ax,4[bp]
10369 2E8B           B9                   001E  mov	cx,*$1E
10370 2E8E           F7E9                       imul	cx
10371 2E90           89C3                       mov	bx,ax
10372                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10373                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
10374 2E92           81C3                 0146  add	bx,#$146
10375 2E96           53                         push	bx
10376                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10377 2E97           FF76         FE            push	-2[bp]
10378                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10379 2E9A           E8         D757            call	_read_byte
10380 2E9D           83C4                   04  add	sp,*4
10381                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
10382 2EA0           8846         F3            mov	-$D[bp],al
10383                                           !BCC_EOS
10384                                           ! 1830   blksize = 0x200;
10385                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
10386 2EA3           B8                   0200  mov	ax,#$200
10387 2EA6           8946         F8            mov	-8[bp],ax
10388                                           !BCC_EOS
10389                                           ! 1831   if (mode == 0x01) blksize>>=2;
10390                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
10391 2EA9           8A46         F3            mov	al,-$D[bp]
10392 2EAC           3C                     01  cmp	al,*1
10393 2EAE           75           0C            jne 	.254
10394                       00002EB0            .255:
10395                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
10396 2EB0           8B46         F8            mov	ax,-8[bp]
10397 2EB3           D1E8                       shr	ax,*1
10398 2EB5           D1E8                       shr	ax,*1
10399 2EB7           8946         F8            mov	-8[bp],ax
10400                                           !BCC_EOS
10401                                           ! 1832   else blksize>>=1;
10402 2EBA           EB           08            jmp .256
10403                       00002EBC            .254:
10404                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
10405 2EBC           8B46         F8            mov	ax,-8[bp]
10406 2EBF           D1E8                       shr	ax,*1
10407 2EC1           8946         F8            mov	-8[bp],ax
10408                                           !BCC_EOS
10409                                           ! 1833   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
10410                       00002EC4            .256:
10411                                           ! Debug: list int = const 0 (used reg = )
10412 2EC4           31C0                       xor	ax,ax
10413 2EC6           50                         push	ax
10414                                           ! Debug: list * unsigned short = const $254 (used reg = )
10415 2EC7           B8                   0254  mov	ax,#$254
10416 2ECA           50                         push	ax
10417                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10418 2ECB           FF76         FE            push	-2[bp]
10419                                           ! Debug: func () void = write_word+0 (used reg = )
10420 2ECE           E8         D761            call	_write_word
10421 2ED1           83C4                   06  add	sp,*6
10422                                           !BCC_EOS
10423                                           ! 1834   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
10424                                           ! Debug: list long = const 0 (used reg = )
10425 2ED4           31C0                       xor	ax,ax
10426 2ED6           31DB                       xor	bx,bx
10427 2ED8           53                         push	bx
10428 2ED9           50                         push	ax
10429                                           ! Debug: list * unsigned long = const $256 (used reg = )
10430 2EDA           B8                   0256  mov	ax,#$256
10431 2EDD           50                         push	ax
10432                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
10433 2EDE           FF76         FE            push	-2[bp]
10434                                           ! Debug: func () void = write_dword+0 (used reg = )
10435 2EE1           E8         D1B7            call	_write_dword
10436 2EE4           83C4                   08  add	sp,*8
10437                                           !BCC_EOS
10438                                           ! 1835   current = 0;
10439                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
10440 2EE7           30C0                       xor	al,al
10441 2EE9           8846         F4            mov	-$C[bp],al
10442                                           !BCC_EOS
10443                                           ! 1836   status = inb(iobase1 + 7);
10444                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10445 2EEC           8B46         FC            mov	ax,-4[bp]
10446                                           ! Debug: list unsigned int = ax+7 (used reg = )
10447 2EEF           05                   0007  add	ax,*7
10448 2EF2           50                         push	ax
10449                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10450 2EF3           E8         D648            call	_inb
10451 2EF6           44                         inc	sp
10452 2EF7           44                         inc	sp
10453                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10454 2EF8           8846         F5            mov	-$B[bp],al
10455                                           !BCC_EOS
10456                                           ! 1837   if (status & 0x80) return 1;
10457                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10458 2EFB           8A46         F5            mov	al,-$B[bp]
10459 2EFE           24                     80  and	al,#$80
10460 2F00           84C0                       test	al,al
10461 2F02           74           07            je  	.257
10462                       00002F04            .258:
10463 2F04           B8                   0001  mov	ax,*1
10464 2F07           89EC                       mov	sp,bp
10465 2F09           5D                         pop	bp
10466 2F0A           C3                         ret
10467                                           !BCC_EOS
10468                                           ! 1838   outb(iobase2 + 6, 0x08 | 0x02);
10469                       00002F0B            .257:
10470                                           ! Debug: list int = const $A (used reg = )
10471 2F0B           B8                   000A  mov	ax,*$A
10472 2F0E           50                         push	ax
10473                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10474 2F0F           8B46         FA            mov	ax,-6[bp]
10475                                           ! Debug: list unsigned int = ax+6 (used reg = )
10476 2F12           05                   0006  add	ax,*6
10477 2F15           50                         push	ax
10478                                           ! Debug: func () void = outb+0 (used reg = )
10479 2F16           E8         D63B            call	_outb
10480 2F19           83C4                   04  add	sp,*4
10481                                           !BCC_EOS
10482                                           ! 1839   if (sector == 0) {
10483                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
10484 2F1C           8B46         0E            mov	ax,$E[bp]
10485 2F1F           85C0                       test	ax,ax
10486 2F21         0F85         0167            bne 	.259
10487                       00002F25            .25A:
10488                                           ! 1840     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
10489                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
10490 2F25           8B46         08            mov	ax,8[bp]
10491 2F28           3D                   0100  cmp	ax,#$100
10492 2F2B           72           04            jb 	.25F
10493 2F2D           B0                     01  mov	al,*1
10494 2F2F           EB           02            jmp	.260
10495                       00002F31            .25F:
10496 2F31           30C0                       xor	al,al
10497                       00002F33            .260:
10498                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
10499 2F33           30E4                       xor	ah,ah
10500 2F35           99                         cwd
10501 2F36           89D3                       mov	bx,dx
10502 2F38           E8         D1D9            call	ltstl
10503 2F3B           75           32            jne 	.25C
10504                       00002F3D            .25E:
10505 2F3D           8B46         14            mov	ax,$14[bp]
10506 2F40           8B5E         16            mov	bx,$16[bp]
10507 2F43           E8         D1CE            call	ltstl
10508 2F46           75           27            jne 	.25C
10509                       00002F48            .25D:
10510                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
10511 2F48           8B46         08            mov	ax,8[bp]
10512 2F4B           31DB                       xor	bx,bx
10513                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
10514                                           ! Debug: expression subtree swapping
10515 2F4D           8D7E         10            lea	di,$10[bp]
10516 2F50           E8         D170            call	laddul
10517                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
10518 2F53           53                         push	bx
10519 2F54           50                         push	ax
10520 2F55           31C0                       xor	ax,ax
10521 2F57           BB                   1000  mov	bx,#$1000
10522 2F5A           53                         push	bx
10523 2F5B           50                         push	ax
10524 2F5C           8B46         EE            mov	ax,-$12[bp]
10525 2F5F           8B5E         F0            mov	bx,-$10[bp]
10526 2F62           8D7E         EA            lea	di,-$16[bp]
10527 2F65           E8         D163            call	lcmpul
10528 2F68           8D66         F2            lea	sp,-$E[bp]
10529 2F6B         0F82         00BC            blo 	.25B
10530                       00002F6F            .25C:
10531                                           ! 1841       outb(iobase1 + 1, 0x00);
10532                                           ! Debug: list int = const 0 (used reg = )
10533 2F6F           31C0                       xor	ax,ax
10534 2F71           50                         push	ax
10535                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10536 2F72           8B46         FC            mov	ax,-4[bp]
10537                                           ! Debug: list unsigned int = ax+1 (used reg = )
10538 2F75           40                         inc	ax
10539 2F76           50                         push	ax
10540                                           ! Debug: func () void = outb+0 (used reg = )
10541 2F77           E8         D5DA            call	_outb
10542 2F7A           83C4                   04  add	sp,*4
10543                                           !BCC_EOS
10544                                           ! 1842       outb(iobase1 + 2, (count >> 8) & 0xff);
10545                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
10546 2F7D           8B46         08            mov	ax,8[bp]
10547 2F80           88E0                       mov	al,ah
10548 2F82           30E4                       xor	ah,ah
10549                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
10550                                           ! Debug: list unsigned char = al+0 (used reg = )
10551 2F84           30E4                       xor	ah,ah
10552 2F86           50                         push	ax
10553                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10554 2F87           8B46         FC            mov	ax,-4[bp]
10555                                           ! Debug: list unsigned int = ax+2 (used reg = )
10556 2F8A           40                         inc	ax
10557 2F8B           40                         inc	ax
10558 2F8C           50                         push	ax
10559                                           ! Debug: func () void = outb+0 (used reg = )
10560 2F8D           E8         D5C4            call	_outb
10561 2F90           83C4                   04  add	sp,*4
10562                                           !BCC_EOS
10563                                           ! 1843       outb(iobase1 + 3, lba_low >> 24);
10564                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10565 2F93           8B46         10            mov	ax,$10[bp]
10566 2F96           8B5E         12            mov	bx,$12[bp]
10567 2F99           93                         xchg	bx,ax
10568 2F9A           88E0                       mov	al,ah
10569 2F9C           30E4                       xor	ah,ah
10570 2F9E           31DB                       xor	bx,bx
10571                                           ! Debug: list unsigned long = bx+0 (used reg = )
10572 2FA0           53                         push	bx
10573 2FA1           50                         push	ax
10574                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
10575 2FA2           8B46         FC            mov	ax,-4[bp]
10576                                           ! Debug: list unsigned int = ax+3 (used reg = )
10577 2FA5           05                   0003  add	ax,*3
10578 2FA8           50                         push	ax
10579                                           ! Debug: func () void = outb+0 (used reg = )
10580 2FA9           E8         D5A8            call	_outb
10581 2FAC           83C4                   06  add	sp,*6
10582                                           !BCC_EOS
10583                                           ! 1844       outb(iobase1 + 4, lba_high & 0xff);
10584                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
10585                                           ! Debug: expression subtree swapping
10586 2FAF           B8                   00FF  mov	ax,#$FF
10587 2FB2           31DB                       xor	bx,bx
10588 2FB4           8D7E         14            lea	di,$14[bp]
10589 2FB7           E8         D101            call	landul
10590                                           ! Debug: list unsigned long = bx+0 (used reg = )
10591 2FBA           53                         push	bx
10592 2FBB           50                         push	ax
10593                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
10594 2FBC           8B46         FC            mov	ax,-4[bp]
10595                                           ! Debug: list unsigned int = ax+4 (used reg = )
10596 2FBF           05                   0004  add	ax,*4
10597 2FC2           50                         push	ax
10598                                           ! Debug: func () void = outb+0 (used reg = )
10599 2FC3           E8         D58E            call	_outb
10600 2FC6           83C4                   06  add	sp,*6
10601                                           !BCC_EOS
10602                                           ! 1845       outb(iobase1 + 5, lba_high >> 8);
10603                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
10604 2FC9           8B46         14            mov	ax,$14[bp]
10605 2FCC           8B5E         16            mov	bx,$16[bp]
10606 2FCF           88E0                       mov	al,ah
10607 2FD1           88DC                       mov	ah,bl
10608 2FD3           88FB                       mov	bl,bh
10609 2FD5           28FF                       sub	bh,bh
10610                                           ! Debug: list unsigned long = bx+0 (used reg = )
10611 2FD7           53                         push	bx
10612 2FD8           50                         push	ax
10613                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
10614 2FD9           8B46         FC            mov	ax,-4[bp]
10615                                           ! Debug: list unsigned int = ax+5 (used reg = )
10616 2FDC           05                   0005  add	ax,*5
10617 2FDF           50                         push	ax
10618                                           ! Debug: func () void = outb+0 (used reg = )
10619 2FE0           E8         D571            call	_outb
10620 2FE3           83C4                   06  add	sp,*6
10621                                           !BCC_EOS
10622                                           ! 1846       command |= 0x04;
10623                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
10624 2FE6           8B46         06            mov	ax,6[bp]
10625 2FE9           0C                     04  or	al,*4
10626 2FEB           8946         06            mov	6[bp],ax
10627                                           !BCC_EOS
10628                                           ! 1847       count &= (1UL << 8) - 1;
10629                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
10630 2FEE           8B46         08            mov	ax,8[bp]
10631 2FF1           31DB                       xor	bx,bx
10632 2FF3           53                         push	bx
10633 2FF4           50                         push	ax
10634 2FF5           B8                   00FF  mov	ax,#$FF
10635 2FF8           31DB                       xor	bx,bx
10636 2FFA           53                         push	bx
10637 2FFB           50                         push	ax
10638 2FFC           8B46         EE            mov	ax,-$12[bp]
10639 2FFF           8B5E         F0            mov	bx,-$10[bp]
10640 3002           8D7E         EA            lea	di,-$16[bp]
10641 3005           E8         D0B3            call	landul
10642 3008           8946         08            mov	8[bp],ax
10643 300B           83C4                   08  add	sp,*8
10644                                           !BCC_EOS
10645                                           ! 1848       lba_low &= (1UL << 24) - 1;
10646                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
10647 300E           B8                   FFFF  mov	ax,#$FFFF
10648 3011           BB                   00FF  mov	bx,#$FF
10649 3014           53                         push	bx
10650 3015           50                         push	ax
10651 3016           8B46         10            mov	ax,$10[bp]
10652 3019           8B5E         12            mov	bx,$12[bp]
10653 301C           8D7E         EE            lea	di,-$12[bp]
10654 301F           E8         D099            call	landul
10655 3022           8946         10            mov	$10[bp],ax
10656 3025           895E         12            mov	$12[bp],bx
10657 3028           83C4                   04  add	sp,*4
10658                                           !BCC_EOS
10659                                           ! 1849       }
10660                                           ! 1850     sector = (Bit16u) (lba_low & 0x000000ffL);
10661                       0000302B            .25B:
10662                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
10663                                           ! Debug: expression subtree swapping
10664 302B           B8                   00FF  mov	ax,#$FF
10665 302E           31DB                       xor	bx,bx
10666 3030           8D7E         10            lea	di,$10[bp]
10667 3033           E8         D085            call	landul
10668                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10669                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
10670 3036           8946         0E            mov	$E[bp],ax
10671                                           !BCC_EOS
10672                                           ! 1851     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
10673                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
10674 3039           8B46         10            mov	ax,$10[bp]
10675 303C           8B5E         12            mov	bx,$12[bp]
10676 303F           88E0                       mov	al,ah
10677 3041           88DC                       mov	ah,bl
10678 3043           88FB                       mov	bl,bh
10679 3045           28FF                       sub	bh,bh
10680                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
10681 3047           53                         push	bx
10682 3048           50                         push	ax
10683 3049           B8                   FFFF  mov	ax,#$FFFF
10684 304C           31DB                       xor	bx,bx
10685 304E           53                         push	bx
10686 304F           50                         push	ax
10687 3050           8B46         EE            mov	ax,-$12[bp]
10688 3053           8B5E         F0            mov	bx,-$10[bp]
10689 3056           8D7E         EA            lea	di,-$16[bp]
10690 3059           E8         D05F            call	landul
10691 305C           83C4                   08  add	sp,*8
10692                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10693                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
10694 305F           8946         0A            mov	$A[bp],ax
10695                                           !BCC_EOS
10696                                           ! 1852     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
10697                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10698 3062           8B46         10            mov	ax,$10[bp]
10699 3065           8B5E         12            mov	bx,$12[bp]
10700 3068           93                         xchg	bx,ax
10701 3069           88E0                       mov	al,ah
10702 306B           30E4                       xor	ah,ah
10703 306D           31DB                       xor	bx,bx
10704                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
10705 306F           53                         push	bx
10706 3070           50                         push	ax
10707 3071           B8                   000F  mov	ax,*$F
10708 3074           31DB                       xor	bx,bx
10709 3076           53                         push	bx
10710 3077           50                         push	ax
10711 3078           8B46         EE            mov	ax,-$12[bp]
10712 307B           8B5E         F0            mov	bx,-$10[bp]
10713 307E           8D7E         EA            lea	di,-$16[bp]
10714 3081           E8         D037            call	landul
10715 3084           83C4                   08  add	sp,*8
10716                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10717                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
10718 3087           0C                     40  or	al,*$40
10719                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
10720 3089           8946         0C            mov	$C[bp],ax
10721                                           !BCC_EOS
10722                                           ! 1853   }
10723                                           ! 1854   outb(iobase1 + 1, 0x00);
10724                       0000308C            .259:
10725                                           ! Debug: list int = const 0 (used reg = )
10726 308C           31C0                       xor	ax,ax
10727 308E           50                         push	ax
10728                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10729 308F           8B46         FC            mov	ax,-4[bp]
10730                                           ! Debug: list unsigned int = ax+1 (used reg = )
10731 3092           40                         inc	ax
10732 3093           50                         push	ax
10733                                           ! Debug: func () void = outb+0 (used reg = )
10734 3094           E8         D4BD            call	_outb
10735 3097           83C4                   04  add	sp,*4
10736                                           !BCC_EOS
10737                                           ! 1855   outb(iobase1 + 2, count);
10738                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
10739 309A           FF76         08            push	8[bp]
10740                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10741 309D           8B46         FC            mov	ax,-4[bp]
10742                                           ! Debug: list unsigned int = ax+2 (used reg = )
10743 30A0           40                         inc	ax
10744 30A1           40                         inc	ax
10745 30A2           50                         push	ax
10746                                           ! Debug: func () void = outb+0 (used reg = )
10747 30A3           E8         D4AE            call	_outb
10748 30A6           83C4                   04  add	sp,*4
10749                                           !BCC_EOS
10750                                           ! 1856   outb(iobase1 + 3, sector);
10751                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
10752 30A9           FF76         0E            push	$E[bp]
10753                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
10754 30AC           8B46         FC            mov	ax,-4[bp]
10755                                           ! Debug: list unsigned int = ax+3 (used reg = )
10756 30AF           05                   0003  add	ax,*3
10757 30B2           50                         push	ax
10758                                           ! Debug: func () void = outb+0 (used reg = )
10759 30B3           E8         D49E            call	_outb
10760 30B6           83C4                   04  add	sp,*4
10761                                           !BCC_EOS
10762                                           ! 1857   outb(iobase1 + 4, cylinder & 0x00ff);
10763                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
10764 30B9           8A46         0A            mov	al,$A[bp]
10765                                           ! Debug: list unsigned char = al+0 (used reg = )
10766 30BC           30E4                       xor	ah,ah
10767 30BE           50                         push	ax
10768                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10769 30BF           8B46         FC            mov	ax,-4[bp]
10770                                           ! Debug: list unsigned int = ax+4 (used reg = )
10771 30C2           05                   0004  add	ax,*4
10772 30C5           50                         push	ax
10773                                           ! Debug: func () void = outb+0 (used reg = )
10774 30C6           E8         D48B            call	_outb
10775 30C9           83C4                   04  add	sp,*4
10776                                           !BCC_EOS
10777                                           ! 1858   outb(iobase1 + 5, cylinder >> 8);
10778                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
10779 30CC           8B46         0A            mov	ax,$A[bp]
10780 30CF           88E0                       mov	al,ah
10781 30D1           30E4                       xor	ah,ah
10782                                           ! Debug: list unsigned int = ax+0 (used reg = )
10783 30D3           50                         push	ax
10784                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10785 30D4           8B46         FC            mov	ax,-4[bp]
10786                                           ! Debug: list unsigned int = ax+5 (used reg = )
10787 30D7           05                   0005  add	ax,*5
10788 30DA           50                         push	ax
10789                                           ! Debug: func () void = outb+0 (used reg = )
10790 30DB           E8         D476            call	_outb
10791 30DE           83C4                   04  add	sp,*4
10792                                           !BCC_EOS
10793                                           ! 1859   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10794 30E1           8A46         F6            mov	al,-$A[bp]
10795 30E4           84C0                       test	al,al
10796 30E6           74           04            je  	.262
10797                       000030E8            .263:
10798 30E8           B0                     B0  mov	al,#$B0
10799 30EA           EB           02            jmp .264
10800                       000030EC            .262:
10801 30EC           B0                     A0  mov	al,#$A0
10802                       000030EE            .264:
10803                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
10804 30EE           0A46         0C            or	al,$C[bp]
10805                                           ! Debug: list unsigned char = al+0 (used reg = )
10806 30F1           30E4                       xor	ah,ah
10807 30F3           50                         push	ax
10808                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10809 30F4           8B46         FC            mov	ax,-4[bp]
10810                                           ! Debug: list unsigned int = ax+6 (used reg = )
10811 30F7           05                   0006  add	ax,*6
10812 30FA           50                         push	ax
10813                                           ! Debug: func () void = outb+0 (used reg = )
10814 30FB           E8         D456            call	_outb
10815 30FE           83C4                   04  add	sp,*4
10816                                           !BCC_EOS
10817                                           ! 1860   outb(iobase1 + 7, command);
10818                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
10819 3101           FF76         06            push	6[bp]
10820                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
10821 3104           8B46         FC            mov	ax,-4[bp]
10822                                           ! Debug: list unsigned int = ax+7 (used reg = )
10823 3107           05                   0007  add	ax,*7
10824 310A           50                         push	ax
10825                                           ! Debug: func () void = outb+0 (used reg = )
10826 310B           E8         D446            call	_outb
10827 310E           83C4                   04  add	sp,*4
10828                                           !BCC_EOS
10829                                           ! 1861   status = await_ide(3, iobase1, 32000u);
10830                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10831 3111           B8                   7D00  mov	ax,#$7D00
10832 3114           50                         push	ax
10833                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10834 3115           FF76         FC            push	-4[bp]
10835                                           ! Debug: list int = const 3 (used reg = )
10836 3118           B8                   0003  mov	ax,*3
10837 311B           50                         push	ax
10838                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10839 311C           E8         EB99            call	_await_ide
10840 311F           83C4                   06  add	sp,*6
10841                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10842 3122           8846         F5            mov	-$B[bp],al
10843                                           !BCC_EOS
10844                                           ! 1862   if (status
10845                                           ! 1862  & 0x01) {
10846                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
10847 3125           8A46         F5            mov	al,-$B[bp]
10848 3128           24                     01  and	al,*1
10849 312A           84C0                       test	al,al
10850 312C           74           09            je  	.265
10851                       0000312E            .266:
10852                                           ! 1863     ;
10853                                           !BCC_EOS
10854                                           ! 1864     return 2;
10855 312E           B8                   0002  mov	ax,*2
10856 3131           89EC                       mov	sp,bp
10857 3133           5D                         pop	bp
10858 3134           C3                         ret
10859                                           !BCC_EOS
10860                                           ! 1865     } else if ( !(status & 0x08) ) {
10861 3135           EB           10            jmp .267
10862                       00003137            .265:
10863                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
10864 3137           8A46         F5            mov	al,-$B[bp]
10865 313A           24                     08  and	al,*8
10866 313C           84C0                       test	al,al
10867 313E           75           07            jne 	.268
10868                       00003140            .269:
10869                                           ! 1866     ;
10870                                           !BCC_EOS
10871                                           ! 1867     return 3;
10872 3140           B8                   0003  mov	ax,*3
10873 3143           89EC                       mov	sp,bp
10874 3145           5D                         pop	bp
10875 3146           C3                         ret
10876                                           !BCC_EOS
10877                                           ! 1868   }
10878                                           ! 1869 #asm
10879                       00003147            .268:
10880                       00003147            .267:
10881                                           !BCC_EOS
10882                                           !BCC_ASM
10883                       00000016            _ata_cmd_data_in.count	set	$16
10884                       00000008            .ata_cmd_data_in.count	set	8
10885                       00000026            _ata_cmd_data_in.segment	set	$26
10886                       00000018            .ata_cmd_data_in.segment	set	$18
10887                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10888                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10889                       00000005            _ata_cmd_data_in.channel	set	5
10890                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10891                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10892                       00000010            .ata_cmd_data_in.lba_low	set	$10
10893                       00000022            _ata_cmd_data_in.lba_high	set	$22
10894                       00000014            .ata_cmd_data_in.lba_high	set	$14
10895                       0000001C            _ata_cmd_data_in.sector	set	$1C
10896                       0000000E            .ata_cmd_data_in.sector	set	$E
10897                       00000006            _ata_cmd_data_in.blksize	set	6
10898                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10899                       0000001A            _ata_cmd_data_in.head	set	$1A
10900                       0000000C            .ata_cmd_data_in.head	set	$C
10901                       00000018            _ata_cmd_data_in.cylinder	set	$18
10902                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10903                       00000012            _ata_cmd_data_in.device	set	$12
10904                       00000004            .ata_cmd_data_in.device	set	4
10905                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10906                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10907                       00000003            _ata_cmd_data_in.status	set	3
10908                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10909                       00000002            _ata_cmd_data_in.current	set	2
10910                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10911                       00000014            _ata_cmd_data_in.command	set	$14
10912                       00000006            .ata_cmd_data_in.command	set	6
10913                       00000001            _ata_cmd_data_in.mode	set	1
10914                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10915                       00000008            _ata_cmd_data_in.iobase2	set	8
10916                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10917                       00000028            _ata_cmd_data_in.offset	set	$28
10918                       0000001A            .ata_cmd_data_in.offset	set	$1A
10919                       00000004            _ata_cmd_data_in.slave	set	4
10920                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10921 3147           FB                                 sti ;; enable higher priority interrupts
10922                                           ! 1871 endasm
10923                                           !BCC_ENDASM
10924                                           !BCC_EOS
10925                                           ! 1872   while (1) {
10926                       00003148            .26C:
10927                                           ! 1873 #asm
10928                                           !BCC_EOS
10929                                           !BCC_ASM
10930                       00000016            _ata_cmd_data_in.count	set	$16
10931                       00000008            .ata_cmd_data_in.count	set	8
10932                       00000026            _ata_cmd_data_in.segment	set	$26
10933                       00000018            .ata_cmd_data_in.segment	set	$18
10934                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10935                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10936                       00000005            _ata_cmd_data_in.channel	set	5
10937                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10938                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10939                       00000010            .ata_cmd_data_in.lba_low	set	$10
10940                       00000022            _ata_cmd_data_in.lba_high	set	$22
10941                       00000014            .ata_cmd_data_in.lba_high	set	$14
10942                       0000001C            _ata_cmd_data_in.sector	set	$1C
10943                       0000000E            .ata_cmd_data_in.sector	set	$E
10944                       00000006            _ata_cmd_data_in.blksize	set	6
10945                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10946                       0000001A            _ata_cmd_data_in.head	set	$1A
10947                       0000000C            .ata_cmd_data_in.head	set	$C
10948                       00000018            _ata_cmd_data_in.cylinder	set	$18
10949                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10950                       00000012            _ata_cmd_data_in.device	set	$12
10951                       00000004            .ata_cmd_data_in.device	set	4
10952                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10953                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10954                       00000003            _ata_cmd_data_in.status	set	3
10955                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10956                       00000002            _ata_cmd_data_in.current	set	2
10957                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10958                       00000014            _ata_cmd_data_in.command	set	$14
10959                       00000006            .ata_cmd_data_in.command	set	6
10960                       00000001            _ata_cmd_data_in.mode	set	1
10961                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10962                       00000008            _ata_cmd_data_in.iobase2	set	8
10963                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10964                       00000028            _ata_cmd_data_in.offset	set	$28
10965                       0000001A            .ata_cmd_data_in.offset	set	$1A
10966                       00000004            _ata_cmd_data_in.slave	set	4
10967                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10968 3148           55                                 push bp
10969 3149           89E5                               mov bp, sp
10970 314B           8B7E         2A                    mov di, _ata_cmd_data_in.offset + 2[bp]
10971 314E           8B46         28                    mov ax, _ata_cmd_data_in.segment + 2[bp]
10972 3151           8B4E         08                    mov cx, _ata_cmd_data_in.blksize + 2[bp]
10973                                                   ;; adjust if there will be an overrun. 2K max sector size
10974 3154           81FF                 F800          cmp di, #0xf800 ;;
10975 3158           76           07                    jbe ata_in_no_adjust
10976                       0000315A            ata_in_adjust:
10977 315A           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10978 315E           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10979                       00003161            ata_in_no_adjust:
10980 3161           8EC0                               mov es, ax ;; segment in es
10981 3163           8B56         0C                    mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
10982 3166           8A66         03                    mov ah, _ata_cmd_data_in.mode + 2[bp]
10983 3169           80FC                   01          cmp ah, #0x01
10984 316C           74           04                    je ata_in_32
10985                       0000316E            ata_in_16:
10986 316E           F3                                 rep
10987 316F           6D                                   insw ;; CX words transfered from port(DX) to ES:[DI]
10988 3170           EB           03                    jmp ata_in_done
10989                       00003172            ata_in_32:
10990 3172           F3                                 rep
10991 3173     66    6D                                   insd ;; CX dwords transfered from port(DX) to ES:[DI]
10992                       00003175            ata_in_done:
10993 3175           897E         2A                    mov _ata_cmd_data_in.offset + 2[bp], di
10994 3178           8C46         28                    mov _ata_cmd_data_in.segment + 2[bp], es
10995 317B           5D                                 pop bp
10996                                           ! 1902 endasm
10997                                           !BCC_ENDASM
10998                                           !BCC_EOS
10999                                           ! 1903     current++;
11000                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11001 317C           8A46         F4            mov	al,-$C[bp]
11002 317F           40                         inc	ax
11003 3180           8846         F4            mov	-$C[bp],al
11004                                           !BCC_EOS
11005                                           ! 1904     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
11006                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11007 3183           8A46         F4            mov	al,-$C[bp]
11008 3186           30E4                       xor	ah,ah
11009 3188           50                         push	ax
11010                                           ! Debug: list * unsigned short = const $254 (used reg = )
11011 3189           B8                   0254  mov	ax,#$254
11012 318C           50                         push	ax
11013                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11014 318D           FF76         FE            push	-2[bp]
11015                                           ! Debug: func () void = write_word+0 (used reg = )
11016 3190           E8         D49F            call	_write_word
11017 3193           83C4                   06  add	sp,*6
11018                                           !BCC_EOS
11019                                           ! 1905     count--;
11020                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11021 3196           8B46         08            mov	ax,8[bp]
11022 3199           48                         dec	ax
11023 319A           8946         08            mov	8[bp],ax
11024                                           !BCC_EOS
11025                                           ! 1906     status = await_ide(2, iobase1, 32000u);
11026                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11027 319D           B8                   7D00  mov	ax,#$7D00
11028 31A0           50                         push	ax
11029                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11030 31A1           FF76         FC            push	-4[bp]
11031                                           ! Debug: list int = const 2 (used reg = )
11032 31A4           B8                   0002  mov	ax,*2
11033 31A7           50                         push	ax
11034                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
11035 31A8           E8         EB0D            call	_await_ide
11036 31AB           83C4                   06  add	sp,*6
11037                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11038 31AE           8846         F5            mov	-$B[bp],al
11039                                           !BCC_EOS
11040                                           ! 1907     if (count == 0) {
11041                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11042 31B1           8B46         08            mov	ax,8[bp]
11043 31B4           85C0                       test	ax,ax
11044 31B6           75           14            jne 	.26D
11045                       000031B8            .26E:
11046                                           ! 1908       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11047                                           ! 1909           != 0x40 ) {
11048                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11049 31B8           8A46         F5            mov	al,-$B[bp]
11050 31BB           24                     C9  and	al,#$C9
11051                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11052 31BD           3C                     40  cmp	al,*$40
11053 31BF           74           07            je  	.26F
11054                       000031C1            .270:
11055                                           ! 1910         ;
11056                                           !BCC_EOS
11057                                           ! 1911         return 4;
11058 31C1           B8                   0004  mov	ax,*4
11059 31C4           89EC                       mov	sp,bp
11060 31C6           5D                         pop	bp
11061 31C7           C3                         ret
11062                                           !BCC_EOS
11063                                           ! 1912         }
11064                                           ! 1913       break;
11065                       000031C8            .26F:
11066 31C8           EB           17            jmp .26A
11067                                           !BCC_EOS
11068                                           ! 1914       }
11069                                           ! 1915     else {
11070 31CA           EB           12            jmp .271
11071                       000031CC            .26D:
11072                                           ! 1916       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11073                                           ! 1917           != (0x40 | 0x08) ) {
11074                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11075 31CC           8A46         F5            mov	al,-$B[bp]
11076 31CF           24                     C9  and	al,#$C9
11077                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11078 31D1           3C                     48  cmp	al,*$48
11079 31D3           74           07            je  	.272
11080                       000031D5            .273:
11081                                           ! 1918         ;
11082                                           !BCC_EOS
11083                                           ! 1919         return 5;
11084 31D5           B8                   0005  mov	ax,*5
11085 31D8           89EC                       mov	sp,bp
11086 31DA           5D                         pop	bp
11087 31DB           C3                         ret
11088                                           !BCC_EOS
11089                                           ! 1920       }
11090                                           ! 1921       continue;
11091                       000031DC            .272:
11092 31DC           EB           00            jmp .26B
11093                                           !BCC_EOS
11094                                           ! 1922     }
11095                                           ! 1923   }
11096                       000031DE            .271:
11097                                           ! 1924   outb(iobase2+6, 0x08);
11098                       000031DE            .26B:
11099 31DE           E9         FF67            jmp	.26C
11100                       000031E1            .274:
11101                       000031E1            .26A:
11102                                           ! Debug: list int = const 8 (used reg = )
11103 31E1           B8                   0008  mov	ax,*8
11104 31E4           50                         push	ax
11105                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11106 31E5           8B46         FA            mov	ax,-6[bp]
11107                                           ! Debug: list unsigned int = ax+6 (used reg = )
11108 31E8           05                   0006  add	ax,*6
11109 31EB           50                         push	ax
11110                                           ! Debug: func () void = outb+0 (used reg = )
11111 31EC           E8         D365            call	_outb
11112 31EF           83C4                   04  add	sp,*4
11113                                           !BCC_EOS
11114                                           ! 1925   return 0;
11115 31F2           31C0                       xor	ax,ax
11116 31F4           89EC                       mov	sp,bp
11117 31F6           5D                         pop	bp
11118 31F7           C3                         ret
11119                                           !BCC_EOS
11120                                           ! 1926 }
11121                                           ! 1927 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
11122                                           ! Register BX used in function ata_cmd_data_in
11123                                           ! 1928 Bit16u device, command, count, cylinder, head, sector, segment, offset;
11124                                           export	_ata_cmd_data_out
11125                       000031F8            _ata_cmd_data_out:
11126                                           !BCC_EOS
11127                                           ! 1929 Bit32u lba_low, lba_high;
11128                                           !BCC_EOS
11129                                           ! 1930 {
11130                                           ! 1931   Bit16u ebda_seg=read_word(0x0040,0x000E);
11131 31F8           55                         push	bp
11132 31F9           89E5                       mov	bp,sp
11133 31FB           4C                         dec	sp
11134 31FC           4C                         dec	sp
11135                                           ! Debug: list int = const $E (used reg = )
11136 31FD           B8                   000E  mov	ax,*$E
11137 3200           50                         push	ax
11138                                           ! Debug: list int = const $40 (used reg = )
11139 3201           B8                   0040  mov	ax,*$40
11140 3204           50                         push	ax
11141                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11142 3205           E8         D3FF            call	_read_word
11143 3208           83C4                   04  add	sp,*4
11144                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11145 320B           8946         FE            mov	-2[bp],ax
11146                                           !BCC_EOS
11147                                           ! 1932   Bit16u iobase1, iobase2, blksize;
11148                                           !BCC_EOS
11149                                           ! 1933   Bit8u channel, slave;
11150                                           !BCC_EOS
11151                                           ! 1934   Bit8u status, current, mode;
11152                                           !BCC_EOS
11153                                           ! 1935   channel = device / 2;
11154 320E           83C4                   F4  add	sp,*-$C
11155                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11156 3211           8B46         04            mov	ax,4[bp]
11157 3214           D1E8                       shr	ax,*1
11158                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
11159 3216           8846         F7            mov	-9[bp],al
11160                                           !BCC_EOS
11161                                           ! 1936   slave = device % 2;
11162                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11163 3219           8B46         04            mov	ax,4[bp]
11164 321C           24                     01  and	al,*1
11165                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
11166 321E           8846         F6            mov	-$A[bp],al
11167                                           !BCC_EOS
11168                                           ! 1937   iobase1 = read_word(ebda_s
11169                                           ! 1937 eg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11170                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11171 3221           8A46         F7            mov	al,-9[bp]
11172 3224           30E4                       xor	ah,ah
11173 3226           B1                     03  mov	cl,*3
11174 3228           D3E0                       shl	ax,cl
11175 322A           89C3                       mov	bx,ax
11176                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11177                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11178 322C           81C3                 0124  add	bx,#$124
11179 3230           53                         push	bx
11180                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11181 3231           FF76         FE            push	-2[bp]
11182                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11183 3234           E8         D3D0            call	_read_word
11184 3237           83C4                   04  add	sp,*4
11185                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
11186 323A           8946         FC            mov	-4[bp],ax
11187                                           !BCC_EOS
11188                                           ! 1938   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11189                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11190 323D           8A46         F7            mov	al,-9[bp]
11191 3240           30E4                       xor	ah,ah
11192 3242           B1                     03  mov	cl,*3
11193 3244           D3E0                       shl	ax,cl
11194 3246           89C3                       mov	bx,ax
11195                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11196                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11197 3248           81C3                 0126  add	bx,#$126
11198 324C           53                         push	bx
11199                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11200 324D           FF76         FE            push	-2[bp]
11201                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11202 3250           E8         D3B4            call	_read_word
11203 3253           83C4                   04  add	sp,*4
11204                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
11205 3256           8946         FA            mov	-6[bp],ax
11206                                           !BCC_EOS
11207                                           ! 1939   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11208                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
11209 3259           8B46         04            mov	ax,4[bp]
11210 325C           B9                   001E  mov	cx,*$1E
11211 325F           F7E9                       imul	cx
11212 3261           89C3                       mov	bx,ax
11213                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11214                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11215 3263           81C3                 0146  add	bx,#$146
11216 3267           53                         push	bx
11217                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11218 3268           FF76         FE            push	-2[bp]
11219                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11220 326B           E8         D386            call	_read_byte
11221 326E           83C4                   04  add	sp,*4
11222                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
11223 3271           8846         F3            mov	-$D[bp],al
11224                                           !BCC_EOS
11225                                           ! 1940   blksize = 0x200;
11226                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
11227 3274           B8                   0200  mov	ax,#$200
11228 3277           8946         F8            mov	-8[bp],ax
11229                                           !BCC_EOS
11230                                           ! 1941   if (mode == 0x01) blksize>>=2;
11231                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
11232 327A           8A46         F3            mov	al,-$D[bp]
11233 327D           3C                     01  cmp	al,*1
11234 327F           75           0C            jne 	.275
11235                       00003281            .276:
11236                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
11237 3281           8B46         F8            mov	ax,-8[bp]
11238 3284           D1E8                       shr	ax,*1
11239 3286           D1E8                       shr	ax,*1
11240 3288           8946         F8            mov	-8[bp],ax
11241                                           !BCC_EOS
11242                                           ! 1942   else blksize>>=1;
11243 328B           EB           08            jmp .277
11244                       0000328D            .275:
11245                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
11246 328D           8B46         F8            mov	ax,-8[bp]
11247 3290           D1E8                       shr	ax,*1
11248 3292           8946         F8            mov	-8[bp],ax
11249                                           !BCC_EOS
11250                                           ! 1943   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11251                       00003295            .277:
11252                                           ! Debug: list int = const 0 (used reg = )
11253 3295           31C0                       xor	ax,ax
11254 3297           50                         push	ax
11255                                           ! Debug: list * unsigned short = const $254 (used reg = )
11256 3298           B8                   0254  mov	ax,#$254
11257 329B           50                         push	ax
11258                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11259 329C           FF76         FE            push	-2[bp]
11260                                           ! Debug: func () void = write_word+0 (used reg = )
11261 329F           E8         D390            call	_write_word
11262 32A2           83C4                   06  add	sp,*6
11263                                           !BCC_EOS
11264                                           ! 1944   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11265                                           ! Debug: list long = const 0 (used reg = )
11266 32A5           31C0                       xor	ax,ax
11267 32A7           31DB                       xor	bx,bx
11268 32A9           53                         push	bx
11269 32AA           50                         push	ax
11270                                           ! Debug: list * unsigned long = const $256 (used reg = )
11271 32AB           B8                   0256  mov	ax,#$256
11272 32AE           50                         push	ax
11273                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
11274 32AF           FF76         FE            push	-2[bp]
11275                                           ! Debug: func () void = write_dword+0 (used reg = )
11276 32B2           E8         CDE6            call	_write_dword
11277 32B5           83C4                   08  add	sp,*8
11278                                           !BCC_EOS
11279                                           ! 1945   current = 0;
11280                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
11281 32B8           30C0                       xor	al,al
11282 32BA           8846         F4            mov	-$C[bp],al
11283                                           !BCC_EOS
11284                                           ! 1946   status = inb(iobase1 + 7);
11285                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11286 32BD           8B46         FC            mov	ax,-4[bp]
11287                                           ! Debug: list unsigned int = ax+7 (used reg = )
11288 32C0           05                   0007  add	ax,*7
11289 32C3           50                         push	ax
11290                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11291 32C4           E8         D277            call	_inb
11292 32C7           44                         inc	sp
11293 32C8           44                         inc	sp
11294                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11295 32C9           8846         F5            mov	-$B[bp],al
11296                                           !BCC_EOS
11297                                           ! 1947   if (status & 0x80) return 1;
11298                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
11299 32CC           8A46         F5            mov	al,-$B[bp]
11300 32CF           24                     80  and	al,#$80
11301 32D1           84C0                       test	al,al
11302 32D3           74           07            je  	.278
11303                       000032D5            .279:
11304 32D5           B8                   0001  mov	ax,*1
11305 32D8           89EC                       mov	sp,bp
11306 32DA           5D                         pop	bp
11307 32DB           C3                         ret
11308                                           !BCC_EOS
11309                                           ! 1948   outb(iobase2 + 6, 0x08 | 0x02);
11310                       000032DC            .278:
11311                                           ! Debug: list int = const $A (used reg = )
11312 32DC           B8                   000A  mov	ax,*$A
11313 32DF           50                         push	ax
11314                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11315 32E0           8B46         FA            mov	ax,-6[bp]
11316                                           ! Debug: list unsigned int = ax+6 (used reg = )
11317 32E3           05                   0006  add	ax,*6
11318 32E6           50                         push	ax
11319                                           ! Debug: func () void = outb+0 (used reg = )
11320 32E7           E8         D26A            call	_outb
11321 32EA           83C4                   04  add	sp,*4
11322                                           !BCC_EOS
11323                                           ! 1949   if (sector == 0) {
11324                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
11325 32ED           8B46         0E            mov	ax,$E[bp]
11326 32F0           85C0                       test	ax,ax
11327 32F2         0F85         0167            bne 	.27A
11328                       000032F6            .27B:
11329                                           ! 1950     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
11330                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
11331 32F6           8B46         08            mov	ax,8[bp]
11332 32F9           3D                   0100  cmp	ax,#$100
11333 32FC           72           04            jb 	.280
11334 32FE           B0                     01  mov	al,*1
11335 3300           EB           02            jmp	.281
11336                       00003302            .280:
11337 3302           30C0                       xor	al,al
11338                       00003304            .281:
11339                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
11340 3304           30E4                       xor	ah,ah
11341 3306           99                         cwd
11342 3307           89D3                       mov	bx,dx
11343 3309           E8         CE08            call	ltstl
11344 330C           75           32            jne 	.27D
11345                       0000330E            .27F:
11346 330E           8B46         14            mov	ax,$14[bp]
11347 3311           8B5E         16            mov	bx,$16[bp]
11348 3314           E8         CDFD            call	ltstl
11349 3317           75           27            jne 	.27D
11350                       00003319            .27E:
11351                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
11352 3319           8B46         08            mov	ax,8[bp]
11353 331C           31DB                       xor	bx,bx
11354                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
11355                                           ! Debug: expression subtree swapping
11356 331E           8D7E         10            lea	di,$10[bp]
11357 3321           E8         CD9F            call	laddul
11358                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
11359 3324           53                         push	bx
11360 3325           50                         push	ax
11361 3326           31C0                       xor	ax,ax
11362 3328           BB                   1000  mov	bx,#$1000
11363 332B           53                         push	bx
11364 332C           50                         push	ax
11365 332D           8B46         EE            mov	ax,-$12[bp]
11366 3330           8B5E         F0            mov	bx,-$10[bp]
11367 3333           8D7E         EA            lea	di,-$16[bp]
11368 3336           E8         CD92            call	lcmpul
11369 3339           8D66         F2            lea	sp,-$E[bp]
11370 333C         0F82         00BC            blo 	.27C
11371                       00003340            .27D:
11372                                           ! 1951       outb(iobase1 + 1, 0x00);
11373                                           ! Debug: list int = const 0 (used reg = )
11374 3340           31C0                       xor	ax,ax
11375 3342           50                         push	ax
11376                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11377 3343           8B46         FC            mov	ax,-4[bp]
11378                                           ! Debug: list unsigned int = ax+1 (used reg = )
11379 3346           40                         inc	ax
11380 3347           50                         push	ax
11381                                           ! Debug: func () void = outb+0 (used reg = )
11382 3348           E8         D209            call	_outb
11383 334B           83C4                   04  add	sp,*4
11384                                           !BCC_EOS
11385                                           ! 1952       outb(iobase1 + 2, (count >> 8) & 0xff);
11386                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
11387 334E           8B46         08            mov	ax,8[bp]
11388 3351           88E0                       mov	al,ah
11389 3353           30E4                       xor	ah,ah
11390                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
11391                                           ! Debug: list unsigned char = al+0 (used reg = )
11392 3355           30E4                       xor	ah,ah
11393 3357           50                         push	ax
11394                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11395 3358           8B46         FC            mov	ax,-4[bp]
11396                                           ! Debug: list unsigned int = ax+2 (used reg = )
11397 335B           40                         inc	ax
11398 335C           40                         inc	ax
11399 335D           50                         push	ax
11400                                           ! Debug: func () void = outb+0 (used reg = )
11401 335E           E8         D1F3            call	_outb
11402 3361           83C4                   04  add	sp,*4
11403                                           !BCC_EOS
11404                                           ! 1953       outb(iobase1 + 3, lba_low >> 24);
11405                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11406 3364           8B46         10            mov	ax,$10[bp]
11407 3367           8B5E         12            mov	bx,$12[bp]
11408 336A           93                         xchg	bx,ax
11409 336B           88E0                       mov	al,ah
11410 336D           30E4                       xor	ah,ah
11411 336F           31DB                       xor	bx,bx
11412                                           ! Debug: list unsigned long = bx+0 (used reg = )
11413 3371           53                         push	bx
11414 3372           50                         push	ax
11415                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
11416 3373           8B46         FC            mov	ax,-4[bp]
11417                                           ! Debug: list unsigned int = ax+3 (used reg = )
11418 3376           05                   0003  add	ax,*3
11419 3379           50                         push	ax
11420                                           ! Debug: func () void = outb+0 (used reg = )
11421 337A           E8         D1D7            call	_outb
11422 337D           83C4                   06  add	sp,*6
11423                                           !BCC_EOS
11424                                           ! 1954       outb(iobase1 + 4, lba_high & 0xff);
11425                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
11426                                           ! Debug: expression subtree swapping
11427 3380           B8                   00FF  mov	ax,#$FF
11428 3383           31DB                       xor	bx,bx
11429 3385           8D7E         14            lea	di,$14[bp]
11430 3388           E8         CD30            call	landul
11431                                           ! Debug: list unsigned long = bx+0 (used reg = )
11432 338B           53                         push	bx
11433 338C           50                         push	ax
11434                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
11435 338D           8B46         FC            mov	ax,-4[bp]
11436                                           ! Debug: list unsigned int = ax+4 (used reg = )
11437 3390           05                   0004  add	ax,*4
11438 3393           50                         push	ax
11439                                           ! Debug: func () void = outb+0 (used reg = )
11440 3394           E8         D1BD            call	_outb
11441 3397           83C4                   06  add	sp,*6
11442                                           !BCC_EOS
11443                                           ! 1955       outb(iobase1 + 5, lba_high >> 8);
11444                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
11445 339A           8B46         14            mov	ax,$14[bp]
11446 339D           8B5E         16            mov	bx,$16[bp]
11447 33A0           88E0                       mov	al,ah
11448 33A2           88DC                       mov	ah,bl
11449 33A4           88FB                       mov	bl,bh
11450 33A6           28FF                       sub	bh,bh
11451                                           ! Debug: list unsigned long = bx+0 (used reg = )
11452 33A8           53                         push	bx
11453 33A9           50                         push	ax
11454                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
11455 33AA           8B46         FC            mov	ax,-4[bp]
11456                                           ! Debug: list unsigned int = ax+5 (used reg = )
11457 33AD           05                   0005  add	ax,*5
11458 33B0           50                         push	ax
11459                                           ! Debug: func () void = outb+0 (used reg = )
11460 33B1           E8         D1A0            call	_outb
11461 33B4           83C4                   06  add	sp,*6
11462                                           !BCC_EOS
11463                                           ! 1956       command |= 0x04;
11464                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
11465 33B7           8B46         06            mov	ax,6[bp]
11466 33BA           0C                     04  or	al,*4
11467 33BC           8946         06            mov	6[bp],ax
11468                                           !BCC_EOS
11469                                           ! 1957       count &= (1UL << 8) - 1;
11470                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
11471 33BF           8B46         08            mov	ax,8[bp]
11472 33C2           31DB                       xor	bx,bx
11473 33C4           53                         push	bx
11474 33C5           50                         push	ax
11475 33C6           B8                   00FF  mov	ax,#$FF
11476 33C9           31DB                       xor	bx,bx
11477 33CB           53                         push	bx
11478 33CC           50                         push	ax
11479 33CD           8B46         EE            mov	ax,-$12[bp]
11480 33D0           8B5E         F0            mov	bx,-$10[bp]
11481 33D3           8D7E         EA            lea	di,-$16[bp]
11482 33D6           E8         CCE2            call	landul
11483 33D9           8946         08            mov	8[bp],ax
11484 33DC           83C4                   08  add	sp,*8
11485                                           !BCC_EOS
11486                                           ! 1958       lba_low &= (1UL << 24) - 1;
11487                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
11488 33DF           B8                   FFFF  mov	ax,#$FFFF
11489 33E2           BB                   00FF  mov	bx,#$FF
11490 33E5           53                         push	bx
11491 33E6           50                         push	ax
11492 33E7           8B46         10            mov	ax,$10[bp]
11493 33EA           8B5E         12            mov	bx,$12[bp]
11494 33ED           8D7E         EE            lea	di,-$12[bp]
11495 33F0           E8         CCC8            call	landul
11496 33F3           8946         10            mov	$10[bp],ax
11497 33F6           895E         12            mov	$12[bp],bx
11498 33F9           83C4                   04  add	sp,*4
11499                                           !BCC_EOS
11500                                           ! 1959       }
11501                                           ! 1960     sector = (Bit16u) (lba_low & 0x000000ffL);
11502                       000033FC            .27C:
11503                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
11504                                           ! Debug: expression subtree swapping
11505 33FC           B8                   00FF  mov	ax,#$FF
11506 33FF           31DB                       xor	bx,bx
11507 3401           8D7E         10            lea	di,$10[bp]
11508 3404           E8         CCB4            call	landul
11509                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11510                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
11511 3407           8946         0E            mov	$E[bp],ax
11512                                           !BCC_EOS
11513                                           ! 1961     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
11514                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
11515 340A           8B46         10            mov	ax,$10[bp]
11516 340D           8B5E         12            mov	bx,$12[bp]
11517 3410           88E0                       mov	al,ah
11518 3412           88DC                       mov	ah,bl
11519 3414           88FB                       mov	bl,bh
11520 3416           28FF                       sub	bh,bh
11521                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
11522 3418           53                         push	bx
11523 3419           50                         push	ax
11524 341A           B8                   FFFF  mov	ax,#$FFFF
11525 341D           31DB                       xor	bx,bx
11526 341F           53                         push	bx
11527 3420           50                         push	ax
11528 3421           8B46         EE            mov	ax,-$12[bp]
11529 3424           8B5E         F0            mov	bx,-$10[bp]
11530 3427           8D7E         EA            lea	di,-$16[bp]
11531 342A           E8         CC8E            call	landul
11532 342D           83C4                   08  add	sp,*8
11533                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11534                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
11535 3430           8946         0A            mov	$A[bp],ax
11536                                           !BCC_EOS
11537                                           ! 1962     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
11538                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11539 3433           8B46         10            mov	ax,$10[bp]
11540 3436           8B5E         12            mov	bx,$12[bp]
11541 3439           93                         xchg	bx,ax
11542 343A           88E0                       mov	al,ah
11543 343C           30E4                       xor	ah,ah
11544 343E           31DB                       xor	bx,bx
11545                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
11546 3440           53                         push	bx
11547 3441           50                         push	ax
11548 3442           B8                   000F  mov	ax,*$F
11549 3445           31DB                       xor	bx,bx
11550 3447           53                         push	bx
11551 3448           50                         push	ax
11552 3449           8B46         EE            mov	ax,-$12[bp]
11553 344C           8B5E         F0            mov	bx,-$10[bp]
11554 344F           8D7E         EA            lea	di,-$16[bp]
11555 3452           E8         CC66            call	landul
11556 3455           83C4                   08  add	sp,*8
11557                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11558                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
11559 3458           0C                     40  or	al,*$40
11560                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
11561 345A           8946         0C            mov	$C[bp],ax
11562                                           !BCC_EOS
11563                                           ! 1963   }
11564                                           ! 1964   outb(iobase1 + 1, 0x00);
11565                       0000345D            .27A:
11566                                           ! Debug: list int = const 0 (used reg = )
11567 345D           31C0                       xor	ax,ax
11568 345F           50                         push	ax
11569                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11570 3460           8B46         FC            mov	ax,-4[bp]
11571                                           ! Debug: list unsigned int = ax+1 (used reg = )
11572 3463           40                         inc	ax
11573 3464           50                         push	ax
11574                                           ! Debug: func () void = outb+0 (used reg = )
11575 3465           E8         D0EC            call	_outb
11576 3468           83C4                   04  add	sp,*4
11577                                           !BCC_EOS
11578                                           ! 1965   outb(iobase1 + 2, count);
11579                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
11580 346B           FF76         08            push	8[bp]
11581                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11582 346E           8B46         FC            mov	ax,-4[bp]
11583                                           ! Debug: list unsigned int = ax+2 (used reg = )
11584 3471           40                         inc	ax
11585 3472           40                         inc	ax
11586 3473           50                         push	ax
11587                                           ! Debug: func () void = outb+0 (used reg = )
11588 3474           E8         D0DD            call	_outb
11589 3477           83C4                   04  add	sp,*4
11590                                           !BCC_EOS
11591                                           ! 1966   outb(iobase1 + 3, sector);
11592                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
11593 347A           FF76         0E            push	$E[bp]
11594                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
11595 347D           8B46         FC            mov	ax,-4[bp]
11596                                           ! Debug: list unsigned int = ax+3 (used reg = )
11597 3480           05                   0003  add	ax,*3
11598 3483           50                         push	ax
11599                                           ! Debug: func () void = outb+0 (used reg = )
11600 3484           E8         D0CD            call	_outb
11601 3487           83C4                   04  add	sp,*4
11602                                           !BCC_EOS
11603                                           ! 1967   outb(iobase1 + 4, cylinder & 0x00ff);
11604                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
11605 348A           8A46         0A            mov	al,$A[bp]
11606                                           ! Debug: list unsigned char = al+0 (used reg = )
11607 348D           30E4                       xor	ah,ah
11608 348F           50                         push	ax
11609                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
11610 3490           8B46         FC            mov	ax,-4[bp]
11611                                           ! Debug: list unsigned int = ax+4 (used reg = )
11612 3493           05                   0004  add	ax,*4
11613 3496           50                         push	ax
11614                                           ! Debug: func () void = outb+0 (used reg = )
11615 3497           E8         D0BA            call	_outb
11616 349A           83C4                   04  add	sp,*4
11617                                           !BCC_EOS
11618                                           ! 1968   outb(iobase1 + 5, cylinder >> 8);
11619                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
11620 349D           8B46         0A            mov	ax,$A[bp]
11621 34A0           88E0                       mov	al,ah
11622 34A2           30E4                       xor	ah,ah
11623                                           ! Debug: list unsigned int = ax+0 (used reg = )
11624 34A4           50                         push	ax
11625                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
11626 34A5           8B46         FC            mov	ax,-4[bp]
11627                                           ! Debug: list unsigned int = ax+5 (used reg = )
11628 34A8           05                   0005  add	ax,*5
11629 34AB           50                         push	ax
11630                                           ! Debug: func () void = outb+0 (used reg = )
11631 34AC           E8         D0A5            call	_outb
11632 34AF           83C4                   04  add	sp,*4
11633                                           !BCC_EOS
11634                                           ! 1969   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
11635 34B2           8A46         F6            mov	al,-$A[bp]
11636 34B5           84C0                       test	al,al
11637 34B7           74           04            je  	.283
11638                       000034B9            .284:
11639 34B9           B0                     B0  mov	al,#$B0
11640 34BB           EB           02            jmp .285
11641                       000034BD            .283:
11642 34BD           B0                     A0  mov	al,#$A0
11643                       000034BF            .285:
11644                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
11645 34BF           0A46         0C            or	al,$C[bp]
11646                                           ! Debug: list unsigned char = al+0 (used reg = )
11647 34C2           30E4                       xor	ah,ah
11648 34C4           50                         push	ax
11649                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
11650 34C5           8B46         FC            mov	ax,-4[bp]
11651                                           ! Debug: list unsigned int = ax+6 (used reg = )
11652 34C8           05                   0006  add	ax,*6
11653 34CB           50                         push	ax
11654                                           ! Debug: func () void = outb+0 (used reg = )
11655 34CC           E8         D085            call	_outb
11656 34CF           83C4                   04  add	sp,*4
11657                                           !BCC_EOS
11658                                           ! 1970   outb(iobase1 + 7, command);
11659                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
11660 34D2           FF76         06            push	6[bp]
11661                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
11662 34D5           8B46         FC            mov	ax,-4[bp]
11663                                           ! Debug: list unsigned int = ax+7 (used reg = )
11664 34D8           05                   0007  add	ax,*7
11665 34DB           50                         push	ax
11666                                           ! Debug: func () void = outb+0 (used reg = )
11667 34DC           E8         D075            call	_outb
11668 34DF           83C4                   04  add	sp,*4
11669                                           !BCC_EOS
11670                                           ! 1971   status = await_ide(3, iobase1, 32000u);
11671                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11672 34E2           B8                   7D00  mov	ax,#$7D00
11673 34E5           50                         push	ax
11674                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11675 34E6           FF76         FC            push	-4[bp]
11676                                           ! Debug: list int = const 3 (used reg = )
11677 34E9           B8                   0003  mov	ax,*3
11678 34EC           50                         push	ax
11679                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
11680 34ED           E8         E7C8            call	_await_ide
11681 34F0           83C4                   06  add	sp,*6
11682                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11683 34F3           8846         F5            mov	-$B[bp],al
11684                                           !BCC_EOS
11685                                           ! 1972   if (status & 0x01) {
11686                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
11687 34F6           8A46         F5            mov	al,-$B[bp]
11688 34F9           24                     01  and	al,*1
11689 34FB           84C0                       test	al,al
11690 34FD           74           09            je  	.286
11691                       000034FF            .287:
11692                                           ! 1973     ;
11693                                           !BCC_EOS
11694                                           ! 1974     return 2;
11695 34FF           B8                   0002  mov	ax,*2
11696 3502           89EC                       mov	sp,bp
11697 3504           5D                         pop	bp
11698 3505           C3                         ret
11699                                           !BCC_EOS
11700                                           ! 1975     } else if ( !(status & 0x08) ) {
11701 3506           EB           10            jmp .288
11702                       00003508            .286:
11703                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
11704 3508           8A46         F5            mov	al,-$B[bp]
11705 350B           24                     08  and	al,*8
11706 350D           84C0                       test	al,al
11707 350F           75           07            jne 	.289
11708                       00003511            .28A:
11709                                           ! 1976     ;
11710                                           !BCC_EOS
11711                                           ! 1977     return 3;
11712 3511           B8                   0003  mov	ax,*3
11713 3514           89EC                       mov	sp,bp
11714 3516           5D                         pop	bp
11715 3517           C3                         ret
11716                                           !BCC_EOS
11717                                           ! 1978     }
11718                                           ! 1979 #asm
11719                       00003518            .289:
11720                       00003518            .288:
11721                                           !BCC_EOS
11722                                           !BCC_ASM
11723                       00000016            _ata_cmd_data_out.count	set	$16
11724                       00000008            .ata_cmd_data_out.count	set	8
11725                       00000026            _ata_cmd_data_out.segment	set	$26
11726                       00000018            .ata_cmd_data_out.segment	set	$18
11727                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11728                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11729                       00000005            _ata_cmd_data_out.channel	set	5
11730                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11731                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11732                       00000010            .ata_cmd_data_out.lba_low	set	$10
11733                       00000022            _ata_cmd_data_out.lba_high	set	$22
11734                       00000014            .ata_cmd_data_out.lba_high	set	$14
11735                       0000001C            _ata_cmd_data_out.sector	set	$1C
11736                       0000000E            .ata_cmd_data_out.sector	set	$E
11737                       00000006            _ata_cmd_data_out.blksize	set	6
11738                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11739                       0000001A            _ata_cmd_data_out.head	set	$1A
11740                       0000000C            .ata_cmd_data_out.head	set	$C
11741                       00000018            _ata_cmd_data_out.cylinder	set	$18
11742                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11743                       00000012            _ata_cmd_data_out.device	set	$12
11744                       00000004            .ata_cmd_data_out.device	set	4
11745                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11746                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11747                       00000003            _ata_cmd_data_out.status	set	3
11748                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11749                       00000002            _ata_cmd_data_out.current	set	2
11750                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11751                       00000014            _ata_cmd_data_out.command	set	$14
11752                       00000006            .ata_cmd_data_out.command	set	6
11753                       00000001            _ata_cmd_data_out.mode	set	1
11754                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11755                       00000008            _ata_cmd_data_out.iobase2	set	8
11756                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11757                       00000028            _ata_cmd_data_out.offset	set	$28
11758                       0000001A            .ata_cmd_data_out.offset	set	$1A
11759                       00000004            _ata_cmd_data_out.slave	set	4
11760                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11761 3518           FB                                 sti ;; enable higher priority interrupts
11762                                           ! 1981 endasm
11763                                           !BCC_ENDASM
11764                                           !BCC_EOS
11765                                           ! 1982   while (1) {
11766                       00003519            .28D:
11767                                           ! 1983 #asm
11768                                           !BCC_EOS
11769                                           !BCC_ASM
11770                       00000016            _ata_cmd_data_out.count	set	$16
11771                       00000008            .ata_cmd_data_out.count	set	8
11772                       00000026            _ata_cmd_data_out.segment	set	$26
11773                       00000018            .ata_cmd_data_out.segment	set	$18
11774                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11775                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11776                       00000005            _ata_cmd_data_out.channel	set	5
11777                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11778                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11779                       00000010            .ata_cmd_data_out.lba_low	set	$10
11780                       00000022            _ata_cmd_data_out.lba_high	set	$22
11781                       00000014            .ata_cmd_data_out.lba_high	set	$14
11782                       0000001C            _ata_cmd_data_out.sector	set	$1C
11783                       0000000E            .ata_cmd_data_out.sector	set	$E
11784                       00000006            _ata_cmd_data_out.blksize	set	6
11785                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11786                       0000001A            _ata_cmd_data_out.head	set	$1A
11787                       0000000C            .ata_cmd_data_out.head	set	$C
11788                       00000018            _ata_cmd_data_out.cylinder	set	$18
11789                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11790                       00000012            _ata_cmd_data_out.device	set	$12
11791                       00000004            .ata_cmd_data_out.device	set	4
11792                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11793                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11794                       00000003            _ata_cmd_data_out.status	set	3
11795                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11796                       00000002            _ata_cmd_data_out.current	set	2
11797                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11798                       00000014            _ata_cmd_data_out.command	set	$14
11799                       00000006            .ata_cmd_data_out.command	set	6
11800                       00000001            _ata_cmd_data_out.mode	set	1
11801                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11802                       00000008            _ata_cmd_data_out.iobase2	set	8
11803                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11804                       00000028            _ata_cmd_data_out.offset	set	$28
11805                       0000001A            .ata_cmd_data_out.offset	set	$1A
11806                       00000004            _ata_cmd_data_out.slave	set	4
11807                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11808 3519           55                                 push bp
11809 351A           89E5                               mov bp, sp
11810 351C           8B76         2A                    mov si, _ata_cmd_data_out.offset + 2[bp]
11811 351F           8B46         28                    mov ax, _ata_cmd_data_out.segment + 2[bp]
11812 3522           8B4E         08                    mov cx, _ata_cmd_data_out.blksize + 2[bp]
11813                                                   ;; adjust if there will be an overrun. 2K max sector size
11814 3525           81FE                 F800          cmp si, #0xf800 ;;
11815 3529           76           07                    jbe ata_out_no_adjust
11816                       0000352B            ata_out_adjust:
11817 352B           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
11818 352F           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
11819                       00003532            ata_out_no_adjust:
11820 3532           8EC0                               mov es, ax ;; segment in es
11821 3534           8B56         0C                    mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
11822 3537           8A66         03                    mov ah, _ata_cmd_data_out.mode + 2[bp]
11823 353A           80FC                   01          cmp ah, #0x01
11824 353D           74           05                    je ata_out_32
11825                       0000353F            ata_out_16:
11826 353F           26                                 seg ES
11827 3540           F3                                 rep
11828 3541           6F                                   outsw ;; CX words transfered from port(DX) to ES:[SI]
11829 3542           EB           04                    jmp ata_out_done
11830                       00003544            ata_out_32:
11831 3544           26                                 seg ES
11832 3545           F3                                 rep
11833 3546     66    6F                                   outsd ;; CX dwords transfered from port(DX) to ES:[SI]
11834                       00003548            ata_out_done:
11835 3548           8976         2A                    mov _ata_cmd_data_out.offset + 2[bp], si
11836 354B           8C46         28                    mov _ata_cmd_data_out.segment + 2[bp], es
11837 354E           5D                                 pop bp
11838                                           ! 2014 endasm
11839                                           !BCC_ENDASM
11840                                           !BCC_EOS
11841                                           ! 2015     current++;
11842                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11843 354F           8A46         F4            mov	al,-$C[bp]
11844 3552           40                         inc	ax
11845 3553           8846         F4            mov	-$C[bp],al
11846                                           !BCC_EOS
11847                                           ! 2016     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
11848                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11849 3556           8A46         F4            mov	al,-$C[bp]
11850 3559           30E4                       xor	ah,ah
11851 355B           50                         push	ax
11852                                           ! Debug: list * unsigned short = const $254 (used reg = )
11853 355C           B8                   0254  mov	ax,#$254
11854 355F           50                         push	ax
11855                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11856 3560           FF76         FE            push	-2[bp]
11857                                           ! Debug: func () void = write_word+0 (used reg = )
11858 3563           E8         D0CC            call	_write_word
11859 3566           83C4                   06  add	sp,*6
11860                                           !BCC_EOS
11861                                           ! 2017     count--;
11862                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11863 3569           8B46         08            mov	ax,8[bp]
11864 356C           48                         dec	ax
11865 356D           8946         08            mov	8[bp],ax
11866                                           !BCC_EOS
11867                                           ! 2018     status = inb(iobase1 + 7);
11868                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11869 3570           8B46         FC            mov	ax,-4[bp]
11870                                           ! Debug: list unsigned int = ax+7 (used reg = )
11871 3573           05                   0007  add	ax,*7
11872 3576           50                         push	ax
11873                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11874 3577           E8         CFC4            call	_inb
11875 357A           44                         inc	sp
11876 357B           44                         inc	sp
11877                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11878 357C           8846         F5            mov	-$B[bp],al
11879                                           !BCC_EOS
11880                                           ! 2019     if (count == 0) {
11881                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11882 357F           8B46         08            mov	ax,8[bp]
11883 3582           85C0                       test	ax,ax
11884 3584           75           14            jne 	.28E
11885                       00003586            .28F:
11886                                           ! 2020       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11887                                           ! 2021           != 0x40 ) {
11888                                           ! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
11889 3586           8A46         F5            mov	al,-$B[bp]
11890 3589           24                     E9  and	al,#$E9
11891                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11892 358B           3C                     40  cmp	al,*$40
11893 358D           74           07            je  	.290
11894                       0000358F            .291:
11895                                           ! 2022         ;
11896                                           !BCC_EOS
11897                                           ! 2023         return 6;
11898 358F           B8                   0006  mov	ax,*6
11899 3592           89EC                       mov	sp,bp
11900 3594           5D                         pop	bp
11901 3595           C3                         ret
11902                                           !BCC_EOS
11903                                           ! 2024         }
11904                                           ! 2025       break;
11905                       00003596            .290:
11906 3596           EB           17            jmp .28B
11907                                           !BCC_EOS
11908                                           ! 2026       }
11909                                           ! 2027     else {
11910 3598           EB           12            jmp .292
11911                       0000359A            .28E:
11912                                           ! 2028       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11913                                           ! 2029           != (0x40 | 0x08) ) {
11914                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11915 359A           8A46         F5            mov	al,-$B[bp]
11916 359D           24                     C9  and	al,#$C9
11917                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11918 359F           3C                     48  cmp	al,*$48
11919 35A1           74           07            je  	.293
11920                       000035A3            .294:
11921                                           ! 2030         ;
11922                                           !BCC_EOS
11923                                           ! 2031         return 7;
11924 35A3           B8                   0007  mov	ax,*7
11925 35A6           89EC                       mov	sp,bp
11926 35A8           5D                         pop	bp
11927 35A9           C3                         ret
11928                                           !BCC_EOS
11929                                           ! 2032       }
11930                                           ! 2033       continue;
11931                       000035AA            .293:
11932 35AA           EB           00            jmp .28C
11933                                           !BCC_EOS
11934                                           ! 2034     }
11935                                           ! 2035   }
11936                       000035AC            .292:
11937                                           ! 2036   outb(iobase2+6, 0x08);
11938                       000035AC            .28C:
11939 35AC           E9         FF6A            jmp	.28D
11940                       000035AF            .295:
11941                       000035AF            .28B:
11942                                           ! Debug: list int = const 8 (used reg = )
11943 35AF           B8                   0008  mov	ax,*8
11944 35B2           50                         push	ax
11945                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11946 35B3           8B46         FA            mov	ax,-6[bp]
11947                                           ! Debug: list unsigned int = ax+6 (used reg = )
11948 35B6           05                   0006  add	ax,*6
11949 35B9           50                         push	ax
11950                                           ! Debug: func () void = outb+0 (used reg = )
11951 35BA           E8         CF97            call	_outb
11952 35BD           83C4                   04  add	sp,*4
11953                                           !BCC_EOS
11954                                           ! 2037   return 0;
11955 35C0           31C0                       xor	ax,ax
11956 35C2           89EC                       mov	sp,bp
11957 35C4           5D                         pop	bp
11958 35C5           C3                         ret
11959                                           !BCC_EOS
11960                                           ! 2038 }
11961                                           ! 2039 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
11962                                           ! Register BX used in function ata_cmd_data_out
11963                                           ! 2040 Bit8u cmdlen,inout;
11964                                           export	_ata_cmd_packet
11965                       000035C6            _ata_cmd_packet:
11966                                           !BCC_EOS
11967                                           ! 2041 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
11968                                           !BCC_EOS
11969                                           ! 2042 Bit16u header;
11970                                           !BCC_EOS
11971                                           ! 2043 Bit32u length;
11972                                           !BCC_EOS
11973                                           ! 2044 {
11974                                           ! 2045   Bit16u ebda_seg=read_word(0x0040,0x000E);
11975 35C6           55                         push	bp
11976 35C7           89E5                       mov	bp,sp
11977 35C9           4C                         dec	sp
11978 35CA           4C                         dec	sp
11979                                           ! Debug: list int = const $E (used reg = )
11980 35CB           B8                   000E  mov	ax,*$E
11981 35CE           50                         push	ax
11982                                           ! Debug: list int = const $40 (used reg = )
11983 35CF           B8                   0040  mov	ax,*$40
11984 35D2           50                         push	ax
11985                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11986 35D3           E8         D031            call	_read_word
11987 35D6           83C4                   04  add	sp,*4
11988                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11989 35D9           8946         FE            mov	-2[bp],ax
11990                                           !BCC_EOS
11991                                           ! 2046   Bit16u iobase1, iobase2;
11992                                           !BCC_EOS
11993                                           ! 2047   Bit16u lcount, lbefore, lafter, count;
11994                                           !BCC_EOS
11995                                           ! 2048   Bit8u channel, slave;
11996                                           !BCC_EOS
11997                                           ! 2049   Bit8u status, mode, lmode;
11998                                           !BCC_EOS
11999                                           ! 2050   Bit32u total, transfer;
12000                                           !BCC_EOS
12001                                           ! 2051   channel = device / 2;
12002 35DC           83C4                   E6  add	sp,*-$1A
12003                                           ! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
12004 35DF           8B46         04            mov	ax,4[bp]
12005 35E2           D1E8                       shr	ax,*1
12006                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
12007 35E4           8846         F1            mov	-$F[bp],al
12008                                           !BCC_EOS
12009                                           ! 2052   slave = device % 2;
12010                                           ! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
12011 35E7           8B46         04            mov	ax,4[bp]
12012 35EA           24                     01  and	al,*1
12013                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
12014 35EC           8846         F0            mov	-$10[bp],al
12015                                           !BCC_EOS
12016                                           ! 2053   if (inout == 0x02) {
12017                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
12018 35EF           8A46         12            mov	al,$12[bp]
12019 35F2           3C                     02  cmp	al,*2
12020 35F4           75           07            jne 	.296
12021                       000035F6            .297:
12022                                           ! 2054     ;
12023                                           !BCC_EOS
12024                                           ! 2055     return 1;
12025 35F6           B8                   0001  mov	ax,*1
12026 35F9           89EC                       mov	sp,bp
12027 35FB           5D                         pop	bp
12028 35FC           C3                         ret
12029                                           !BCC_EOS
12030                                           ! 2056     }
12031                                           ! 2057   if (header & 1) {
12032                       000035FD            .296:
12033                                           ! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
12034 35FD           8A46         0C            mov	al,$C[bp]
12035 3600           24                     01  and	al,*1
12036 3602           84C0                       test	al,al
12037 3604           74           07            je  	.298
12038                       00003606            .299:
12039                                           ! 2058     ;
12040                                           !BCC_EOS
12041                                           ! 2059     return 1;
12042 3606           B8                   0001  mov	ax,*1
12043 3609           89EC                       mov	sp,bp
12044 360B           5D                         pop	bp
12045 360C           C3                         ret
12046                                           !BCC_EOS
12047                                           ! 2060     }
12048                                           ! 2061   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
12049                       0000360D            .298:
12050                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12051 360D           8A46         F1            mov	al,-$F[bp]
12052 3610           30E4                       xor	ah,ah
12053 3612           B1                     03  mov	cl,*3
12054 3614           D3E0                       shl	ax,cl
12055 3616           89C3                       mov	bx,ax
12056                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
12057                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
12058 3618           81C3                 0124  add	bx,#$124
12059 361C           53                         push	bx
12060                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12061 361D           FF76         FE            push	-2[bp]
12062                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12063 3620           E8         CFE4            call	_read_word
12064 3623           83C4                   04  add	sp,*4
12065                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12066 3626           8946         FC            mov	-4[bp],ax
12067                                           !BCC_EOS
12068                                           ! 2062   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
12069                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12070 3629           8A46         F1            mov	al,-$F[bp]
12071 362C           30E4                       xor	ah,ah
12072 362E           B1                     03  mov	cl,*3
12073 3630           D3E0                       shl	ax,cl
12074 3632           89C3                       mov	bx,ax
12075                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
12076                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
12077 3634           81C3                 0126  add	bx,#$126
12078 3638           53                         push	bx
12079                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12080 3639           FF76         FE            push	-2[bp]
12081                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12082 363C           E8         CFC8            call	_read_word
12083 363F           83C4                   04  add	sp,*4
12084                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
12085 3642           8946         FA            mov	-6[bp],ax
12086                                           !BCC_EOS
12087                                           ! 2063   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
12088                                           ! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
12089 3645           8B46         04            mov	ax,4[bp]
12090 3648           B9                   001E  mov	cx,*$1E
12091 364B           F7E9                       imul	cx
12092 364D           89C3                       mov	bx,ax
12093                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
12094                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
12095 364F           81C3                 0146  add	bx,#$146
12096 3653           53                         push	bx
12097                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12098 3654           FF76         FE            push	-2[bp]
12099                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12100 3657           E8         CF9A            call	_read_byte
12101 365A           83C4                   04  add	sp,*4
12102                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
12103 365D           8846         EE            mov	-$12[bp],al
12104                                           !BCC_EOS
12105                                           ! 2064   transfer= 0L;
12106                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
12107 3660           31C0                       xor	ax,ax
12108 3662           31DB                       xor	bx,bx
12109 3664           8946         E4            mov	-$1C[bp],ax
12110 3667           895E         E6            mov	-$1A[bp],bx
12111                                           !BCC_EOS
12112                                           ! 2065   if (cmdlen < 12) cmdlen=12;
12113                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12114 366A           8A46         06            mov	al,6[bp]
12115 366D           3C                     0C  cmp	al,*$C
12116 366F           73           05            jae 	.29A
12117                       00003671            .29B:
12118                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12119 3671           B0                     0C  mov	al,*$C
12120 3673           8846         06            mov	6[bp],al
12121                                           !BCC_EOS
12122                                           ! 2066   if (cmdlen > 12) cmdlen=16;
12123                       00003676            .29A:
12124                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12125 3676           8A46         06            mov	al,6[bp]
12126 3679           3C                     0C  cmp	al,*$C
12127 367B           76           05            jbe 	.29C
12128                       0000367D            .29D:
12129                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12130 367D           B0                     10  mov	al,*$10
12131 367F           8846         06            mov	6[bp],al
12132                                           !BCC_EOS
12133                                           ! 2067   cmdlen>>=1;
12134                       00003682            .29C:
12135                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12136 3682           8A46         06            mov	al,6[bp]
12137 3685           30E4                       xor	ah,ah
12138 3687           D1E8                       shr	ax,*1
12139 3689           8846         06            mov	6[bp],al
12140                                           !BCC_EOS
12141                                           ! 2068   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
12142                                           ! Debug: list int = const 0 (used reg = )
12143 368C           31C0                       xor	ax,ax
12144 368E           50                         push	ax
12145                                           ! Debug: list * unsigned short = const $254 (used reg = )
12146 368F           B8                   0254  mov	ax,#$254
12147 3692           50                         push	ax
12148                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
12149 3693           FF76         FE            push	-2[bp]
12150                                           ! Debug: func () void = write_word+0 (used reg = )
12151 3696           E8         CF99            call	_write_word
12152 3699           83C4                   06  add	sp,*6
12153                                           !BCC_EOS
12154                                           ! 2069   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
12155                                           ! Debug: list long = const 0 (used reg = )
12156 369C           31C0                       xor	ax,ax
12157 369E           31DB                       xor	bx,bx
12158 36A0           53                         push	bx
12159 36A1           50                         push	ax
12160                                           ! Debug: list * unsigned long = const $256 (used reg = )
12161 36A2           B8                   0256  mov	ax,#$256
12162 36A5           50                         push	ax
12163                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
12164 36A6           FF76         FE            push	-2[bp]
12165                                           ! Debug: func () void = write_dword+0 (used reg = )
12166 36A9           E8         C9EF            call	_write_dword
12167 36AC           83C4                   08  add	sp,*8
12168                                           !BCC_EOS
12169                                           ! 2070   status = inb(iobase1 + 7);
12170                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12171 36AF           8B46         FC            mov	ax,-4[bp]
12172                                           ! Debug: list unsigned int = ax+7 (used reg = )
12173 36B2           05                   0007  add	ax,*7
12174 36B5           50                         push	ax
12175                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12176 36B6           E8         CE85            call	_inb
12177 36B9           44                         inc	sp
12178 36BA           44                         inc	sp
12179                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12180 36BB           8846         EF            mov	-$11[bp],al
12181                                           !BCC_EOS
12182                                           ! 2071   if (
12183                                           ! 2071 status & 0x80) return 2;
12184                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
12185 36BE           8A46         EF            mov	al,-$11[bp]
12186 36C1           24                     80  and	al,#$80
12187 36C3           84C0                       test	al,al
12188 36C5           74           07            je  	.29E
12189                       000036C7            .29F:
12190 36C7           B8                   0002  mov	ax,*2
12191 36CA           89EC                       mov	sp,bp
12192 36CC           5D                         pop	bp
12193 36CD           C3                         ret
12194                                           !BCC_EOS
12195                                           ! 2072   outb(iobase2 + 6, 0x08 | 0x02);
12196                       000036CE            .29E:
12197                                           ! Debug: list int = const $A (used reg = )
12198 36CE           B8                   000A  mov	ax,*$A
12199 36D1           50                         push	ax
12200                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
12201 36D2           8B46         FA            mov	ax,-6[bp]
12202                                           ! Debug: list unsigned int = ax+6 (used reg = )
12203 36D5           05                   0006  add	ax,*6
12204 36D8           50                         push	ax
12205                                           ! Debug: func () void = outb+0 (used reg = )
12206 36D9           E8         CE78            call	_outb
12207 36DC           83C4                   04  add	sp,*4
12208                                           !BCC_EOS
12209                                           ! 2073   outb(iobase1 + 1, 0x00);
12210                                           ! Debug: list int = const 0 (used reg = )
12211 36DF           31C0                       xor	ax,ax
12212 36E1           50                         push	ax
12213                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
12214 36E2           8B46         FC            mov	ax,-4[bp]
12215                                           ! Debug: list unsigned int = ax+1 (used reg = )
12216 36E5           40                         inc	ax
12217 36E6           50                         push	ax
12218                                           ! Debug: func () void = outb+0 (used reg = )
12219 36E7           E8         CE6A            call	_outb
12220 36EA           83C4                   04  add	sp,*4
12221                                           !BCC_EOS
12222                                           ! 2074   outb(iobase1 + 2, 0x00);
12223                                           ! Debug: list int = const 0 (used reg = )
12224 36ED           31C0                       xor	ax,ax
12225 36EF           50                         push	ax
12226                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
12227 36F0           8B46         FC            mov	ax,-4[bp]
12228                                           ! Debug: list unsigned int = ax+2 (used reg = )
12229 36F3           40                         inc	ax
12230 36F4           40                         inc	ax
12231 36F5           50                         push	ax
12232                                           ! Debug: func () void = outb+0 (used reg = )
12233 36F6           E8         CE5B            call	_outb
12234 36F9           83C4                   04  add	sp,*4
12235                                           !BCC_EOS
12236                                           ! 2075   outb(iobase1 + 3, 0x00);
12237                                           ! Debug: list int = const 0 (used reg = )
12238 36FC           31C0                       xor	ax,ax
12239 36FE           50                         push	ax
12240                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
12241 36FF           8B46         FC            mov	ax,-4[bp]
12242                                           ! Debug: list unsigned int = ax+3 (used reg = )
12243 3702           05                   0003  add	ax,*3
12244 3705           50                         push	ax
12245                                           ! Debug: func () void = outb+0 (used reg = )
12246 3706           E8         CE4B            call	_outb
12247 3709           83C4                   04  add	sp,*4
12248                                           !BCC_EOS
12249                                           ! 2076   outb(iobase1 + 4, 0xfff0 & 0x00ff);
12250                                           ! Debug: list unsigned int = const $F0 (used reg = )
12251 370C           B8                   00F0  mov	ax,#$F0
12252 370F           50                         push	ax
12253                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
12254 3710           8B46         FC            mov	ax,-4[bp]
12255                                           ! Debug: list unsigned int = ax+4 (used reg = )
12256 3713           05                   0004  add	ax,*4
12257 3716           50                         push	ax
12258                                           ! Debug: func () void = outb+0 (used reg = )
12259 3717           E8         CE3A            call	_outb
12260 371A           83C4                   04  add	sp,*4
12261                                           !BCC_EOS
12262                                           ! 2077   outb(iobase1 + 5, 0xfff0 >> 8);
12263                                           ! Debug: list unsigned int = const $FF (used reg = )
12264 371D           B8                   00FF  mov	ax,#$FF
12265 3720           50                         push	ax
12266                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
12267 3721           8B46         FC            mov	ax,-4[bp]
12268                                           ! Debug: list unsigned int = ax+5 (used reg = )
12269 3724           05                   0005  add	ax,*5
12270 3727           50                         push	ax
12271                                           ! Debug: func () void = outb+0 (used reg = )
12272 3728           E8         CE29            call	_outb
12273 372B           83C4                   04  add	sp,*4
12274                                           !BCC_EOS
12275                                           ! 2078   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
12276 372E           8A46         F0            mov	al,-$10[bp]
12277 3731           84C0                       test	al,al
12278 3733           74           04            je  	.2A0
12279                       00003735            .2A1:
12280 3735           B0                     B0  mov	al,#$B0
12281 3737           EB           02            jmp .2A2
12282                       00003739            .2A0:
12283 3739           B0                     A0  mov	al,#$A0
12284                       0000373B            .2A2:
12285                                           ! Debug: list char = al+0 (used reg = )
12286 373B           30E4                       xor	ah,ah
12287 373D           50                         push	ax
12288                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
12289 373E           8B46         FC            mov	ax,-4[bp]
12290                                           ! Debug: list unsigned int = ax+6 (used reg = )
12291 3741           05                   0006  add	ax,*6
12292 3744           50                         push	ax
12293                                           ! Debug: func () void = outb+0 (used reg = )
12294 3745           E8         CE0C            call	_outb
12295 3748           83C4                   04  add	sp,*4
12296                                           !BCC_EOS
12297                                           ! 2079   outb(iobase1 + 7, 0xA0);
12298                                           ! Debug: list int = const $A0 (used reg = )
12299 374B           B8                   00A0  mov	ax,#$A0
12300 374E           50                         push	ax
12301                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
12302 374F           8B46         FC            mov	ax,-4[bp]
12303                                           ! Debug: list unsigned int = ax+7 (used reg = )
12304 3752           05                   0007  add	ax,*7
12305 3755           50                         push	ax
12306                                           ! Debug: func () void = outb+0 (used reg = )
12307 3756           E8         CDFB            call	_outb
12308 3759           83C4                   04  add	sp,*4
12309                                           !BCC_EOS
12310                                           ! 2080   status = await_ide(3, iobase1, 32000u);
12311                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12312 375C           B8                   7D00  mov	ax,#$7D00
12313 375F           50                         push	ax
12314                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12315 3760           FF76         FC            push	-4[bp]
12316                                           ! Debug: list int = const 3 (used reg = )
12317 3763           B8                   0003  mov	ax,*3
12318 3766           50                         push	ax
12319                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12320 3767           E8         E54E            call	_await_ide
12321 376A           83C4                   06  add	sp,*6
12322                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12323 376D           8846         EF            mov	-$11[bp],al
12324                                           !BCC_EOS
12325                                           ! 2081   if (status & 0x01) {
12326                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
12327 3770           8A46         EF            mov	al,-$11[bp]
12328 3773           24                     01  and	al,*1
12329 3775           84C0                       test	al,al
12330 3777           74           09            je  	.2A3
12331                       00003779            .2A4:
12332                                           ! 2082     ;
12333                                           !BCC_EOS
12334                                           ! 2083     return 3;
12335 3779           B8                   0003  mov	ax,*3
12336 377C           89EC                       mov	sp,bp
12337 377E           5D                         pop	bp
12338 377F           C3                         ret
12339                                           !BCC_EOS
12340                                           ! 2084     } else if ( !(status & 0x08) ) {
12341 3780           EB           10            jmp .2A5
12342                       00003782            .2A3:
12343                                           ! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
12344 3782           8A46         EF            mov	al,-$11[bp]
12345 3785           24                     08  and	al,*8
12346 3787           84C0                       test	al,al
12347 3789           75           07            jne 	.2A6
12348                       0000378B            .2A7:
12349                                           ! 2085     ;
12350                                           !BCC_EOS
12351                                           ! 2086     return 4;
12352 378B           B8                   0004  mov	ax,*4
12353 378E           89EC                       mov	sp,bp
12354 3790           5D                         pop	bp
12355 3791           C3                         ret
12356                                           !BCC_EOS
12357                                           ! 2087     }
12358                                           ! 2088   cmdseg += (cmdoff / 16);
12359                       00003792            .2A6:
12360                       00003792            .2A5:
12361                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12362 3792           8B46         0A            mov	ax,$A[bp]
12363 3795           B1                     04  mov	cl,*4
12364 3797           D3E8                       shr	ax,cl
12365                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
12366 3799           0346         08            add	ax,8[bp]
12367 379C           8946         08            mov	8[bp],ax
12368                                           !BCC_EOS
12369                                           ! 2089   cmdoff %= 16;
12370                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12371 379F           8B46         0A            mov	ax,$A[bp]
12372 37A2           24                     0F  and	al,*$F
12373 37A4           30E4                       xor	ah,ah
12374 37A6           8946         0A            mov	$A[bp],ax
12375                                           !BCC_EOS
12376                                           ! 2090 #asm
12377                                           !BCC_EOS
12378                                           !BCC_ASM
12379                       00000026            _ata_cmd_packet.cmdoff	set	$26
12380                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12381                       00000028            _ata_cmd_packet.header	set	$28
12382                       0000000C            .ata_cmd_packet.header	set	$C
12383                       0000000E            _ata_cmd_packet.count	set	$E
12384                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12385                       00000010            _ata_cmd_packet.lafter	set	$10
12386                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12387                       00000018            _ata_cmd_packet.iobase1	set	$18
12388                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12389                       0000000D            _ata_cmd_packet.channel	set	$D
12390                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12391                       00000024            _ata_cmd_packet.cmdseg	set	$24
12392                       00000008            .ata_cmd_packet.cmdseg	set	8
12393                       00000022            _ata_cmd_packet.cmdlen	set	$22
12394                       00000006            .ata_cmd_packet.cmdlen	set	6
12395                       00000009            _ata_cmd_packet.lmode	set	9
12396                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12397                       00000020            _ata_cmd_packet.device	set	$20
12398                       00000004            .ata_cmd_packet.device	set	4
12399                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
12400                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12401                       00000014            _ata_cmd_packet.lcount	set	$14
12402                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12403                       00000004            _ata_cmd_packet.total	set	4
12404                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12405                       0000000B            _ata_cmd_packet.status	set	$B
12406                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12407                       0000000A            _ata_cmd_packet.mode	set	$A
12408                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12409                       00000032            _ata_cmd_packet.bufoff	set	$32
12410                       00000016            .ata_cmd_packet.bufoff	set	$16
12411                       00000000            _ata_cmd_packet.transfer	set	0
12412                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12413                       00000016            _ata_cmd_packet.iobase2	set	$16
12414                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12415                       00000012            _ata_cmd_packet.lbefore	set	$12
12416                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12417                       00000030            _ata_cmd_packet.bufseg	set	$30
12418                       00000014            .ata_cmd_packet.bufseg	set	$14
12419                       0000000C            _ata_cmd_packet.slave	set	$C
12420                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12421                       0000002E            _ata_cmd_packet.inout	set	$2E
12422                       00000012            .ata_cmd_packet.inout	set	$12
12423                       0000002A            _ata_cmd_packet.length	set	$2A
12424                       0000000E            .ata_cmd_packet.length	set	$E
12425 37A9           FB                               sti ;; enable higher priority interrupts
12426 37AA           55                               push bp
12427 37AB           89E5                             mov bp, sp
12428 37AD           8B76         28                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
12429 37B0           8B46         26                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
12430 37B3           8B4E         24                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
12431 37B6           8EC0                             mov es, ax ;; segment in es
12432 37B8           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
12433 37BB           26                               seg ES
12434 37BC           F3                               rep
12435 37BD           6F                                 outsw ;; CX words transfered from port(DX) to ES:[SI]
12436 37BE           5D                               pop bp
12437                                           ! 2103 endasm
12438                                           !BCC_ENDASM
12439                                           !BCC_EOS
12440                                           ! 2104   if (inout == 0x00) {
12441                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
12442 37BF           8A46         12            mov	al,$12[bp]
12443 37C2           84C0                       test	al,al
12444 37C4           75           17            jne 	.2A8
12445                       000037C6            .2A9:
12446                                           ! 2105     status = await_ide(2, iobase1, 32000u);
12447                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12448 37C6           B8                   7D00  mov	ax,#$7D00
12449 37C9           50                         push	ax
12450                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12451 37CA           FF76         FC            push	-4[bp]
12452                                           ! Debug: list int = const 2 (used reg = )
12453 37CD           B8                   0002  mov	ax,*2
12454 37D0           50                         push	ax
12455                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12456 37D1           E8         E4E4            call	_await_ide
12457 37D4           83C4                   06  add	sp,*6
12458                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12459 37D7           8846         EF            mov	-$11[bp],al
12460                                           !BCC_EOS
12461                                           ! 2106     }
12462                                           ! 2107   else {
12463 37DA           E9         0272            br 	.2AA
12464                       000037DD            .2A8:
12465                                           ! 2108         Bit16u loops = 0;
12466 37DD           4C                         dec	sp
12467 37DE           4C                         dec	sp
12468                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
12469 37DF           31C0                       xor	ax,ax
12470 37E1           8946         E2            mov	-$1E[bp],ax
12471                                           !BCC_EOS
12472                                           ! 2109         Bit8u sc;
12473                                           !BCC_EOS
12474                                           ! 2110   while (1) {
12475 37E4           4C                         dec	sp
12476 37E5           4C                         dec	sp
12477                       000037E6            .2AD:
12478                                           ! 2111       if (loops == 0) {
12479                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
12480 37E6           8B46         E2            mov	ax,-$1E[bp]
12481 37E9           85C0                       test	ax,ax
12482 37EB           75           25            jne 	.2AE
12483                       000037ED            .2AF:
12484                                           ! 2112         status = inb(iobase2 + 6);
12485                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
12486 37ED           8B46         FA            mov	ax,-6[bp]
12487                                           ! Debug: list unsigned int = ax+6 (used reg = )
12488 37F0           05                   0006  add	ax,*6
12489 37F3           50                         push	ax
12490                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12491 37F4           E8         CD47            call	_inb
12492 37F7           44                         inc	sp
12493 37F8           44                         inc	sp
12494                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12495 37F9           8846         EF            mov	-$11[bp],al
12496                                           !BCC_EOS
12497                                           ! 2113         status = await_ide(3, iobase1, 32000u);
12498                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12499 37FC           B8                   7D00  mov	ax,#$7D00
12500 37FF           50                         push	ax
12501                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12502 3800           FF76         FC            push	-4[bp]
12503                                           ! Debug: list int = const 3 (used reg = )
12504 3803           B8                   0003  mov	ax,*3
12505 3806           50                         push	ax
12506                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12507 3807           E8         E4AE            call	_await_ide
12508 380A           83C4                   06  add	sp,*6
12509                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12510 380D           8846         EF            mov	-$11[bp],al
12511                                           !BCC_EOS
12512                                           ! 2114       }
12513                                           ! 2115       else
12514                                           ! 2116         status = await_ide(2, iobase1, 32000u);
12515 3810           EB           14            jmp .2B0
12516                       00003812            .2AE:
12517                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12518 3812           B8                   7D00  mov	ax,#$7D00
12519 3815           50                         push	ax
12520                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12521 3816           FF76         FC            push	-4[bp]
12522                                           ! Debug: list int = const 2 (used reg = )
12523 3819           B8                   0002  mov	ax,*2
12524 381C           50                         push	ax
12525                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12526 381D           E8         E498            call	_await_ide
12527 3820           83C4                   06  add	sp,*6
12528                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12529 3823           8846         EF            mov	-$11[bp],al
12530                                           !BCC_EOS
12531                                           ! 2117       loops++;
12532                       00003826            .2B0:
12533                                           ! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
12534 3826           8B46         E2            mov	ax,-$1E[bp]
12535 3829           40                         inc	ax
12536 382A           8946         E2            mov	-$1E[bp],ax
12537                                           !BCC_EOS
12538                                           ! 2118       sc = inb(iobase1 + 2);
12539                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12540 382D           8B46         FC            mov	ax,-4[bp]
12541                                           ! Debug: list unsigned int = ax+2 (used reg = )
12542 3830           40                         inc	ax
12543 3831           40                         inc	ax
12544 3832           50                         push	ax
12545                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12546 3833           E8         CD08            call	_inb
12547 3836           44                         inc	sp
12548 3837           44                         inc	sp
12549                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
12550 3838           8846         E1            mov	-$1F[bp],al
12551                                           !BCC_EOS
12552                                           ! 2119       if(((inb(iobase1 + 2)&0x7)==0x3) &&
12553                                           ! 2120          ((status & (0x40 | 0x01)) == 0x40)) break;
12554                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12555 383B           8B46         FC            mov	ax,-4[bp]
12556                                           ! Debug: list unsigned int = ax+2 (used reg = )
12557 383E           40                         inc	ax
12558 383F           40                         inc	ax
12559 3840           50                         push	ax
12560                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12561 3841           E8         CCFA            call	_inb
12562 3844           44                         inc	sp
12563 3845           44                         inc	sp
12564                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
12565 3846           24                     07  and	al,*7
12566                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
12567 3848           3C                     03  cmp	al,*3
12568 384A           75           0C            jne 	.2B1
12569                       0000384C            .2B3:
12570                                           ! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
12571 384C           8A46         EF            mov	al,-$11[bp]
12572 384F           24                     41  and	al,*$41
12573                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
12574 3851           3C                     40  cmp	al,*$40
12575 3853           75           03            jne 	.2B1
12576                       00003855            .2B2:
12577 3855           E9         01F4            br 	.2AB
12578                                           !BCC_EOS
12579                                           ! 2121       if (status & 0x01) {
12580                       00003858            .2B1:
12581                                           ! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
12582 3858           8A46         EF            mov	al,-$11[bp]
12583 385B           24                     01  and	al,*1
12584 385D           84C0                       test	al,al
12585 385F           74           07            je  	.2B4
12586                       00003861            .2B5:
12587                                           ! 2122         ;
12588                                           !BCC_EOS
12589                                           ! 2123         return 3;
12590 3861           B8                   0003  mov	ax,*3
12591 3864           89EC                       mov	sp,bp
12592 3866           5D                         pop	bp
12593 3867           C3                         ret
12594                                           !BCC_EOS
12595                                           ! 2124       }
12596                                           ! 2125       bufseg += (bufoff / 16);
12597                       00003868            .2B4:
12598                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12599 3868           8B46         16            mov	ax,$16[bp]
12600 386B           B1                     04  mov	cl,*4
12601 386D           D3E8                       shr	ax,cl
12602                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
12603 386F           0346         14            add	ax,$14[bp]
12604 3872           8946         14            mov	$14[bp],ax
12605                                           !BCC_EOS
12606                                           ! 2126       bufoff %= 16;
12607                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12608 3875           8B46         16            mov	ax,$16[bp]
12609 3878           24                     0F  and	al,*$F
12610 387A           30E4                       xor	ah,ah
12611 387C           8946         16            mov	$16[bp],ax
12612                                           !BCC_EOS
12613                                           ! 2127       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
12614                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
12615 387F           8B46         FC            mov	ax,-4[bp]
12616                                           ! Debug: list unsigned int = ax+4 (used reg = )
12617 3882           05                   0004  add	ax,*4
12618 3885           50                         push	ax
12619                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12620 3886           E8         CCB5            call	_inb
12621 3889           44                         inc	sp
12622 388A           44                         inc	sp
12623 388B           50                         push	ax
12624                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
12625 388C           8B46         FC            mov	ax,-4[bp]
12626                                           ! Debug: list unsigned int = ax+5 (used reg = )
12627 388F           05                   0005  add	ax,*5
12628 3892           50                         push	ax
12629                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12630 3893           E8         CCA8            call	_inb
12631 3896           44                         inc	sp
12632 3897           44                         inc	sp
12633                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
12634 3898           30E4                       xor	ah,ah
12635                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
12636 389A           88C4                       mov	ah,al
12637 389C           30C0                       xor	al,al
12638                                           ! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
12639 389E           0246         DE            add	al,-$22[bp]
12640 38A1           80D4                   00  adc	ah,*0
12641 38A4           44                         inc	sp
12642 38A5           44                         inc	sp
12643                                           ! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
12644 38A6           8946         F8            mov	-8[bp],ax
12645                                           !BCC_EOS
12646                                           ! 2128       if(header>lcount) {
12647                                           ! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12648 38A9           8B46         0C            mov	ax,$C[bp]
12649 38AC           3B46         F8            cmp	ax,-8[bp]
12650 38AF           76           16            jbe 	.2B6
12651                       000038B1            .2B7:
12652                                           ! 2129          lbefore=lcount;
12653                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12654 38B1           8B46         F8            mov	ax,-8[bp]
12655 38B4           8946         F6            mov	-$A[bp],ax
12656                                           !BCC_EOS
12657                                           ! 2130          header-=lcount;
12658                                           ! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12659 38B7           8B46         0C            mov	ax,$C[bp]
12660 38BA           2B46         F8            sub	ax,-8[bp]
12661 38BD           8946         0C            mov	$C[bp],ax
12662                                           !BCC_EOS
12663                                           ! 2131          lcount=0;
12664                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12665 38C0           31C0                       xor	ax,ax
12666 38C2           8946         F8            mov	-8[bp],ax
12667                                           !BCC_EOS
12668                                           ! 2132          }
12669                                           ! 2133       else {
12670 38C5           EB           14            jmp .2B8
12671                       000038C7            .2B6:
12672                                           ! 2134         lbefore=header;
12673                                           ! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12674 38C7           8B46         0C            mov	ax,$C[bp]
12675 38CA           8946         F6            mov	-$A[bp],ax
12676                                           !BCC_EOS
12677                                           ! 2135         header=0;
12678                                           ! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
12679 38CD           31C0                       xor	ax,ax
12680 38CF           8946         0C            mov	$C[bp],ax
12681                                           !BCC_EOS
12682                                           ! 2136         lcount-=lbefore;
12683                                           ! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12684 38D2           8B46         F8            mov	ax,-8[bp]
12685 38D5           2B46         F6            sub	ax,-$A[bp]
12686 38D8           8946         F8            mov	-8[bp],ax
12687                                           !BCC_EOS
12688                                           ! 2137         }
12689                                           ! 2138       if(lcount>length) {
12690                       000038DB            .2B8:
12691                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12692 38DB           8B46         F8            mov	ax,-8[bp]
12693 38DE           31DB                       xor	bx,bx
12694                                           ! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12695 38E0           8D7E         0E            lea	di,$E[bp]
12696 38E3           E8         C7E5            call	lcmpul
12697 38E6           76           20            jbe 	.2B9
12698                       000038E8            .2BA:
12699                                           ! 2139         lafter=lcount-length;
12700                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12701 38E8           8B46         F8            mov	ax,-8[bp]
12702 38EB           31DB                       xor	bx,bx
12703                                           ! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12704 38ED           8D7E         0E            lea	di,$E[bp]
12705 38F0           E8         C7EE            call	lsubul
12706                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
12707 38F3           8946         F4            mov	-$C[bp],ax
12708                                           !BCC_EOS
12709                                           ! 2140         lcount=length;
12710                                           ! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12711 38F6           8B46         0E            mov	ax,$E[bp]
12712 38F9           8946         F8            mov	-8[bp],ax
12713                                           !BCC_EOS
12714                                           ! 2141         length=0;
12715                                           ! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
12716 38FC           31C0                       xor	ax,ax
12717 38FE           31DB                       xor	bx,bx
12718 3900           8946         0E            mov	$E[bp],ax
12719 3903           895E         10            mov	$10[bp],bx
12720                                           !BCC_EOS
12721                                           ! 2142         }
12722                                           ! 2143       else {
12723 3906           EB           21            jmp .2BB
12724                       00003908            .2B9:
12725                                           ! 2144         lafter=0;
12726                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12727 3908           31C0                       xor	ax,ax
12728 390A           8946         F4            mov	-$C[bp],ax
12729                                           !BCC_EOS
12730                                           ! 2145         length-=lcount;
12731                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12732 390D           8B46         F8            mov	ax,-8[bp]
12733 3910           31DB                       xor	bx,bx
12734                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
12735 3912           53                         push	bx
12736 3913           50                         push	ax
12737 3914           8B46         0E            mov	ax,$E[bp]
12738 3917           8B5E         10            mov	bx,$10[bp]
12739 391A           8D7E         DC            lea	di,-$24[bp]
12740 391D           E8         C7C1            call	lsubul
12741 3920           8946         0E            mov	$E[bp],ax
12742 3923           895E         10            mov	$10[bp],bx
12743 3926           83C4                   04  add	sp,*4
12744                                           !BCC_EOS
12745                                           ! 2146         }
12746                                           ! 2147       count = lcount;
12747                       00003929            .2BB:
12748                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
12749 3929           8B46         F8            mov	ax,-8[bp]
12750 392C           8946         F2            mov	-$E[bp],ax
12751                                           !BCC_EOS
12752                                           ! 2148       ;
12753                                           !BCC_EOS
12754                                           ! 2149       ;
12755                                           !BCC_EOS
12756                                           ! 2150       lmode = mode;
12757                                           ! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
12758 392F           8A46         EE            mov	al,-$12[bp]
12759 3932           8846         ED            mov	-$13[bp],al
12760                                           !BCC_EOS
12761                                           ! 2151       if (lbefore & 0x03) lmode=0x00;
12762                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
12763 3935           8A46         F6            mov	al,-$A[bp]
12764 3938           24                     03  and	al,*3
12765 393A           84C0                       test	al,al
12766 393C           74           05            je  	.2BC
12767                       0000393E            .2BD:
12768                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12769 393E           30C0                       xor	al,al
12770 3940           8846         ED            mov	-$13[bp],al
12771                                           !BCC_EOS
12772                                           ! 2152       if (lcount & 0x03) lmode=0x00;
12773                       00003943            .2BC:
12774                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
12775 3943           8A46         F8            mov	al,-8[bp]
12776 3946           24                     03  and	al,*3
12777 3948           84C0                       test	al,al
12778 394A           74           05            je  	.2BE
12779                       0000394C            .2BF:
12780                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12781 394C           30C0                       xor	al,al
12782 394E           8846         ED            mov	-$13[bp],al
12783                                           !BCC_EOS
12784                                           ! 2153       if (lafter 
12785                       00003951            .2BE:
12786                                           ! 2153 & 0x03) lmode=0x00;
12787                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
12788 3951           8A46         F4            mov	al,-$C[bp]
12789 3954           24                     03  and	al,*3
12790 3956           84C0                       test	al,al
12791 3958           74           05            je  	.2C0
12792                       0000395A            .2C1:
12793                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12794 395A           30C0                       xor	al,al
12795 395C           8846         ED            mov	-$13[bp],al
12796                                           !BCC_EOS
12797                                           ! 2154       if (lcount & 0x01) {
12798                       0000395F            .2C0:
12799                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12800 395F           8A46         F8            mov	al,-8[bp]
12801 3962           24                     01  and	al,*1
12802 3964           84C0                       test	al,al
12803 3966           74           1E            je  	.2C2
12804                       00003968            .2C3:
12805                                           ! 2155         lcount+=1;
12806                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12807 3968           8B46         F8            mov	ax,-8[bp]
12808 396B           40                         inc	ax
12809 396C           8946         F8            mov	-8[bp],ax
12810                                           !BCC_EOS
12811                                           ! 2156         if ((lafter > 0) && (lafter & 0x01)) {
12812                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12813 396F           8B46         F4            mov	ax,-$C[bp]
12814 3972           85C0                       test	ax,ax
12815 3974           74           10            je  	.2C4
12816                       00003976            .2C6:
12817                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12818 3976           8A46         F4            mov	al,-$C[bp]
12819 3979           24                     01  and	al,*1
12820 397B           84C0                       test	al,al
12821 397D           74           07            je  	.2C4
12822                       0000397F            .2C5:
12823                                           ! 2157           lafter-=1;
12824                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12825 397F           8B46         F4            mov	ax,-$C[bp]
12826 3982           48                         dec	ax
12827 3983           8946         F4            mov	-$C[bp],ax
12828                                           !BCC_EOS
12829                                           ! 2158           }
12830                                           ! 2159         }
12831                       00003986            .2C4:
12832                                           ! 2160       if (lmode == 0x01) {
12833                       00003986            .2C2:
12834                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
12835 3986           8A46         ED            mov	al,-$13[bp]
12836 3989           3C                     01  cmp	al,*1
12837 398B           75           20            jne 	.2C7
12838                       0000398D            .2C8:
12839                                           ! 2161         lcount>>=2; lbefore>>=2; lafter>>=2;
12840                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
12841 398D           8B46         F8            mov	ax,-8[bp]
12842 3990           D1E8                       shr	ax,*1
12843 3992           D1E8                       shr	ax,*1
12844 3994           8946         F8            mov	-8[bp],ax
12845                                           !BCC_EOS
12846                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
12847 3997           8B46         F6            mov	ax,-$A[bp]
12848 399A           D1E8                       shr	ax,*1
12849 399C           D1E8                       shr	ax,*1
12850 399E           8946         F6            mov	-$A[bp],ax
12851                                           !BCC_EOS
12852                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
12853 39A1           8B46         F4            mov	ax,-$C[bp]
12854 39A4           D1E8                       shr	ax,*1
12855 39A6           D1E8                       shr	ax,*1
12856 39A8           8946         F4            mov	-$C[bp],ax
12857                                           !BCC_EOS
12858                                           ! 2162         }
12859                                           ! 2163       else {
12860 39AB           EB           18            jmp .2C9
12861                       000039AD            .2C7:
12862                                           ! 2164         lcount>>=1; lbefore>>=1; lafter>>=1;
12863                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12864 39AD           8B46         F8            mov	ax,-8[bp]
12865 39B0           D1E8                       shr	ax,*1
12866 39B2           8946         F8            mov	-8[bp],ax
12867                                           !BCC_EOS
12868                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
12869 39B5           8B46         F6            mov	ax,-$A[bp]
12870 39B8           D1E8                       shr	ax,*1
12871 39BA           8946         F6            mov	-$A[bp],ax
12872                                           !BCC_EOS
12873                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12874 39BD           8B46         F4            mov	ax,-$C[bp]
12875 39C0           D1E8                       shr	ax,*1
12876 39C2           8946         F4            mov	-$C[bp],ax
12877                                           !BCC_EOS
12878                                           ! 2165         }
12879                                           ! 2166        ;
12880                       000039C5            .2C9:
12881                                           !BCC_EOS
12882                                           ! 2167 #asm
12883                                           !BCC_EOS
12884                                           !BCC_ASM
12885                       0000002A            _ata_cmd_packet.cmdoff	set	$2A
12886                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12887                       0000002C            _ata_cmd_packet.header	set	$2C
12888                       0000000C            .ata_cmd_packet.header	set	$C
12889                       00000012            _ata_cmd_packet.count	set	$12
12890                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12891                       00000014            _ata_cmd_packet.lafter	set	$14
12892                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12893                       0000001C            _ata_cmd_packet.iobase1	set	$1C
12894                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12895                       00000011            _ata_cmd_packet.channel	set	$11
12896                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12897                       00000028            _ata_cmd_packet.cmdseg	set	$28
12898                       00000008            .ata_cmd_packet.cmdseg	set	8
12899                       00000026            _ata_cmd_packet.cmdlen	set	$26
12900                       00000006            .ata_cmd_packet.cmdlen	set	6
12901                       0000000D            _ata_cmd_packet.lmode	set	$D
12902                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12903                       00000024            _ata_cmd_packet.device	set	$24
12904                       00000004            .ata_cmd_packet.device	set	4
12905                       00000002            _ata_cmd_packet.loops	set	2
12906                       FFFFFFE2            .ata_cmd_packet.loops	set	-$1E
12907                       0000001E            _ata_cmd_packet.ebda_seg	set	$1E
12908                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12909                       00000018            _ata_cmd_packet.lcount	set	$18
12910                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12911                       00000008            _ata_cmd_packet.total	set	8
12912                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12913                       0000000F            _ata_cmd_packet.status	set	$F
12914                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12915                       0000000E            _ata_cmd_packet.mode	set	$E
12916                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12917                       00000036            _ata_cmd_packet.bufoff	set	$36
12918                       00000016            .ata_cmd_packet.bufoff	set	$16
12919                       00000004            _ata_cmd_packet.transfer	set	4
12920                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12921                       00000001            _ata_cmd_packet.sc	set	1
12922                       FFFFFFE1            .ata_cmd_packet.sc	set	-$1F
12923                       0000001A            _ata_cmd_packet.iobase2	set	$1A
12924                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12925                       00000016            _ata_cmd_packet.lbefore	set	$16
12926                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12927                       00000034            _ata_cmd_packet.bufseg	set	$34
12928                       00000014            .ata_cmd_packet.bufseg	set	$14
12929                       00000010            _ata_cmd_packet.slave	set	$10
12930                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12931                       00000032            _ata_cmd_packet.inout	set	$32
12932                       00000012            .ata_cmd_packet.inout	set	$12
12933                       0000002E            _ata_cmd_packet.length	set	$2E
12934                       0000000E            .ata_cmd_packet.length	set	$E
12935 39C5           55                                 push bp
12936 39C6           89E5                               mov bp, sp
12937 39C8           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
12938 39CB           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
12939 39CE           E3           15                    jcxz ata_packet_no_before
12940 39D0           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12941 39D3           80FC                   01          cmp ah, #0x01
12942 39D6           74           05                    je ata_packet_in_before_32
12943                       000039D8            ata_packet_in_before_16:
12944 39D8           ED                                 in ax, dx
12945 39D9           E2           FD                    loop ata_packet_in_before_16
12946 39DB           EB           08                    jmp ata_packet_no_before
12947                       000039DD            ata_packet_in_before_32:
12948 39DD     66    50                                 push eax
12949                       000039DF            ata_packet_in_before_32_loop:
12950 39DF     66    ED                                 in eax, dx
12951 39E1           E2           FC                    loop ata_packet_in_before_32_loop
12952 39E3     66    58                                 pop eax
12953                       000039E5            ata_packet_no_before:
12954 39E5           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
12955 39E8           E3           17                    jcxz ata_packet_after
12956 39EA           8B7E         38                    mov di, _ata_cmd_packet.bufoff + 2[bp]
12957 39ED           8B46         36                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
12958 39F0           8EC0                               mov es, ax
12959 39F2           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12960 39F5           80FC                   01          cmp ah, #0x01
12961 39F8           74           04                    je ata_packet_in_32
12962                       000039FA            ata_packet_in_16:
12963 39FA           F3                                 rep
12964 39FB           6D                                   insw ;; CX words transfered tp port(DX) to ES:[DI]
12965 39FC           EB           03                    jmp ata_packet_after
12966                       000039FE            ata_packet_in_32:
12967 39FE           F3                                 rep
12968 39FF     66    6D                                   insd ;; CX dwords transfered to port(DX) to ES:[DI]
12969                       00003A01            ata_packet_after:
12970 3A01           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
12971 3A04           E3           15                    jcxz ata_packet_done
12972 3A06           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12973 3A09           80FC                   01          cmp ah, #0x01
12974 3A0C           74           05                    je ata_packet_in_after_32
12975                       00003A0E            ata_packet_in_after_16:
12976 3A0E           ED                                 in ax, dx
12977 3A0F           E2           FD                    loop ata_packet_in_after_16
12978 3A11           EB           08                    jmp ata_packet_done
12979                       00003A13            ata_packet_in_after_32:
12980 3A13     66    50                                 push eax
12981                       00003A15            ata_packet_in_after_32_loop:
12982 3A15     66    ED                                 in eax, dx
12983 3A17           E2           FC                    loop ata_packet_in_after_32_loop
12984 3A19     66    58                                 pop eax
12985                       00003A1B            ata_packet_done:
12986 3A1B           5D                                 pop bp
12987                                           ! 2220 endasm
12988                                           !BCC_ENDASM
12989                                           !BCC_EOS
12990                                           ! 2221       bufoff += count;
12991                                           ! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
12992 3A1C           8B46         16            mov	ax,$16[bp]
12993 3A1F           0346         F2            add	ax,-$E[bp]
12994 3A22           8946         16            mov	$16[bp],ax
12995                                           !BCC_EOS
12996                                           ! 2222       transfer += count;
12997                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
12998 3A25           8B46         F2            mov	ax,-$E[bp]
12999 3A28           31DB                       xor	bx,bx
13000                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
13001 3A2A           8D7E         E4            lea	di,-$1C[bp]
13002 3A2D           E8         C693            call	laddul
13003 3A30           8946         E4            mov	-$1C[bp],ax
13004 3A33           895E         E6            mov	-$1A[bp],bx
13005                                           !BCC_EOS
13006                                           ! 2223       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
13007                                           ! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
13008 3A36           FF76         E6            push	-$1A[bp]
13009 3A39           FF76         E4            push	-$1C[bp]
13010                                           ! Debug: list * unsigned long = const $256 (used reg = )
13011 3A3C           B8                   0256  mov	ax,#$256
13012 3A3F           50                         push	ax
13013                                           ! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
13014 3A40           FF76         FE            push	-2[bp]
13015                                           ! Debug: func () void = write_dword+0 (used reg = )
13016 3A43           E8         C655            call	_write_dword
13017 3A46           83C4                   08  add	sp,*8
13018                                           !BCC_EOS
13019                                           ! 2224       }
13020                                           ! 2225     }
13021                       00003A49            .2AC:
13022 3A49           E9         FD9A            br 	.2AD
13023                       00003A4C            .2CA:
13024                       00003A4C            .2AB:
13025 3A4C           83C4                   04  add	sp,*4
13026                                           ! 2226   if ( (status & (0x80 | 0x40 |
13027                       00003A4F            .2AA:
13028                                           ! 2226  0x20 | 0x08 | 0x01) )
13029                                           ! 2227          != 0x40 ) {
13030                                           ! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
13031 3A4F           8A46         EF            mov	al,-$11[bp]
13032 3A52           24                     E9  and	al,#$E9
13033                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
13034 3A54           3C                     40  cmp	al,*$40
13035 3A56           74           07            je  	.2CB
13036                       00003A58            .2CC:
13037                                           ! 2228     ;
13038                                           !BCC_EOS
13039                                           ! 2229     return 4;
13040 3A58           B8                   0004  mov	ax,*4
13041 3A5B           89EC                       mov	sp,bp
13042 3A5D           5D                         pop	bp
13043 3A5E           C3                         ret
13044                                           !BCC_EOS
13045                                           ! 2230     }
13046                                           ! 2231   outb(iobase2+6, 0x08);
13047                       00003A5F            .2CB:
13048                                           ! Debug: list int = const 8 (used reg = )
13049 3A5F           B8                   0008  mov	ax,*8
13050 3A62           50                         push	ax
13051                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
13052 3A63           8B46         FA            mov	ax,-6[bp]
13053                                           ! Debug: list unsigned int = ax+6 (used reg = )
13054 3A66           05                   0006  add	ax,*6
13055 3A69           50                         push	ax
13056                                           ! Debug: func () void = outb+0 (used reg = )
13057 3A6A           E8         CAE7            call	_outb
13058 3A6D           83C4                   04  add	sp,*4
13059                                           !BCC_EOS
13060                                           ! 2232   return 0;
13061 3A70           31C0                       xor	ax,ax
13062 3A72           89EC                       mov	sp,bp
13063 3A74           5D                         pop	bp
13064 3A75           C3                         ret
13065                                           !BCC_EOS
13066                                           ! 2233 }
13067                                           ! 2234   Bit16u
13068                                           ! Register BX used in function ata_cmd_packet
13069                                           ! 2235 atapi_get_sense(device, seg, asc, ascq)
13070                                           ! 2236   Bit16u device;
13071                                           export	_atapi_get_sense
13072                       00003A76            _atapi_get_sense:
13073                                           !BCC_EOS
13074                                           ! 2237 {
13075                                           ! 2238   Bit8u atacmd[12];
13076                                           !BCC_EOS
13077                                           ! 2239   Bit8u buffer[18];
13078                                           !BCC_EOS
13079                                           ! 2240   Bit8u i;
13080                                           !BCC_EOS
13081                                           ! 2241   memsetb(get_SS(),atacmd,0,12);
13082 3A76           55                         push	bp
13083 3A77           89E5                       mov	bp,sp
13084 3A79           83C4                   E0  add	sp,*-$20
13085                                           ! Debug: list int = const $C (used reg = )
13086 3A7C           B8                   000C  mov	ax,*$C
13087 3A7F           50                         push	ax
13088                                           ! Debug: list int = const 0 (used reg = )
13089 3A80           31C0                       xor	ax,ax
13090 3A82           50                         push	ax
13091                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
13092 3A83           8D5E         F4            lea	bx,-$C[bp]
13093 3A86           53                         push	bx
13094                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13095 3A87           E8         CBC3            call	_get_SS
13096                                           ! Debug: list unsigned short = ax+0 (used reg = )
13097 3A8A           50                         push	ax
13098                                           ! Debug: func () void = memsetb+0 (used reg = )
13099 3A8B           E8         C572            call	_memsetb
13100 3A8E           83C4                   08  add	sp,*8
13101                                           !BCC_EOS
13102                                           ! 2242   atacmd[0]=0x03;
13103                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
13104 3A91           B0                     03  mov	al,*3
13105 3A93           8846         F4            mov	-$C[bp],al
13106                                           !BCC_EOS
13107                                           ! 2243   atacmd[4]=sizeof(buffer);
13108                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
13109 3A96           B0                     12  mov	al,*$12
13110 3A98           8846         F8            mov	-8[bp],al
13111                                           !BCC_EOS
13112                                           ! 2244   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
13113                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
13114 3A9B           8D5E         E2            lea	bx,-$1E[bp]
13115 3A9E           53                         push	bx
13116                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13117 3A9F           E8         CBAB            call	_get_SS
13118                                           ! Debug: list unsigned short = ax+0 (used reg = )
13119 3AA2           50                         push	ax
13120                                           ! Debug: list int = const 1 (used reg = )
13121 3AA3           B8                   0001  mov	ax,*1
13122 3AA6           50                         push	ax
13123                                           ! Debug: list long = const $12 (used reg = )
13124 3AA7           B8                   0012  mov	ax,*$12
13125 3AAA           31DB                       xor	bx,bx
13126 3AAC           53                         push	bx
13127 3AAD           50                         push	ax
13128                                           ! Debug: list int = const 0 (used reg = )
13129 3AAE           31C0                       xor	ax,ax
13130 3AB0           50                         push	ax
13131                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
13132 3AB1           8D5E         F4            lea	bx,-$C[bp]
13133 3AB4           53                         push	bx
13134                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13135 3AB5           E8         CB95            call	_get_SS
13136                                           ! Debug: list unsigned short = ax+0 (used reg = )
13137 3AB8           50                         push	ax
13138                                           ! Debug: list int = const $C (used reg = )
13139 3AB9           B8                   000C  mov	ax,*$C
13140 3ABC           50                         push	ax
13141                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
13142 3ABD           FF76         04            push	4[bp]
13143                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13144 3AC0           E8         FB03            call	_ata_cmd_packet
13145 3AC3           83C4                   14  add	sp,*$14
13146                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13147 3AC6           85C0                       test	ax,ax
13148 3AC8           74           07            je  	.2CD
13149                       00003ACA            .2CE:
13150                                           ! 2245     return 0x0002;
13151 3ACA           B8                   0002  mov	ax,*2
13152 3ACD           89EC                       mov	sp,bp
13153 3ACF           5D                         pop	bp
13154 3AD0           C3                         ret
13155                                           !BCC_EOS
13156                                           ! 2246   write_byte(seg,asc,buffer[12]);
13157                       00003AD1            .2CD:
13158                                           ! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
13159 3AD1           8A46         EE            mov	al,-$12[bp]
13160 3AD4           30E4                       xor	ah,ah
13161 3AD6           50                         push	ax
13162                                           ! Debug: list int asc = [S+$24+6] (used reg = )
13163 3AD7           FF76         08            push	8[bp]
13164                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13165 3ADA           FF76         06            push	6[bp]
13166                                           ! Debug: func () void = write_byte+0 (used reg = )
13167 3ADD           E8         CB3A            call	_write_byte
13168 3AE0           83C4                   06  add	sp,*6
13169                                           !BCC_EOS
13170                                           ! 2247   write_byte(seg,ascq,buffer[13]);
13171                                           ! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
13172 3AE3           8A46         EF            mov	al,-$11[bp]
13173 3AE6           30E4                       xor	ah,ah
13174 3AE8           50                         push	ax
13175                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
13176 3AE9           FF76         0A            push	$A[bp]
13177                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13178 3AEC           FF76         06            push	6[bp]
13179                                           ! Debug: func () void = write_byte+0 (used reg = )
13180 3AEF           E8         CB28            call	_write_byte
13181 3AF2           83C4                   06  add	sp,*6
13182                                           !BCC_EOS
13183                                           ! 2248   return 0;
13184 3AF5           31C0                       xor	ax,ax
13185 3AF7           89EC                       mov	sp,bp
13186 3AF9           5D                         pop	bp
13187 3AFA           C3                         ret
13188                                           !BCC_EOS
13189                                           ! 2249 }
13190                                           ! 2250   Bit16u
13191                                           ! Register BX used in function atapi_get_sense
13192                                           ! 2251 atapi_is_ready(device)
13193                                           ! 2252   Bit16u device;
13194                                           export	_atapi_is_ready
13195                       00003AFB            _atapi_is_ready:
13196                                           !BCC_EOS
13197                                           ! 2253 {
13198                                           ! 2254   Bit8u packet[12];
13199                                           !BCC_EOS
13200                                           ! 2255   Bit8u buf[8];
13201                                           !BCC_EOS
13202                                           ! 2256   Bit32u block_len;
13203                                           !BCC_EOS
13204                                           ! 2257   Bit32u sectors;
13205                                           !BCC_EOS
13206                                           ! 2258   Bit32u timeout;
13207                                           !BCC_EOS
13208                                           ! 2259   Bit32u time;
13209                                           !BCC_EOS
13210                                           ! 2260   Bit8u asc, ascq;
13211                                           !BCC_EOS
13212                                           ! 2261   Bit8u in_progress;
13213                                           !BCC_EOS
13214                                           ! 2262   Bit16u ebda_seg = read_word(0x0040,0x000E);
13215 3AFB           55                         push	bp
13216 3AFC           89E5                       mov	bp,sp
13217 3AFE           83C4                   D6  add	sp,*-$2A
13218                                           ! Debug: list int = const $E (used reg = )
13219 3B01           B8                   000E  mov	ax,*$E
13220 3B04           50                         push	ax
13221                                           ! Debug: list int = const $40 (used reg = )
13222 3B05           B8                   0040  mov	ax,*$40
13223 3B08           50                         push	ax
13224                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13225 3B09           E8         CAFB            call	_read_word
13226 3B0C           83C4                   04  add	sp,*4
13227                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
13228 3B0F           8946         D6            mov	-$2A[bp],ax
13229                                           !BCC_EOS
13230                                           ! 2263   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
13231                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13232 3B12           8B46         04            mov	ax,4[bp]
13233 3B15           B9                   001E  mov	cx,*$1E
13234 3B18           F7E9                       imul	cx
13235 3B1A           89C3                       mov	bx,ax
13236                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13237                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13238 3B1C           81C3                 0142  add	bx,#$142
13239 3B20           53                         push	bx
13240                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13241 3B21           FF76         D6            push	-$2A[bp]
13242                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13243 3B24           E8         CACD            call	_read_byte
13244 3B27           83C4                   04  add	sp,*4
13245                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13246 3B2A           3C                     03  cmp	al,*3
13247 3B2C           74           15            je  	.2CF
13248                       00003B2E            .2D0:
13249                                           ! 2264     bios_printf(2, "not implemented for non-ATAPI device\n");
13250                                           ! Debug: list * char = .2D1+0 (used reg = )
13251 3B2E           BB                   D33A  mov	bx,#.2D1
13252 3B31           53                         push	bx
13253                                           ! Debug: list int = const 2 (used reg = )
13254 3B32           B8                   0002  mov	ax,*2
13255 3B35           50                         push	ax
13256                                           ! Debug: func () void = bios_printf+0 (used reg = )
13257 3B36           E8         CEE2            call	_bios_printf
13258 3B39           83C4                   04  add	sp,*4
13259                                           !BCC_EOS
13260                                           ! 2265     return -1;
13261 3B3C           B8                   FFFF  mov	ax,#$FFFF
13262 3B3F           89EC                       mov	sp,bp
13263 3B41           5D                         pop	bp
13264 3B42           C3                         ret
13265                                           !BCC_EOS
13266                                           ! 2266   }
13267                                           ! 2267   ;
13268                       00003B43            .2CF:
13269                                           !BCC_EOS
13270                                           ! 2268   memsetb(get_SS(),packet, 0, sizeof packet);
13271                                           ! Debug: list int = const $C (used reg = )
13272 3B43           B8                   000C  mov	ax,*$C
13273 3B46           50                         push	ax
13274                                           ! Debug: list int = const 0 (used reg = )
13275 3B47           31C0                       xor	ax,ax
13276 3B49           50                         push	ax
13277                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
13278 3B4A           8D5E         F4            lea	bx,-$C[bp]
13279 3B4D           53                         push	bx
13280                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13281 3B4E           E8         CAFC            call	_get_SS
13282                                           ! Debug: list unsigned short = ax+0 (used reg = )
13283 3B51           50                         push	ax
13284                                           ! Debug: func () void = memsetb+0 (used reg = )
13285 3B52           E8         C4AB            call	_memsetb
13286 3B55           83C4                   08  add	sp,*8
13287                                           !BCC_EOS
13288                                           ! 2269   packet[0] = 0x25;
13289                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
13290 3B58           B0                     25  mov	al,*$25
13291 3B5A           8846         F4            mov	-$C[bp],al
13292                                           !BCC_EOS
13293                                           ! 2270   timeout = 5000;
13294                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
13295 3B5D           B8                   1388  mov	ax,#$1388
13296 3B60           31DB                       xor	bx,bx
13297 3B62           8946         E0            mov	-$20[bp],ax
13298 3B65           895E         E2            mov	-$1E[bp],bx
13299                                           !BCC_EOS
13300                                           ! 2271   time = 0;
13301                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
13302 3B68           31C0                       xor	ax,ax
13303 3B6A           31DB                       xor	bx,bx
13304 3B6C           8946         DC            mov	-$24[bp],ax
13305 3B6F           895E         DE            mov	-$22[bp],bx
13306                                           !BCC_EOS
13307                                           ! 2272   in_progress = 0;
13308                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13309 3B72           30C0                       xor	al,al
13310 3B74           8846         D9            mov	-$27[bp],al
13311                                           !BCC_EOS
13312                                           ! 2273   while (time < timeout) {
13313 3B77           E9         00AB            br 	.2D3
13314                       00003B7A            .2D4:
13315                                           ! 2274     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
13316                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
13317 3B7A           8D5E         EC            lea	bx,-$14[bp]
13318 3B7D           53                         push	bx
13319                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13320 3B7E           E8         CACC            call	_get_SS
13321                                           ! Debug: list unsigned short = ax+0 (used reg = )
13322 3B81           50                         push	ax
13323                                           ! Debug: list int = const 1 (used reg = )
13324 3B82           B8                   0001  mov	ax,*1
13325 3B85           50                         push	ax
13326                                           ! Debug: list long = const 8 (used reg = )
13327 3B86           B8                   0008  mov	ax,*8
13328 3B89           31DB                       xor	bx,bx
13329 3B8B           53                         push	bx
13330 3B8C           50                         push	ax
13331                                           ! Debug: list int = const 0 (used reg = )
13332 3B8D           31C0                       xor	ax,ax
13333 3B8F           50                         push	ax
13334                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
13335 3B90           8D5E         F4            lea	bx,-$C[bp]
13336 3B93           53                         push	bx
13337                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13338 3B94           E8         CAB6            call	_get_SS
13339                                           ! Debug: list unsigned short = ax+0 (used reg = )
13340 3B97           50                         push	ax
13341                                           ! Debug: list int = const $C (used reg = )
13342 3B98           B8                   000C  mov	ax,*$C
13343 3B9B           50                         push	ax
13344                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
13345 3B9C           FF76         04            push	4[bp]
13346                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13347 3B9F           E8         FA24            call	_ata_cmd_packet
13348 3BA2           83C4                   14  add	sp,*$14
13349                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13350 3BA5           85C0                       test	ax,ax
13351 3BA7           75           06            jne 	.2D5
13352                       00003BA9            .2D6:
13353                                           ! 2275       goto ok;
13354 3BA9           83C4                   00  add	sp,#..FFFA+$2C
13355 3BAC           E9         008D            br 	.FFFA
13356                                           !BCC_EOS
13357                                           ! 2276     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
13358                       00003BAF            .2D5:
13359                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
13360 3BAF           8D5E         DA            lea	bx,-$26[bp]
13361 3BB2           53                         push	bx
13362                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
13363 3BB3           8D5E         DB            lea	bx,-$25[bp]
13364 3BB6           53                         push	bx
13365                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13366 3BB7           E8         CA93            call	_get_SS
13367                                           ! Debug: list unsigned short = ax+0 (used reg = )
13368 3BBA           50                         push	ax
13369                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
13370 3BBB           FF76         04            push	4[bp]
13371                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
13372 3BBE           E8         FEB5            call	_atapi_get_sense
13373 3BC1           83C4                   08  add	sp,*8
13374                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13375 3BC4           85C0                       test	ax,ax
13376 3BC6           75           41            jne 	.2D7
13377                       00003BC8            .2D8:
13378                                           ! 2277       if (asc == 0x3a) {
13379                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
13380 3BC8           8A46         DB            mov	al,-$25[bp]
13381 3BCB           3C                     3A  cmp	al,*$3A
13382 3BCD           75           07            jne 	.2D9
13383                       00003BCF            .2DA:
13384                                           ! 2278         ;
13385                                           !BCC_EOS
13386                                           ! 2279         return -1;
13387 3BCF           B8                   FFFF  mov	ax,#$FFFF
13388 3BD2           89EC                       mov	sp,bp
13389 3BD4           5D                         pop	bp
13390 3BD5           C3                         ret
13391                                           !BCC_EOS
13392                                           ! 2280       }
13393                                           ! 2281       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
13394                       00003BD6            .2D9:
13395                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
13396 3BD6           8A46         DB            mov	al,-$25[bp]
13397 3BD9           3C                     04  cmp	al,*4
13398 3BDB           75           2C            jne 	.2DB
13399                       00003BDD            .2DE:
13400                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
13401 3BDD           8A46         DA            mov	al,-$26[bp]
13402 3BE0           3C                     01  cmp	al,*1
13403 3BE2           75           25            jne 	.2DB
13404                       00003BE4            .2DD:
13405 3BE4           8A46         D9            mov	al,-$27[bp]
13406 3BE7           84C0                       test	al,al
13407 3BE9           75           1E            jne 	.2DB
13408                       00003BEB            .2DC:
13409                                           ! 2282         bios_printf(2, "Waiting for device to detect medium... ");
13410                                           ! Debug: list * char = .2DF+0 (used reg = )
13411 3BEB           BB                   D312  mov	bx,#.2DF
13412 3BEE           53                         push	bx
13413                                           ! Debug: list int = const 2 (used reg = )
13414 3BEF           B8                   0002  mov	ax,*2
13415 3BF2           50                         push	ax
13416                                           ! Debug: func () void = bios_printf+0 (used reg = )
13417 3BF3           E8         CE25            call	_bios_printf
13418 3BF6           83C4                   04  add	sp,*4
13419                                           !BCC_EOS
13420                                           ! 2283         timeout = 30000;
13421                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
13422 3BF9           B8                   7530  mov	ax,#$7530
13423 3BFC           31DB                       xor	bx,bx
13424 3BFE           8946         E0            mov	-$20[bp],ax
13425 3C01           895E         E2            mov	-$1E[bp],bx
13426                                           !BCC_EOS
13427                                           ! 2284         in_progress = 1;
13428                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13429 3C04           B0                     01  mov	al,*1
13430 3C06           8846         D9            mov	-$27[bp],al
13431                                           !BCC_EOS
13432                                           ! 2285       }
13433                                           ! 2286     }
13434                       00003C09            .2DB:
13435                                           ! 2287     time += 100;
13436                       00003C09            .2D7:
13437                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
13438 3C09           B8                   0064  mov	ax,*$64
13439 3C0C           31DB                       xor	bx,bx
13440 3C0E           53                         push	bx
13441 3C0F           50                         push	ax
13442 3C10           8B46         DC            mov	ax,-$24[bp]
13443 3C13           8B5E         DE            mov	bx,-$22[bp]
13444 3C16           8D7E         D2            lea	di,-$2E[bp]
13445 3C19           E8         C4A7            call	laddul
13446 3C1C           8946         DC            mov	-$24[bp],ax
13447 3C1F           895E         DE            mov	-$22[bp],bx
13448 3C22           83C4                   04  add	sp,*4
13449                                           !BCC_EOS
13450                                           ! 2288   }
13451                                           ! 2289   ;
13452                       00003C25            .2D3:
13453                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
13454 3C25           8B46         E0            mov	ax,-$20[bp]
13455 3C28           8B5E         E2            mov	bx,-$1E[bp]
13456 3C2B           8D7E         DC            lea	di,-$24[bp]
13457 3C2E           E8         C49A            call	lcmpul
13458 3C31         0F87         FF45            bhi 	.2D4
13459                       00003C35            .2E0:
13460                       00003C35            .2D2:
13461                                           !BCC_EOS
13462                                           ! 2290   return -1;
13463 3C35           B8                   FFFF  mov	ax,#$FFFF
13464 3C38           89EC                       mov	sp,bp
13465 3C3A           5D                         pop	bp
13466 3C3B           C3                         ret
13467                                           !BCC_EOS
13468                                           ! 2291 ok:
13469                       00003C3C            .FFFA:
13470                       FFFFFFD4            ..FFFA	=	-$2C
13471                                           ! 2292   block_len = (Bit32u) buf[4] << 24
13472                                           ! 2293     | (Bit32u) buf[5] << 16
13473                                           ! 2294     | (Bit32u) buf[6] << 8
13474                                           ! 2295     | (Bit32u) buf[7] << 0;
13475                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
13476 3C3C           8A46         F3            mov	al,-$D[bp]
13477 3C3F           30E4                       xor	ah,ah
13478 3C41           31DB                       xor	bx,bx
13479                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13480 3C43           53                         push	bx
13481 3C44           50                         push	ax
13482                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
13483 3C45           8A46         F2            mov	al,-$E[bp]
13484 3C48           30E4                       xor	ah,ah
13485 3C4A           31DB                       xor	bx,bx
13486                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13487 3C4C           88DF                       mov	bh,bl
13488 3C4E           88E3                       mov	bl,ah
13489 3C50           88C4                       mov	ah,al
13490 3C52           30C0                       xor	al,al
13491 3C54           53                         push	bx
13492 3C55           50                         push	ax
13493                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
13494 3C56           8A46         F1            mov	al,-$F[bp]
13495 3C59           30E4                       xor	ah,ah
13496 3C5B           31DB                       xor	bx,bx
13497                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13498 3C5D           93                         xchg	bx,ax
13499 3C5E           31C0                       xor	ax,ax
13500 3C60           53                         push	bx
13501 3C61           50                         push	ax
13502                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
13503 3C62           8A46         F0            mov	al,-$10[bp]
13504 3C65           30E4                       xor	ah,ah
13505 3C67           31DB                       xor	bx,bx
13506                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13507 3C69           88C4                       mov	ah,al
13508 3C6B           30C0                       xor	al,al
13509 3C6D           93                         xchg	bx,ax
13510 3C6E           31C0                       xor	ax,ax
13511                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13512 3C70           8D7E         CA            lea	di,-$36[bp]
13513 3C73           E8         C491            call	lorul
13514 3C76           83C4                   04  add	sp,*4
13515                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13516 3C79           8D7E         CE            lea	di,-$32[bp]
13517 3C7C           E8         C488            call	lorul
13518 3C7F           83C4                   04  add	sp,*4
13519                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13520 3C82           8D7E         D2            lea	di,-$2E[bp]
13521 3C85           E8         C47F            call	lorul
13522 3C88           83C4                   04  add	sp,*4
13523                                           ! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13524 3C8B           8946         E8            mov	-$18[bp],ax
13525 3C8E           895E         EA            mov	-$16[bp],bx
13526                                           !BCC_EOS
13527                                           ! 2296   ;
13528                                           !BCC_EOS
13529                                           ! 2297   if (block_len!= 2048 && block_len!= 512)
13530                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13531                                           ! Debug: expression subtree swapping
13532 3C91           B8                   0800  mov	ax,#$800
13533 3C94           31DB                       xor	bx,bx
13534 3C96           53                         push	bx
13535 3C97           50                         push	ax
13536 3C98           8B46         E8            mov	ax,-$18[bp]
13537 3C9B           8B5E         EA            mov	bx,-$16[bp]
13538 3C9E           8D7E         D2            lea	di,-$2E[bp]
13539 3CA1           E8         C427            call	lcmpul
13540 3CA4           8D66         D6            lea	sp,-$2A[bp]
13541 3CA7           74           33            je  	.2E1
13542                       00003CA9            .2E3:
13543                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13544                                           ! Debug: expression subtree swapping
13545 3CA9           B8                   0200  mov	ax,#$200
13546 3CAC           31DB                       xor	bx,bx
13547 3CAE           53                         push	bx
13548 3CAF           50                         push	ax
13549 3CB0           8B46         E8            mov	ax,-$18[bp]
13550 3CB3           8B5E         EA            mov	bx,-$16[bp]
13551 3CB6           8D7E         D2            lea	di,-$2E[bp]
13552 3CB9           E8         C40F            call	lcmpul
13553 3CBC           8D66         D6            lea	sp,-$2A[bp]
13554 3CBF           74           1B            je  	.2E1
13555                       00003CC1            .2E2:
13556                                           ! 2298   {
13557                                           ! 2299     bios_printf(2, "Unsupported sector size %u\n", block_len);
13558                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13559 3CC1           FF76         EA            push	-$16[bp]
13560 3CC4           FF76         E8            push	-$18[bp]
13561                                           ! Debug: list * char = .2E4+0 (used reg = )
13562 3CC7           BB                   D2F6  mov	bx,#.2E4
13563 3CCA           53                         push	bx
13564                                           ! Debug: list int = const 2 (used reg = )
13565 3CCB           B8                   0002  mov	ax,*2
13566 3CCE           50                         push	ax
13567                                           ! Debug: func () void = bios_printf+0 (used reg = )
13568 3CCF           E8         CD49            call	_bios_printf
13569 3CD2           83C4                   08  add	sp,*8
13570                                           !BCC_EOS
13571                                           ! 2300     return -1;
13572 3CD5           B8                   FFFF  mov	ax,#$FFFF
13573 3CD8           89EC                       mov	sp,bp
13574 3CDA           5D                         pop	bp
13575 3CDB           C3                         ret
13576                                           !BCC_EOS
13577                                           ! 2301   }
13578                                           ! 2302   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
13579                       00003CDC            .2E1:
13580                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13581 3CDC           FF76         EA            push	-$16[bp]
13582 3CDF           FF76         E8            push	-$18[bp]
13583                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13584 3CE2           8B46         04            mov	ax,4[bp]
13585 3CE5           B9                   001E  mov	cx,*$1E
13586 3CE8           F7E9                       imul	cx
13587 3CEA           89C3                       mov	bx,ax
13588                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
13589                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
13590 3CEC           81C3                 0148  add	bx,#$148
13591 3CF0           53                         push	bx
13592                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13593 3CF1           FF76         D6            push	-$2A[bp]
13594                                           ! Debug: func () void = write_dword+0 (used reg = )
13595 3CF4           E8         C3A4            call	_write_dword
13596 3CF7           83C4                   08  add	sp,*8
13597                                           !BCC_EOS
13598                                           ! 2303   sectors = (Bit32u) buf[0] << 24
13599                                           ! 2304     | (Bit32u) buf[1] << 16
13600                                           ! 2305     | (Bit32u) buf[2] << 8
13601                                           ! 2306     | (Bit32u) buf[3] << 0;
13602                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
13603 3CFA           8A46         EF            mov	al,-$11[bp]
13604 3CFD           30E4                       xor	ah,ah
13605 3CFF           31DB                       xor	bx,bx
13606                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13607 3D01           53                         push	bx
13608 3D02           50                         push	ax
13609                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
13610 3D03           8A46         EE            mov	al,-$12[bp]
13611 3D06           30E4                       xor	ah,ah
13612 3D08           31DB                       xor	bx,bx
13613                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13614 3D0A           88DF                       mov	bh,bl
13615 3D0C           88E3                       mov	bl,ah
13616 3D0E           88C4                       mov	ah,al
13617 3D10           30C0                       xor	al,al
13618 3D12           53                         push	bx
13619 3D13           50                         push	ax
13620                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
13621 3D14           8A46         ED            mov	al,-$13[bp]
13622 3D17           30E4                       xor	ah,ah
13623 3D19           31DB                       xor	bx,bx
13624                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13625 3D1B           93                         xchg	bx,ax
13626 3D1C           31C0                       xor	ax,ax
13627 3D1E           53                         push	bx
13628 3D1F           50                         push	ax
13629                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
13630 3D20           8A46         EC            mov	al,-$14[bp]
13631 3D23           30E4                       xor	ah,ah
13632 3D25           31DB                       xor	bx,bx
13633                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13634 3D27           88C4                       mov	ah,al
13635 3D29           30C0                       xor	al,al
13636 3D2B           93                         xchg	bx,ax
13637 3D2C           31C0                       xor	ax,ax
13638                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13639 3D2E           8D7E         CA            lea	di,-$36[bp]
13640 3D31           E8         C3D3            call	lorul
13641 3D34           83C4                   04  add	sp,*4
13642                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13643 3D37           8D7E         CE            lea	di,-$32[bp]
13644 3D3A           E8         C3CA            call	lorul
13645 3D3D           83C4                   04  add	sp,*4
13646                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13647 3D40           8D7E         D2            lea	di,-$2E[bp]
13648 3D43           E8         C3C1            call	lorul
13649 3D46           83C4                   04  add	sp,*4
13650                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13651 3D49           8946         E4            mov	-$1C[bp],ax
13652 3D4C           895E         E6            mov	-$1A[bp],bx
13653                                           !BCC_EOS
13654                                           ! 2307   ;
13655                                           !BCC_EOS
13656                                           ! 2308   if (block_len == 2048)
13657                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13658                                           ! Debug: expression subtree swapping
13659 3D4F           B8                   0800  mov	ax,#$800
13660 3D52           31DB                       xor	bx,bx
13661 3D54           53                         push	bx
13662 3D55           50                         push	ax
13663 3D56           8B46         E8            mov	ax,-$18[bp]
13664 3D59           8B5E         EA            mov	bx,-$16[bp]
13665 3D5C           8D7E         D2            lea	di,-$2E[bp]
13666 3D5F           E8         C369            call	lcmpul
13667 3D62           8D66         D6            lea	sp,-$2A[bp]
13668 3D65           75           12            jne 	.2E5
13669                       00003D67            .2E6:
13670                                           ! 2309     sectors <<= 2;
13671                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13672 3D67           8B46         E4            mov	ax,-$1C[bp]
13673 3D6A           8B5E         E6            mov	bx,-$1A[bp]
13674 3D6D           BF                   0002  mov	di,*2
13675 3D70           E8         C3D4            call	lslul
13676 3D73           8946         E4            mov	-$1C[bp],ax
13677 3D76           895E         E6            mov	-$1A[bp],bx
13678                                           !BCC_EOS
13679                                           ! 2310   if (sectors != read_d
13680                       00003D79            .2E5:
13681                                           ! 2310 word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
13682                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13683 3D79           8B46         04            mov	ax,4[bp]
13684 3D7C           B9                   001E  mov	cx,*$1E
13685 3D7F           F7E9                       imul	cx
13686 3D81           89C3                       mov	bx,ax
13687                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13688                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13689 3D83           81C3                 0158  add	bx,#$158
13690 3D87           53                         push	bx
13691                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13692 3D88           FF76         D6            push	-$2A[bp]
13693                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
13694 3D8B           E8         C2F5            call	_read_dword
13695 3D8E           89D3                       mov	bx,dx
13696 3D90           83C4                   04  add	sp,*4
13697                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13698                                           ! Debug: expression subtree swapping
13699 3D93           8D7E         E4            lea	di,-$1C[bp]
13700 3D96           E8         C332            call	lcmpul
13701 3D99           74           24            je  	.2E7
13702                       00003D9B            .2E8:
13703                                           ! 2311     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
13704                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
13705 3D9B           8B46         E4            mov	ax,-$1C[bp]
13706 3D9E           8B5E         E6            mov	bx,-$1A[bp]
13707 3DA1           88E0                       mov	al,ah
13708 3DA3           88DC                       mov	ah,bl
13709 3DA5           88FB                       mov	bl,bh
13710 3DA7           28FF                       sub	bh,bh
13711 3DA9           BF                   0003  mov	di,*3
13712 3DAC           E8         C37A            call	lsrul
13713                                           ! Debug: list unsigned long = bx+0 (used reg = )
13714 3DAF           53                         push	bx
13715 3DB0           50                         push	ax
13716                                           ! Debug: list * char = .2E9+0 (used reg = )
13717 3DB1           BB                   D2E0  mov	bx,#.2E9
13718 3DB4           53                         push	bx
13719                                           ! Debug: list int = const 2 (used reg = )
13720 3DB5           B8                   0002  mov	ax,*2
13721 3DB8           50                         push	ax
13722                                           ! Debug: func () void = bios_printf+0 (used reg = )
13723 3DB9           E8         CC5F            call	_bios_printf
13724 3DBC           83C4                   08  add	sp,*8
13725                                           !BCC_EOS
13726                                           ! 2312   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
13727                       00003DBF            .2E7:
13728                                           ! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
13729 3DBF           FF76         E6            push	-$1A[bp]
13730 3DC2           FF76         E4            push	-$1C[bp]
13731                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13732 3DC5           8B46         04            mov	ax,4[bp]
13733 3DC8           B9                   001E  mov	cx,*$1E
13734 3DCB           F7E9                       imul	cx
13735 3DCD           89C3                       mov	bx,ax
13736                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13737                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13738 3DCF           81C3                 0158  add	bx,#$158
13739 3DD3           53                         push	bx
13740                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13741 3DD4           FF76         D6            push	-$2A[bp]
13742                                           ! Debug: func () void = write_dword+0 (used reg = )
13743 3DD7           E8         C2C1            call	_write_dword
13744 3DDA           83C4                   08  add	sp,*8
13745                                           !BCC_EOS
13746                                           ! 2313   return 0;
13747 3DDD           31C0                       xor	ax,ax
13748 3DDF           89EC                       mov	sp,bp
13749 3DE1           5D                         pop	bp
13750 3DE2           C3                         ret
13751                                           !BCC_EOS
13752                                           ! 2314 }
13753                                           ! 2315   Bit16u
13754                                           ! Register BX used in function atapi_is_ready
13755                                           ! 2316 atapi_is_cdrom(device)
13756                                           ! 2317   Bit8u device;
13757                                           export	_atapi_is_cdrom
13758                       00003DE3            _atapi_is_cdrom:
13759                                           !BCC_EOS
13760                                           ! 2318 {
13761                                           ! 2319   Bit16u ebda_seg=read_word(0x0040,0x000E);
13762 3DE3           55                         push	bp
13763 3DE4           89E5                       mov	bp,sp
13764 3DE6           4C                         dec	sp
13765 3DE7           4C                         dec	sp
13766                                           ! Debug: list int = const $E (used reg = )
13767 3DE8           B8                   000E  mov	ax,*$E
13768 3DEB           50                         push	ax
13769                                           ! Debug: list int = const $40 (used reg = )
13770 3DEC           B8                   0040  mov	ax,*$40
13771 3DEF           50                         push	ax
13772                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13773 3DF0           E8         C814            call	_read_word
13774 3DF3           83C4                   04  add	sp,*4
13775                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13776 3DF6           8946         FE            mov	-2[bp],ax
13777                                           !BCC_EOS
13778                                           ! 2320   if (device >= (4*2))
13779                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
13780 3DF9           8A46         04            mov	al,4[bp]
13781 3DFC           3C                     08  cmp	al,*8
13782 3DFE           72           06            jb  	.2EA
13783                       00003E00            .2EB:
13784                                           ! 2321     return 0;
13785 3E00           31C0                       xor	ax,ax
13786 3E02           89EC                       mov	sp,bp
13787 3E04           5D                         pop	bp
13788 3E05           C3                         ret
13789                                           !BCC_EOS
13790                                           ! 2322   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
13791                       00003E06            .2EA:
13792                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13793 3E06           8A46         04            mov	al,4[bp]
13794 3E09           30E4                       xor	ah,ah
13795 3E0B           B9                   001E  mov	cx,*$1E
13796 3E0E           F7E9                       imul	cx
13797 3E10           89C3                       mov	bx,ax
13798                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13799                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13800 3E12           81C3                 0142  add	bx,#$142
13801 3E16           53                         push	bx
13802                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13803 3E17           FF76         FE            push	-2[bp]
13804                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13805 3E1A           E8         C7D7            call	_read_byte
13806 3E1D           83C4                   04  add	sp,*4
13807                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13808 3E20           3C                     03  cmp	al,*3
13809 3E22           74           06            je  	.2EC
13810                       00003E24            .2ED:
13811                                           ! 2323     return 0;
13812 3E24           31C0                       xor	ax,ax
13813 3E26           89EC                       mov	sp,bp
13814 3E28           5D                         pop	bp
13815 3E29           C3                         ret
13816                                           !BCC_EOS
13817                                           ! 2324   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
13818                       00003E2A            .2EC:
13819                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13820 3E2A           8A46         04            mov	al,4[bp]
13821 3E2D           30E4                       xor	ah,ah
13822 3E2F           B9                   001E  mov	cx,*$1E
13823 3E32           F7E9                       imul	cx
13824 3E34           89C3                       mov	bx,ax
13825                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
13826                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
13827 3E36           81C3                 0143  add	bx,#$143
13828 3E3A           53                         push	bx
13829                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13830 3E3B           FF76         FE            push	-2[bp]
13831                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13832 3E3E           E8         C7B3            call	_read_byte
13833 3E41           83C4                   04  add	sp,*4
13834                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
13835 3E44           3C                     05  cmp	al,*5
13836 3E46           74           06            je  	.2EE
13837                       00003E48            .2EF:
13838                                           ! 2325     return 0;
13839 3E48           31C0                       xor	ax,ax
13840 3E4A           89EC                       mov	sp,bp
13841 3E4C           5D                         pop	bp
13842 3E4D           C3                         ret
13843                                           !BCC_EOS
13844                                           ! 2326   return 1;
13845                       00003E4E            .2EE:
13846 3E4E           B8                   0001  mov	ax,*1
13847 3E51           89EC                       mov	sp,bp
13848 3E53           5D                         pop	bp
13849 3E54           C3                         ret
13850                                           !BCC_EOS
13851                                           ! 2327 }
13852                                           ! 2328   void
13853                                           ! Register BX used in function atapi_is_cdrom
13854                                           ! 2329 cdemu_init()
13855                                           ! 2330 {
13856                                           export	_cdemu_init
13857                       00003E55            _cdemu_init:
13858                                           ! 2331   Bit16u ebda_seg=read_word(0x0040,0x000E);
13859 3E55           55                         push	bp
13860 3E56           89E5                       mov	bp,sp
13861 3E58           4C                         dec	sp
13862 3E59           4C                         dec	sp
13863                                           ! Debug: list int = const $E (used reg = )
13864 3E5A           B8                   000E  mov	ax,*$E
13865 3E5D           50                         push	ax
13866                                           ! Debug: list int = const $40 (used reg = )
13867 3E5E           B8                   0040  mov	ax,*$40
13868 3E61           50                         push	ax
13869                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13870 3E62           E8         C7A2            call	_read_word
13871 3E65           83C4                   04  add	sp,*4
13872                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13873 3E68           8946         FE            mov	-2[bp],ax
13874                                           !BCC_EOS
13875                                           ! 2332   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
13876                                           ! Debug: list int = const 0 (used reg = )
13877 3E6B           31C0                       xor	ax,ax
13878 3E6D           50                         push	ax
13879                                           ! Debug: list * unsigned char = const $25A (used reg = )
13880 3E6E           B8                   025A  mov	ax,#$25A
13881 3E71           50                         push	ax
13882                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
13883 3E72           FF76         FE            push	-2[bp]
13884                                           ! Debug: func () void = write_byte+0 (used reg = )
13885 3E75           E8         C7A2            call	_write_byte
13886 3E78           83C4                   06  add	sp,*6
13887                                           !BCC_EOS
13888                                           ! 2333 }
13889 3E7B           89EC                       mov	sp,bp
13890 3E7D           5D                         pop	bp
13891 3E7E           C3                         ret
13892                                           ! 2334   Bit8u
13893                                           ! 2335 cdemu_isactive()
13894                                           ! 2336 {
13895                                           export	_cdemu_isactive
13896                       00003E7F            _cdemu_isactive:
13897                                           ! 2337   Bit16u ebda_seg=read_word(0x0040,0x000E);
13898 3E7F           55                         push	bp
13899 3E80           89E5                       mov	bp,sp
13900 3E82           4C                         dec	sp
13901 3E83           4C                         dec	sp
13902                                           ! Debug: list int = const $E (used reg = )
13903 3E84           B8                   000E  mov	ax,*$E
13904 3E87           50                         push	ax
13905                                           ! Debug: list int = const $40 (used reg = )
13906 3E88           B8                   0040  mov	ax,*$40
13907 3E8B           50                         push	ax
13908                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13909 3E8C           E8         C778            call	_read_word
13910 3E8F           83C4                   04  add	sp,*4
13911                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13912 3E92           8946         FE            mov	-2[bp],ax
13913                                           !BCC_EOS
13914                                           ! 2338   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
13915                                           ! Debug: list * unsigned char = const $25A (used reg = )
13916 3E95           B8                   025A  mov	ax,#$25A
13917 3E98           50                         push	ax
13918                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13919 3E99           FF76         FE            push	-2[bp]
13920                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13921 3E9C           E8         C755            call	_read_byte
13922 3E9F           83C4                   04  add	sp,*4
13923                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13924 3EA2           89EC                       mov	sp,bp
13925 3EA4           5D                         pop	bp
13926 3EA5           C3                         ret
13927                                           !BCC_EOS
13928                                           ! 2339 }
13929                                           ! 2340   Bit8u
13930                                           ! 2341 cdemu_emulated_drive()
13931                                           ! 2342 {
13932                                           export	_cdemu_emulated_drive
13933                       00003EA6            _cdemu_emulated_drive:
13934                                           ! 2343   Bit16u ebda_seg=read_word(0x0040,0x000E);
13935 3EA6           55                         push	bp
13936 3EA7           89E5                       mov	bp,sp
13937 3EA9           4C                         dec	sp
13938 3EAA           4C                         dec	sp
13939                                           ! Debug: list int = const $E (used reg = )
13940 3EAB           B8                   000E  mov	ax,*$E
13941 3EAE           50                         push	ax
13942                                           ! Debug: list int = const $40 (used reg = )
13943 3EAF           B8                   0040  mov	ax,*$40
13944 3EB2           50                         push	ax
13945                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13946 3EB3           E8         C751            call	_read_word
13947 3EB6           83C4                   04  add	sp,*4
13948                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13949 3EB9           8946         FE            mov	-2[bp],ax
13950                                           !BCC_EOS
13951                                           ! 2344   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
13952                                           ! Debug: list * unsigned char = const $25C (used reg = )
13953 3EBC           B8                   025C  mov	ax,#$25C
13954 3EBF           50                         push	ax
13955                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13956 3EC0           FF76         FE            push	-2[bp]
13957                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13958 3EC3           E8         C72E            call	_read_byte
13959 3EC6           83C4                   04  add	sp,*4
13960                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13961 3EC9           89EC                       mov	sp,bp
13962 3ECB           5D                         pop	bp
13963 3ECC           C3                         ret
13964                                           !BCC_EOS
13965                                           ! 2345 }
13966                                           ! 2346 static char isotag[6]="CD001";
13967                                           
13968                       00003ECD            _isotag:
13969                       00003ECD            .2F0:
13970 3ECD                        43            .ascii	"CD001"
13971 3ED2                        00            .byte	0
13972                                           !BCC_EOS
13973                                           ! 2347 static char eltorito[24]="EL TORITO SPECIFICATION";
13974                       00003ED3            _eltorito:
13975                       00003ED3            .2F1:
13976 3ED3                        45            .ascii	"EL TORITO SPECIFICATION"
13977 3EEA                        00            .byte	0
13978                                           !BCC_EOS
13979                                           ! 2348   Bit16u
13980                                           ! 2349 cdrom_boot()
13981                                           ! 2350 {
13982                                           
13983                                           export	_cdrom_boot
13984                       00003EEB            _cdrom_boot:
13985                                           ! 2351   Bit16u ebda_seg=read_word(0x0040,0x000E);
13986 3EEB           55                         push	bp
13987 3EEC           89E5                       mov	bp,sp
13988 3EEE           4C                         dec	sp
13989 3EEF           4C                         dec	sp
13990                                           ! Debug: list int = const $E (used reg = )
13991 3EF0           B8                   000E  mov	ax,*$E
13992 3EF3           50                         push	ax
13993                                           ! Debug: list int = const $40 (used reg = )
13994 3EF4           B8                   0040  mov	ax,*$40
13995 3EF7           50                         push	ax
13996                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13997 3EF8           E8         C70C            call	_read_word
13998 3EFB           83C4                   04  add	sp,*4
13999                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14000 3EFE           8946         FE            mov	-2[bp],ax
14001                                           !BCC_EOS
14002                                           ! 2352   Bit8u atacmd[12], buffer[2048];
14003                                           !BCC_EOS
14004                                           ! 2353   Bit32u lba;
14005                                           !BCC_EOS
14006                                           ! 2354   Bit16u boot_segment, nbsectors, i, error;
14007                                           !BCC_EOS
14008                                           ! 2355   Bit8u device;
14009                                           !BCC_EOS
14010                                           ! 2356   for (device=0; device<(4*2);device++) {
14011 3F01           81C4                 F7E6  add	sp,#-$81A
14012                                           ! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
14013 3F05           30C0                       xor	al,al
14014 3F07           8886       F7E5            mov	-$81B[bp],al
14015                                           !BCC_EOS
14016                                           !BCC_EOS
14017 3F0B           EB           1B            jmp .2F4
14018                       00003F0D            .2F5:
14019                                           ! 2357     if (atapi_is_cdrom(device)) break;
14020                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14021 3F0D           8A86       F7E5            mov	al,-$81B[bp]
14022 3F11           30E4                       xor	ah,ah
14023 3F13           50                         push	ax
14024                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
14025 3F14           E8         FECC            call	_atapi_is_cdrom
14026 3F17           44                         inc	sp
14027 3F18           44                         inc	sp
14028 3F19           85C0                       test	ax,ax
14029 3F1B           74           02            je  	.2F6
14030                       00003F1D            .2F7:
14031 3F1D           EB           11            jmp .2F2
14032                                           !BCC_EOS
14033                                           ! 2358     }
14034                       00003F1F            .2F6:
14035                                           ! 2359   if(device >= (4*2)) return 2;
14036                       00003F1F            .2F3:
14037                                           ! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
14038 3F1F           8A86       F7E5            mov	al,-$81B[bp]
14039 3F23           40                         inc	ax
14040 3F24           8886       F7E5            mov	-$81B[bp],al
14041                       00003F28            .2F4:
14042                                           ! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14043 3F28           8A86       F7E5            mov	al,-$81B[bp]
14044 3F2C           3C                     08  cmp	al,*8
14045 3F2E           72           DD            jb 	.2F5
14046                       00003F30            .2F8:
14047                       00003F30            .2F2:
14048                                           ! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14049 3F30           8A86       F7E5            mov	al,-$81B[bp]
14050 3F34           3C                     08  cmp	al,*8
14051 3F36           72           07            jb  	.2F9
14052                       00003F38            .2FA:
14053 3F38           B8                   0002  mov	ax,*2
14054 3F3B           89EC                       mov	sp,bp
14055 3F3D           5D                         pop	bp
14056 3F3E           C3                         ret
14057                                           !BCC_EOS
14058                                           ! 2360   if(error = atapi_is_ready(device) != 0)
14059                       00003F3F            .2F9:
14060                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14061 3F3F           8A86       F7E5            mov	al,-$81B[bp]
14062 3F43           30E4                       xor	ah,ah
14063 3F45           50                         push	ax
14064                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
14065 3F46           E8         FBB2            call	_atapi_is_ready
14066 3F49           44                         inc	sp
14067 3F4A           44                         inc	sp
14068                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14069 3F4B           85C0                       test	ax,ax
14070 3F4D           74           04            je 	.2FD
14071 3F4F           B0                     01  mov	al,*1
14072 3F51           EB           02            jmp	.2FE
14073                       00003F53            .2FD:
14074 3F53           30C0                       xor	al,al
14075                       00003F55            .2FE:
14076                                           ! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14077 3F55           30E4                       xor	ah,ah
14078 3F57           8986       F7E6            mov	-$81A[bp],ax
14079 3F5B           85C0                       test	ax,ax
14080 3F5D           74           00            je  	.2FB
14081                       00003F5F            .2FC:
14082                                           ! 2361     ;
14083                                           !BCC_EOS
14084                                           ! 2362   memsetb(get_SS(),atacmd,0,12);
14085                       00003F5F            .2FB:
14086                                           ! Debug: list int = const $C (used reg = )
14087 3F5F           B8                   000C  mov	ax,*$C
14088 3F62           50                         push	ax
14089                                           ! Debug: list int = const 0 (used reg = )
14090 3F63           31C0                       xor	ax,ax
14091 3F65           50                         push	ax
14092                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14093 3F66           8D5E         F2            lea	bx,-$E[bp]
14094 3F69           53                         push	bx
14095                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14096 3F6A           E8         C6E0            call	_get_SS
14097                                           ! Debug: list unsigned short = ax+0 (used reg = )
14098 3F6D           50                         push	ax
14099                                           ! Debug: func () void = memsetb+0 (used reg = )
14100 3F6E           E8         C08F            call	_memsetb
14101 3F71           83C4                   08  add	sp,*8
14102                                           !BCC_EOS
14103                                           ! 2363   atacmd[0]=0x28;
14104                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14105 3F74           B0                     28  mov	al,*$28
14106 3F76           8846         F2            mov	-$E[bp],al
14107                                           !BCC_EOS
14108                                           ! 2364   atacmd[7]=(0x01 & 0xff00) >> 8;
14109                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14110 3F79           30C0                       xor	al,al
14111 3F7B           8846         F9            mov	-7[bp],al
14112                                           !BCC_EOS
14113                                           ! 2365   atacmd[8]=(0x01 & 0x00ff);
14114                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14115 3F7E           B0                     01  mov	al,*1
14116 3F80           8846         FA            mov	-6[bp],al
14117                                           !BCC_EOS
14118                                           ! 2366   atacmd[2]=(0x11 & 0xff000000) >> 24;
14119                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14120 3F83           30C0                       xor	al,al
14121 3F85           8846         F4            mov	-$C[bp],al
14122                                           !BCC_EOS
14123                                           ! 2367   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
14124                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14125 3F88           30C0                       xor	al,al
14126 3F8A           8846         F5            mov	-$B[bp],al
14127                                           !BCC_EOS
14128                                           ! 2368   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
14129                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14130 3F8D           30C0                       xor	al,al
14131 3F8F           8846         F6            mov	-$A[bp],al
14132                                           !BCC_EOS
14133                                           ! 2369   atacmd[5]=(0x11 & 0x000000ff);
14134                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14135 3F92           B0                     11  mov	al,*$11
14136 3F94           8846         F7            mov	-9[bp],al
14137                                           !BCC_EOS
14138                                           ! 2370   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14139                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14140 3F97           8D9E       F7F2            lea	bx,-$80E[bp]
14141 3F9B           53                         push	bx
14142                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14143 3F9C           E8         C6AE            call	_get_SS
14144                                           ! Debug: list unsigned short = ax+0 (used reg = )
14145 3F9F           50                         push	ax
14146                                           ! Debug: list int = const 1 (used reg = )
14147 3FA0           B8                   0001  mov	ax,*1
14148 3FA3           50                         push	ax
14149                                           ! Debug: list long = const $800 (used reg = )
14150 3FA4           B8                   0800  mov	ax,#$800
14151 3FA7           31DB                       xor	bx,bx
14152 3FA9           53                         push	bx
14153 3FAA           50                         push	ax
14154                                           ! Debug: list int = const 0 (used reg = )
14155 3FAB           31C0                       xor	ax,ax
14156 3FAD           50                         push	ax
14157                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14158 3FAE           8D5E         F2            lea	bx,-$E[bp]
14159 3FB1           53                         push	bx
14160                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14161 3FB2           E8         C698            call	_get_SS
14162                                           ! Debug: list unsigned short = ax+0 (used reg = )
14163 3FB5           50                         push	ax
14164                                           ! Debug: list int = const $C (used reg = )
14165 3FB6           B8                   000C  mov	ax,*$C
14166 3FB9           50                         push	ax
14167                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14168 3FBA           8A86       F7E5            mov	al,-$81B[bp]
14169 3FBE           30E4                       xor	ah,ah
14170 3FC0           50                         push	ax
14171                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14172 3FC1           E8         F602            call	_ata_cmd_packet
14173 3FC4           83C4                   14  add	sp,*$14
14174                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14175 3FC7           8986       F7E6            mov	-$81A[bp],ax
14176                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14177 3FCB           85C0                       test	ax,ax
14178 3FCD           74           07            je  	.2FF
14179                       00003FCF            .300:
14180                                           ! 2371     return 3;
14181 3FCF           B8                   0003  mov	ax,*3
14182 3FD2           89EC                       mov	sp,bp
14183 3FD4           5D                         pop	bp
14184 3FD5           C3                         ret
14185                                           !BCC_EOS
14186                                           ! 2372   if(buffer[0]!=0)return 4;
14187                       00003FD6            .2FF:
14188                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
14189 3FD6           8A86       F7F2            mov	al,-$80E[bp]
14190 3FDA           84C0                       test	al,al
14191 3FDC           74           07            je  	.301
14192                       00003FDE            .302:
14193 3FDE           B8                   0004  mov	ax,*4
14194 3FE1           89EC                       mov	sp,bp
14195 3FE3           5D                         pop	bp
14196 3FE4           C3                         ret
14197                                           !BCC_EOS
14198                                           ! 2373   for(i=0;i<5;i++){
14199                       00003FE5            .301:
14200                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14201 3FE5           31C0                       xor	ax,ax
14202 3FE7           8986       F7E8            mov	-$818[bp],ax
14203                                           !BCC_EOS
14204                                           !BCC_EOS
14205 3FEB           EB           46            jmp .305
14206                       00003FED            .306:
14207                                           ! 2374     if(read_byte(get_SS(),&buffer[1+i])!=read_byte(0xf000,&isotag[i]))return 5;
14208                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
14209 3FED           8B9E       F7E8            mov	bx,-$818[bp]
14210                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
14211                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
14212 3FF1           81C3                 3ECD  add	bx,#_isotag
14213 3FF5           53                         push	bx
14214                                           ! Debug: list unsigned int = const $F000 (used reg = )
14215 3FF6           B8                   F000  mov	ax,#$F000
14216 3FF9           50                         push	ax
14217                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14218 3FFA           E8         C5F7            call	_read_byte
14219 3FFD           83C4                   04  add	sp,*4
14220 4000           50                         push	ax
14221                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
14222                                           ! Debug: expression subtree swapping
14223 4001           8B86       F7E8            mov	ax,-$818[bp]
14224                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14225 4005           40                         inc	ax
14226 4006           89EB                       mov	bx,bp
14227 4008           01C3                       add	bx,ax
14228                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14229                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14230 400A           81C3                 F7F2  add	bx,#-$80E
14231 400E           53                         push	bx
14232                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14233 400F           E8         C63B            call	_get_SS
14234                                           ! Debug: list unsigned short = ax+0 (used reg = )
14235 4012           50                         push	ax
14236                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14237 4013           E8         C5DE            call	_read_byte
14238 4016           83C4                   04  add	sp,*4
14239                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14240 4019           3A86       F7E2            cmp	al,-$81E[bp]
14241 401D           8DA6       F7E4            lea	sp,-$81C[bp]
14242 4021           74           07            je  	.307
14243                       00004023            .308:
14244 4023           B8                   0005  mov	ax,*5
14245 4026           89EC                       mov	sp,bp
14246 4028           5D                         pop	bp
14247 4029           C3                         ret
14248                                           !BCC_EOS
14249                                           ! 2375    }
14250                       0000402A            .307:
14251                                           ! 2376   for(i=0;i<23;i++)
14252                       0000402A            .304:
14253                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14254 402A           8B86       F7E8            mov	ax,-$818[bp]
14255 402E           40                         inc	ax
14256 402F           8986       F7E8            mov	-$818[bp],ax
14257                       00004033            .305:
14258                                           ! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
14259 4033           8B86       F7E8            mov	ax,-$818[bp]
14260 4037           3D                   0005  cmp	ax,*5
14261 403A           72           B1            jb 	.306
14262                       0000403C            .309:
14263                       0000403C            .303:
14264                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14265 403C           31C0                       xor	ax,ax
14266 403E           8986       F7E8            mov	-$818[bp],ax
14267                                           !BCC_EOS
14268                                           !BCC_EOS
14269                                           ! 2377     if(read_byte(get_SS(),&buffer[7+i])!=read_byte(0xf000,&eltorito[i]))return 6;
14270 4042           EB           48            jmp .30C
14271                       00004044            .30D:
14272                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
14273 4044           8B9E       F7E8            mov	bx,-$818[bp]
14274                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
14275                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
14276 4048           81C3                 3ED3  add	bx,#_eltorito
14277 404C           53                         push	bx
14278                                           ! Debug: list unsigned int = const $F000 (used reg = )
14279 404D           B8                   F000  mov	ax,#$F000
14280 4050           50                         push	ax
14281                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14282 4051           E8         C5A0            call	_read_byte
14283 4054           83C4                   04  add	sp,*4
14284 4057           50                         push	ax
14285                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
14286                                           ! Debug: expression subtree swapping
14287 4058           8B86       F7E8            mov	ax,-$818[bp]
14288                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14289 405C           05                   0007  add	ax,*7
14290 405F           89EB                       mov	bx,bp
14291 4061           01C3                       add	bx,ax
14292                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14293                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14294 4063           81C3                 F7F2  add	bx,#-$80E
14295 4067           53                         push	bx
14296                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14297 4068           E8         C5E2            call	_get_SS
14298                                           ! Debug: list unsigned short = ax+0 (used reg = )
14299 406B           50                         push	ax
14300                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14301 406C           E8         C585            call	_read_byte
14302 406F           83C4                   04  add	sp,*4
14303                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14304 4072           3A86       F7E2            cmp	al,-$81E[bp]
14305 4076           8DA6       F7E4            lea	sp,-$81C[bp]
14306 407A           74           07            je  	.30E
14307                       0000407C            .30F:
14308 407C           B8                   0006  mov	ax,*6
14309 407F           89EC                       mov	sp,bp
14310 4081           5D                         pop	bp
14311 4082           C3                         ret
14312                                           !BCC_EOS
14313                                           ! 2378   lba=buffer
14314                       00004083            .30E:
14315                       00004083            .30B:
14316                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14317 4083           8B86       F7E8            mov	ax,-$818[bp]
14318 4087           40                         inc	ax
14319 4088           8986       F7E8            mov	-$818[bp],ax
14320                       0000408C            .30C:
14321                                           ! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
14322 408C           8B86       F7E8            mov	ax,-$818[bp]
14323 4090           3D                   0017  cmp	ax,*$17
14324 4093           72           AF            jb 	.30D
14325                       00004095            .310:
14326                       00004095            .30A:
14327                                           ! 2378 [0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
14328                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
14329 4095           8A86       F839            mov	al,-$7C7[bp]
14330 4099           30E4                       xor	ah,ah
14331 409B           31DB                       xor	bx,bx
14332 409D           53                         push	bx
14333 409E           50                         push	ax
14334                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
14335 409F           8A86       F83A            mov	al,-$7C6[bp]
14336 40A3           30E4                       xor	ah,ah
14337 40A5           B9                   0100  mov	cx,#$100
14338 40A8           F7E9                       imul	cx
14339                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14340 40AA           31DB                       xor	bx,bx
14341 40AC           53                         push	bx
14342 40AD           50                         push	ax
14343                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
14344 40AE           8A86       F83B            mov	al,-$7C5[bp]
14345 40B2           30E4                       xor	ah,ah
14346 40B4           31DB                       xor	bx,bx
14347                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14348 40B6           53                         push	bx
14349 40B7           50                         push	ax
14350 40B8           31C0                       xor	ax,ax
14351 40BA           BB                   0001  mov	bx,*1
14352 40BD           53                         push	bx
14353 40BE           50                         push	ax
14354 40BF           8B86       F7D8            mov	ax,-$828[bp]
14355 40C3           8B9E       F7DA            mov	bx,-$826[bp]
14356 40C7           8DBE       F7D4            lea	di,-$82C[bp]
14357 40CB           E8         C01B            call	lmulul
14358 40CE           83C4                   08  add	sp,*8
14359 40D1           53                         push	bx
14360 40D2           50                         push	ax
14361                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
14362 40D3           8A86       F83C            mov	al,-$7C4[bp]
14363 40D7           30E4                       xor	ah,ah
14364 40D9           31DB                       xor	bx,bx
14365                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14366 40DB           53                         push	bx
14367 40DC           50                         push	ax
14368 40DD           31C0                       xor	ax,ax
14369 40DF           BB                   0100  mov	bx,#$100
14370 40E2           53                         push	bx
14371 40E3           50                         push	ax
14372 40E4           8B86       F7D4            mov	ax,-$82C[bp]
14373 40E8           8B9E       F7D6            mov	bx,-$82A[bp]
14374 40EC           8DBE       F7D0            lea	di,-$830[bp]
14375 40F0           E8         BFF6            call	lmulul
14376 40F3           83C4                   08  add	sp,*8
14377                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14378 40F6           8DBE       F7D8            lea	di,-$828[bp]
14379 40FA           E8         BFC6            call	laddul
14380 40FD           83C4                   04  add	sp,*4
14381                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14382 4100           8DBE       F7DC            lea	di,-$824[bp]
14383 4104           E8         BFBC            call	laddul
14384 4107           83C4                   04  add	sp,*4
14385                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14386 410A           8DBE       F7E0            lea	di,-$820[bp]
14387 410E           E8         BFB2            call	laddul
14388 4111           83C4                   04  add	sp,*4
14389                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14390 4114           8986       F7EE            mov	-$812[bp],ax
14391 4118           899E       F7F0            mov	-$810[bp],bx
14392                                           !BCC_EOS
14393                                           ! 2379   memsetb(get_SS(),atacmd,0,12);
14394                                           ! Debug: list int = const $C (used reg = )
14395 411C           B8                   000C  mov	ax,*$C
14396 411F           50                         push	ax
14397                                           ! Debug: list int = const 0 (used reg = )
14398 4120           31C0                       xor	ax,ax
14399 4122           50                         push	ax
14400                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14401 4123           8D5E         F2            lea	bx,-$E[bp]
14402 4126           53                         push	bx
14403                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14404 4127           E8         C523            call	_get_SS
14405                                           ! Debug: list unsigned short = ax+0 (used reg = )
14406 412A           50                         push	ax
14407                                           ! Debug: func () void = memsetb+0 (used reg = )
14408 412B           E8         BED2            call	_memsetb
14409 412E           83C4                   08  add	sp,*8
14410                                           !BCC_EOS
14411                                           ! 2380   atacmd[0]=0x28;
14412                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14413 4131           B0                     28  mov	al,*$28
14414 4133           8846         F2            mov	-$E[bp],al
14415                                           !BCC_EOS
14416                                           ! 2381   atacmd[7]=(0x01 & 0xff00) >> 8;
14417                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14418 4136           30C0                       xor	al,al
14419 4138           8846         F9            mov	-7[bp],al
14420                                           !BCC_EOS
14421                                           ! 2382   atacmd[8]=(0x01 & 0x00ff);
14422                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14423 413B           B0                     01  mov	al,*1
14424 413D           8846         FA            mov	-6[bp],al
14425                                           !BCC_EOS
14426                                           ! 2383   atacmd[2]=(lba & 0xff000000) >> 24;
14427                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14428                                           ! Debug: expression subtree swapping
14429 4140           31C0                       xor	ax,ax
14430 4142           BB                   FF00  mov	bx,#$FF00
14431 4145           8DBE       F7EE            lea	di,-$812[bp]
14432 4149           E8         BF6F            call	landul
14433                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14434 414C           93                         xchg	bx,ax
14435 414D           88E0                       mov	al,ah
14436 414F           30E4                       xor	ah,ah
14437 4151           31DB                       xor	bx,bx
14438                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14439 4153           8846         F4            mov	-$C[bp],al
14440                                           !BCC_EOS
14441                                           ! 2384   atacmd[3]=(lba & 0x00ff0000) >> 16;
14442                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14443                                           ! Debug: expression subtree swapping
14444 4156           31C0                       xor	ax,ax
14445 4158           BB                   00FF  mov	bx,#$FF
14446 415B           8DBE       F7EE            lea	di,-$812[bp]
14447 415F           E8         BF59            call	landul
14448                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14449 4162           93                         xchg	bx,ax
14450 4163           31DB                       xor	bx,bx
14451                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14452 4165           8846         F5            mov	-$B[bp],al
14453                                           !BCC_EOS
14454                                           ! 2385   atacmd[4]=(lba & 0x0000ff00) >> 8;
14455                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14456                                           ! Debug: expression subtree swapping
14457 4168           B8                   FF00  mov	ax,#$FF00
14458 416B           31DB                       xor	bx,bx
14459 416D           8DBE       F7EE            lea	di,-$812[bp]
14460 4171           E8         BF47            call	landul
14461                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14462 4174           88E0                       mov	al,ah
14463 4176           88DC                       mov	ah,bl
14464 4178           88FB                       mov	bl,bh
14465 417A           28FF                       sub	bh,bh
14466                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14467 417C           8846         F6            mov	-$A[bp],al
14468                                           !BCC_EOS
14469                                           ! 2386   atacmd[5]=(lba & 0x000000ff);
14470                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14471                                           ! Debug: expression subtree swapping
14472 417F           B8                   00FF  mov	ax,#$FF
14473 4182           31DB                       xor	bx,bx
14474 4184           8DBE       F7EE            lea	di,-$812[bp]
14475 4188           E8         BF30            call	landul
14476                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14477 418B           8846         F7            mov	-9[bp],al
14478                                           !BCC_EOS
14479                                           ! 2387   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14480                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14481 418E           8D9E       F7F2            lea	bx,-$80E[bp]
14482 4192           53                         push	bx
14483                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14484 4193           E8         C4B7            call	_get_SS
14485                                           ! Debug: list unsigned short = ax+0 (used reg = )
14486 4196           50                         push	ax
14487                                           ! Debug: list int = const 1 (used reg = )
14488 4197           B8                   0001  mov	ax,*1
14489 419A           50                         push	ax
14490                                           ! Debug: list long = const $800 (used reg = )
14491 419B           B8                   0800  mov	ax,#$800
14492 419E           31DB                       xor	bx,bx
14493 41A0           53                         push	bx
14494 41A1           50                         push	ax
14495                                           ! Debug: list int = const 0 (used reg = )
14496 41A2           31C0                       xor	ax,ax
14497 41A4           50                         push	ax
14498                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14499 41A5           8D5E         F2            lea	bx,-$E[bp]
14500 41A8           53                         push	bx
14501                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14502 41A9           E8         C4A1            call	_get_SS
14503                                           ! Debug: list unsigned short = ax+0 (used reg = )
14504 41AC           50                         push	ax
14505                                           ! Debug: list int = const $C (used reg = )
14506 41AD           B8                   000C  mov	ax,*$C
14507 41B0           50                         push	ax
14508                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14509 41B1           8A86       F7E5            mov	al,-$81B[bp]
14510 41B5           30E4                       xor	ah,ah
14511 41B7           50                         push	ax
14512                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14513 41B8           E8         F40B            call	_ata_cmd_packet
14514 41BB           83C4                   14  add	sp,*$14
14515                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14516 41BE           8986       F7E6            mov	-$81A[bp],ax
14517                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14518 41C2           85C0                       test	ax,ax
14519 41C4           74           07            je  	.311
14520                       000041C6            .312:
14521                                           ! 2388     return 7;
14522 41C6           B8                   0007  mov	ax,*7
14523 41C9           89EC                       mov	sp,bp
14524 41CB           5D                         pop	bp
14525 41CC           C3                         ret
14526                                           !BCC_EOS
14527                                           ! 2389   if(buffer[0x00]!=0x01)return 8;
14528                       000041CD            .311:
14529                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
14530 41CD           8A86       F7F2            mov	al,-$80E[bp]
14531 41D1           3C                     01  cmp	al,*1
14532 41D3           74           07            je  	.313
14533                       000041D5            .314:
14534 41D5           B8                   0008  mov	ax,*8
14535 41D8           89EC                       mov	sp,bp
14536 41DA           5D                         pop	bp
14537 41DB           C3                         ret
14538                                           !BCC_EOS
14539                                           ! 2390   if(buffer[0x01]!=0x00)return 9;
14540                       000041DC            .313:
14541                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
14542 41DC           8A86       F7F3            mov	al,-$80D[bp]
14543 41E0           84C0                       test	al,al
14544 41E2           74           07            je  	.315
14545                       000041E4            .316:
14546 41E4           B8                   0009  mov	ax,*9
14547 41E7           89EC                       mov	sp,bp
14548 41E9           5D                         pop	bp
14549 41EA           C3                         ret
14550                                           !BCC_EOS
14551                                           ! 2391   if(buffer[0x1E]!=0x55)return 10;
14552                       000041EB            .315:
14553                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
14554 41EB           8A86       F810            mov	al,-$7F0[bp]
14555 41EF           3C                     55  cmp	al,*$55
14556 41F1           74           07            je  	.317
14557                       000041F3            .318:
14558 41F3           B8                   000A  mov	ax,*$A
14559 41F6           89EC                       mov	sp,bp
14560 41F8           5D                         pop	bp
14561 41F9           C3                         ret
14562                                           !BCC_EOS
14563                                           ! 2392   if(buffer[0x1F]!=0xAA)return 10;
14564                       000041FA            .317:
14565                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
14566 41FA           8A86       F811            mov	al,-$7EF[bp]
14567 41FE           3C                     AA  cmp	al,#$AA
14568 4200           74           07            je  	.319
14569                       00004202            .31A:
14570 4202           B8                   000A  mov	ax,*$A
14571 4205           89EC                       mov	sp,bp
14572 4207           5D                         pop	bp
14573 4208           C3                         ret
14574                                           !BCC_EOS
14575                                           ! 2393   if(buffer[0x20]!=0x88)return 11;
14576                       00004209            .319:
14577                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
14578 4209           8A86       F812            mov	al,-$7EE[bp]
14579 420D           3C                     88  cmp	al,#$88
14580 420F           74           07            je  	.31B
14581                       00004211            .31C:
14582 4211           B8                   000B  mov	ax,*$B
14583 4214           89EC                       mov	sp,bp
14584 4216           5D                         pop	bp
14585 4217           C3                         ret
14586                                           !BCC_EOS
14587                                           ! 2394   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
14588                       00004218            .31B:
14589                                           ! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
14590 4218           8A86       F813            mov	al,-$7ED[bp]
14591 421C           30E4                       xor	ah,ah
14592 421E           50                         push	ax
14593                                           ! Debug: list * unsigned char = const $25B (used reg = )
14594 421F           B8                   025B  mov	ax,#$25B
14595 4222           50                         push	ax
14596                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14597 4223           FF76         FE            push	-2[bp]
14598                                           ! Debug: func () void = write_byte+0 (used reg = )
14599 4226           E8         C3F1            call	_write_byte
14600 4229           83C4                   06  add	sp,*6
14601                                           !BCC_EOS
14602                                           ! 2395   if(buffer[0x21]==0){
14603                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14604 422C           8A86       F813            mov	al,-$7ED[bp]
14605 4230           84C0                       test	al,al
14606 4232           75           13            jne 	.31D
14607                       00004234            .31E:
14608                                           ! 2396     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
14609                                           ! Debug: list int = const $E0 (used reg = )
14610 4234           B8                   00E0  mov	ax,#$E0
14611 4237           50                         push	ax
14612                                           ! Debug: list * unsigned char = const $25C (used reg = )
14613 4238           B8                   025C  mov	ax,#$25C
14614 423B           50                         push	ax
14615                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14616 423C           FF76         FE            push	-2[bp]
14617                                           ! Debug: func () void = write_byte+0 (used reg = )
14618 423F           E8         C3D8            call	_write_byte
14619 4242           83C4                   06  add	sp,*6
14620                                           !BCC_EOS
14621                                           ! 2397     }
14622                                           ! 2398   else if(buffer[0x21]<4)
14623 4245           EB           2B            jmp .31F
14624                       00004247            .31D:
14625                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14626 4247           8A86       F813            mov	al,-$7ED[bp]
14627 424B           3C                     04  cmp	al,*4
14628 424D           73           12            jae 	.320
14629                       0000424F            .321:
14630                                           ! 2399     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
14631                                           ! Debug: list int = const 0 (used reg = )
14632 424F           31C0                       xor	ax,ax
14633 4251           50                         push	ax
14634                                           ! Debug: list * unsigned char = const $25C (used reg = )
14635 4252           B8                   025C  mov	ax,#$25C
14636 4255           50                         push	ax
14637                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14638 4256           FF76         FE            push	-2[bp]
14639                                           ! Debug: func () void = write_byte+0 (used reg = )
14640 4259           E8         C3BE            call	_write_byte
14641 425C           83C4                   06  add	sp,*6
14642                                           !BCC_EOS
14643                                           ! 2400   else
14644                                           ! 2401     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
14645 425F           EB           11            jmp .322
14646                       00004261            .320:
14647                                           ! Debug: list int = const $80 (used reg = )
14648 4261           B8                   0080  mov	ax,#$80
14649 4264           50                         push	ax
14650                                           ! Debug: list * unsigned char = const $25C (used reg = )
14651 4265           B8                   025C  mov	ax,#$25C
14652 4268           50                         push	ax
14653                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14654 4269           FF76         FE            push	-2[bp]
14655                                           ! Debug: func () void = write_byte+0 (used reg = )
14656 426C           E8         C3AB            call	_write_byte
14657 426F           83C4                   06  add	sp,*6
14658                                           !BCC_EOS
14659                                           ! 2402   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
14660                       00004272            .322:
14661                       00004272            .31F:
14662                                           ! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14663 4272           8A86       F7E5            mov	al,-$81B[bp]
14664 4276           30E4                       xor	ah,ah
14665 4278           D1E8                       shr	ax,*1
14666                                           ! Debug: list unsigned int = ax+0 (used reg = )
14667 427A           50                         push	ax
14668                                           ! Debug: list * unsigned char = const $25D (used reg = )
14669 427B           B8                   025D  mov	ax,#$25D
14670 427E           50                         push	ax
14671                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14672 427F           FF76         FE            push	-2[bp]
14673                                           ! Debug: func () void = write_byte+0 (used reg = )
14674 4282           E8         C395            call	_write_byte
14675 4285           83C4                   06  add	sp,*6
14676                                           !BCC_EOS
14677                                           ! 2403   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
14678                                           ! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14679 4288           8A86       F7E5            mov	al,-$81B[bp]
14680 428C           30E4                       xor	ah,ah
14681 428E           24                     01  and	al,*1
14682                                           ! Debug: list unsigned char = al+0 (used reg = )
14683 4290           30E4                       xor	ah,ah
14684 4292           50                         push	ax
14685                                           ! Debug: list * unsigned short = const $25E (used reg = )
14686 4293           B8                   025E  mov	ax,#$25E
14687 4296           50                         push	ax
14688                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14689 4297           FF76         FE            push	-2[bp]
14690                                           ! Debug: func () void = write_byte+0 (used reg = )
14691 429A           E8         C37D            call	_write_byte
14692 429D           83C4                   06  add	sp,*6
14693                                           !BCC_EOS
14694                                           ! 2404   boot_segment=buffer[0x23]*0x100+buffer[0x22];
14695                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
14696 42A0           8A86       F815            mov	al,-$7EB[bp]
14697 42A4           30E4                       xor	ah,ah
14698 42A6           B9                   0100  mov	cx,#$100
14699 42A9           F7E9                       imul	cx
14700                                           ! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
14701 42AB           0286       F814            add	al,-$7EC[bp]
14702 42AF           80D4                   00  adc	ah,*0
14703                                           ! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14704 42B2           8986       F7EC            mov	-$814[bp],ax
14705                                           !BCC_EOS
14706                                           ! 2405   if(boot_segment==0x0000)boot_segment=0x07C0;
14707                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14708 42B6           8B86       F7EC            mov	ax,-$814[bp]
14709 42BA           85C0                       test	ax,ax
14710 42BC           75           07            jne 	.323
14711                       000042BE            .324:
14712                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14713 42BE           B8                   07C0  mov	ax,#$7C0
14714 42C1           8986       F7EC            mov	-$814[bp],ax
14715                                           !BCC_EOS
14716                                           ! 2406   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
14717                       000042C5            .323:
14718                                           ! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
14719 42C5           FFB6       F7EC            push	-$814[bp]
14720                                           ! Debug: list * unsigned short = const $266 (used reg = )
14721 42C9           B8                   0266  mov	ax,#$266
14722 42CC           50                         push	ax
14723                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14724 42CD           FF76         FE            push	-2[bp]
14725                                           ! Debug: func () void = write_word+0 (used reg = )
14726 42D0           E8         C35F            call	_write_word
14727 42D3           83C4                   06  add	sp,*6
14728                                           !BCC_EOS
14729                                           ! 2407   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
14730                                           ! Debug: list int = const 0 (used reg = )
14731 42D6           31C0                       xor	ax,ax
14732 42D8           50                         push	ax
14733                                           ! Debug: list * unsigned short = const $264 (used reg = )
14734 42D9           B8                   0264  mov	ax,#$264
14735 42DC           50                         push	ax
14736                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14737 42DD           FF76         FE            push	-2[bp]
14738                                           ! Debug: func () void = write_word+0 (used reg = )
14739 42E0           E8         C34F            call	_write_word
14740 42E3           83C4                   06  add	sp,*6
14741                                           !BCC_EOS
14742                                           ! 2408   nbsectors=buffer[0x27]*0x100+buffer[0x26];
14743                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
14744 42E6           8A86       F819            mov	al,-$7E7[bp]
14745 42EA           30E4                       xor	ah,ah
14746 42EC           B9                   0100  mov	cx,#$100
14747 42EF           F7E9                       imul	cx
14748                                           ! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
14749 42F1           0286       F818            add	al,-$7E8[bp]
14750 42F5           80D4                   00  adc	ah,*0
14751                                           ! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14752 42F8           8986       F7EA            mov	-$816[bp],ax
14753                                           !BCC_EOS
14754                                           ! 2409   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
14755                                           ! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
14756 42FC           FFB6       F7EA            push	-$816[bp]
14757                                           ! Debug: list * unsigned short = const $268 (used reg = )
14758 4300           B8                   0268  mov	ax,#$268
14759 4303           50                         push	ax
14760                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14761 4304           FF76         FE            push	-2[bp]
14762                                           ! Debug: func () void = write_word+0 (used reg = )
14763 4307           E8         C328            call	_write_word
14764 430A           83C4                   06  add	sp,*6
14765                                           !BCC_EOS
14766                                           ! 2410   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
14767                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
14768 430D           8A86       F81A            mov	al,-$7E6[bp]
14769 4311           30E4                       xor	ah,ah
14770 4313           31DB                       xor	bx,bx
14771 4315           53                         push	bx
14772 4316           50                         push	ax
14773                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
14774 4317           8A86       F81B            mov	al,-$7E5[bp]
14775 431B           30E4                       xor	ah,ah
14776 431D           B9                   0100  mov	cx,#$100
14777 4320           F7E9                       imul	cx
14778                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14779 4322           31DB                       xor	bx,bx
14780 4324           53                         push	bx
14781 4325           50                         push	ax
14782                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
14783 4326           8A86       F81C            mov	al,-$7E4[bp]
14784 432A           30E4                       xor	ah,ah
14785 432C           31DB                       xor	bx,bx
14786                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14787 432E           53                         push	bx
14788 432F           50                         push	ax
14789 4330           31C0                       xor	ax,ax
14790 4332           BB                   0001  mov	bx,*1
14791 4335           53                         push	bx
14792 4336           50                         push	ax
14793 4337           8B86       F7D8            mov	ax,-$828[bp]
14794 433B           8B9E       F7DA            mov	bx,-$826[bp]
14795 433F           8DBE       F7D4            lea	di,-$82C[bp]
14796 4343           E8         BDA3            call	lmulul
14797 4346           83C4                   08  add	sp,*8
14798 4349           53                         push	bx
14799 434A           50                         push	ax
14800                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
14801 434B           8A86       F81D            mov	al,-$7E3[bp]
14802 434F           30E4                       xor	ah,ah
14803 4351           31DB                       xor	bx,bx
14804                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14805 4353           53                         push	bx
14806 4354           50                         push	ax
14807 4355           31C0                       xor	ax,ax
14808 4357           BB                   0100  mov	bx,#$100
14809 435A           53                         push	bx
14810 435B           50                         push	ax
14811 435C           8B86       F7D4            mov	ax,-$82C[bp]
14812 4360           8B9E       F7D6            mov	bx,-$82A[bp]
14813 4364           8DBE       F7D0            lea	di,-$830[bp]
14814 4368           E8         BD7E            call	lmulul
14815 436B           83C4                   08  add	sp,*8
14816                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14817 436E           8DBE       F7D8            lea	di,-$828[bp]
14818 4372           E8         BD4E            call	laddul
14819 4375           83C4                   04  add	sp,*4
14820                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14821 4378           8DBE       F7DC            lea	di,-$824[bp]
14822 437C           E8         BD44            call	laddul
14823 437F           83C4                   04  add	sp,*4
14824                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14825 4382           8DBE       F7E0            lea	di,-$820[bp]
14826 4386           E8         BD3A            call	laddul
14827 4389           83C4                   04  add	sp,*4
14828                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14829 438C           8986       F7EE            mov	-$812[bp],ax
14830 4390           899E       F7F0            mov	-$810[bp],bx
14831                                           !BCC_EOS
14832                                           ! 2411   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
14833                                           ! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
14834 4394           FFB6       F7F0            push	-$810[bp]
14835 4398           FFB6       F7EE            push	-$812[bp]
14836                                           ! Debug: list * unsigned long = const $260 (used reg = )
14837 439C           B8                   0260  mov	ax,#$260
14838 439F           50                         push	ax
14839                                           ! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
14840 43A0           FF76         FE            push	-2[bp]
14841                                           ! Debug: func () void = write_dword+0 (used reg = )
14842 43A3           E8         BCF5            call	_write_dword
14843 43A6           83C4                   08  add	sp,*8
14844                                           !BCC_EOS
14845                                           ! 2412   memsetb(get_SS(),atacmd,0,12);
14846                                           ! Debug: list int = const $C (used reg = )
14847 43A9           B8                   000C  mov	ax,*$C
14848 43AC           50                         push	ax
14849                                           ! Debug: list int = const 0 (used reg = )
14850 43AD           31C0                       xor	ax,ax
14851 43AF           50                         push	ax
14852                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14853 43B0           8D5E         F2            lea	bx,-$E[bp]
14854 43B3           53                         push	bx
14855                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14856 43B4           E8         C296            call	_get_SS
14857                                           ! Debug: list unsigned short = ax+0 (used reg = )
14858 43B7           50                         push	ax
14859                                           ! Debug: func () void = memsetb+0 (used reg = )
14860 43B8           E8         BC45            call	_memsetb
14861 43BB           83C4                   08  add	sp,*8
14862                                           !BCC_EOS
14863                                           ! 2413   atacmd[0]=0x28;
14864                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14865 43BE           B0                     28  mov	al,*$28
14866 43C0           8846         F2            mov	-$E[bp],al
14867                                           !BCC_EOS
14868                                           ! 2414   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
14869                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14870 43C3           8B86       F7EA            mov	ax,-$816[bp]
14871                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14872 43C7           48                         dec	ax
14873 43C8           D1E8                       shr	ax,*1
14874 43CA           D1E8                       shr	ax,*1
14875                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14876                                           ! Debug: expression subtree swapping
14877                                           ! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
14878 43CC           40                         inc	ax
14879 43CD           30C0                       xor	al,al
14880                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
14881 43CF           88E0                       mov	al,ah
14882 43D1           30E4                       xor	ah,ah
14883                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14884 43D3           8846         F9            mov	-7[bp],al
14885                                           !BCC_EOS
14886                                           ! 2415   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
14887                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14888 43D6           8B86       F7EA            mov	ax,-$816[bp]
14889                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14890 43DA           48                         dec	ax
14891 43DB           D1E8                       shr	ax,*1
14892 43DD           D1E8                       shr	ax,*1
14893                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14894                                           ! Debug: expression subtree swapping
14895                                           ! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
14896 43DF           40                         inc	ax
14897                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
14898 43E0           8846         FA            mov	-6[bp],al
14899                                           !BCC_EOS
14900                                           ! 2416   atacmd[2]=(lba & 0xff000000) >> 24;
14901                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14902                                           ! Debug: expression subtree swapping
14903 43E3           31C0                       xor	ax,ax
14904 43E5           BB                   FF00  mov	bx,#$FF00
14905 43E8           8DBE       F7EE            lea	di,-$812[bp]
14906 43EC           E8         BCCC            call	landul
14907                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14908 43EF           93                         xchg	bx,ax
14909 43F0           88E0                       mov	al,ah
14910 43F2           30E4                       xor	ah,ah
14911 43F4           31DB                       xor	bx,bx
14912                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14913 43F6           8846         F4            mov	-$C[bp],al
14914                                           !BCC_EOS
14915                                           ! 2417   atacmd[3]=(lba & 0x00ff0000) >> 16;
14916                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14917                                           ! Debug: expression subtree swapping
14918 43F9           31C0                       xor	ax,ax
14919 43FB           BB                   00FF  mov	bx,#$FF
14920 43FE           8DBE       F7EE            lea	di,-$812[bp]
14921 4402           E8         BCB6            call	landul
14922                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14923 4405           93                         xchg	bx,ax
14924 4406           31DB                       xor	bx,bx
14925                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14926 4408           8846         F5            mov	-$B[bp],al
14927                                           !BCC_EOS
14928                                           ! 2418   atacmd[4]=(lba & 0x0000ff00) >> 8;
14929                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14930                                           ! Debug: expression subtree swapping
14931 440B           B8                   FF00  mov	ax,#$FF00
14932 440E           31DB                       xor	bx,bx
14933 4410           8DBE       F7EE            lea	di,-$812[bp]
14934 4414           E8         BCA4            call	landul
14935                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14936 4417           88E0                       mov	al,ah
14937 4419           88DC                       mov	ah,bl
14938 441B           88FB                       mov	bl,bh
14939 441D           28FF                       sub	bh,bh
14940                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14941 441F           8846         F6            mov	-$A[bp],al
14942                                           !BCC_EOS
14943                                           ! 2419   atacmd[5]=(lba & 0x000000ff);
14944                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14945                                           ! Debug: expression subtree swapping
14946 4422           B8                   00FF  mov	ax,#$FF
14947 4425           31DB                       xor	bx,bx
14948 4427           8DBE       F7EE            lea	di,-$812[bp]
14949 442B           E8         BC8D            call	landul
14950                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14951 442E           8846         F7            mov	-9[bp],al
14952                                           !BCC_EOS
14953                                           ! 2420   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
14954                                           ! Debug: list int = const 0 (used reg = )
14955 4431           31C0                       xor	ax,ax
14956 4433           50                         push	ax
14957                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
14958 4434           FFB6       F7EC            push	-$814[bp]
14959                                           ! Debug: list int = const 1 (used reg = )
14960 4438           B8                   0001  mov	ax,*1
14961 443B           50                         push	ax
14962                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
14963 443C           8B86       F7EA            mov	ax,-$816[bp]
14964 4440           31DB                       xor	bx,bx
14965                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
14966 4442           53                         push	bx
14967 4443           50                         push	ax
14968 4444           B8                   0200  mov	ax,#$200
14969 4447           31DB                       xor	bx,bx
14970 4449           53                         push	bx
14971 444A           50                         push	ax
14972 444B           8B86       F7DA            mov	ax,-$826[bp]
14973 444F           8B9E       F7DC            mov	bx,-$824[bp]
14974 4453           8DBE       F7D6            lea	di,-$82A[bp]
14975 4457           E8         BC8F            call	lmulul
14976 445A           83C4                   08  add	sp,*8
14977                                           ! Debug: list unsigned long = bx+0 (used reg = )
14978 445D           53                         push	bx
14979 445E           50                         push	ax
14980                                           ! Debug: list int = const 0 (used reg = )
14981 445F           31C0                       xor	ax,ax
14982 4461           50                         push	ax
14983                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14984 4462           8D5E         F2            lea	bx,-$E[bp]
14985 4465           53                         push	bx
14986                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14987 4466           E8         C1E4            call	_get_SS
14988                                           ! Debug: list unsigned short = ax+0 (used reg = )
14989 4469           50                         push	ax
14990                                           ! Debug: list int = const $C (used reg = )
14991 446A           B8                   000C  mov	ax,*$C
14992 446D           50                         push	ax
14993                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14994 446E           8A86       F7E5            mov	al,-$81B[bp]
14995 4472           30E4                       xor	ah,ah
14996 4474           50                         push	ax
14997                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14998 4475           E8         F14E            call	_ata_cmd_packet
14999 4478           83C4                   14  add	sp,*$14
15000                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
15001 447B           8986       F7E6            mov	-$81A[bp],ax
15002                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
15003 447F           85C0                       test	ax,ax
15004 4481           74           07            je  	.325
15005                       00004483            .326:
15006                                           ! 2421     return 12;
15007 4483           B8                   000C  mov	ax,*$C
15008 4486           89EC                       mov	sp,bp
15009 4488           5D                         pop	bp
15010 4489           C3                         ret
15011                                           !BCC_EOS
15012                                           ! 2422   
15013                                           ! 2422 switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
15014                       0000448A            .325:
15015                                           ! Debug: list * unsigned char = const $25B (used reg = )
15016 448A           B8                   025B  mov	ax,#$25B
15017 448D           50                         push	ax
15018                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15019 448E           FF76         FE            push	-2[bp]
15020                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15021 4491           E8         C160            call	_read_byte
15022 4494           83C4                   04  add	sp,*4
15023 4497           E9         0120            br 	.329
15024                                           ! 2423     case 0x01:
15025                                           ! 2424       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
15026                       0000449A            .32A:
15027                                           ! Debug: list int = const $F (used reg = )
15028 449A           B8                   000F  mov	ax,*$F
15029 449D           50                         push	ax
15030                                           ! Debug: list * unsigned short = const $26E (used reg = )
15031 449E           B8                   026E  mov	ax,#$26E
15032 44A1           50                         push	ax
15033                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15034 44A2           FF76         FE            push	-2[bp]
15035                                           ! Debug: func () void = write_word+0 (used reg = )
15036 44A5           E8         C18A            call	_write_word
15037 44A8           83C4                   06  add	sp,*6
15038                                           !BCC_EOS
15039                                           ! 2425       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15040                                           ! Debug: list int = const $50 (used reg = )
15041 44AB           B8                   0050  mov	ax,*$50
15042 44AE           50                         push	ax
15043                                           ! Debug: list * unsigned short = const $26C (used reg = )
15044 44AF           B8                   026C  mov	ax,#$26C
15045 44B2           50                         push	ax
15046                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15047 44B3           FF76         FE            push	-2[bp]
15048                                           ! Debug: func () void = write_word+0 (used reg = )
15049 44B6           E8         C179            call	_write_word
15050 44B9           83C4                   06  add	sp,*6
15051                                           !BCC_EOS
15052                                           ! 2426       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15053                                           ! Debug: list int = const 2 (used reg = )
15054 44BC           B8                   0002  mov	ax,*2
15055 44BF           50                         push	ax
15056                                           ! Debug: list * unsigned short = const $26A (used reg = )
15057 44C0           B8                   026A  mov	ax,#$26A
15058 44C3           50                         push	ax
15059                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15060 44C4           FF76         FE            push	-2[bp]
15061                                           ! Debug: func () void = write_word+0 (used reg = )
15062 44C7           E8         C168            call	_write_word
15063 44CA           83C4                   06  add	sp,*6
15064                                           !BCC_EOS
15065                                           ! 2427       break;
15066 44CD           E9         0102            br 	.327
15067                                           !BCC_EOS
15068                                           ! 2428     case 0x02:
15069                                           ! 2429       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
15070                       000044D0            .32B:
15071                                           ! Debug: list int = const $12 (used reg = )
15072 44D0           B8                   0012  mov	ax,*$12
15073 44D3           50                         push	ax
15074                                           ! Debug: list * unsigned short = const $26E (used reg = )
15075 44D4           B8                   026E  mov	ax,#$26E
15076 44D7           50                         push	ax
15077                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15078 44D8           FF76         FE            push	-2[bp]
15079                                           ! Debug: func () void = write_word+0 (used reg = )
15080 44DB           E8         C154            call	_write_word
15081 44DE           83C4                   06  add	sp,*6
15082                                           !BCC_EOS
15083                                           ! 2430       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15084                                           ! Debug: list int = const $50 (used reg = )
15085 44E1           B8                   0050  mov	ax,*$50
15086 44E4           50                         push	ax
15087                                           ! Debug: list * unsigned short = const $26C (used reg = )
15088 44E5           B8                   026C  mov	ax,#$26C
15089 44E8           50                         push	ax
15090                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15091 44E9           FF76         FE            push	-2[bp]
15092                                           ! Debug: func () void = write_word+0 (used reg = )
15093 44EC           E8         C143            call	_write_word
15094 44EF           83C4                   06  add	sp,*6
15095                                           !BCC_EOS
15096                                           ! 2431       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15097                                           ! Debug: list int = const 2 (used reg = )
15098 44F2           B8                   0002  mov	ax,*2
15099 44F5           50                         push	ax
15100                                           ! Debug: list * unsigned short = const $26A (used reg = )
15101 44F6           B8                   026A  mov	ax,#$26A
15102 44F9           50                         push	ax
15103                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15104 44FA           FF76         FE            push	-2[bp]
15105                                           ! Debug: func () void = write_word+0 (used reg = )
15106 44FD           E8         C132            call	_write_word
15107 4500           83C4                   06  add	sp,*6
15108                                           !BCC_EOS
15109                                           ! 2432       break;
15110 4503           E9         00CC            br 	.327
15111                                           !BCC_EOS
15112                                           ! 2433     case 0x03:
15113                                           ! 2434       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
15114                       00004506            .32C:
15115                                           ! Debug: list int = const $24 (used reg = )
15116 4506           B8                   0024  mov	ax,*$24
15117 4509           50                         push	ax
15118                                           ! Debug: list * unsigned short = const $26E (used reg = )
15119 450A           B8                   026E  mov	ax,#$26E
15120 450D           50                         push	ax
15121                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15122 450E           FF76         FE            push	-2[bp]
15123                                           ! Debug: func () void = write_word+0 (used reg = )
15124 4511           E8         C11E            call	_write_word
15125 4514           83C4                   06  add	sp,*6
15126                                           !BCC_EOS
15127                                           ! 2435       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15128                                           ! Debug: list int = const $50 (used reg = )
15129 4517           B8                   0050  mov	ax,*$50
15130 451A           50                         push	ax
15131                                           ! Debug: list * unsigned short = const $26C (used reg = )
15132 451B           B8                   026C  mov	ax,#$26C
15133 451E           50                         push	ax
15134                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15135 451F           FF76         FE            push	-2[bp]
15136                                           ! Debug: func () void = write_word+0 (used reg = )
15137 4522           E8         C10D            call	_write_word
15138 4525           83C4                   06  add	sp,*6
15139                                           !BCC_EOS
15140                                           ! 2436       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15141                                           ! Debug: list int = const 2 (used reg = )
15142 4528           B8                   0002  mov	ax,*2
15143 452B           50                         push	ax
15144                                           ! Debug: list * unsigned short = const $26A (used reg = )
15145 452C           B8                   026A  mov	ax,#$26A
15146 452F           50                         push	ax
15147                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15148 4530           FF76         FE            push	-2[bp]
15149                                           ! Debug: func () void = write_word+0 (used reg = )
15150 4533           E8         C0FC            call	_write_word
15151 4536           83C4                   06  add	sp,*6
15152                                           !BCC_EOS
15153                                           ! 2437       break;
15154 4539           E9         0096            br 	.327
15155                                           !BCC_EOS
15156                                           ! 2438     case 0x04:
15157                                           ! 2439       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
15158                       0000453C            .32D:
15159                                           ! Debug: list int = const $1C4 (used reg = )
15160 453C           B8                   01C4  mov	ax,#$1C4
15161 453F           50                         push	ax
15162                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15163 4540           FFB6       F7EC            push	-$814[bp]
15164                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15165 4544           E8         C0AD            call	_read_byte
15166 4547           83C4                   04  add	sp,*4
15167                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
15168 454A           24                     3F  and	al,*$3F
15169                                           ! Debug: list unsigned char = al+0 (used reg = )
15170 454C           30E4                       xor	ah,ah
15171 454E           50                         push	ax
15172                                           ! Debug: list * unsigned short = const $26E (used reg = )
15173 454F           B8                   026E  mov	ax,#$26E
15174 4552           50                         push	ax
15175                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15176 4553           FF76         FE            push	-2[bp]
15177                                           ! Debug: func () void = write_word+0 (used reg = )
15178 4556           E8         C0D9            call	_write_word
15179 4559           83C4                   06  add	sp,*6
15180                                           !BCC_EOS
15181                                           ! 2440       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
15182                                           ! 2441               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
15183                                           ! Debug: list int = const $1C5 (used reg = )
15184 455C           B8                   01C5  mov	ax,#$1C5
15185 455F           50                         push	ax
15186                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15187 4560           FFB6       F7EC            push	-$814[bp]
15188                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15189 4564           E8         C08D            call	_read_byte
15190 4567           83C4                   04  add	sp,*4
15191 456A           50                         push	ax
15192                                           ! Debug: list int = const $1C4 (used reg = )
15193 456B           B8                   01C4  mov	ax,#$1C4
15194 456E           50                         push	ax
15195                                           ! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
15196 456F           FFB6       F7EC            push	-$814[bp]
15197                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15198 4573           E8         C07E            call	_read_byte
15199 4576           83C4                   04  add	sp,*4
15200                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
15201 4579           30E4                       xor	ah,ah
15202 457B           D1E0                       shl	ax,*1
15203 457D           D1E0                       shl	ax,*1
15204                                           ! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
15205 457F           0286       F7E2            add	al,0+..FFF9[bp]
15206 4583           80D4                   00  adc	ah,*0
15207 4586           44                         inc	sp
15208 4587           44                         inc	sp
15209                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
15210                                           ! Debug: list unsigned int = ax+1 (used reg = )
15211 4588           40                         inc	ax
15212 4589           50                         push	ax
15213                                           ! Debug: list * unsigned short = const $26C (used reg = )
15214 458A           B8                   026C  mov	ax,#$26C
15215 458D           50                         push	ax
15216                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15217 458E           FF76         FE            push	-2[bp]
15218                                           ! Debug: func () void = write_word+0 (used reg = )
15219 4591           E8         C09E            call	_write_word
15220 4594           83C4                   06  add	sp,*6
15221                                           !BCC_EOS
15222                                           ! 2442       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
15223                                           ! Debug: list int = const $1C3 (used reg = )
15224 4597           B8                   01C3  mov	ax,#$1C3
15225 459A           50                         push	ax
15226                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15227 459B           FFB6       F7EC            push	-$814[bp]
15228                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15229 459F           E8         C052            call	_read_byte
15230 45A2           83C4                   04  add	sp,*4
15231                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15232 45A5           30E4                       xor	ah,ah
15233                                           ! Debug: list unsigned int = ax+1 (used reg = )
15234 45A7           40                         inc	ax
15235 45A8           50                         push	ax
15236                                           ! Debug: list * unsigned short = const $26A (used reg = )
15237 45A9           B8                   026A  mov	ax,#$26A
15238 45AC           50                         push	ax
15239                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15240 45AD           FF76         FE            push	-2[bp]
15241                                           ! Debug: func () void = write_word+0 (used reg = )
15242 45B0           E8         C07F            call	_write_word
15243 45B3           83C4                   06  add	sp,*6
15244                                           !BCC_EOS
15245                                           ! 2443       break;
15246 45B6           EB           1A            jmp .327
15247                                           !BCC_EOS
15248                                           ! 2444    }
15249                                           ! 2445   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
15250 45B8           EB           18            jmp .327
15251                       000045BA            .329:
15252 45BA           2C                     01  sub	al,*1
15253 45BC         0F84         FEDA            beq 	.32A
15254 45C0           2C                     01  sub	al,*1
15255 45C2         0F84         FF0A            beq 	.32B
15256 45C6           2C                     01  sub	al,*1
15257 45C8         0F84         FF3A            beq 	.32C
15258 45CC           2C                     01  sub	al,*1
15259 45CE         0F84         FF6A            beq 	.32D
15260                       000045D2            .327:
15261                       FFFFF7E2            ..FFF9	=	-$81E
15262                                           ! Debug: list * unsigned char = const $25B (used reg = )
15263 45D2           B8                   025B  mov	ax,#$25B
15264 45D5           50                         push	ax
15265                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15266 45D6           FF76         FE            push	-2[bp]
15267                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15268 45D9           E8         C018            call	_read_byte
15269 45DC           83C4                   04  add	sp,*4
15270                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15271 45DF           84C0                       test	al,al
15272 45E1           74           52            je  	.32E
15273                       000045E3            .32F:
15274                                           ! 2446     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
15275                                           ! Debug: list * unsigned char = const $25C (used reg = )
15276 45E3           B8                   025C  mov	ax,#$25C
15277 45E6           50                         push	ax
15278                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15279 45E7           FF76         FE            push	-2[bp]
15280                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15281 45EA           E8         C007            call	_read_byte
15282 45ED           83C4                   04  add	sp,*4
15283                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15284 45F0           84C0                       test	al,al
15285 45F2           75           23            jne 	.330
15286                       000045F4            .331:
15287                                           ! 2447       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
15288                                           ! Debug: list int = const $10 (used reg = )
15289 45F4           B8                   0010  mov	ax,*$10
15290 45F7           50                         push	ax
15291                                           ! Debug: list int = const $40 (used reg = )
15292 45F8           B8                   0040  mov	ax,*$40
15293 45FB           50                         push	ax
15294                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15295 45FC           E8         BFF5            call	_read_byte
15296 45FF           83C4                   04  add	sp,*4
15297                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
15298 4602           0C                     41  or	al,*$41
15299                                           ! Debug: list unsigned char = al+0 (used reg = )
15300 4604           30E4                       xor	ah,ah
15301 4606           50                         push	ax
15302                                           ! Debug: list int = const $10 (used reg = )
15303 4607           B8                   0010  mov	ax,*$10
15304 460A           50                         push	ax
15305                                           ! Debug: list int = const $40 (used reg = )
15306 460B           B8                   0040  mov	ax,*$40
15307 460E           50                         push	ax
15308                                           ! Debug: func () void = write_byte+0 (used reg = )
15309 460F           E8         C008            call	_write_byte
15310 4612           83C4                   06  add	sp,*6
15311                                           !BCC_EOS
15312                                           ! 2448     else
15313                                           ! 2449       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
15314 4615           EB           1E            jmp .332
15315                       00004617            .330:
15316                                           ! Debug: list * unsigned char = const $232 (used reg = )
15317 4617           B8                   0232  mov	ax,#$232
15318 461A           50                         push	ax
15319                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15320 461B           FF76         FE            push	-2[bp]
15321                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15322 461E           E8         BFD3            call	_read_byte
15323 4621           83C4                   04  add	sp,*4
15324                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15325 4624           30E4                       xor	ah,ah
15326                                           ! Debug: list unsigned int = ax+1 (used reg = )
15327 4626           40                         inc	ax
15328 4627           50                         push	ax
15329                                           ! Debug: list * unsigned char = const $232 (used reg = )
15330 4628           B8                   0232  mov	ax,#$232
15331 462B           50                         push	ax
15332                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15333 462C           FF76         FE            push	-2[bp]
15334                                           ! Debug: func () void = write_byte+0 (used reg = )
15335 462F           E8         BFE8            call	_write_byte
15336 4632           83C4                   06  add	sp,*6
15337                                           !BCC_EOS
15338                                           ! 2450    }
15339                       00004635            .332:
15340                                           ! 2451   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
15341                       00004635            .32E:
15342                                           ! Debug: list * unsigned char = const $25B (used reg = )
15343 4635           B8                   025B  mov	ax,#$25B
15344 4638           50                         push	ax
15345                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15346 4639           FF76         FE            push	-2[bp]
15347                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15348 463C           E8         BFB5            call	_read_byte
15349 463F           83C4                   04  add	sp,*4
15350                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15351 4642           84C0                       test	al,al
15352 4644           74           11            je  	.333
15353                       00004646            .334:
15354                                           ! 2452     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
15355                                           ! Debug: list int = const 1 (used reg = )
15356 4646           B8                   0001  mov	ax,*1
15357 4649           50                         push	ax
15358                                           ! Debug: list * unsigned char = const $25A (used reg = )
15359 464A           B8                   025A  mov	ax,#$25A
15360 464D           50                         push	ax
15361                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15362 464E           FF76         FE            push	-2[bp]
15363                                           ! Debug: func () void = write_byte+0 (used reg = )
15364 4651           E8         BFC6            call	_write_byte
15365 4654           83C4                   06  add	sp,*6
15366                                           !BCC_EOS
15367                                           ! 2453   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
15368                       00004657            .333:
15369                                           ! Debug: list * unsigned char = const $25C (used reg = )
15370 4657           B8                   025C  mov	ax,#$25C
15371 465A           50                         push	ax
15372                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15373 465B           FF76         FE            push	-2[bp]
15374                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15375 465E           E8         BF93            call	_read_byte
15376 4661           83C4                   04  add	sp,*4
15377                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
15378 4664           30E4                       xor	ah,ah
15379 4666           B9                   0100  mov	cx,#$100
15380 4669           F7E9                       imul	cx
15381                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
15382                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
15383 466B           89EC                       mov	sp,bp
15384 466D           5D                         pop	bp
15385 466E           C3                         ret
15386                                           !BCC_EOS
15387                                           ! 2454 }
15388                                           ! 2455   void
15389                                           ! Register BX used in function cdrom_boot
15390                                           ! 2456 int14_function(regs, ds, iret_addr)
15391                                           ! 2457   pusha_regs_t regs;
15392                                           export	_int14_function
15393                       0000466F            _int14_function:
15394                                           !BCC_EOS
15395                                           ! 2458   Bit16u ds;
15396                                           !BCC_EOS
15397                                           ! 2459   iret_addr_t iret_addr;
15398                                           !BCC_EOS
15399                                           ! 2460 {
15400                                           ! 2461   Bit16u addr,timer,val16;
15401                                           !BCC_EOS
15402                                           ! 2462   Bit8u timeout;
15403                                           !BCC_EOS
15404                                           ! 2463 #asm
15405 466F           55                         push	bp
15406 4670           89E5                       mov	bp,sp
15407 4672           83C4                   F8  add	sp,*-8
15408                                           !BCC_EOS
15409                                           !BCC_ASM
15410                       0000001C            _int14_function.ds	set	$1C
15411                       00000014            .int14_function.ds	set	$14
15412                       00000004            _int14_function.timer	set	4
15413                       FFFFFFFC            .int14_function.timer	set	-4
15414                       00000001            _int14_function.timeout	set	1
15415                       FFFFFFF9            .int14_function.timeout	set	-7
15416                       0000001E            _int14_function.iret_addr	set	$1E
15417                       00000016            .int14_function.iret_addr	set	$16
15418                       00000006            _int14_function.addr	set	6
15419                       FFFFFFFE            .int14_function.addr	set	-2
15420                       00000002            _int14_function.val16	set	2
15421                       FFFFFFFA            .int14_function.val16	set	-6
15422                       0000000C            _int14_function.regs	set	$C
15423                       00000004            .int14_function.regs	set	4
15424 4675           FB                           sti
15425                                           ! 2465 endasm
15426                                           !BCC_ENDASM
15427                                           !BCC_EOS
15428                                           ! 2466   addr = read_word(0x0040, (regs.u.r16.dx << 1));
15429                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
15430 4676           8B46         0E            mov	ax,$E[bp]
15431 4679           D1E0                       shl	ax,*1
15432                                           ! Debug: list unsigned int = ax+0 (used reg = )
15433 467B           50                         push	ax
15434                                           ! Debug: list int = const $40 (used reg = )
15435 467C           B8                   0040  mov	ax,*$40
15436 467F           50                         push	ax
15437                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15438 4680           E8         BF84            call	_read_word
15439 4683           83C4                   04  add	sp,*4
15440                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
15441 4686           8946         FE            mov	-2[bp],ax
15442                                           !BCC_EOS
15443                                           ! 2467   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
15444                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
15445                                           ! Debug: expression subtree swapping
15446 4689           8B46         0E            mov	ax,$E[bp]
15447                                           ! Debug: list unsigned int = ax+$7C (used reg = )
15448 468C           05                   007C  add	ax,*$7C
15449 468F           50                         push	ax
15450                                           ! Debug: list int = const $40 (used reg = )
15451 4690           B8                   0040  mov	ax,*$40
15452 4693           50                         push	ax
15453                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15454 4694           E8         BF5D            call	_read_byte
15455 4697           83C4                   04  add	sp,*4
15456                                           ! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
15457 469A           8846         F9            mov	-7[bp],al
15458                                           !BCC_EOS
15459                                           ! 2468   if ((regs.u.r16.dx
15460                                           ! 2468  < 4) && (addr > 0)) {
15461                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
15462 469D           8B46         0E            mov	ax,$E[bp]
15463 46A0           3D                   0004  cmp	ax,*4
15464 46A3         0F83         022C            bhis	.335
15465                       000046A7            .337:
15466                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
15467 46A7           8B46         FE            mov	ax,-2[bp]
15468 46AA           85C0                       test	ax,ax
15469 46AC         0F84         0223            beq 	.335
15470                       000046B0            .336:
15471                                           ! 2469     switch (regs.u.r8.ah) {
15472 46B0           8A46         13            mov	al,$13[bp]
15473 46B3           E9         0203            br 	.33A
15474                                           ! 2470       case 0:
15475                                           ! 2471         outb(addr+3, inb(addr+3) | 0x80);
15476                       000046B6            .33B:
15477                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
15478 46B6           8B46         FE            mov	ax,-2[bp]
15479                                           ! Debug: list unsigned int = ax+3 (used reg = )
15480 46B9           05                   0003  add	ax,*3
15481 46BC           50                         push	ax
15482                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15483 46BD           E8         BE7E            call	_inb
15484 46C0           44                         inc	sp
15485 46C1           44                         inc	sp
15486                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
15487 46C2           0C                     80  or	al,#$80
15488                                           ! Debug: list unsigned char = al+0 (used reg = )
15489 46C4           30E4                       xor	ah,ah
15490 46C6           50                         push	ax
15491                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15492 46C7           8B46         FE            mov	ax,-2[bp]
15493                                           ! Debug: list unsigned int = ax+3 (used reg = )
15494 46CA           05                   0003  add	ax,*3
15495 46CD           50                         push	ax
15496                                           ! Debug: func () void = outb+0 (used reg = )
15497 46CE           E8         BE83            call	_outb
15498 46D1           83C4                   04  add	sp,*4
15499                                           !BCC_EOS
15500                                           ! 2472         if (regs.u.r8.al & 0xE0 == 0) {
15501                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
15502 46D4           8A46         12            mov	al,$12[bp]
15503 46D7           30C0                       xor	al,al
15504 46D9           84C0                       test	al,al
15505 46DB           74           1E            je  	.33C
15506                       000046DD            .33D:
15507                                           ! 2473           outb(addr, 0x17);
15508                                           ! Debug: list int = const $17 (used reg = )
15509 46DD           B8                   0017  mov	ax,*$17
15510 46E0           50                         push	ax
15511                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15512 46E1           FF76         FE            push	-2[bp]
15513                                           ! Debug: func () void = outb+0 (used reg = )
15514 46E4           E8         BE6D            call	_outb
15515 46E7           83C4                   04  add	sp,*4
15516                                           !BCC_EOS
15517                                           ! 2474           outb(addr+1, 0x04);
15518                                           ! Debug: list int = const 4 (used reg = )
15519 46EA           B8                   0004  mov	ax,*4
15520 46ED           50                         push	ax
15521                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15522 46EE           8B46         FE            mov	ax,-2[bp]
15523                                           ! Debug: list unsigned int = ax+1 (used reg = )
15524 46F1           40                         inc	ax
15525 46F2           50                         push	ax
15526                                           ! Debug: func () void = outb+0 (used reg = )
15527 46F3           E8         BE5E            call	_outb
15528 46F6           83C4                   04  add	sp,*4
15529                                           !BCC_EOS
15530                                           ! 2475         } else {
15531 46F9           EB           39            jmp .33E
15532                       000046FB            .33C:
15533                                           ! 2476           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
15534                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
15535 46FB           8A46         12            mov	al,$12[bp]
15536 46FE           24                     E0  and	al,#$E0
15537                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
15538 4700           30E4                       xor	ah,ah
15539 4702           B1                     05  mov	cl,*5
15540 4704           D3E8                       shr	ax,cl
15541                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
15542 4706           89C3                       mov	bx,ax
15543 4708           B8                   0600  mov	ax,#$600
15544 470B           89D9                       mov	cx,bx
15545 470D           D3F8                       sar	ax,cl
15546                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15547 470F           8946         FA            mov	-6[bp],ax
15548                                           !BCC_EOS
15549                                           ! 2477           outb(addr, val16 & 0xFF);
15550                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
15551 4712           8A46         FA            mov	al,-6[bp]
15552                                           ! Debug: list unsigned char = al+0 (used reg = )
15553 4715           30E4                       xor	ah,ah
15554 4717           50                         push	ax
15555                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15556 4718           FF76         FE            push	-2[bp]
15557                                           ! Debug: func () void = outb+0 (used reg = )
15558 471B           E8         BE36            call	_outb
15559 471E           83C4                   04  add	sp,*4
15560                                           !BCC_EOS
15561                                           ! 2478           outb(addr+1, val16 >> 8);
15562                                           ! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
15563 4721           8B46         FA            mov	ax,-6[bp]
15564 4724           88E0                       mov	al,ah
15565 4726           30E4                       xor	ah,ah
15566                                           ! Debug: list unsigned int = ax+0 (used reg = )
15567 4728           50                         push	ax
15568                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15569 4729           8B46         FE            mov	ax,-2[bp]
15570                                           ! Debug: list unsigned int = ax+1 (used reg = )
15571 472C           40                         inc	ax
15572 472D           50                         push	ax
15573                                           ! Debug: func () void = outb+0 (used reg = )
15574 472E           E8         BE23            call	_outb
15575 4731           83C4                   04  add	sp,*4
15576                                           !BCC_EOS
15577                                           ! 2479         }
15578                                           ! 2480         outb(addr+3, regs.u.r8.al & 0x1F);
15579                       00004734            .33E:
15580                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
15581 4734           8A46         12            mov	al,$12[bp]
15582 4737           24                     1F  and	al,*$1F
15583                                           ! Debug: list unsigned char = al+0 (used reg = )
15584 4739           30E4                       xor	ah,ah
15585 473B           50                         push	ax
15586                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15587 473C           8B46         FE            mov	ax,-2[bp]
15588                                           ! Debug: list unsigned int = ax+3 (used reg = )
15589 473F           05                   0003  add	ax,*3
15590 4742           50                         push	ax
15591                                           ! Debug: func () void = outb+0 (used reg = )
15592 4743           E8         BE0E            call	_outb
15593 4746           83C4                   04  add	sp,*4
15594                                           !BCC_EOS
15595                                           ! 2481         regs.u.r8.ah = inb(addr+5);
15596                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15597 4749           8B46         FE            mov	ax,-2[bp]
15598                                           ! Debug: list unsigned int = ax+5 (used reg = )
15599 474C           05                   0005  add	ax,*5
15600 474F           50                         push	ax
15601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15602 4750           E8         BDEB            call	_inb
15603 4753           44                         inc	sp
15604 4754           44                         inc	sp
15605                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15606 4755           8846         13            mov	$13[bp],al
15607                                           !BCC_EOS
15608                                           ! 2482         regs.u.r8.al = inb(addr+6);
15609                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15610 4758           8B46         FE            mov	ax,-2[bp]
15611                                           ! Debug: list unsigned int = ax+6 (used reg = )
15612 475B           05                   0006  add	ax,*6
15613 475E           50                         push	ax
15614                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15615 475F           E8         BDDC            call	_inb
15616 4762           44                         inc	sp
15617 4763           44                         inc	sp
15618                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15619 4764           8846         12            mov	$12[bp],al
15620                                           !BCC_EOS
15621                                           ! 2483         iret_addr.flags.u.r8.flagsl &= 0xfe;
15622                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15623 4767           8A46         1A            mov	al,$1A[bp]
15624 476A           24                     FE  and	al,#$FE
15625 476C           8846         1A            mov	$1A[bp],al
15626                                           !BCC_EOS
15627                                           ! 2484         break;
15628 476F           E9         015F            br 	.338
15629                                           !BCC_EOS
15630                                           ! 2485       case 1:
15631                                           ! 2486         timer = read_word(0x0040, 0x006C);
15632                       00004772            .33F:
15633                                           ! Debug: list int = const $6C (used reg = )
15634 4772           B8                   006C  mov	ax,*$6C
15635 4775           50                         push	ax
15636                                           ! Debug: list int = const $40 (used reg = )
15637 4776           B8                   0040  mov	ax,*$40
15638 4779           50                         push	ax
15639                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15640 477A           E8         BE8A            call	_read_word
15641 477D           83C4                   04  add	sp,*4
15642                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15643 4780           8946         FC            mov	-4[bp],ax
15644                                           !BCC_EOS
15645                                           ! 2487         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
15646 4783           EB           26            jmp .341
15647                       00004785            .342:
15648                                           ! 2488           val16 = read_word(0x0040, 0x006C);
15649                                           ! Debug: list int = const $6C (used reg = )
15650 4785           B8                   006C  mov	ax,*$6C
15651 4788           50                         push	ax
15652                                           ! Debug: list int = const $40 (used reg = )
15653 4789           B8                   0040  mov	ax,*$40
15654 478C           50                         push	ax
15655                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15656 478D           E8         BE77            call	_read_word
15657 4790           83C4                   04  add	sp,*4
15658                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15659 4793           8946         FA            mov	-6[bp],ax
15660                                           !BCC_EOS
15661                                           ! 2489           if (val16 != timer) {
15662                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15663 4796           8B46         FA            mov	ax,-6[bp]
15664 4799           3B46         FC            cmp	ax,-4[bp]
15665 479C           74           0D            je  	.343
15666                       0000479E            .344:
15667                                           ! 2490             timer = val16;
15668                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15669 479E           8B46         FA            mov	ax,-6[bp]
15670 47A1           8946         FC            mov	-4[bp],ax
15671                                           !BCC_EOS
15672                                           ! 2491             timeout--;
15673                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
15674 47A4           8A46         F9            mov	al,-7[bp]
15675 47A7           48                         dec	ax
15676 47A8           8846         F9            mov	-7[bp],al
15677                                           !BCC_EOS
15678                                           ! 2492             }
15679                                           ! 2493           }
15680                       000047AB            .343:
15681                                           ! 2494         if (timeout) outb(addr, regs.u.r8.al);
15682                       000047AB            .341:
15683                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15684 47AB           8B46         FE            mov	ax,-2[bp]
15685                                           ! Debug: list unsigned int = ax+5 (used reg = )
15686 47AE           05                   0005  add	ax,*5
15687 47B1           50                         push	ax
15688                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15689 47B2           E8         BD89            call	_inb
15690 47B5           44                         inc	sp
15691 47B6           44                         inc	sp
15692                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
15693 47B7           24                     60  and	al,*$60
15694                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
15695 47B9           3C                     60  cmp	al,*$60
15696 47BB           74           07            je  	.345
15697                       000047BD            .346:
15698 47BD           8A46         F9            mov	al,-7[bp]
15699 47C0           84C0                       test	al,al
15700 47C2           75           C1            jne	.342
15701                       000047C4            .345:
15702                       000047C4            .340:
15703 47C4           8A46         F9            mov	al,-7[bp]
15704 47C7           84C0                       test	al,al
15705 47C9           74           0F            je  	.347
15706                       000047CB            .348:
15707                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
15708 47CB           8A46         12            mov	al,$12[bp]
15709 47CE           30E4                       xor	ah,ah
15710 47D0           50                         push	ax
15711                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15712 47D1           FF76         FE            push	-2[bp]
15713                                           ! Debug: func () void = outb+0 (used reg = )
15714 47D4           E8         BD7D            call	_outb
15715 47D7           83C4                   04  add	sp,*4
15716                                           !BCC_EOS
15717                                           ! 2495         regs.u.r8.ah = inb(addr+5);
15718                       000047DA            .347:
15719                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15720 47DA           8B46         FE            mov	ax,-2[bp]
15721                                           ! Debug: list unsigned int = ax+5 (used reg = )
15722 47DD           05                   0005  add	ax,*5
15723 47E0           50                         push	ax
15724                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15725 47E1           E8         BD5A            call	_inb
15726 47E4           44                         inc	sp
15727 47E5           44                         inc	sp
15728                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15729 47E6           8846         13            mov	$13[bp],al
15730                                           !BCC_EOS
15731                                           ! 2496         if (!timeout) regs.u.r8.ah |= 0x80;
15732 47E9           8A46         F9            mov	al,-7[bp]
15733 47EC           84C0                       test	al,al
15734 47EE           75           08            jne 	.349
15735                       000047F0            .34A:
15736                                           ! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15737 47F0           8A46         13            mov	al,$13[bp]
15738 47F3           0C                     80  or	al,#$80
15739 47F5           8846         13            mov	$13[bp],al
15740                                           !BCC_EOS
15741                                           ! 2497         iret_addr.flags.u.r8.flagsl &= 0xfe;
15742                       000047F8            .349:
15743                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15744 47F8           8A46         1A            mov	al,$1A[bp]
15745 47FB           24                     FE  and	al,#$FE
15746 47FD           8846         1A            mov	$1A[bp],al
15747                                           !BCC_EOS
15748                                           ! 2498         break;
15749 4800           E9         00CE            br 	.338
15750                                           !BCC_EOS
15751                                           ! 2499       case 2:
15752                                           ! 2500         timer = read_word(0x0040, 0x006C);
15753                       00004803            .34B:
15754                                           ! Debug: list int = const $6C (used reg = )
15755 4803           B8                   006C  mov	ax,*$6C
15756 4806           50                         push	ax
15757                                           ! Debug: list int = const $40 (used reg = )
15758 4807           B8                   0040  mov	ax,*$40
15759 480A           50                         push	ax
15760                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15761 480B           E8         BDF9            call	_read_word
15762 480E           83C4                   04  add	sp,*4
15763                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15764 4811           8946         FC            mov	-4[bp],ax
15765                                           !BCC_EOS
15766                                           ! 2501         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
15767 4814           EB           26            jmp .34D
15768                       00004816            .34E:
15769                                           ! 2502           val16 = read_word(0x0040, 0x006C);
15770                                           ! Debug: list int = const $6C (used reg = )
15771 4816           B8                   006C  mov	ax,*$6C
15772 4819           50                         push	ax
15773                                           ! Debug: list int = const $40 (used reg = )
15774 481A           B8                   0040  mov	ax,*$40
15775 481D           50                         push	ax
15776                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15777 481E           E8         BDE6            call	_read_word
15778 4821           83C4                   04  add	sp,*4
15779                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15780 4824           8946         FA            mov	-6[bp],ax
15781                                           !BCC_EOS
15782                                           ! 2503           if (val16 != timer) {
15783                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15784 4827           8B46         FA            mov	ax,-6[bp]
15785 482A           3B46         FC            cmp	ax,-4[bp]
15786 482D           74           0D            je  	.34F
15787                       0000482F            .350:
15788                                           ! 2504             timer = val16;
15789                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15790 482F           8B46         FA            mov	ax,-6[bp]
15791 4832           8946         FC            mov	-4[bp],ax
15792                                           !BCC_EOS
15793                                           ! 2505             timeout--;
15794                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
15795 4835           8A46         F9            mov	al,-7[bp]
15796 4838           48                         dec	ax
15797 4839           8846         F9            mov	-7[bp],al
15798                                           !BCC_EOS
15799                                           ! 2506             }
15800                                           ! 2507           }
15801                       0000483C            .34F:
15802                                           ! 2508         if (timeout) {
15803                       0000483C            .34D:
15804                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15805 483C           8B46         FE            mov	ax,-2[bp]
15806                                           ! Debug: list unsigned int = ax+5 (used reg = )
15807 483F           05                   0005  add	ax,*5
15808 4842           50                         push	ax
15809                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15810 4843           E8         BCF8            call	_inb
15811 4846           44                         inc	sp
15812 4847           44                         inc	sp
15813                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
15814 4848           24                     01  and	al,*1
15815                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15816 484A           84C0                       test	al,al
15817 484C           75           07            jne 	.351
15818                       0000484E            .352:
15819 484E           8A46         F9            mov	al,-7[bp]
15820 4851           84C0                       test	al,al
15821 4853           75           C1            jne	.34E
15822                       00004855            .351:
15823                       00004855            .34C:
15824 4855           8A46         F9            mov	al,-7[bp]
15825 4858           84C0                       test	al,al
15826 485A           74           12            je  	.353
15827                       0000485C            .354:
15828                                           ! 2509           regs.u.r8.ah = 0;
15829                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
15830 485C           30C0                       xor	al,al
15831 485E           8846         13            mov	$13[bp],al
15832                                           !BCC_EOS
15833                                           ! 2510           regs.u.r8.al = inb(addr);
15834                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
15835 4861           FF76         FE            push	-2[bp]
15836                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15837 4864           E8         BCD7            call	_inb
15838 4867           44                         inc	sp
15839 4868           44                         inc	sp
15840                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15841 4869           8846         12            mov	$12[bp],al
15842                                           !BCC_EOS
15843                                           ! 2511         } else {
15844 486C           EB           0F            jmp .355
15845                       0000486E            .353:
15846                                           ! 2512           regs.u.r8.ah = inb(addr+5);
15847                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15848 486E           8B46         FE            mov	ax,-2[bp]
15849                                           ! Debug: list unsigned int = ax+5 (used reg = )
15850 4871           05                   0005  add	ax,*5
15851 4874           50                         push	ax
15852                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15853 4875           E8         BCC6            call	_inb
15854 4878           44                         inc	sp
15855 4879           44                         inc	sp
15856                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15857 487A           8846         13            mov	$13[bp],al
15858                                           !BCC_EOS
15859                                           ! 2513           }
15860                                           ! 2514         iret_addr.flags.u.r8.flagsl &= 0xfe;
15861                       0000487D            .355:
15862                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15863 487D           8A46         1A            mov	al,$1A[bp]
15864 4880           24                     FE  and	al,#$FE
15865 4882           8846         1A            mov	$1A[bp],al
15866                                           !BCC_EOS
15867                                           ! 2515         break;
15868 4885           EB           4A            jmp .338
15869                                           !BCC_EOS
15870                                           ! 2516       case 3:
15871                                           ! 2517         regs.u.r8.ah = inb(addr+5);
15872                       00004887            .356:
15873                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15874 4887           8B46         FE            mov	ax,-2[bp]
15875                                           ! Debug: list unsigned int = ax+5 (used reg = )
15876 488A           05                   0005  add	ax,*5
15877 488D           50                         push	ax
15878                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15879 488E           E8         BCAD            call	_inb
15880 4891           44                         inc	sp
15881 4892           44                         inc	sp
15882                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15883 4893           8846         13            mov	$13[bp],al
15884                                           !BCC_EOS
15885                                           ! 2518         regs.u.r8.al = inb(addr+6);
15886                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15887 4896           8B46         FE            mov	ax,-2[bp]
15888                                           ! Debug: list unsigned int = ax+6 (used reg = )
15889 4899           05                   0006  add	ax,*6
15890 489C           50                         push	ax
15891                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15892 489D           E8         BC9E            call	_inb
15893 48A0           44                         inc	sp
15894 48A1           44                         inc	sp
15895                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15896 48A2           8846         12            mov	$12[bp],al
15897                                           !BCC_EOS
15898                                           ! 2519         iret_addr.flags.u.r8.flagsl &= 0xfe;
15899                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15900 48A5           8A46         1A            mov	al,$1A[bp]
15901 48A8           24                     FE  and	al,#$FE
15902 48AA           8846         1A            mov	$1A[bp],al
15903                                           !BCC_EOS
15904                                           ! 2520         break;
15905 48AD           EB           22            jmp .338
15906                                           !BCC_EOS
15907                                           ! 2521       default:
15908                                           ! 2522         iret_addr.flags.u.r8.flagsl |= 0x01;
15909                       000048AF            .357:
15910                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15911 48AF           8A46         1A            mov	al,$1A[bp]
15912 48B2           0C                     01  or	al,*1
15913 48B4           8846         1A            mov	$1A[bp],al
15914                                           !BCC_EOS
15915                                           ! 2523       }
15916                                           ! 2524   } else {
15917 48B7           EB           18            jmp .338
15918                       000048B9            .33A:
15919 48B9           2C                     00  sub	al,*0
15920 48BB         0F84         FDF7            beq 	.33B
15921 48BF           2C                     01  sub	al,*1
15922 48C1         0F84         FEAD            beq 	.33F
15923 48C5           2C                     01  sub	al,*1
15924 48C7         0F84         FF38            beq 	.34B
15925 48CB           2C                     01  sub	al,*1
15926 48CD           74           B8            je 	.356
15927 48CF           EB           DE            jmp	.357
15928                       000048D1            .338:
15929                       FFFFFFF6            ..FFF8	=	-$A
15930 48D1           EB           08            jmp .358
15931                       000048D3            .335:
15932                                           ! 2525     iret_addr.flags.u.r8.flagsl |= 0x01;
15933                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15934 48D3           8A46         1A            mov	al,$1A[bp]
15935 48D6           0C                     01  or	al,*1
15936 48D8           8846         1A            mov	$1A[bp],al
15937                                           !BCC_EOS
15938                                           ! 2526     }
15939                                           ! 2527 }
15940                       000048DB            .358:
15941 48DB           89EC                       mov	sp,bp
15942 48DD           5D                         pop	bp
15943 48DE           C3                         ret
15944                                           ! 2528   void
15945                                           ! Register BX used in function int14_function
15946                                           ! 2529 int15_function(regs, ES, DS, FLAGS)
15947                                           ! 2530   pusha_regs_t regs;
15948                                           export	_int15_function
15949                       000048DF            _int15_function:
15950                                           !BCC_EOS
15951                                           ! 2531   Bit16u ES, DS, FLAGS;
15952                                           !BCC_EOS
15953                                           ! 2532 {
15954                                           ! 2533   Bit16u ebda_seg=read_word(0x0040,0x000E);
15955 48DF           55                         push	bp
15956 48E0           89E5                       mov	bp,sp
15957 48E2           4C                         dec	sp
15958 48E3           4C                         dec	sp
15959                                           ! Debug: list int = const $E (used reg = )
15960 48E4           B8                   000E  mov	ax,*$E
15961 48E7           50                         push	ax
15962                                           ! Debug: list int = const $40 (used reg = )
15963 48E8           B8                   0040  mov	ax,*$40
15964 48EB           50                         push	ax
15965                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15966 48EC           E8         BD18            call	_read_word
15967 48EF           83C4                   04  add	sp,*4
15968                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15969 48F2           8946         FE            mov	-2[bp],ax
15970                                           !BCC_EOS
15971                                           ! 2534   bx_bool prev_a20_enable;
15972                                           !BCC_EOS
15973                                           ! 2535   Bit16u base15_00;
15974                                           !BCC_EOS
15975                                           ! 2536   Bit8u base23_16;
15976                                           !BCC_EOS
15977                                           ! 2537   Bit16u ss;
15978                                           !BCC_EOS
15979                                           ! 2538   Bit16u CX,DX;
15980                                           !BCC_EOS
15981                                           ! 2539   Bit16u bRegister;
15982                                           !BCC_EOS
15983                                           ! 2540   Bit8u irqDisable;
15984                                           !BCC_EOS
15985                                           ! 2541 ;
15986 48F5           83C4                   F0  add	sp,*-$10
15987                                           !BCC_EOS
15988                                           ! 2542   switch (regs.u.r8.ah) {
15989 48F8           8A46         13            mov	al,$13[bp]
15990                                           ! 2542 
15991 48FB           E9         0489            br 	.35B
15992                                           ! 2543     case 0x24:
15993                                           ! 2544       switch (regs.u.r8.al) {
15994                       000048FE            .35C:
15995 48FE           8A46         12            mov	al,$12[bp]
15996 4901           EB           74            jmp .35F
15997                                           ! 2545         case 0x00:
15998                                           ! 2546           set_enable_a20(0);
15999                       00004903            .360:
16000                                           ! Debug: list int = const 0 (used reg = )
16001 4903           31C0                       xor	ax,ax
16002 4905           50                         push	ax
16003                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16004 4906           E8         CFD2            call	_set_enable_a20
16005 4909           44                         inc	sp
16006 490A           44                         inc	sp
16007                                           !BCC_EOS
16008                                           ! 2547           FLAGS &= 0xfffe;
16009                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16010 490B           8B46         18            mov	ax,$18[bp]
16011 490E           24                     FE  and	al,#$FE
16012 4910           8946         18            mov	$18[bp],ax
16013                                           !BCC_EOS
16014                                           ! 2548           regs.u.r8.ah = 0;
16015                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16016 4913           30C0                       xor	al,al
16017 4915           8846         13            mov	$13[bp],al
16018                                           !BCC_EOS
16019                                           ! 2549           break;
16020 4918           EB           6F            jmp .35D
16021                                           !BCC_EOS
16022                                           ! 2550         case 0x01:
16023                                           ! 2551           set_enable_a20(1);
16024                       0000491A            .361:
16025                                           ! Debug: list int = const 1 (used reg = )
16026 491A           B8                   0001  mov	ax,*1
16027 491D           50                         push	ax
16028                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16029 491E           E8         CFBA            call	_set_enable_a20
16030 4921           44                         inc	sp
16031 4922           44                         inc	sp
16032                                           !BCC_EOS
16033                                           ! 2552           FLAGS &= 0xfffe;
16034                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16035 4923           8B46         18            mov	ax,$18[bp]
16036 4926           24                     FE  and	al,#$FE
16037 4928           8946         18            mov	$18[bp],ax
16038                                           !BCC_EOS
16039                                           ! 2553           regs.u.r8.ah = 0;
16040                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16041 492B           30C0                       xor	al,al
16042 492D           8846         13            mov	$13[bp],al
16043                                           !BCC_EOS
16044                                           ! 2554           break;
16045 4930           EB           57            jmp .35D
16046                                           !BCC_EOS
16047                                           ! 2555         case 0x02:
16048                                           ! 2556           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
16049                       00004932            .362:
16050                                           ! Debug: list int = const $92 (used reg = )
16051 4932           B8                   0092  mov	ax,#$92
16052 4935           50                         push	ax
16053                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16054 4936           E8         BC05            call	_inb
16055 4939           44                         inc	sp
16056 493A           44                         inc	sp
16057                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
16058 493B           30E4                       xor	ah,ah
16059 493D           D1E8                       shr	ax,*1
16060                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
16061 493F           24                     01  and	al,*1
16062                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
16063 4941           8846         12            mov	$12[bp],al
16064                                           !BCC_EOS
16065                                           ! 2557           FLAGS &= 0xfffe;
16066                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16067 4944           8B46         18            mov	ax,$18[bp]
16068 4947           24                     FE  and	al,#$FE
16069 4949           8946         18            mov	$18[bp],ax
16070                                           !BCC_EOS
16071                                           ! 2558           regs.u.r8.ah = 0;
16072                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16073 494C           30C0                       xor	al,al
16074 494E           8846         13            mov	$13[bp],al
16075                                           !BCC_EOS
16076                                           ! 2559           break;
16077 4951           EB           36            jmp .35D
16078                                           !BCC_EOS
16079                                           ! 2560         case 0x03:
16080                                           ! 2561           FLAGS &= 0xfffe;
16081                       00004953            .363:
16082                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16083 4953           8B46         18            mov	ax,$18[bp]
16084 4956           24                     FE  and	al,#$FE
16085 4958           8946         18            mov	$18[bp],ax
16086                                           !BCC_EOS
16087                                           ! 2562           regs.u.r8.ah = 0;
16088                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16089 495B           30C0                       xor	al,al
16090 495D           8846         13            mov	$13[bp],al
16091                                           !BCC_EOS
16092                                           ! 2563           regs.u.r16.bx = 3;
16093                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
16094 4960           B8                   0003  mov	ax,*3
16095 4963           8946         0C            mov	$C[bp],ax
16096                                           !BCC_EOS
16097                                           ! 2564           break;
16098 4966           EB           21            jmp .35D
16099                                           !BCC_EOS
16100                                           ! 2565         default:
16101                                           ! 2566           ;
16102                       00004968            .364:
16103                                           !BCC_EOS
16104                                           ! 2567           FLAGS |= 0x0001;
16105                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16106 4968           8B46         18            mov	ax,$18[bp]
16107 496B           0C                     01  or	al,*1
16108 496D           8946         18            mov	$18[bp],ax
16109                                           !BCC_EOS
16110                                           ! 2568           regs.u.r8.ah = 0x86;
16111                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16112 4970           B0                     86  mov	al,#$86
16113 4972           8846         13            mov	$13[bp],al
16114                                           !BCC_EOS
16115                                           ! 2569       }
16116                                           ! 2570       break;
16117 4975           EB           12            jmp .35D
16118                       00004977            .35F:
16119 4977           2C                     00  sub	al,*0
16120 4979           74           88            je 	.360
16121 497B           2C                     01  sub	al,*1
16122 497D           74           9B            je 	.361
16123 497F           2C                     01  sub	al,*1
16124 4981           74           AF            je 	.362
16125 4983           2C                     01  sub	al,*1
16126 4985           74           CC            je 	.363
16127 4987           EB           DF            jmp	.364
16128                       00004989            .35D:
16129 4989           E9         044B            br 	.359
16130                                           !BCC_EOS
16131                                           ! 2571     case 0x41:
16132                                           ! 2572       FLAGS |= 0x0001;
16133                       0000498C            .365:
16134                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16135 498C           8B46         18            mov	ax,$18[bp]
16136 498F           0C                     01  or	al,*1
16137 4991           8946         18            mov	$18[bp],ax
16138                                           !BCC_EOS
16139                                           ! 2573       regs.u.r8.ah = 0x86;
16140                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16141 4994           B0                     86  mov	al,#$86
16142 4996           8846         13            mov	$13[bp],al
16143                                           !BCC_EOS
16144                                           ! 2574       break;
16145 4999           E9         043B            br 	.359
16146                                           !BCC_EOS
16147                                           ! 2575     case 0x4f:
16148                                           ! 2576       FLAGS |= 0x0001;
16149                       0000499C            .366:
16150                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16151 499C           8B46         18            mov	ax,$18[bp]
16152 499F           0C                     01  or	al,*1
16153 49A1           8946         18            mov	$18[bp],ax
16154                                           !BCC_EOS
16155                                           ! 2577       break;
16156 49A4           E9         0430            br 	.359
16157                                           !BCC_EOS
16158                                           ! 2578     case 0x52:
16159                                           ! 2579       FLAGS &= 0xfffe;
16160                       000049A7            .367:
16161                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16162 49A7           8B46         18            mov	ax,$18[bp]
16163 49AA           24                     FE  and	al,#$FE
16164 49AC           8946         18            mov	$18[bp],ax
16165                                           !BCC_EOS
16166                                           ! 2580       regs.u.r8.ah = 0;
16167                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16168 49AF           30C0                       xor	al,al
16169 49B1           8846         13            mov	$13[bp],al
16170                                           !BCC_EOS
16171                                           ! 2581       break;
16172 49B4           E9         0420            br 	.359
16173                                           !BCC_EOS
16174                                           ! 2582     case 0x83: {
16175                       000049B7            .368:
16176                                           ! 2583       if( regs.u.r8.al == 0 ) {
16177                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
16178 49B7           8A46         12            mov	al,$12[bp]
16179 49BA           84C0                       test	al,al
16180 49BC         0F85         00C1            bne 	.369
16181                       000049C0            .36A:
16182                                           ! 2584         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
16183                                           ! Debug: list int = const $A0 (used reg = )
16184 49C0           B8                   00A0  mov	ax,#$A0
16185 49C3           50                         push	ax
16186                                           ! Debug: list int = const $40 (used reg = )
16187 49C4           B8                   0040  mov	ax,*$40
16188 49C7           50                         push	ax
16189                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16190 49C8           E8         BC29            call	_read_byte
16191 49CB           83C4                   04  add	sp,*4
16192                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
16193 49CE           24                     01  and	al,*1
16194                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
16195 49D0           84C0                       test	al,al
16196 49D2         0F85         009C            bne 	.36B
16197                       000049D6            .36C:
16198                                           ! 2585           write_byte( 0x40, 0xA0, 1 );
16199                                           ! Debug: list int = const 1 (used reg = )
16200 49D6           B8                   0001  mov	ax,*1
16201 49D9           50                         push	ax
16202                                           ! Debug: list int = const $A0 (used reg = )
16203 49DA           B8                   00A0  mov	ax,#$A0
16204 49DD           50                         push	ax
16205                                           ! Debug: list int = const $40 (used reg = )
16206 49DE           B8                   0040  mov	ax,*$40
16207 49E1           50                         push	ax
16208                                           ! Debug: func () void = write_byte+0 (used reg = )
16209 49E2           E8         BC35            call	_write_byte
16210 49E5           83C4                   06  add	sp,*6
16211                                           !BCC_EOS
16212                                           ! 2586           write_word( 0x40, 0x98, ES );
16213                                           ! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
16214 49E8           FF76         14            push	$14[bp]
16215                                           ! Debug: list int = const $98 (used reg = )
16216 49EB           B8                   0098  mov	ax,#$98
16217 49EE           50                         push	ax
16218                                           ! Debug: list int = const $40 (used reg = )
16219 49EF           B8                   0040  mov	ax,*$40
16220 49F2           50                         push	ax
16221                                           ! Debug: func () void = write_word+0 (used reg = )
16222 49F3           E8         BC3C            call	_write_word
16223 49F6           83C4                   06  add	sp,*6
16224                                           !BCC_EOS
16225                                           ! 2587           write_word( 0x40, 0x9A, regs.u.r16.bx );
16226                                           ! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
16227 49F9           FF76         0C            push	$C[bp]
16228                                           ! Debug: list int = const $9A (used reg = )
16229 49FC           B8                   009A  mov	ax,#$9A
16230 49FF           50                         push	ax
16231                                           ! Debug: list int = const $40 (used reg = )
16232 4A00           B8                   0040  mov	ax,*$40
16233 4A03           50                         push	ax
16234                                           ! Debug: func () void = write_word+0 (used reg = )
16235 4A04           E8         BC2B            call	_write_word
16236 4A07           83C4                   06  add	sp,*6
16237                                           !BCC_EOS
16238                                           ! 2588           write_word( 0x40, 0x9C, regs.u.r16.dx );
16239                                           ! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
16240 4A0A           FF76         0E            push	$E[bp]
16241                                           ! Debug: list int = const $9C (used reg = )
16242 4A0D           B8                   009C  mov	ax,#$9C
16243 4A10           50                         push	ax
16244                                           ! Debug: list int = const $40 (used reg = )
16245 4A11           B8                   0040  mov	ax,*$40
16246 4A14           50                         push	ax
16247                                           ! Debug: func () void = write_word+0 (used reg = )
16248 4A15           E8         BC1A            call	_write_word
16249 4A18           83C4                   06  add	sp,*6
16250                                           !BCC_EOS
16251                                           ! 2589           write_word( 0x40, 0x9E, regs.u.r16.cx );
16252                                           ! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
16253 4A1B           FF76         10            push	$10[bp]
16254                                           ! Debug: list int = const $9E (used reg = )
16255 4A1E           B8                   009E  mov	ax,#$9E
16256 4A21           50                         push	ax
16257                                           ! Debug: list int = const $40 (used reg = )
16258 4A22           B8                   0040  mov	ax,*$40
16259 4A25           50                         push	ax
16260                                           ! Debug: func () void = write_word+0 (used reg = )
16261 4A26           E8         BC09            call	_write_word
16262 4A29           83C4                   06  add	sp,*6
16263                                           !BCC_EOS
16264                                           ! 2590           FLAGS &= 0xfffe;
16265                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16266 4A2C           8B46         18            mov	ax,$18[bp]
16267 4A2F           24                     FE  and	al,#$FE
16268 4A31           8946         18            mov	$18[bp],ax
16269                                           !BCC_EOS
16270                                           ! 2591           irqDisable = inb( 0xA1 );
16271                                           ! Debug: list int = const $A1 (used reg = )
16272 4A34           B8                   00A1  mov	ax,#$A1
16273 4A37           50                         push	ax
16274                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16275 4A38           E8         BB03            call	_inb
16276 4A3B           44                         inc	sp
16277 4A3C           44                         inc	sp
16278                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
16279 4A3D           8846         EF            mov	-$11[bp],al
16280                                           !BCC_EOS
16281                                           ! 2592           outb( 0xA1, irqDisable & 0xFE );
16282                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
16283 4A40           8A46         EF            mov	al,-$11[bp]
16284 4A43           24                     FE  and	al,#$FE
16285                                           ! Debug: list unsigned char = al+0 (used reg = )
16286 4A45           30E4                       xor	ah,ah
16287 4A47           50                         push	ax
16288                                           ! Debug: list int = const $A1 (used reg = )
16289 4A48           B8                   00A1  mov	ax,#$A1
16290 4A4B           50                         push	ax
16291                                           ! Debug: func () void = outb+0 (used reg = )
16292 4A4C           E8         BB05            call	_outb
16293 4A4F           83C4                   04  add	sp,*4
16294                                           !BCC_EOS
16295                                           ! 2593           bRegister = inb_cmos( 0xB );
16296                                           ! Debug: list int = const $B (used reg = )
16297 4A52           B8                   000B  mov	ax,*$B
16298 4A55           50                         push	ax
16299                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16300 4A56           E8         BB2A            call	_inb_cmos
16301 4A59           44                         inc	sp
16302 4A5A           44                         inc	sp
16303                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16304 4A5B           30E4                       xor	ah,ah
16305 4A5D           8946         F0            mov	-$10[bp],ax
16306                                           !BCC_EOS
16307                                           ! 2594           outb_cmos( 0xB, bRegister | 0x40 );
16308                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
16309 4A60           8B46         F0            mov	ax,-$10[bp]
16310 4A63           0C                     40  or	al,*$40
16311                                           ! Debug: list unsigned int = ax+0 (used reg = )
16312 4A65           50                         push	ax
16313                                           ! Debug: list int = const $B (used reg = )
16314 4A66           B8                   000B  mov	ax,*$B
16315 4A69           50                         push	ax
16316                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16317 4A6A           E8         BB07            call	_outb_cmos
16318 4A6D           83C4                   04  add	sp,*4
16319                                           !BCC_EOS
16320                                           ! 2595         } else {
16321 4A70           EB           0D            jmp .36D
16322                       00004A72            .36B:
16323                                           ! 2596           ;
16324                                           !BCC_EOS
16325                                           ! 2597           FLAGS |= 0x0001;
16326                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16327 4A72           8B46         18            mov	ax,$18[bp]
16328 4A75           0C                     01  or	al,*1
16329 4A77           8946         18            mov	$18[bp],ax
16330                                           !BCC_EOS
16331                                           ! 2598           regs.u.r8.ah = 0x86;
16332                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16333 4A7A           B0                     86  mov	al,#$86
16334 4A7C           8846         13            mov	$13[bp],al
16335                                           !BCC_EOS
16336                                           ! 2599         }
16337                                           ! 2600       } else if( regs.u.r8.al == 1 ) {
16338                       00004A7F            .36D:
16339 4A7F           EB           54            jmp .36E
16340                       00004A81            .369:
16341                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
16342 4A81           8A46         12            mov	al,$12[bp]
16343 4A84           3C                     01  cmp	al,*1
16344 4A86           75           39            jne 	.36F
16345                       00004A88            .370:
16346                                           ! 2601         write_byte( 0x40, 0xA0, 0 );
16347                                           ! Debug: list int = const 0 (used reg = )
16348 4A88           31C0                       xor	ax,ax
16349 4A8A           50                         push	ax
16350                                           ! Debug: list int = const $A0 (used reg = )
16351 4A8B           B8                   00A0  mov	ax,#$A0
16352 4A8E           50                         push	ax
16353                                           ! Debug: list int = const $40 (used reg = )
16354 4A8F           B8                   0040  mov	ax,*$40
16355 4A92           50                         push	ax
16356                                           ! Debug: func () void = write_byte+0 (used reg = )
16357 4A93           E8         BB84            call	_write_byte
16358 4A96           83C4                   06  add	sp,*6
16359                                           !BCC_EOS
16360                                           ! 2602         FLAGS &= 0xfffe;
16361                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16362 4A99           8B46         18            mov	ax,$18[bp]
16363 4A9C           24                     FE  and	al,#$FE
16364 4A9E           8946         18            mov	$18[bp],ax
16365                                           !BCC_EOS
16366                                           ! 2603         bRegister = inb_cmos( 0xB );
16367                                           ! Debug: list int = const $B (used reg = )
16368 4AA1           B8                   000B  mov	ax,*$B
16369 4AA4           50                         push	ax
16370                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16371 4AA5           E8         BADB            call	_inb_cmos
16372 4AA8           44                         inc	sp
16373 4AA9           44                         inc	sp
16374                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16375 4AAA           30E4                       xor	ah,ah
16376 4AAC           8946         F0            mov	-$10[bp],ax
16377                                           !BCC_EOS
16378                                           ! 2604         outb_cmos( 0xB, bRegister & ~0x40 );
16379                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
16380 4AAF           8B46         F0            mov	ax,-$10[bp]
16381 4AB2           24                     BF  and	al,#$BF
16382                                           ! Debug: list unsigned int = ax+0 (used reg = )
16383 4AB4           50                         push	ax
16384                                           ! Debug: list int = const $B (used reg = )
16385 4AB5           B8                   000B  mov	ax,*$B
16386 4AB8           50                         push	ax
16387                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16388 4AB9           E8         BAB8            call	_outb_cmos
16389 4ABC           83C4                   04  add	sp,*4
16390                                           !BCC_EOS
16391                                           ! 2605       } else {
16392 4ABF           EB           14            jmp .371
16393                       00004AC1            .36F:
16394                                           ! 2606         ;
16395                                           !BCC_EOS
16396                                           ! 2607         FLAGS |= 0x0001;
16397                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16398 4AC1           8B46         18            mov	ax,$18[bp]
16399 4AC4           0C                     01  or	al,*1
16400 4AC6           8946         18            mov	$18[bp],ax
16401                                           !BCC_EOS
16402                                           ! 2608         regs.u.r8.ah = 0x86;
16403                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16404 4AC9           B0                     86  mov	al,#$86
16405 4ACB           8846         13            mov	$13[bp],al
16406                                           !BCC_EOS
16407                                           ! 2609         regs.u.r8.al--;
16408                                           ! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
16409 4ACE           8A46         12            mov	al,$12[bp]
16410 4AD1           48                         dec	ax
16411 4AD2           8846         12            mov	$12[bp],al
16412                                           !BCC_EOS
16413                                           ! 2610       }
16414                                           ! 2611       break;
16415                       00004AD5            .371:
16416                       00004AD5            .36E:
16417 4AD5           E9         02FF            br 	.359
16418                                           !BCC_EOS
16419                                           ! 2612     }
16420                                           ! 2613     case 0x87:
16421                                           ! 2614 #asm
16422                       00004AD8            .372:
16423                                           !BCC_EOS
16424                                           !BCC_ASM
16425                       00000006            _int15_function.CX	set	6
16426                       FFFFFFF4            .int15_function.CX	set	-$C
16427                       0000002A            _int15_function.FLAGS	set	$2A
16428                       00000018            .int15_function.FLAGS	set	$18
16429                       00000001            _int15_function.irqDisable	set	1
16430                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16431                       00000028            _int15_function.DS	set	$28
16432                       00000016            .int15_function.DS	set	$16
16433                       00000004            _int15_function.DX	set	4
16434                       FFFFFFF2            .int15_function.DX	set	-$E
16435                       0000000B            _int15_function.base23_16	set	$B
16436                       FFFFFFF9            .int15_function.base23_16	set	-7
16437                       00000002            _int15_function.bRegister	set	2
16438                       FFFFFFF0            .int15_function.bRegister	set	-$10
16439                       00000026            _int15_function.ES	set	$26
16440                       00000014            .int15_function.ES	set	$14
16441                       00000010            _int15_function.ebda_seg	set	$10
16442                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16443                       0000000C            _int15_function.base15_00	set	$C
16444                       FFFFFFFA            .int15_function.base15_00	set	-6
16445                       00000008            _int15_function.ss	set	8
16446                       FFFFFFF6            .int15_function.ss	set	-$A
16447                       00000016            _int15_function.regs	set	$16
16448                       00000004            .int15_function.regs	set	4
16449                       0000000E            _int15_function.prev_a20_enable	set	$E
16450                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16451 4AD8           FA                           cli
16452                                           ! 2616 endasm
16453                                           !BCC_ENDASM
16454                                           !BCC_EOS
16455                                           ! 2617       prev_a20_enable = set_enable_a20(1);
16456                                           ! Debug: list int = const 1 (used reg = )
16457 4AD9           B8                   0001  mov	ax,*1
16458 4ADC           50                         push	ax
16459                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16460 4ADD           E8         CDFB            call	_set_enable_a20
16461 4AE0           44                         inc	sp
16462 4AE1           44                         inc	sp
16463                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
16464 4AE2           8946         FC            mov	-4[bp],ax
16465                                           !BCC_EOS
16466                                           ! 2618       base15_00 = (ES << 4) + regs.u.r16.si;
16467                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16468 4AE5           8B46         14            mov	ax,$14[bp]
16469 4AE8           B1                     04  mov	cl,*4
16470 4AEA           D3E0                       shl	ax,cl
16471                                           ! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
16472 4AEC           0346         06            add	ax,6[bp]
16473                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16474 4AEF           8946         FA            mov	-6[bp],ax
16475                                           !BCC_EOS
16476                                           ! 2619       base23_16 = ES >> 12;
16477                                           ! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
16478 4AF2           8B46         14            mov	ax,$14[bp]
16479 4AF5           88E0                       mov	al,ah
16480 4AF7           30E4                       xor	ah,ah
16481 4AF9           B1                     04  mov	cl,*4
16482 4AFB           D3E8                       shr	ax,cl
16483                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16484 4AFD           8846         F9            mov	-7[bp],al
16485                                           !BCC_EOS
16486                                           ! 2620       if (base15_00 < (ES<<4))
16487                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16488 4B00           8B46         14            mov	ax,$14[bp]
16489 4B03           B1                     04  mov	cl,*4
16490 4B05           D3E0                       shl	ax,cl
16491                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16492 4B07           3B46         FA            cmp	ax,-6[bp]
16493 4B0A           76           07            jbe 	.373
16494                       00004B0C            .374:
16495                                           ! 2621         base23_16++;
16496                                           ! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
16497 4B0C           8A46         F9            mov	al,-7[bp]
16498 4B0F           40                         inc	ax
16499 4B10           8846         F9            mov	-7[bp],al
16500                                           !BCC_EOS
16501                                           ! 2622       write_word(ES, regs.u.r16.si+0x08+0, 47);
16502                       00004B13            .373:
16503                                           ! Debug: list int = const $2F (used reg = )
16504 4B13           B8                   002F  mov	ax,*$2F
16505 4B16           50                         push	ax
16506                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16507 4B17           8B46         06            mov	ax,6[bp]
16508                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
16509                                           ! Debug: list unsigned int = ax+8 (used reg = )
16510 4B1A           05                   0008  add	ax,*8
16511 4B1D           50                         push	ax
16512                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16513 4B1E           FF76         14            push	$14[bp]
16514                                           ! Debug: func () void = write_word+0 (used reg = )
16515 4B21           E8         BB0E            call	_write_word
16516 4B24           83C4                   06  add	sp,*6
16517                                           !BCC_EOS
16518                                           ! 2623     
16519                                           ! 2623   write_word(ES, regs.u.r16.si+0x08+2, base15_00);
16520                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16521 4B27           FF76         FA            push	-6[bp]
16522                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16523 4B2A           8B46         06            mov	ax,6[bp]
16524                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
16525                                           ! Debug: list unsigned int = ax+$A (used reg = )
16526 4B2D           05                   000A  add	ax,*$A
16527 4B30           50                         push	ax
16528                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16529 4B31           FF76         14            push	$14[bp]
16530                                           ! Debug: func () void = write_word+0 (used reg = )
16531 4B34           E8         BAFB            call	_write_word
16532 4B37           83C4                   06  add	sp,*6
16533                                           !BCC_EOS
16534                                           ! 2624       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
16535                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16536 4B3A           8A46         F9            mov	al,-7[bp]
16537 4B3D           30E4                       xor	ah,ah
16538 4B3F           50                         push	ax
16539                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16540 4B40           8B46         06            mov	ax,6[bp]
16541                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
16542                                           ! Debug: list unsigned int = ax+$C (used reg = )
16543 4B43           05                   000C  add	ax,*$C
16544 4B46           50                         push	ax
16545                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16546 4B47           FF76         14            push	$14[bp]
16547                                           ! Debug: func () void = write_byte+0 (used reg = )
16548 4B4A           E8         BACD            call	_write_byte
16549 4B4D           83C4                   06  add	sp,*6
16550                                           !BCC_EOS
16551                                           ! 2625       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
16552                                           ! Debug: list int = const $93 (used reg = )
16553 4B50           B8                   0093  mov	ax,#$93
16554 4B53           50                         push	ax
16555                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16556 4B54           8B46         06            mov	ax,6[bp]
16557                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
16558                                           ! Debug: list unsigned int = ax+$D (used reg = )
16559 4B57           05                   000D  add	ax,*$D
16560 4B5A           50                         push	ax
16561                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16562 4B5B           FF76         14            push	$14[bp]
16563                                           ! Debug: func () void = write_byte+0 (used reg = )
16564 4B5E           E8         BAB9            call	_write_byte
16565 4B61           83C4                   06  add	sp,*6
16566                                           !BCC_EOS
16567                                           ! 2626       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
16568                                           ! Debug: list int = const 0 (used reg = )
16569 4B64           31C0                       xor	ax,ax
16570 4B66           50                         push	ax
16571                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16572 4B67           8B46         06            mov	ax,6[bp]
16573                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
16574                                           ! Debug: list unsigned int = ax+$E (used reg = )
16575 4B6A           05                   000E  add	ax,*$E
16576 4B6D           50                         push	ax
16577                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16578 4B6E           FF76         14            push	$14[bp]
16579                                           ! Debug: func () void = write_word+0 (used reg = )
16580 4B71           E8         BABE            call	_write_word
16581 4B74           83C4                   06  add	sp,*6
16582                                           !BCC_EOS
16583                                           ! 2627       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
16584                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16585 4B77           B8                   FFFF  mov	ax,#$FFFF
16586 4B7A           50                         push	ax
16587                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16588 4B7B           8B46         06            mov	ax,6[bp]
16589                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
16590                                           ! Debug: list unsigned int = ax+$20 (used reg = )
16591 4B7E           05                   0020  add	ax,*$20
16592 4B81           50                         push	ax
16593                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16594 4B82           FF76         14            push	$14[bp]
16595                                           ! Debug: func () void = write_word+0 (used reg = )
16596 4B85           E8         BAAA            call	_write_word
16597 4B88           83C4                   06  add	sp,*6
16598                                           !BCC_EOS
16599                                           ! 2628       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
16600                                           ! Debug: list int = const 0 (used reg = )
16601 4B8B           31C0                       xor	ax,ax
16602 4B8D           50                         push	ax
16603                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16604 4B8E           8B46         06            mov	ax,6[bp]
16605                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
16606                                           ! Debug: list unsigned int = ax+$22 (used reg = )
16607 4B91           05                   0022  add	ax,*$22
16608 4B94           50                         push	ax
16609                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16610 4B95           FF76         14            push	$14[bp]
16611                                           ! Debug: func () void = write_word+0 (used reg = )
16612 4B98           E8         BA97            call	_write_word
16613 4B9B           83C4                   06  add	sp,*6
16614                                           !BCC_EOS
16615                                           ! 2629       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
16616                                           ! Debug: list int = const $F (used reg = )
16617 4B9E           B8                   000F  mov	ax,*$F
16618 4BA1           50                         push	ax
16619                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16620 4BA2           8B46         06            mov	ax,6[bp]
16621                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
16622                                           ! Debug: list unsigned int = ax+$24 (used reg = )
16623 4BA5           05                   0024  add	ax,*$24
16624 4BA8           50                         push	ax
16625                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16626 4BA9           FF76         14            push	$14[bp]
16627                                           ! Debug: func () void = write_byte+0 (used reg = )
16628 4BAC           E8         BA6B            call	_write_byte
16629 4BAF           83C4                   06  add	sp,*6
16630                                           !BCC_EOS
16631                                           ! 2630       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
16632                                           ! Debug: list int = const $9B (used reg = )
16633 4BB2           B8                   009B  mov	ax,#$9B
16634 4BB5           50                         push	ax
16635                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16636 4BB6           8B46         06            mov	ax,6[bp]
16637                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
16638                                           ! Debug: list unsigned int = ax+$25 (used reg = )
16639 4BB9           05                   0025  add	ax,*$25
16640 4BBC           50                         push	ax
16641                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16642 4BBD           FF76         14            push	$14[bp]
16643                                           ! Debug: func () void = write_byte+0 (used reg = )
16644 4BC0           E8         BA57            call	_write_byte
16645 4BC3           83C4                   06  add	sp,*6
16646                                           !BCC_EOS
16647                                           ! 2631       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
16648                                           ! Debug: list int = const 0 (used reg = )
16649 4BC6           31C0                       xor	ax,ax
16650 4BC8           50                         push	ax
16651                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16652 4BC9           8B46         06            mov	ax,6[bp]
16653                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
16654                                           ! Debug: list unsigned int = ax+$26 (used reg = )
16655 4BCC           05                   0026  add	ax,*$26
16656 4BCF           50                         push	ax
16657                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16658 4BD0           FF76         14            push	$14[bp]
16659                                           ! Debug: func () void = write_word+0 (used reg = )
16660 4BD3           E8         BA5C            call	_write_word
16661 4BD6           83C4                   06  add	sp,*6
16662                                           !BCC_EOS
16663                                           ! 2632       ss = get_SS();
16664                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
16665 4BD9           E8         BA71            call	_get_SS
16666                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
16667 4BDC           8946         F6            mov	-$A[bp],ax
16668                                           !BCC_EOS
16669                                           ! 2633       base15_00 = ss << 4;
16670                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
16671 4BDF           8B46         F6            mov	ax,-$A[bp]
16672 4BE2           B1                     04  mov	cl,*4
16673 4BE4           D3E0                       shl	ax,cl
16674                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16675 4BE6           8946         FA            mov	-6[bp],ax
16676                                           !BCC_EOS
16677                                           ! 2634       base23_16 = ss >> 12;
16678                                           ! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
16679 4BE9           8B46         F6            mov	ax,-$A[bp]
16680 4BEC           88E0                       mov	al,ah
16681 4BEE           30E4                       xor	ah,ah
16682 4BF0           B1                     04  mov	cl,*4
16683 4BF2           D3E8                       shr	ax,cl
16684                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16685 4BF4           8846         F9            mov	-7[bp],al
16686                                           !BCC_EOS
16687                                           ! 2635       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
16688                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16689 4BF7           B8                   FFFF  mov	ax,#$FFFF
16690 4BFA           50                         push	ax
16691                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16692 4BFB           8B46         06            mov	ax,6[bp]
16693                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
16694                                           ! Debug: list unsigned int = ax+$28 (used reg = )
16695 4BFE           05                   0028  add	ax,*$28
16696 4C01           50                         push	ax
16697                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16698 4C02           FF76         14            push	$14[bp]
16699                                           ! Debug: func () void = write_word+0 (used reg = )
16700 4C05           E8         BA2A            call	_write_word
16701 4C08           83C4                   06  add	sp,*6
16702                                           !BCC_EOS
16703                                           ! 2636       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
16704                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16705 4C0B           FF76         FA            push	-6[bp]
16706                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16707 4C0E           8B46         06            mov	ax,6[bp]
16708                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
16709                                           ! Debug: list unsigned int = ax+$2A (used reg = )
16710 4C11           05                   002A  add	ax,*$2A
16711 4C14           50                         push	ax
16712                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16713 4C15           FF76         14            push	$14[bp]
16714                                           ! Debug: func () void = write_word+0 (used reg = )
16715 4C18           E8         BA17            call	_write_word
16716 4C1B           83C4                   06  add	sp,*6
16717                                           !BCC_EOS
16718                                           ! 2637       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
16719                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16720 4C1E           8A46         F9            mov	al,-7[bp]
16721 4C21           30E4                       xor	ah,ah
16722 4C23           50                         push	ax
16723                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16724 4C24           8B46         06            mov	ax,6[bp]
16725                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
16726                                           ! Debug: list unsigned int = ax+$2C (used reg = )
16727 4C27           05                   002C  add	ax,*$2C
16728 4C2A           50                         push	ax
16729                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16730 4C2B           FF76         14            push	$14[bp]
16731                                           ! Debug: func () void = write_byte+0 (used reg = )
16732 4C2E           E8         B9E9            call	_write_byte
16733 4C31           83C4                   06  add	sp,*6
16734                                           !BCC_EOS
16735                                           ! 2638       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
16736                                           ! Debug: list int = const $93 (used reg = )
16737 4C34           B8                   0093  mov	ax,#$93
16738 4C37           50                         push	ax
16739                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16740 4C38           8B46         06            mov	ax,6[bp]
16741                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
16742                                           ! Debug: list unsigned int = ax+$2D (used reg = )
16743 4C3B           05                   002D  add	ax,*$2D
16744 4C3E           50                         push	ax
16745                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16746 4C3F           FF76         14            push	$14[bp]
16747                                           ! Debug: func () void = write_byte+0 (used reg = )
16748 4C42           E8         B9D5            call	_write_byte
16749 4C45           83C4                   06  add	sp,*6
16750                                           !BCC_EOS
16751                                           ! 2639       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
16752                                           ! Debug: list int = const 0 (used reg = )
16753 4C48           31C0                       xor	ax,ax
16754 4C4A           50                         push	ax
16755                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16756 4C4B           8B46         06            mov	ax,6[bp]
16757                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
16758                                           ! Debug: list unsigned int = ax+$2E (used reg = )
16759 4C4E           05                   002E  add	ax,*$2E
16760 4C51           50                         push	ax
16761                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16762 4C52           FF76         14            push	$14[bp]
16763                                           ! Debug: func () void = write_word+0 (used reg = )
16764 4C55           E8         B9DA            call	_write_word
16765 4C58           83C4                   06  add	sp,*6
16766                                           !BCC_EOS
16767                                           ! 2640       CX = regs.u.r16.cx;
16768                                           ! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
16769 4C5B           8B46         10            mov	ax,$10[bp]
16770 4C5E           8946         F4            mov	-$C[bp],ax
16771                                           !BCC_EOS
16772                                           ! 2641 #asm
16773                                           !BCC_EOS
16774                                           !BCC_ASM
16775                       00000006            _int15_function.CX	set	6
16776                       FFFFFFF4            .int15_function.CX	set	-$C
16777                       0000002A            _int15_function.FLAGS	set	$2A
16778                       00000018            .int15_function.FLAGS	set	$18
16779                       00000001            _int15_function.irqDisable	set	1
16780                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16781                       00000028            _int15_function.DS	set	$28
16782                       00000016            .int15_function.DS	set	$16
16783                       00000004            _int15_function.DX	set	4
16784                       FFFFFFF2            .int15_function.DX	set	-$E
16785                       0000000B            _int15_function.base23_16	set	$B
16786                       FFFFFFF9            .int15_function.base23_16	set	-7
16787                       00000002            _int15_function.bRegister	set	2
16788                       FFFFFFF0            .int15_function.bRegister	set	-$10
16789                       00000026            _int15_function.ES	set	$26
16790                       00000014            .int15_function.ES	set	$14
16791                       00000010            _int15_function.ebda_seg	set	$10
16792                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16793                       0000000C            _int15_function.base15_00	set	$C
16794                       FFFFFFFA            .int15_function.base15_00	set	-6
16795                       00000008            _int15_function.ss	set	8
16796                       FFFFFFF6            .int15_function.ss	set	-$A
16797                       00000016            _int15_function.regs	set	$16
16798                       00000004            .int15_function.regs	set	4
16799                       0000000E            _int15_function.prev_a20_enable	set	$E
16800                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16801 4C61           89E3                             mov bx, sp
16802 4C63           36                               SEG SS
16803 4C64           8B4F         06                    mov cx, _int15_function.CX [bx]
16804 4C67     66    50                               push eax
16805 4C69     66    31C0                             xor eax, eax
16806 4C6C           8ED8                             mov ds, ax
16807 4C6E           8C16       0469                  mov 0x0469, ss
16808 4C72           8926       0467                  mov 0x0467, sp
16809 4C76           26                               SEG ES
16810 4C77         0F0154         08                    lgdt [si + 0x08]
16811 4C7B           2E                               SEG CS
16812 4C7C         0F011E       F88C                    lidt [pmode_IDT_info]
16813                                                 ;; perhaps do something with IDT here
16814                                                 ;; set PE bit in CR0
16815 4C81         0F20C0                             mov eax, cr0
16816 4C84           0C                     01        or al, #0x01
16817 4C86         0F22C0                             mov cr0, eax
16818                                                 ;; far jump to flush CPU queue after transition to protected mode
16819                                                 JMP_AP(0x0020, protected_mode)
 +a   4C89                        EA              db 0xea
 +a   4C8A                      4C8E              dw  protected_mode
 +a   4C8C                      0020              dw 0x0020
16820                       00004C8E            protected_mode:
16821                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
16822 4C8E           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
16823 4C91           8ED0                             mov ss, ax
16824 4C93           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
16825 4C96           8ED8                             mov ds, ax
16826 4C98           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
16827 4C9B           8EC0                             mov es, ax
16828 4C9D           31F6                             xor si, si
16829 4C9F           31FF                             xor di, di
16830 4CA1           FC                               cld
16831 4CA2           F3                               rep
16832 4CA3           A5                                 movsw ;; move CX words from DS:SI to ES:DI
16833                                                 ;; make sure DS and ES limits are 64KB
16834 4CA4           B8                   0028        mov ax, #0x28
16835 4CA7           8ED8                             mov ds, ax
16836 4CA9           8EC0                             mov es, ax
16837                                                 ;; reset PG bit in CR0 ???
16838 4CAB         0F20C0                             mov eax, cr0
16839 4CAE           24                     FE        and al, #0xFE
16840 4CB0         0F22C0                             mov cr0, eax
16841                                                 ;; far jump to flush CPU queue after transition to real mode
16842                                                 JMP_AP(0xf000, real_mode)
 +a   4CB3                        EA              db 0xea
 +a   4CB4                      4CB8              dw  real_mode
 +a   4CB6                      F000              dw 0xf000
16843                       00004CB8            real_mode:
16844                                                 ;; restore IDT to normal real-mode defaults
16845 4CB8           2E                               SEG CS
16846 4CB9         0F011E       F891                    lidt [rmode_IDT_info]
16847 4CBE           31C0                             xor ax, ax
16848 4CC0           8ED8                             mov ds, ax
16849 4CC2           8E16       0469                  mov ss, 0x0469
16850 4CC6           8B26       0467                  mov sp, 0x0467
16851 4CCA     66    58                               pop eax
16852                                           ! 2693 endasm
16853                                           !BCC_ENDASM
16854                                           !BCC_EOS
16855                                           ! 2694       set_enable_a20(prev_a20_enable);
16856                                           ! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
16857 4CCC           FF76         FC            push	-4[bp]
16858                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16859 4CCF           E8         CC09            call	_set_enable_a20
16860 4CD2           44                         inc	sp
16861 4CD3           44                         inc	sp
16862                                           !BCC_EOS
16863                                           ! 2695 #asm
16864                                           !BCC_EOS
16865                                           !BCC_ASM
16866                       00000006            _int15_function.CX	set	6
16867                       FFFFFFF4            .int15_function.CX	set	-$C
16868                       0000002A            _int15_function.FLAGS	set	$2A
16869                       00000018            .int15_function.FLAGS	set	$18
16870                       00000001            _int15_function.irqDisable	set	1
16871                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16872                       00000028            _int15_function.DS	set	$28
16873                       00000016            .int15_function.DS	set	$16
16874                       00000004            _int15_function.DX	set	4
16875                       FFFFFFF2            .int15_function.DX	set	-$E
16876                       0000000B            _int15_function.base23_16	set	$B
16877                       FFFFFFF9            .int15_function.base23_16	set	-7
16878                       00000002            _int15_function.bRegister	set	2
16879                       FFFFFFF0            .int15_function.bRegister	set	-$10
16880                       00000026            _int15_function.ES	set	$26
16881                       00000014            .int15_function.ES	set	$14
16882                       00000010            _int15_function.ebda_seg	set	$10
16883                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16884                       0000000C            _int15_function.base15_00	set	$C
16885                       FFFFFFFA            .int15_function.base15_00	set	-6
16886                       00000008            _int15_function.ss	set	8
16887                       FFFFFFF6            .int15_function.ss	set	-$A
16888                       00000016            _int15_function.regs	set	$16
16889                       00000004            .int15_function.regs	set	4
16890                       0000000E            _int15_function.prev_a20_enable	set	$E
16891                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16892 4CD4           FB                           sti
16893                                           ! 2697 endasm
16894                                           !BCC_ENDASM
16895                                           !BCC_EOS
16896                                           ! 2698       regs.u.r8.ah = 0;
16897                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16898 4CD5           30C0                       xor	al,al
16899 4CD7           8846         13            mov	$13[bp],al
16900                                           !BCC_EOS
16901                                           ! 2699       FLAGS &= 0xfffe;
16902                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16903 4CDA           8B46         18            mov	ax,$18[bp]
16904 4CDD           24                     FE  and	al,#$FE
16905 4CDF           8946         18            mov	$18[bp],ax
16906                                           !BCC_EOS
16907                                           ! 2700       break;
16908 4CE2           E9         00F2            br 	.359
16909                                           !BCC_EOS
16910                                           ! 2701     case 0x88:
16911                                           ! 2702       regs.u.r8.al = inb_cmos(0x30);
16912                       00004CE5            .375:
16913                                           ! Debug: list int = const $30 (used reg = )
16914 4CE5           B8                   0030  mov	ax,*$30
16915 4CE8           50                         push	ax
16916                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16917 4CE9           E8         B897            call	_inb_cmos
16918 4CEC           44                         inc	sp
16919 4CED           44                         inc	sp
16920                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
16921 4CEE           8846         12            mov	$12[bp],al
16922                                           !BCC_EOS
16923                                           ! 2703       regs.u.r8.ah = inb_cmos(0x31);
16924                                           ! Debug: list int = const $31 (used reg = )
16925 4CF1           B8                   0031  mov	ax,*$31
16926 4CF4           50                         push	ax
16927                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16928 4CF5           E8         B88B            call	_inb_cmos
16929 4CF8           44                         inc	sp
16930 4CF9           44                         inc	sp
16931                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
16932 4CFA           8846         13            mov	$13[bp],al
16933                                           !BCC_EOS
16934                                           ! 2704       if(regs.u.r16.ax > 0xffc0)
16935                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
16936 4CFD           8B46         12            mov	ax,$12[bp]
16937 4D00           3D                   FFC0  cmp	ax,#$FFC0
16938 4D03           76           06            jbe 	.376
16939                       00004D05            .377:
16940                                           ! 2705         regs.u.r16.ax = 0xffc0;
16941                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
16942 4D05           B8                   FFC0  mov	ax,#$FFC0
16943 4D08           8946         12            mov	$12[bp],ax
16944                                           !BCC_EOS
16945                                           ! 2706       FLAGS &= 0xfffe;
16946                       00004D0B            .376:
16947                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16948 4D0B           8B46         18            mov	ax,$18[bp]
16949 4D0E           24                     FE  and	al,#$FE
16950 4D10           8946         18            mov	$18[bp],ax
16951                                           !BCC_EOS
16952                                           ! 2707       break;
16953 4D13           E9         00C1            br 	.359
16954                                           !BCC_EOS
16955                                           ! 2708     case 0x90:
16956                                           ! 2709       break;
16957                       00004D16            .378:
16958 4D16           E9         00BE            br 	.359
16959                                           !BCC_EOS
16960                                           ! 2710     case 0x91:
16961                                           ! 2711       break;
16962                       00004D19            .379:
16963 4D19           E9         00BB            br 	.359
16964                                           !BCC_EOS
16965                                           ! 2712     case 0xbf:
16966                                           ! 2713       ;
16967                       00004D1C            .37A:
16968                                           !BCC_EOS
16969                                           ! 2714       FLAGS |= 0x0001;
16970                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16971 4D1C           8B46         18            mov	ax,$18[bp]
16972 4D1F           0C                     01  or	al,*1
16973 4D21           8946         18            mov	$18[bp],ax
16974                                           !BCC_EOS
16975                                           ! 2715       regs.u.r8.ah = 0x86;
16976                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16977 4D24           B0                     86  mov	al,#$86
16978 4D26           8846         13            mov	$13[bp],al
16979                                           !BCC_EOS
16980                                           ! 2716       break;
16981 4D29           E9         00AB            br 	.359
16982                                           !BCC_EOS
16983                                           ! 2717     case 0xC0:
16984                                           ! 2718       FLAGS &= 0xfffe;
16985                       00004D2C            .37B:
16986                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16987 4D2C           8B46         18            mov	ax,$18[bp]
16988 4D2F           24                     FE  and	al,#$FE
16989 4D31           8946         18            mov	$18[bp],ax
16990                                           !BCC_EOS
16991                                           ! 2719       regs.u.r8.ah = 0;
16992                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16993 4D34           30C0                       xor	al,al
16994 4D36           8846         13            mov	$13[bp],al
16995                                           !BCC_EOS
16996                                           ! 2720       regs.u.r16.bx = 0xe6f5;
16997                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
16998 4D39           B8                   E6F5  mov	ax,#$E6F5
16999 4D3C           8946         0C            mov	$C[bp],ax
17000                                           !BCC_EOS
17001                                           ! 2721       ES = 0xF000;
17002                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
17003 4D3F           B8                   F000  mov	ax,#$F000
17004 4D42           8946         14            mov	$14[bp],ax
17005                                           !BCC_EOS
17006                                           ! 2722       break;
17007 4D45           E9         008F            br 	.359
17008                                           !BCC_EOS
17009                                           ! 2723     case 0xc1:
17010                                           ! 2724       ES = ebda_seg;
17011                       00004D48            .37C:
17012                                           ! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
17013 4D48           8B46         FE            mov	ax,-2[bp]
17014 4D4B           8946         14            mov	$14[bp],ax
17015                                           !BCC_EOS
17016                                           ! 2725       FLAGS &= 0xfffe;
17017                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
17018 4D4E           8B46         18            mov	ax,$18[bp]
17019 4D51           24                     FE  and	al,#$FE
17020 4D53           8946         18            mov	$18[bp],ax
17021                                           !BCC_EOS
17022                                           ! 2726       break;
17023 4D56           E9         007E            br 	.359
17024                                           !BCC_EOS
17025                                           ! 2727     case 0xd8:
17026                                           ! 2728       bios_printf(8, "EISA BIOS not present\n");
17027                       00004D59            .37D:
17028                                           ! Debug: list * char = .37E+0 (used reg = )
17029 4D59           BB                   D2C9  mov	bx,#.37E
17030 4D5C           53                         push	bx
17031                                           ! Debug: list int = const 8 (used reg = )
17032 4D5D           B8                   0008  mov	ax,*8
17033 4D60           50                         push	ax
17034                                           ! Debug: func () void = bios_printf+0 (used reg = )
17035 4D61           E8         BCB7            call	_bios_printf
17036 4D64           83C4                   04  add	sp,*4
17037                                           !BCC_EOS
17038                                           ! 2729       FLAGS |= 0x0001;
17039                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
17040 4D67           8B46         18            mov	ax,$18[bp]
17041 4D6A           0C                     01  or	al,*1
17042 4D6C           8946         18            mov	$18[bp],ax
17043                                           !BCC_EOS
17044                                           ! 2730       regs.u.r8.ah = 0x86;
17045                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
17046 4D6F           B0                     86  mov	al,#$86
17047 4D71           8846         13            mov	$13[bp],al
17048                                           !BCC_EOS
17049                                           ! 2731       break;
17050 4D74           EB           61            jmp .359
17051                                           !BCC_EOS
17052                                           ! 2732     default:
17053                                           ! 2733       ;
17054                       00004D76            .37F:
17055                                           !BCC_EOS
17056                                           ! 2734       FLAGS |= 0x0001;
17057                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
17058 4D76           8B46         18            mov	ax,$18[bp]
17059 4D79           0C                     01  or	al,*1
17060 4D7B           8946         18            mov	$18[bp],ax
17061                                           !BCC_EOS
17062                                           ! 2735       regs.u.r8.ah = 0x86;
17063                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
17064 4D7E           B0                     86  mov	al,#$86
17065 4D80           8846         13            mov	$13[bp],al
17066                                           !BCC_EOS
17067                                           ! 2736       break;
17068 4D83           EB           52            jmp .359
17069                                           !BCC_EOS
17070                                           ! 2737     }
17071                                           ! 2738 }
17072 4D85           EB           50            jmp .359
17073                       00004D87            .35B:
17074 4D87           2C                     24  sub	al,*$24
17075 4D89         0F84         FB71            beq 	.35C
17076 4D8D           2C                     1D  sub	al,*$1D
17077 4D8F         0F84         FBF9            beq 	.365
17078 4D93           2C                     0E  sub	al,*$E
17079 4D95         0F84         FC03            beq 	.366
17080 4D99           2C                     03  sub	al,*3
17081 4D9B         0F84         FC08            beq 	.367
17082 4D9F           2C                     31  sub	al,*$31
17083 4DA1         0F84         FC12            beq 	.368
17084 4DA5           2C                     04  sub	al,*4
17085 4DA7         0F84         FD2D            beq 	.372
17086 4DAB           2C                     01  sub	al,*1
17087 4DAD         0F84         FF34            beq 	.375
17088 4DB1           2C                     08  sub	al,*8
17089 4DB3         0F84         FF5F            beq 	.378
17090 4DB7           2C                     01  sub	al,*1
17091 4DB9         0F84         FF5C            beq 	.379
17092 4DBD           2C                     2E  sub	al,*$2E
17093 4DBF         0F84         FF59            beq 	.37A
17094 4DC3           2C                     01  sub	al,*1
17095 4DC5         0F84         FF63            beq 	.37B
17096 4DC9           2C                     01  sub	al,*1
17097 4DCB         0F84         FF79            beq 	.37C
17098 4DCF           2C                     17  sub	al,*$17
17099 4DD1         0F84         FF84            beq 	.37D
17100 4DD5           EB           9F            jmp	.37F
17101                       00004DD7            .359:
17102                       FFFFFFEC            ..FFF7	=	-$14
17103 4DD7           89EC                       mov	sp,bp
17104 4DD9           5D                         pop	bp
17105 4DDA           C3                         ret
17106                                           ! 2739   void
17107                                           ! Register BX used in function int15_function
17108                                           ! 2740 int15_function_mouse(regs, ES, DS, FLAGS)
17109                                           ! 2741   pusha_regs_t regs;
17110                                           export	_int15_function_mouse
17111                       00004DDB            _int15_function_mouse:
17112                                           !BCC_EOS
17113                                           ! 2742   Bit16u ES, DS, FLAGS;
17114                                           !BCC_EOS
17115                                           ! 2743 {
17116                                           ! 2744   Bit16u ebda_seg=read_word(0x0040,0x000E);
17117 4DDB           55                         push	bp
17118 4DDC           89E5                       mov	bp,sp
17119 4DDE           4C                         dec	sp
17120 4DDF           4C                         dec	sp
17121                                           ! Debug: list int = const $E (used reg = )
17122 4DE0           B8                   000E  mov	ax,*$E
17123 4DE3           50                         push	ax
17124                                           ! Debug: list int = const $40 (used reg = )
17125 4DE4           B8                   0040  mov	ax,*$40
17126 4DE7           50                         push	ax
17127                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
17128 4DE8           E8         B81C            call	_read_word
17129 4DEB           83C4                   04  add	sp,*4
17130                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
17131 4DEE           8946         FE            mov	-2[bp],ax
17132                                           !BCC_EOS
17133                                           ! 2745   Bit8u mouse_flags_1, mouse_flags_2;
17134                                           !BCC_EOS
17135                                           ! 2746   Bit16u mouse_driver_seg;
17136                                           !BCC_EOS
17137                                           ! 2747   Bit16u mouse_driver_offset;
17138                                           !BCC_EOS
17139                                           ! 2748   Bit8u comm_byte, prev_command_byte;
17140                                           !BCC_EOS
17141                                           ! 2749   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
17142                                           !BCC_EOS
17143                                           ! 2750 ;
17144 4DF1           83C4                   F4  add	sp,*-$C
17145                                           !BCC_EOS
17146                                           ! 2751   switch (regs.u.r8.ah) {
17147 4DF4           8A46         13            mov	al,$13[bp]
17148 4DF7           E9         063C            br 	.382
17149                                           ! 2752     case 0xC2:
17150                                           ! 2753       switch (regs.u.r8.al) {
17151                       00004DFA            .383:
17152 4DFA           8A46         12            mov	al,$12[bp]
17153 4DFD           E9         05FE            br 	.386
17154                                           ! 2754         case 0:
17155                                           ! 2755 ;
17156                       00004E00            .387:
17157                                           !BCC_EOS
17158                                           ! 2756           switch (regs.u.r8.bh) {
17159 4E00           8A46         0D            mov	al,$D[bp]
17160 4E03           E9         00E9            br 	.38A
17161                                           ! 2757             case 0:
17162                                           ! 2758 ;
17163                       00004E06            .38B:
17164                                           !BCC_EOS
17165                                           ! 2759               inhibit_mouse_int_and_events();
17166                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17167 4E06           E8         0FAF            call	_inhibit_mouse_int_and_events
17168                                           !BCC_EOS
17169                                           ! 2760               ret = send_to_mouse_ctrl(0xF5);
17170                                           ! Debug: list int = const $F5 (used reg = )
17171 4E09           B8                   00F5  mov	ax,#$F5
17172 4E0C           50                         push	ax
17173                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17174 4E0D           E8         10F9            call	_send_to_mouse_ctrl
17175 4E10           44                         inc	sp
17176 4E11           44                         inc	sp
17177                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17178 4E12           8846         F5            mov	-$B[bp],al
17179                                           !BCC_EOS
17180                                           ! 2761               if (ret == 0) {
17181                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17182 4E15           8A46         F5            mov	al,-$B[bp]
17183 4E18           84C0                       test	al,al
17184 4E1A           75           2B            jne 	.38C
17185                       00004E1C            .38D:
17186                                           ! 2762                 ret = get_mouse_data(&mouse_data1);
17187                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17188 4E1C           8D5E         F4            lea	bx,-$C[bp]
17189 4E1F           53                         push	bx
17190                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17191 4E20           E8         1130            call	_get_mouse_data
17192 4E23           44                         inc	sp
17193 4E24           44                         inc	sp
17194                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17195 4E25           8846         F5            mov	-$B[bp],al
17196                                           !BCC_EOS
17197                                           ! 2763                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
17198                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17199 4E28           8A46         F5            mov	al,-$B[bp]
17200 4E2B           84C0                       test	al,al
17201 4E2D           74           07            je  	.38F
17202                       00004E2F            .390:
17203                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17204 4E2F           8A46         F4            mov	al,-$C[bp]
17205 4E32           3C                     FA  cmp	al,#$FA
17206 4E34           75           11            jne 	.38E
17207                       00004E36            .38F:
17208                                           ! 2764                   FLAGS &= 0xfffe;
17209                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17210 4E36           8B46         18            mov	ax,$18[bp]
17211 4E39           24                     FE  and	al,#$FE
17212 4E3B           8946         18            mov	$18[bp],ax
17213                                           !BCC_EOS
17214                                           ! 2765                   regs.u.r8.ah = 0;
17215                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17216 4E3E           30C0                       xor	al,al
17217 4E40           8846         13            mov	$13[bp],al
17218                                           !BCC_EOS
17219                                           ! 2766                   return;
17220 4E43           89EC                       mov	sp,bp
17221 4E45           5D                         pop	bp
17222 4E46           C3                         ret
17223                                           !BCC_EOS
17224                                           ! 2767                   }
17225                                           ! 2768                 }
17226                       00004E47            .38E:
17227                                           ! 2769               FLAGS |= 0x0001;
17228                       00004E47            .38C:
17229                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17230 4E47           8B46         18            mov	ax,$18[bp]
17231 4E4A           0C                     01  or	al,*1
17232 4E4C           8946         18            mov	$18[bp],ax
17233                                           !BCC_EOS
17234                                           ! 2770               regs.u.r8.ah = ret;
17235                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17236 4E4F           8A46         F5            mov	al,-$B[bp]
17237 4E52           8846         13            mov	$13[bp],al
17238                                           !BCC_EOS
17239                                           ! 2771               return;
17240 4E55           89EC                       mov	sp,bp
17241 4E57           5D                         pop	bp
17242 4E58           C3                         ret
17243                                           !BCC_EOS
17244                                           ! 2772               break;
17245 4E59           E9         00A1            br 	.388
17246                                           !BCC_EOS
17247                                           ! 2773             ca
17248                                           ! 2773 se 1:
17249                                           ! 2774 ;
17250                       00004E5C            .391:
17251                                           !BCC_EOS
17252                                           ! 2775               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17253                                           ! Debug: list int = const $27 (used reg = )
17254 4E5C           B8                   0027  mov	ax,*$27
17255 4E5F           50                         push	ax
17256                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17257 4E60           FF76         FE            push	-2[bp]
17258                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17259 4E63           E8         B78E            call	_read_byte
17260 4E66           83C4                   04  add	sp,*4
17261                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17262 4E69           8846         FC            mov	-4[bp],al
17263                                           !BCC_EOS
17264                                           ! 2776               if ( (mouse_flags_2 & 0x80) == 0 ) {
17265                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17266 4E6C           8A46         FC            mov	al,-4[bp]
17267 4E6F           24                     80  and	al,#$80
17268                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17269 4E71           84C0                       test	al,al
17270 4E73           75           11            jne 	.392
17271                       00004E75            .393:
17272                                           ! 2777                 ;
17273                                           !BCC_EOS
17274                                           ! 2778                 FLAGS |= 0x0001;
17275                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17276 4E75           8B46         18            mov	ax,$18[bp]
17277 4E78           0C                     01  or	al,*1
17278 4E7A           8946         18            mov	$18[bp],ax
17279                                           !BCC_EOS
17280                                           ! 2779                 regs.u.r8.ah = 5;
17281                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
17282 4E7D           B0                     05  mov	al,*5
17283 4E7F           8846         13            mov	$13[bp],al
17284                                           !BCC_EOS
17285                                           ! 2780                 return;
17286 4E82           89EC                       mov	sp,bp
17287 4E84           5D                         pop	bp
17288 4E85           C3                         ret
17289                                           !BCC_EOS
17290                                           ! 2781                 }
17291                                           ! 2782               inhibit_mouse_int_and_events();
17292                       00004E86            .392:
17293                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17294 4E86           E8         0F2F            call	_inhibit_mouse_int_and_events
17295                                           !BCC_EOS
17296                                           ! 2783               ret = send_to_mouse_ctrl(0xF4);
17297                                           ! Debug: list int = const $F4 (used reg = )
17298 4E89           B8                   00F4  mov	ax,#$F4
17299 4E8C           50                         push	ax
17300                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17301 4E8D           E8         1079            call	_send_to_mouse_ctrl
17302 4E90           44                         inc	sp
17303 4E91           44                         inc	sp
17304                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17305 4E92           8846         F5            mov	-$B[bp],al
17306                                           !BCC_EOS
17307                                           ! 2784               if (ret == 0) {
17308                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17309 4E95           8A46         F5            mov	al,-$B[bp]
17310 4E98           84C0                       test	al,al
17311 4E9A           75           2E            jne 	.394
17312                       00004E9C            .395:
17313                                           ! 2785                 ret = get_mouse_data(&mouse_data1);
17314                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17315 4E9C           8D5E         F4            lea	bx,-$C[bp]
17316 4E9F           53                         push	bx
17317                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17318 4EA0           E8         10B0            call	_get_mouse_data
17319 4EA3           44                         inc	sp
17320 4EA4           44                         inc	sp
17321                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17322 4EA5           8846         F5            mov	-$B[bp],al
17323                                           !BCC_EOS
17324                                           ! 2786                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
17325                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17326 4EA8           8A46         F5            mov	al,-$B[bp]
17327 4EAB           84C0                       test	al,al
17328 4EAD           75           1B            jne 	.396
17329                       00004EAF            .398:
17330                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17331 4EAF           8A46         F4            mov	al,-$C[bp]
17332 4EB2           3C                     FA  cmp	al,#$FA
17333 4EB4           75           14            jne 	.396
17334                       00004EB6            .397:
17335                                           ! 2787                   enable_mouse_int_and_events();
17336                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17337 4EB6           E8         0FAC            call	_enable_mouse_int_and_events
17338                                           !BCC_EOS
17339                                           ! 2788                   FLAGS &= 0xfffe;
17340                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17341 4EB9           8B46         18            mov	ax,$18[bp]
17342 4EBC           24                     FE  and	al,#$FE
17343 4EBE           8946         18            mov	$18[bp],ax
17344                                           !BCC_EOS
17345                                           ! 2789                   regs.u.r8.ah = 0;
17346                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17347 4EC1           30C0                       xor	al,al
17348 4EC3           8846         13            mov	$13[bp],al
17349                                           !BCC_EOS
17350                                           ! 2790                   return;
17351 4EC6           89EC                       mov	sp,bp
17352 4EC8           5D                         pop	bp
17353 4EC9           C3                         ret
17354                                           !BCC_EOS
17355                                           ! 2791                   }
17356                                           ! 2792                 }
17357                       00004ECA            .396:
17358                                           ! 2793               FLAGS |= 0x0001;
17359                       00004ECA            .394:
17360                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17361 4ECA           8B46         18            mov	ax,$18[bp]
17362 4ECD           0C                     01  or	al,*1
17363 4ECF           8946         18            mov	$18[bp],ax
17364                                           !BCC_EOS
17365                                           ! 2794               regs.u.r8.ah = ret;
17366                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17367 4ED2           8A46         F5            mov	al,-$B[bp]
17368 4ED5           8846         13            mov	$13[bp],al
17369                                           !BCC_EOS
17370                                           ! 2795               return;
17371 4ED8           89EC                       mov	sp,bp
17372 4EDA           5D                         pop	bp
17373 4EDB           C3                         ret
17374                                           !BCC_EOS
17375                                           ! 2796             default:
17376                                           ! 2797               ;
17377                       00004EDC            .399:
17378                                           !BCC_EOS
17379                                           ! 2798               FLAGS |= 0x0001;
17380                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17381 4EDC           8B46         18            mov	ax,$18[bp]
17382 4EDF           0C                     01  or	al,*1
17383 4EE1           8946         18            mov	$18[bp],ax
17384                                           !BCC_EOS
17385                                           ! 2799               regs.u.r8.ah = 1;
17386                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
17387 4EE4           B0                     01  mov	al,*1
17388 4EE6           8846         13            mov	$13[bp],al
17389                                           !BCC_EOS
17390                                           ! 2800               return;
17391 4EE9           89EC                       mov	sp,bp
17392 4EEB           5D                         pop	bp
17393 4EEC           C3                         ret
17394                                           !BCC_EOS
17395                                           ! 2801             }
17396                                           ! 2802           break;
17397 4EED           EB           0E            jmp .388
17398                       00004EEF            .38A:
17399 4EEF           2C                     00  sub	al,*0
17400 4EF1         0F84         FF11            beq 	.38B
17401 4EF5           2C                     01  sub	al,*1
17402 4EF7         0F84         FF61            beq 	.391
17403 4EFB           EB           DF            jmp	.399
17404                       00004EFD            .388:
17405 4EFD           E9         0523            br 	.384
17406                                           !BCC_EOS
17407                                           ! 2803         case 1:
17408                                           ! 2804         case 5:
17409                       00004F00            .39A:
17410                                           ! 2805 ;
17411                       00004F00            .39B:
17412                                           !BCC_EOS
17413                                           ! 2806           if (regs.u.r8.al == 5) {
17414                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
17415 4F00           8A46         12            mov	al,$12[bp]
17416 4F03           3C                     05  cmp	al,*5
17417 4F05           75           5E            jne 	.39C
17418                       00004F07            .39D:
17419                                           ! 2807             if (regs.u.r8.bh != 3) {
17420                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
17421 4F07           8A46         0D            mov	al,$D[bp]
17422 4F0A           3C                     03  cmp	al,*3
17423 4F0C           74           11            je  	.39E
17424                       00004F0E            .39F:
17425                                           ! 2808               FLAGS |= 0x0001;
17426                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17427 4F0E           8B46         18            mov	ax,$18[bp]
17428 4F11           0C                     01  or	al,*1
17429 4F13           8946         18            mov	$18[bp],ax
17430                                           !BCC_EOS
17431                                           ! 2809               regs.u.r8.ah = 0x02;
17432                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
17433 4F16           B0                     02  mov	al,*2
17434 4F18           8846         13            mov	$13[bp],al
17435                                           !BCC_EOS
17436                                           ! 2810               return;
17437 4F1B           89EC                       mov	sp,bp
17438 4F1D           5D                         pop	bp
17439 4F1E           C3                         ret
17440                                           !BCC_EOS
17441                                           ! 2811             }
17442                                           ! 2812             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17443                       00004F1F            .39E:
17444                                           ! Debug: list int = const $27 (used reg = )
17445 4F1F           B8                   0027  mov	ax,*$27
17446 4F22           50                         push	ax
17447                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17448 4F23           FF76         FE            push	-2[bp]
17449                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17450 4F26           E8         B6CB            call	_read_byte
17451 4F29           83C4                   04  add	sp,*4
17452                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17453 4F2C           8846         FC            mov	-4[bp],al
17454                                           !BCC_EOS
17455                                           ! 2813             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
17456                                           ! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17457 4F2F           8A46         FC            mov	al,-4[bp]
17458 4F32           30C0                       xor	al,al
17459                                           ! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
17460 4F34           0A46         0D            or	al,$D[bp]
17461                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17462 4F37           8846         FC            mov	-4[bp],al
17463                                           !BCC_EOS
17464                                           ! 2814             mouse_flags_1 = 0x00;
17465                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17466 4F3A           30C0                       xor	al,al
17467 4F3C           8846         FD            mov	-3[bp],al
17468                                           !BCC_EOS
17469                                           ! 2815             write_byte(ebda_seg, 0x0026, mouse_flags_1);
17470                                           ! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17471 4F3F           8A46         FD            mov	al,-3[bp]
17472 4F42           30E4                       xor	ah,ah
17473 4F44           50                         push	ax
17474                                           ! Debug: list int = const $26 (used reg = )
17475 4F45           B8                   0026  mov	ax,*$26
17476 4F48           50                         push	ax
17477                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17478 4F49           FF76         FE            push	-2[bp]
17479                                           ! Debug: func () void = write_byte+0 (used reg = )
17480 4F4C           E8         B6CB            call	_write_byte
17481 4F4F           83C4                   06  add	sp,*6
17482                                           !BCC_EOS
17483                                           ! 2816             write_byte(ebda_seg, 0x0027, mouse_flags_2);
17484                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17485 4F52           8A46         FC            mov	al,-4[bp]
17486 4F55           30E4                       xor	ah,ah
17487 4F57           50                         push	ax
17488                                           ! Debug: list int = const $27 (used reg = )
17489 4F58           B8                   0027  mov	ax,*$27
17490 4F5B           50                         push	ax
17491                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17492 4F5C           FF76         FE            push	-2[bp]
17493                                           ! Debug: func () void = write_byte+0 (used reg = )
17494 4F5F           E8         B6B8            call	_write_byte
17495 4F62           83C4                   06  add	sp,*6
17496                                           !BCC_EOS
17497                                           ! 2817           }
17498                                           ! 2818           inhibit_mouse_int_and_events();
17499                       00004F65            .39C:
17500                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17501 4F65           E8         0E50            call	_inhibit_mouse_int_and_events
17502                                           !BCC_EOS
17503                                           ! 2819           ret = send_to_mouse_ctrl(0xFF);
17504                                           ! Debug: list int = const $FF (used reg = )
17505 4F68           B8                   00FF  mov	ax,#$FF
17506 4F6B           50                         push	ax
17507                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17508 4F6C           E8         0F9A            call	_send_to_mouse_ctrl
17509 4F6F           44                         inc	sp
17510 4F70           44                         inc	sp
17511                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17512 4F71           8846         F5            mov	-$B[bp],al
17513                                           !BCC_EOS
17514                                           ! 2820           if (ret == 0) {
17515                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17516 4F74           8A46         F5            mov	al,-$B[bp]
17517 4F77           84C0                       test	al,al
17518 4F79         0F85         0087            bne 	.3A0
17519                       00004F7D            .3A1:
17520                                           ! 2821             ret = get_mouse_data(&mouse_data3);
17521                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
17522 4F7D           8D5E         F2            lea	bx,-$E[bp]
17523 4F80           53                         push	bx
17524                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17525 4F81           E8         0FCF            call	_get_mouse_data
17526 4F84           44                         inc	sp
17527 4F85           44                         inc	sp
17528                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17529 4F86           8846         F5            mov	-$B[bp],al
17530                                           !BCC_EOS
17531                                           ! 2822             if (mouse_data3 == 0xfe) {
17532                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17533 4F89           8A46         F2            mov	al,-$E[bp]
17534 4F8C           3C                     FE  cmp	al,#$FE
17535 4F8E           75           0C            jne 	.3A2
17536                       00004F90            .3A3:
17537                                           ! 2823               FLAGS |= 0x0001;
17538                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17539 4F90           8B46         18            mov	ax,$18[bp]
17540 4F93           0C                     01  or	al,*1
17541 4F95           8946         18            mov	$18[bp],ax
17542                                           !BCC_EOS
17543                                           ! 2824               return;
17544 4F98           89EC                       mov	sp,bp
17545 4F9A           5D                         pop	bp
17546 4F9B           C3                         ret
17547                                           !BCC_EOS
17548                                           ! 2825             }
17549                                           ! 2826             if (mouse_data3 != 0xfa)
17550                       00004F9C            .3A2:
17551                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17552 4F9C           8A46         F2            mov	al,-$E[bp]
17553 4F9F           3C                     FA  cmp	al,#$FA
17554 4FA1           74           14            je  	.3A4
17555                       00004FA3            .3A5:
17556                                           ! 2827               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
17557                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17558 4FA3           8A46         F2            mov	al,-$E[bp]
17559 4FA6           30E4                       xor	ah,ah
17560 4FA8           50                         push	ax
17561                                           ! Debug: list * char = .3A6+0 (used reg = )
17562 4FA9           BB                   D29E  mov	bx,#.3A6
17563 4FAC           53                         push	bx
17564                                           ! Debug: list int = const 7 (used reg = )
17565 4FAD           B8                   0007  mov	ax,*7
17566 4FB0           50                         push	ax
17567                                           ! Debug: func () void = bios_printf+0 (used reg = )
17568 4FB1           E8         BA67            call	_bios_printf
17569 4FB4           83C4                   06  add	sp,*6
17570                                           !BCC_EOS
17571                                           ! 2828             if ( ret == 0 ) {
17572                       00004FB7            .3A4:
17573                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17574 4FB7           8A46         F5            mov	al,-$B[bp]
17575 4FBA           84C0                       test	al,al
17576 4FBC           75           46            jne 	.3A7
17577                       00004FBE            .3A8:
17578                                           ! 2829               ret = get_mouse_data(&mouse_data1);
17579                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17580 4FBE           8D5E         F4            lea	bx,-$C[bp]
17581 4FC1           53                         push	bx
17582                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17583 4FC2           E8         0F8E            call	_get_mouse_data
17584 4FC5           44                         inc	sp
17585 4FC6           44                         inc	sp
17586                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17587 4FC7           8846         F5            mov	-$B[bp],al
17588                                           !BCC_EOS
17589                                           ! 2830               if ( ret == 0 ) {
17590                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17591 4FCA           8A46         F5            mov	al,-$B[bp]
17592 4FCD           84C0                       test	al,al
17593 4FCF           75           33            jne 	.3A9
17594                       00004FD1            .3AA:
17595                                           ! 2831                 ret = get_mouse_data(&mouse_data2);
17596                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17597 4FD1           8D5E         F3            lea	bx,-$D[bp]
17598 4FD4           53                         push	bx
17599                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17600 4FD5           E8         0F7B            call	_get_mouse_data
17601 4FD8           44                         inc	sp
17602 4FD9           44                         inc	sp
17603                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17604 4FDA           8846         F5            mov	-$B[bp],al
17605                                           !BCC_EOS
17606                                           ! 2832                 if ( ret == 0 ) {
17607                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17608 4FDD           8A46         F5            mov	al,-$B[bp]
17609 4FE0           84C0                       test	al,al
17610 4FE2           75           20            jne 	.3AB
17611                       00004FE4            .3AC:
17612                                           ! 2833                   enable_mouse_int_and_even
17613                                           ! 2833 ts();
17614                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17615 4FE4           E8         0E7E            call	_enable_mouse_int_and_events
17616                                           !BCC_EOS
17617                                           ! 2834                   FLAGS &= 0xfffe;
17618                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17619 4FE7           8B46         18            mov	ax,$18[bp]
17620 4FEA           24                     FE  and	al,#$FE
17621 4FEC           8946         18            mov	$18[bp],ax
17622                                           !BCC_EOS
17623                                           ! 2835                   regs.u.r8.ah = 0;
17624                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17625 4FEF           30C0                       xor	al,al
17626 4FF1           8846         13            mov	$13[bp],al
17627                                           !BCC_EOS
17628                                           ! 2836                   regs.u.r8.bl = mouse_data1;
17629                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
17630 4FF4           8A46         F4            mov	al,-$C[bp]
17631 4FF7           8846         0C            mov	$C[bp],al
17632                                           !BCC_EOS
17633                                           ! 2837                   regs.u.r8.bh = mouse_data2;
17634                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
17635 4FFA           8A46         F3            mov	al,-$D[bp]
17636 4FFD           8846         0D            mov	$D[bp],al
17637                                           !BCC_EOS
17638                                           ! 2838                   return;
17639 5000           89EC                       mov	sp,bp
17640 5002           5D                         pop	bp
17641 5003           C3                         ret
17642                                           !BCC_EOS
17643                                           ! 2839                   }
17644                                           ! 2840                 }
17645                       00005004            .3AB:
17646                                           ! 2841               }
17647                       00005004            .3A9:
17648                                           ! 2842             }
17649                       00005004            .3A7:
17650                                           ! 2843           FLAGS |= 0x0001;
17651                       00005004            .3A0:
17652                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17653 5004           8B46         18            mov	ax,$18[bp]
17654 5007           0C                     01  or	al,*1
17655 5009           8946         18            mov	$18[bp],ax
17656                                           !BCC_EOS
17657                                           ! 2844           regs.u.r8.ah = ret;
17658                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17659 500C           8A46         F5            mov	al,-$B[bp]
17660 500F           8846         13            mov	$13[bp],al
17661                                           !BCC_EOS
17662                                           ! 2845           return;
17663 5012           89EC                       mov	sp,bp
17664 5014           5D                         pop	bp
17665 5015           C3                         ret
17666                                           !BCC_EOS
17667                                           ! 2846         case 2:
17668                                           ! 2847 ;
17669                       00005016            .3AD:
17670                                           !BCC_EOS
17671                                           ! 2848           switch (regs.u.r8.bh) {
17672 5016           8A46         0D            mov	al,$D[bp]
17673 5019           EB           38            jmp .3B0
17674                                           ! 2849             case 0: mouse_data1 = 10; break;
17675                       0000501B            .3B1:
17676                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17677 501B           B0                     0A  mov	al,*$A
17678 501D           8846         F4            mov	-$C[bp],al
17679                                           !BCC_EOS
17680 5020           EB           54            jmp .3AE
17681                                           !BCC_EOS
17682                                           ! 2850             case 1: mouse_data1 = 20; break;
17683                       00005022            .3B2:
17684                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17685 5022           B0                     14  mov	al,*$14
17686 5024           8846         F4            mov	-$C[bp],al
17687                                           !BCC_EOS
17688 5027           EB           4D            jmp .3AE
17689                                           !BCC_EOS
17690                                           ! 2851             case 2: mouse_data1 = 40; break;
17691                       00005029            .3B3:
17692                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17693 5029           B0                     28  mov	al,*$28
17694 502B           8846         F4            mov	-$C[bp],al
17695                                           !BCC_EOS
17696 502E           EB           46            jmp .3AE
17697                                           !BCC_EOS
17698                                           ! 2852             case 3: mouse_data1 = 60; break;
17699                       00005030            .3B4:
17700                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17701 5030           B0                     3C  mov	al,*$3C
17702 5032           8846         F4            mov	-$C[bp],al
17703                                           !BCC_EOS
17704 5035           EB           3F            jmp .3AE
17705                                           !BCC_EOS
17706                                           ! 2853             case 4: mouse_data1 = 80; break;
17707                       00005037            .3B5:
17708                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17709 5037           B0                     50  mov	al,*$50
17710 5039           8846         F4            mov	-$C[bp],al
17711                                           !BCC_EOS
17712 503C           EB           38            jmp .3AE
17713                                           !BCC_EOS
17714                                           ! 2854             case 5: mouse_data1 = 100; break;
17715                       0000503E            .3B6:
17716                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17717 503E           B0                     64  mov	al,*$64
17718 5040           8846         F4            mov	-$C[bp],al
17719                                           !BCC_EOS
17720 5043           EB           31            jmp .3AE
17721                                           !BCC_EOS
17722                                           ! 2855             case 6: mouse_data1 = 200; break;
17723                       00005045            .3B7:
17724                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17725 5045           B0                     C8  mov	al,#$C8
17726 5047           8846         F4            mov	-$C[bp],al
17727                                           !BCC_EOS
17728 504A           EB           2A            jmp .3AE
17729                                           !BCC_EOS
17730                                           ! 2856             default: mouse_data1 = 0;
17731                       0000504C            .3B8:
17732                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17733 504C           30C0                       xor	al,al
17734 504E           8846         F4            mov	-$C[bp],al
17735                                           !BCC_EOS
17736                                           ! 2857           }
17737                                           ! 2858           if (mouse_data1 > 0) {
17738 5051           EB           23            jmp .3AE
17739                       00005053            .3B0:
17740 5053           2C                     00  sub	al,*0
17741 5055           72           F5            jb 	.3B8
17742 5057           3C                     06  cmp	al,*6
17743 5059           77           19            ja  	.3B9
17744 505B           30E4                       xor	ah,ah
17745 505D           D1E0                       shl	ax,*1
17746 505F           89C3                       mov	bx,ax
17747 5061           2E                         seg	cs
17748 5062           FFA7       5066            br	.3BA[bx]
17749                       00005066            .3BA:
17750 5066                      501B            .word	.3B1
17751 5068                      5022            .word	.3B2
17752 506A                      5029            .word	.3B3
17753 506C                      5030            .word	.3B4
17754 506E                      5037            .word	.3B5
17755 5070                      503E            .word	.3B6
17756 5072                      5045            .word	.3B7
17757                       00005074            .3B9:
17758 5074           EB           D6            jmp	.3B8
17759                       00005076            .3AE:
17760                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17761 5076           8A46         F4            mov	al,-$C[bp]
17762 5079           84C0                       test	al,al
17763 507B           74           57            je  	.3BB
17764                       0000507D            .3BC:
17765                                           ! 2859             ret = send_to_mouse_ctrl(0xF3);
17766                                           ! Debug: list int = const $F3 (used reg = )
17767 507D           B8                   00F3  mov	ax,#$F3
17768 5080           50                         push	ax
17769                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17770 5081           E8         0E85            call	_send_to_mouse_ctrl
17771 5084           44                         inc	sp
17772 5085           44                         inc	sp
17773                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17774 5086           8846         F5            mov	-$B[bp],al
17775                                           !BCC_EOS
17776                                           ! 2860             if (ret == 0) {
17777                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17778 5089           8A46         F5            mov	al,-$B[bp]
17779 508C           84C0                       test	al,al
17780 508E           75           35            jne 	.3BD
17781                       00005090            .3BE:
17782                                           ! 2861               ret = get_mouse_data(&mouse_data2);
17783                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17784 5090           8D5E         F3            lea	bx,-$D[bp]
17785 5093           53                         push	bx
17786                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17787 5094           E8         0EBC            call	_get_mouse_data
17788 5097           44                         inc	sp
17789 5098           44                         inc	sp
17790                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17791 5099           8846         F5            mov	-$B[bp],al
17792                                           !BCC_EOS
17793                                           ! 2862               ret = send_to_mouse_ctrl(mouse_data1);
17794                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17795 509C           8A46         F4            mov	al,-$C[bp]
17796 509F           30E4                       xor	ah,ah
17797 50A1           50                         push	ax
17798                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17799 50A2           E8         0E64            call	_send_to_mouse_ctrl
17800 50A5           44                         inc	sp
17801 50A6           44                         inc	sp
17802                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17803 50A7           8846         F5            mov	-$B[bp],al
17804                                           !BCC_EOS
17805                                           ! 2863               ret = get_mouse_data(&mouse_data2);
17806                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17807 50AA           8D5E         F3            lea	bx,-$D[bp]
17808 50AD           53                         push	bx
17809                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17810 50AE           E8         0EA2            call	_get_mouse_data
17811 50B1           44                         inc	sp
17812 50B2           44                         inc	sp
17813                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17814 50B3           8846         F5            mov	-$B[bp],al
17815                                           !BCC_EOS
17816                                           ! 2864               FLAGS &= 0xfffe;
17817                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17818 50B6           8B46         18            mov	ax,$18[bp]
17819 50B9           24                     FE  and	al,#$FE
17820 50BB           8946         18            mov	$18[bp],ax
17821                                           !BCC_EOS
17822                                           ! 2865               regs.u.r8.ah = 0;
17823                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17824 50BE           30C0                       xor	al,al
17825 50C0           8846         13            mov	$13[bp],al
17826                                           !BCC_EOS
17827                                           ! 2866             } else {
17828 50C3           EB           0D            jmp .3BF
17829                       000050C5            .3BD:
17830                                           ! 2867               FLAGS |= 0x0001;
17831                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17832 50C5           8B46         18            mov	ax,$18[bp]
17833 50C8           0C                     01  or	al,*1
17834 50CA           8946         18            mov	$18[bp],ax
17835                                           !BCC_EOS
17836                                           ! 2868               regs.u.r8.ah = 0x86;
17837                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17838 50CD           B0                     86  mov	al,#$86
17839 50CF           8846         13            mov	$13[bp],al
17840                                           !BCC_EOS
17841                                           ! 2869             }
17842                                           ! 2870           } else {
17843                       000050D2            .3BF:
17844 50D2           EB           0D            jmp .3C0
17845                       000050D4            .3BB:
17846                                           ! 2871             FLAGS |= 0x0001;
17847                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17848 50D4           8B46         18            mov	ax,$18[bp]
17849 50D7           0C                     01  or	al,*1
17850 50D9           8946         18            mov	$18[bp],ax
17851                                           !BCC_EOS
17852                                           ! 2872             regs.u.r8.ah = 0x86;
17853                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17854 50DC           B0                     86  mov	al,#$86
17855 50DE           8846         13            mov	$13[bp],al
17856                                           !BCC_EOS
17857                                           ! 2873           }
17858                                           ! 2874           break;
17859                       000050E1            .3C0:
17860 50E1           E9         033F            br 	.384
17861                                           !BCC_EOS
17862                                           ! 2875         case 3:
17863                                           ! 2876 ;
17864                       000050E4            .3C1:
17865                                           !BCC_EOS
17866                                           ! 2877           comm_byte = inhibit_mouse_int_and_events();
17867                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17868 50E4           E8         0CD1            call	_inhibit_mouse_int_and_events
17869                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
17870 50E7           8846         F7            mov	-9[bp],al
17871                                           !BCC_EOS
17872                                           ! 2878           if (regs.u.r8.bh < 4) {
17873                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
17874 50EA           8A46         0D            mov	al,$D[bp]
17875 50ED           3C                     04  cmp	al,*4
17876 50EF         0F83         008D            bhis	.3C2
17877                       000050F3            .3C3:
17878                                           ! 2879             ret = send_to_mouse_ctrl(0xE8);
17879                                           ! Debug: list int = const $E8 (used reg = )
17880 50F3           B8                   00E8  mov	ax,#$E8
17881 50F6           50                         push	ax
17882                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17883 50F7           E8         0E0F            call	_send_to_mouse_ctrl
17884 50FA           44                         inc	sp
17885 50FB           44                         inc	sp
17886                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17887 50FC           8846         F5            mov	-$B[bp],al
17888                                           !BCC_EOS
17889                                           ! 2880             if (ret == 0) {
17890                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17891 50FF           8A46         F5            mov	al,-$B[bp]
17892 5102           84C0                       test	al,al
17893 5104           75           6B            jne 	.3C4
17894                       00005106            .3C5:
17895                                           ! 2881               ret = get_mouse_data(&mouse_data1);
17896                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17897 5106           8D5E         F4            lea	bx,-$C[bp]
17898 5109           53                         push	bx
17899                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17900 510A           E8         0E46            call	_get_mouse_data
17901 510D           44                         inc	sp
17902 510E           44                         inc	sp
17903                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17904 510F           8846         F5            mov	-$B[bp],al
17905                                           !BCC_EOS
17906                                           ! 2882               if (mouse_data1 != 0xfa)
17907                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17908 5112           8A46         F4            mov	al,-$C[bp]
17909 5115           3C                     FA  cmp	al,#$FA
17910 5117           74           14            je  	.3C6
17911                       00005119            .3C7:
17912                                           ! 2883                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
17913                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17914 5119           8A46         F4            mov	al,-$C[bp]
17915 511C           30E4                       xor	ah,ah
17916 511E           50                         push	ax
17917                                           ! Debug: list * char = .3C8+0 (used reg = )
17918 511F           BB                   D272  mov	bx,#.3C8
17919 5122           53                         push	bx
17920                                           ! Debug: list int = const 7 (used reg = )
17921 5123           B8                   0007  mov	ax,*7
17922 5126           50                         push	ax
17923                                           ! Debug: func () void = bios_printf+0 (used reg = )
17924 5127           E8         B8F1            call	_bios_printf
17925 512A           83C4                   06  add	sp,*6
17926                                           !BCC_EOS
17927                                           ! 2884               ret = send_to_mouse_ctrl(regs.u.r8.bh);
17928                       0000512D            .3C6:
17929                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
17930 512D           8A46         0D            mov	al,$D[bp]
17931 5130           30E4                       xor	ah,ah
17932 5132           50                         push	ax
17933                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17934 5133           E8         0DD3            call	_send_to_mouse_ctrl
17935 5136           44                         inc	sp
17936 5137           44                         inc	sp
17937                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17938 5138           8846         F5            mov	-$B[bp],al
17939                                           !BCC_EOS
17940                                           ! 2885               ret = get_mouse_data(&mouse_data1);
17941                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17942 513B           8D5E         F4            lea	bx,-$C[bp]
17943 513E           53                         push	bx
17944                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17945 513F           E8         0E11            call	_get_mouse_data
17946 5142           44                         inc	sp
17947 5143           44                         inc	sp
17948                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17949 5144           8846         F5            mov	-$B[bp],al
17950                                           !BCC_EOS
17951                                           ! 2886               if (mouse_data1 != 0xfa)
17952                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17953 5147           8A46         F4            mov	al,-$C[bp]
17954 514A           3C                     FA  cmp	al,#$FA
17955 514C           74           14            je  	.3C9
17956                       0000514E            .3CA:
17957                                           ! 2887                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
17958                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17959 514E           8A46         F4            mov	al,-$C[bp]
17960 5151           30E4                       xor	ah,ah
17961 5153           50                         push	ax
17962                                           ! Debug: list * char = .3CB+0 (used reg = )
17963 5154           BB                   D246  mov	bx,#.3CB
17964 5157           53                         push	bx
17965                                           ! Debug: list int = const 7 (used reg = )
17966 5158           B8                   0007  mov	ax,*7
17967 515B           50                         push	ax
17968                                           ! Debug: func () void = bios_printf+0 (used reg = )
17969 515C           E8         B8BC            call	_bios_printf
17970 515F           83C4                   06  add	sp,*6
17971                                           !BCC_EOS
17972                                           ! 2888               FLAGS &= 0xfffe;
17973                       00005162            .3C9:
17974                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17975 5162           8B46         18            mov	ax,$18[bp]
17976 5165           24                     FE  and	al,#$FE
17977 5167           8946         18            mov	$18[bp],ax
17978                                           !BCC_EOS
17979                                           ! 2889               regs.u.r8.ah = 0;
17980                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17981 516A           30C0                       xor	al,al
17982 516C           8846         13            mov	$13[bp],al
17983                                           !BCC_EOS
17984                                           ! 2890             } else {
17985 516F           EB           0D            jmp .3CC
17986                       00005171            .3C4:
17987                                           ! 2891               FLAGS |= 0x0001;
17988                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17989 5171           8B46         18            mov	ax,$18[bp]
17990 5174           0C                     01  or	al,*1
17991 5176           8946         18            mov	$18[bp],ax
17992                                           !BCC_EOS
17993                                           ! 2892         
17994                                           ! 2892       regs.u.r8.ah = 0x86;
17995                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17996 5179           B0                     86  mov	al,#$86
17997 517B           8846         13            mov	$13[bp],al
17998                                           !BCC_EOS
17999                                           ! 2893             }
18000                                           ! 2894           } else {
18001                       0000517E            .3CC:
18002 517E           EB           0D            jmp .3CD
18003                       00005180            .3C2:
18004                                           ! 2895             FLAGS |= 0x0001;
18005                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18006 5180           8B46         18            mov	ax,$18[bp]
18007 5183           0C                     01  or	al,*1
18008 5185           8946         18            mov	$18[bp],ax
18009                                           !BCC_EOS
18010                                           ! 2896             regs.u.r8.ah = 0x86;
18011                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18012 5188           B0                     86  mov	al,#$86
18013 518A           8846         13            mov	$13[bp],al
18014                                           !BCC_EOS
18015                                           ! 2897           }
18016                                           ! 2898           set_kbd_command_byte(comm_byte);
18017                       0000518D            .3CD:
18018                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18019 518D           8A46         F7            mov	al,-9[bp]
18020 5190           30E4                       xor	ah,ah
18021 5192           50                         push	ax
18022                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18023 5193           E8         0DFE            call	_set_kbd_command_byte
18024 5196           44                         inc	sp
18025 5197           44                         inc	sp
18026                                           !BCC_EOS
18027                                           ! 2899           break;
18028 5198           E9         0288            br 	.384
18029                                           !BCC_EOS
18030                                           ! 2900         case 4:
18031                                           ! 2901 ;
18032                       0000519B            .3CE:
18033                                           !BCC_EOS
18034                                           ! 2902           inhibit_mouse_int_and_events();
18035                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18036 519B           E8         0C1A            call	_inhibit_mouse_int_and_events
18037                                           !BCC_EOS
18038                                           ! 2903           ret = send_to_mouse_ctrl(0xF2);
18039                                           ! Debug: list int = const $F2 (used reg = )
18040 519E           B8                   00F2  mov	ax,#$F2
18041 51A1           50                         push	ax
18042                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18043 51A2           E8         0D64            call	_send_to_mouse_ctrl
18044 51A5           44                         inc	sp
18045 51A6           44                         inc	sp
18046                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18047 51A7           8846         F5            mov	-$B[bp],al
18048                                           !BCC_EOS
18049                                           ! 2904           if (ret == 0) {
18050                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18051 51AA           8A46         F5            mov	al,-$B[bp]
18052 51AD           84C0                       test	al,al
18053 51AF           75           2D            jne 	.3CF
18054                       000051B1            .3D0:
18055                                           ! 2905             ret = get_mouse_data(&mouse_data1);
18056                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18057 51B1           8D5E         F4            lea	bx,-$C[bp]
18058 51B4           53                         push	bx
18059                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18060 51B5           E8         0D9B            call	_get_mouse_data
18061 51B8           44                         inc	sp
18062 51B9           44                         inc	sp
18063                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18064 51BA           8846         F5            mov	-$B[bp],al
18065                                           !BCC_EOS
18066                                           ! 2906             ret = get_mouse_data(&mouse_data2);
18067                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18068 51BD           8D5E         F3            lea	bx,-$D[bp]
18069 51C0           53                         push	bx
18070                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18071 51C1           E8         0D8F            call	_get_mouse_data
18072 51C4           44                         inc	sp
18073 51C5           44                         inc	sp
18074                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18075 51C6           8846         F5            mov	-$B[bp],al
18076                                           !BCC_EOS
18077                                           ! 2907             FLAGS &= 0xfffe;
18078                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18079 51C9           8B46         18            mov	ax,$18[bp]
18080 51CC           24                     FE  and	al,#$FE
18081 51CE           8946         18            mov	$18[bp],ax
18082                                           !BCC_EOS
18083                                           ! 2908             regs.u.r8.ah = 0;
18084                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18085 51D1           30C0                       xor	al,al
18086 51D3           8846         13            mov	$13[bp],al
18087                                           !BCC_EOS
18088                                           ! 2909             regs.u.r8.bh = mouse_data2;
18089                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
18090 51D6           8A46         F3            mov	al,-$D[bp]
18091 51D9           8846         0D            mov	$D[bp],al
18092                                           !BCC_EOS
18093                                           ! 2910           } else {
18094 51DC           EB           0D            jmp .3D1
18095                       000051DE            .3CF:
18096                                           ! 2911             FLAGS |= 0x0001;
18097                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18098 51DE           8B46         18            mov	ax,$18[bp]
18099 51E1           0C                     01  or	al,*1
18100 51E3           8946         18            mov	$18[bp],ax
18101                                           !BCC_EOS
18102                                           ! 2912             regs.u.r8.ah = 0x86;
18103                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18104 51E6           B0                     86  mov	al,#$86
18105 51E8           8846         13            mov	$13[bp],al
18106                                           !BCC_EOS
18107                                           ! 2913           }
18108                                           ! 2914           break;
18109                       000051EB            .3D1:
18110 51EB           E9         0235            br 	.384
18111                                           !BCC_EOS
18112                                           ! 2915         case 6:
18113                                           ! 2916 ;
18114                       000051EE            .3D2:
18115                                           !BCC_EOS
18116                                           ! 2917           switch (regs.u.r8.bh) {
18117 51EE           8A46         0D            mov	al,$D[bp]
18118 51F1           E9         015A            br 	.3D5
18119                                           ! 2918             case 0:
18120                                           ! 2919               comm_byte = inhibit_mouse_int_and_events();
18121                       000051F4            .3D6:
18122                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18123 51F4           E8         0BC1            call	_inhibit_mouse_int_and_events
18124                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18125 51F7           8846         F7            mov	-9[bp],al
18126                                           !BCC_EOS
18127                                           ! 2920               ret = send_to_mouse_ctrl(0xE9);
18128                                           ! Debug: list int = const $E9 (used reg = )
18129 51FA           B8                   00E9  mov	ax,#$E9
18130 51FD           50                         push	ax
18131                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18132 51FE           E8         0D08            call	_send_to_mouse_ctrl
18133 5201           44                         inc	sp
18134 5202           44                         inc	sp
18135                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18136 5203           8846         F5            mov	-$B[bp],al
18137                                           !BCC_EOS
18138                                           ! 2921               if (ret == 0) {
18139                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18140 5206           8A46         F5            mov	al,-$B[bp]
18141 5209           84C0                       test	al,al
18142 520B         0F85         0095            bne 	.3D7
18143                       0000520F            .3D8:
18144                                           ! 2922                 ret = get_mouse_data(&mouse_data1);
18145                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18146 520F           8D5E         F4            lea	bx,-$C[bp]
18147 5212           53                         push	bx
18148                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18149 5213           E8         0D3D            call	_get_mouse_data
18150 5216           44                         inc	sp
18151 5217           44                         inc	sp
18152                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18153 5218           8846         F5            mov	-$B[bp],al
18154                                           !BCC_EOS
18155                                           ! 2923                 if (mouse_data1 != 0xfa)
18156                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18157 521B           8A46         F4            mov	al,-$C[bp]
18158 521E           3C                     FA  cmp	al,#$FA
18159 5220           74           14            je  	.3D9
18160                       00005222            .3DA:
18161                                           ! 2924                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18162                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18163 5222           8A46         F4            mov	al,-$C[bp]
18164 5225           30E4                       xor	ah,ah
18165 5227           50                         push	ax
18166                                           ! Debug: list * char = .3DB+0 (used reg = )
18167 5228           BB                   D21A  mov	bx,#.3DB
18168 522B           53                         push	bx
18169                                           ! Debug: list int = const 7 (used reg = )
18170 522C           B8                   0007  mov	ax,*7
18171 522F           50                         push	ax
18172                                           ! Debug: func () void = bios_printf+0 (used reg = )
18173 5230           E8         B7E8            call	_bios_printf
18174 5233           83C4                   06  add	sp,*6
18175                                           !BCC_EOS
18176                                           ! 2925                 if (ret == 0) {
18177                       00005236            .3D9:
18178                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18179 5236           8A46         F5            mov	al,-$B[bp]
18180 5239           84C0                       test	al,al
18181 523B           75           67            jne 	.3DC
18182                       0000523D            .3DD:
18183                                           ! 2926                   ret = get_mouse_data(&mouse_data1);
18184                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18185 523D           8D5E         F4            lea	bx,-$C[bp]
18186 5240           53                         push	bx
18187                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18188 5241           E8         0D0F            call	_get_mouse_data
18189 5244           44                         inc	sp
18190 5245           44                         inc	sp
18191                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18192 5246           8846         F5            mov	-$B[bp],al
18193                                           !BCC_EOS
18194                                           ! 2927                   if ( ret == 0 ) {
18195                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18196 5249           8A46         F5            mov	al,-$B[bp]
18197 524C           84C0                       test	al,al
18198 524E           75           54            jne 	.3DE
18199                       00005250            .3DF:
18200                                           ! 2928                     ret = get_mouse_data(&mouse_data2);
18201                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18202 5250           8D5E         F3            lea	bx,-$D[bp]
18203 5253           53                         push	bx
18204                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18205 5254           E8         0CFC            call	_get_mouse_data
18206 5257           44                         inc	sp
18207 5258           44                         inc	sp
18208                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18209 5259           8846         F5            mov	-$B[bp],al
18210                                           !BCC_EOS
18211                                           ! 2929                     if ( ret == 0 ) {
18212                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18213 525C           8A46         F5            mov	al,-$B[bp]
18214 525F           84C0                       test	al,al
18215 5261           75           41            jne 	.3E0
18216                       00005263            .3E1:
18217                                           ! 2930                       ret = get_mouse_data(&mouse_data3);
18218                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
18219 5263           8D5E         F2            lea	bx,-$E[bp]
18220 5266           53                         push	bx
18221                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18222 5267           E8         0CE9            call	_get_mouse_data
18223 526A           44                         inc	sp
18224 526B           44                         inc	sp
18225                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18226 526C           8846         F5            mov	-$B[bp],al
18227                                           !BCC_EOS
18228                                           ! 2931                       if ( ret == 0 ) {
18229                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18230 526F           8A46         F5            mov	al,-$B[bp]
18231 5272           84C0                       test	al,al
18232 5274           75           2E            jne 	.3E2
18233                       00005276            .3E3:
18234                                           ! 2932                         FLAGS &= 0xfffe;
18235                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18236 5276           8B46         18            mov	ax,$18[bp]
18237 5279           24                     FE  and	al,#$FE
18238 527B           8946         18            mov	$18[bp],ax
18239                                           !BCC_EOS
18240                                           ! 2933                         regs.u.r8.ah = 0;
18241                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18242 527E           30C0                       xor	al,al
18243 5280           8846         13            mov	$13[bp],al
18244                                           !BCC_EOS
18245                                           ! 2934                         regs.u.r8.bl = mouse_data1;
18246                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
18247 5283           8A46         F4            mov	al,-$C[bp]
18248 5286           8846         0C            mov	$C[bp],al
18249                                           !BCC_EOS
18250                                           ! 2935                         regs.u.r8.cl = mouse_data2;
18251                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
18252 5289           8A46         F3            mov	al,-$D[bp]
18253 528C           8846         10            mov	$10[bp],al
18254                                           !BCC_EOS
18255                                           ! 2936                         regs.u.r8.dl = mouse_data3;
18256                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
18257 528F           8A46         F2            mov	al,-$E[bp]
18258 5292           8846         0E            mov	$E[bp],al
18259                                           !BCC_EOS
18260                                           ! 2937                         set_kbd_command_byte(comm_byte);
18261                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18262 5295           8A46         F7            mov	al,-9[bp]
18263 5298           30E4                       xor	ah,ah
18264 529A           50                         push	ax
18265                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18266 529B           E8         0CF6            call	_set_kbd_command_byte
18267 529E           44                         inc	sp
18268 529F           44                         inc	sp
18269                                           !BCC_EOS
18270                                           ! 2938                         return;
18271 52A0           89EC                       mov	sp,bp
18272 52A2           5D                         pop	bp
18273 52A3           C3                         ret
18274                                           !BCC_EOS
18275                                           ! 2939                         }
18276                                           ! 2940                       }
18277                       000052A4            .3E2:
18278                                           ! 2941                     }
18279                       000052A4            .3E0:
18280                                           ! 2942                   }
18281                       000052A4            .3DE:
18282                                           ! 2943                 }
18283                       000052A4            .3DC:
18284                                           ! 2944               FLAGS |= 0x0001;
18285                       000052A4            .3D7:
18286                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18287 52A4           8B46         18            mov	ax,$18[bp]
18288 52A7           0C                     01  or	al,*1
18289 52A9           8946         18            mov	$18[bp],ax
18290                                           !BCC_EOS
18291                                           ! 2945               regs.u.r8.ah = ret;
18292                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
18293 52AC           8A46         F5            mov	al,-$B[bp]
18294 52AF           8846         13            mov	$13[bp],al
18295                                           !BCC_EOS
18296                                           ! 2946               set_kbd_command_byte(comm_byte);
18297                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18298 52B2           8A46         F7            mov	al,-9[bp]
18299 52B5           30E4                       xor	ah,ah
18300 52B7           50                         push	ax
18301                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18302 52B8           E8         0CD9            call	_set_kbd_command_byte
18303 52BB           44                         inc	sp
18304 52BC           44                         inc	sp
18305                                           !BCC_EOS
18306                                           ! 2947               return;
18307 52BD           89EC                       mov	sp,bp
18308 52BF           5D                         pop	bp
18309 52C0           C3                         ret
18310                                           !BCC_EOS
18311                                           ! 2948             case 1:
18312                                           ! 2949             case 2:
18313                       000052C1            .3E4:
18314                                           ! 2950               comm_byte = inhibit_mouse_int_and_events();
18315                       000052C1            .3E5:
18316                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18317 52C1           E8         0AF4            call	_inhibit_mouse_int_and_events
18318                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18319 52C4           8846         F7            mov	-9[bp],al
18320                                           !BCC_EOS
18321                                           ! 2951               if (regs.
18322                                           ! 2951 u.r8.bh == 1) {
18323                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
18324 52C7           8A46         0D            mov	al,$D[bp]
18325 52CA           3C                     01  cmp	al,*1
18326 52CC           75           0E            jne 	.3E6
18327                       000052CE            .3E7:
18328                                           ! 2952                 ret = send_to_mouse_ctrl(0xE6);
18329                                           ! Debug: list int = const $E6 (used reg = )
18330 52CE           B8                   00E6  mov	ax,#$E6
18331 52D1           50                         push	ax
18332                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18333 52D2           E8         0C34            call	_send_to_mouse_ctrl
18334 52D5           44                         inc	sp
18335 52D6           44                         inc	sp
18336                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18337 52D7           8846         F5            mov	-$B[bp],al
18338                                           !BCC_EOS
18339                                           ! 2953               } else {
18340 52DA           EB           0C            jmp .3E8
18341                       000052DC            .3E6:
18342                                           ! 2954                 ret = send_to_mouse_ctrl(0xE7);
18343                                           ! Debug: list int = const $E7 (used reg = )
18344 52DC           B8                   00E7  mov	ax,#$E7
18345 52DF           50                         push	ax
18346                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18347 52E0           E8         0C26            call	_send_to_mouse_ctrl
18348 52E3           44                         inc	sp
18349 52E4           44                         inc	sp
18350                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18351 52E5           8846         F5            mov	-$B[bp],al
18352                                           !BCC_EOS
18353                                           ! 2955               }
18354                                           ! 2956               if (ret == 0) {
18355                       000052E8            .3E8:
18356                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18357 52E8           8A46         F5            mov	al,-$B[bp]
18358 52EB           84C0                       test	al,al
18359 52ED           75           19            jne 	.3E9
18360                       000052EF            .3EA:
18361                                           ! 2957                 get_mouse_data(&mouse_data1);
18362                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18363 52EF           8D5E         F4            lea	bx,-$C[bp]
18364 52F2           53                         push	bx
18365                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18366 52F3           E8         0C5D            call	_get_mouse_data
18367 52F6           44                         inc	sp
18368 52F7           44                         inc	sp
18369                                           !BCC_EOS
18370                                           ! 2958                 ret = (mouse_data1 != 0xFA);
18371                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18372 52F8           8A46         F4            mov	al,-$C[bp]
18373 52FB           3C                     FA  cmp	al,#$FA
18374 52FD           74           04            je 	.3EB
18375 52FF           B0                     01  mov	al,*1
18376 5301           EB           02            jmp	.3EC
18377                       00005303            .3EB:
18378 5303           30C0                       xor	al,al
18379                       00005305            .3EC:
18380                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18381 5305           8846         F5            mov	-$B[bp],al
18382                                           !BCC_EOS
18383                                           ! 2959               }
18384                                           ! 2960               if (ret == 0) {
18385                       00005308            .3E9:
18386                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18387 5308           8A46         F5            mov	al,-$B[bp]
18388 530B           84C0                       test	al,al
18389 530D           75           0F            jne 	.3ED
18390                       0000530F            .3EE:
18391                                           ! 2961                 FLAGS &= 0xfffe;
18392                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18393 530F           8B46         18            mov	ax,$18[bp]
18394 5312           24                     FE  and	al,#$FE
18395 5314           8946         18            mov	$18[bp],ax
18396                                           !BCC_EOS
18397                                           ! 2962                 regs.u.r8.ah = 0;
18398                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18399 5317           30C0                       xor	al,al
18400 5319           8846         13            mov	$13[bp],al
18401                                           !BCC_EOS
18402                                           ! 2963               } else {
18403 531C           EB           0D            jmp .3EF
18404                       0000531E            .3ED:
18405                                           ! 2964                 FLAGS |= 0x0001;
18406                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18407 531E           8B46         18            mov	ax,$18[bp]
18408 5321           0C                     01  or	al,*1
18409 5323           8946         18            mov	$18[bp],ax
18410                                           !BCC_EOS
18411                                           ! 2965                 regs.u.r8.ah = 0x86;
18412                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18413 5326           B0                     86  mov	al,#$86
18414 5328           8846         13            mov	$13[bp],al
18415                                           !BCC_EOS
18416                                           ! 2966               }
18417                                           ! 2967               set_kbd_command_byte(comm_byte);
18418                       0000532B            .3EF:
18419                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18420 532B           8A46         F7            mov	al,-9[bp]
18421 532E           30E4                       xor	ah,ah
18422 5330           50                         push	ax
18423                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18424 5331           E8         0C60            call	_set_kbd_command_byte
18425 5334           44                         inc	sp
18426 5335           44                         inc	sp
18427                                           !BCC_EOS
18428                                           ! 2968               break;
18429 5336           EB           2A            jmp .3D3
18430                                           !BCC_EOS
18431                                           ! 2969             default:
18432                                           ! 2970               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
18433                       00005338            .3F0:
18434                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18435 5338           8A46         0D            mov	al,$D[bp]
18436 533B           30E4                       xor	ah,ah
18437 533D           50                         push	ax
18438                                           ! Debug: list * char = .3F1+0 (used reg = )
18439 533E           BB                   D200  mov	bx,#.3F1
18440 5341           53                         push	bx
18441                                           ! Debug: list int = const 7 (used reg = )
18442 5342           B8                   0007  mov	ax,*7
18443 5345           50                         push	ax
18444                                           ! Debug: func () void = bios_printf+0 (used reg = )
18445 5346           E8         B6D2            call	_bios_printf
18446 5349           83C4                   06  add	sp,*6
18447                                           !BCC_EOS
18448                                           ! 2971             }
18449                                           ! 2972           break;
18450 534C           EB           14            jmp .3D3
18451                       0000534E            .3D5:
18452 534E           2C                     00  sub	al,*0
18453 5350         0F84         FEA0            beq 	.3D6
18454 5354           2C                     01  sub	al,*1
18455 5356         0F84         FF67            beq 	.3E4
18456 535A           2C                     01  sub	al,*1
18457 535C         0F84         FF61            beq 	.3E5
18458 5360           EB           D6            jmp	.3F0
18459                       00005362            .3D3:
18460 5362           E9         00BE            br 	.384
18461                                           !BCC_EOS
18462                                           ! 2973         case 7:
18463                                           ! 2974 ;
18464                       00005365            .3F2:
18465                                           !BCC_EOS
18466                                           ! 2975           mouse_driver_seg = ES;
18467                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18468 5365           8B46         14            mov	ax,$14[bp]
18469 5368           8946         FA            mov	-6[bp],ax
18470                                           !BCC_EOS
18471                                           ! 2976           mouse_driver_offset = regs.u.r16.bx;
18472                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18473 536B           8B46         0C            mov	ax,$C[bp]
18474 536E           8946         F8            mov	-8[bp],ax
18475                                           !BCC_EOS
18476                                           ! 2977           write_word(ebda_seg, 0x0022, mouse_driver_offset);
18477                                           ! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18478 5371           FF76         F8            push	-8[bp]
18479                                           ! Debug: list int = const $22 (used reg = )
18480 5374           B8                   0022  mov	ax,*$22
18481 5377           50                         push	ax
18482                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18483 5378           FF76         FE            push	-2[bp]
18484                                           ! Debug: func () void = write_word+0 (used reg = )
18485 537B           E8         B2B4            call	_write_word
18486 537E           83C4                   06  add	sp,*6
18487                                           !BCC_EOS
18488                                           ! 2978           write_word(ebda_seg, 0x0024, mouse_driver_seg);
18489                                           ! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18490 5381           FF76         FA            push	-6[bp]
18491                                           ! Debug: list int = const $24 (used reg = )
18492 5384           B8                   0024  mov	ax,*$24
18493 5387           50                         push	ax
18494                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18495 5388           FF76         FE            push	-2[bp]
18496                                           ! Debug: func () void = write_word+0 (used reg = )
18497 538B           E8         B2A4            call	_write_word
18498 538E           83C4                   06  add	sp,*6
18499                                           !BCC_EOS
18500                                           ! 2979           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
18501                                           ! Debug: list int = const $27 (used reg = )
18502 5391           B8                   0027  mov	ax,*$27
18503 5394           50                         push	ax
18504                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
18505 5395           FF76         FE            push	-2[bp]
18506                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18507 5398           E8         B259            call	_read_byte
18508 539B           83C4                   04  add	sp,*4
18509                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18510 539E           8846         FC            mov	-4[bp],al
18511                                           !BCC_EOS
18512                                           ! 2980           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
18513                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18514 53A1           8B46         F8            mov	ax,-8[bp]
18515 53A4           85C0                       test	ax,ax
18516 53A6           75           1D            jne 	.3F3
18517                       000053A8            .3F5:
18518                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18519 53A8           8B46         FA            mov	ax,-6[bp]
18520 53AB           85C0                       test	ax,ax
18521 53AD           75           16            jne 	.3F3
18522                       000053AF            .3F4:
18523                                           ! 2981             if ( (mouse_flags_2 & 0x80) != 0 ) {
18524                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18525 53AF           8A46         FC            mov	al,-4[bp]
18526 53B2           24                     80  and	al,#$80
18527                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
18528 53B4           84C0                       test	al,al
18529 53B6           74           0B            je  	.3F6
18530                       000053B8            .3F7:
18531                                           ! 2982               mouse_flags_2 &= ~0x80;
18532                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18533 53B8           8A46         FC            mov	al,-4[bp]
18534 53BB           24                     7F  and	al,*$7F
18535 53BD           8846         FC            mov	-4[bp],al
18536                                           !BCC_EOS
18537                                           ! 2983               inhibit_mouse_int_and_events();
18538                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18539 53C0           E8         09F5            call	_inhibit_mouse_int_and_events
18540                                           !BCC_EOS
18541                                           ! 2984               }
18542                                           ! 2985             }
18543                       000053C3            .3F6:
18544                                           ! 2986           else {
18545 53C3           EB           08            jmp .3F8
18546                       000053C5            .3F3:
18547                                           ! 2987             mouse_flags_2 |= 0x80;
18548                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18549 53C5           8A46         FC            mov	al,-4[bp]
18550 53C8           0C                     80  or	al,#$80
18551 53CA           8846         FC            mov	-4[bp],al
18552                                           !BCC_EOS
18553                                           ! 2988             }
18554                                           ! 2989           write_byte(ebda_seg, 0x0027, mouse_flags_2);
18555                       000053CD            .3F8:
18556                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18557 53CD           8A46         FC            mov	al,-4[bp]
18558 53D0           30E4                       xor	ah,ah
18559 53D2           50                         push	ax
18560                                           ! Debug: list int = const $27 (used reg = )
18561 53D3           B8                   0027  mov	ax,*$27
18562 53D6           50                         push	ax
18563                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18564 53D7           FF76         FE            push	-2[bp]
18565                                           ! Debug: func () void = write_byte+0 (used reg = )
18566 53DA           E8         B23D            call	_write_byte
18567 53DD           83C4                   06  add	sp,*6
18568                                           !BCC_EOS
18569                                           ! 2990           FLAGS &= 0xfffe;
18570                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18571 53E0           8B46         18            mov	ax,$18[bp]
18572 53E3           24                     FE  and	al,#$FE
18573 53E5           8946         18            mov	$18[bp],ax
18574                                           !BCC_EOS
18575                                           ! 2991           regs.u.r8.ah = 0;
18576                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18577 53E8           30C0                       xor	al,al
18578 53EA           8846         13            mov	$13[bp],al
18579                                           !BCC_EOS
18580                                           ! 2992           break;
18581 53ED           EB           34            jmp .384
18582                                           !BCC_EOS
18583                                           ! 2993         default:
18584                                           ! 2994 ;
18585                       000053EF            .3F9:
18586                                           !BCC_EOS
18587                                           ! 2995           regs.u.r8.ah = 1;
18588                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
18589 53EF           B0                     01  mov	al,*1
18590 53F1           8846         13            mov	$13[bp],al
18591                                           !BCC_EOS
18592                                           ! 2996           FLAGS |= 0x0001;
18593                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18594 53F4           8B46         18            mov	ax,$18[bp]
18595 53F7           0C                     01  or	al,*1
18596 53F9           8946         18            mov	$18[bp],ax
18597                                           !BCC_EOS
18598                                           ! 2997         }
18599                                           ! 2998       break;
18600 53FC           EB           25            jmp .384
18601                       000053FE            .386:
18602 53FE           2C                     00  sub	al,*0
18603 5400           72           ED            jb 	.3F9
18604 5402           3C                     07  cmp	al,*7
18605 5404           77           1B            ja  	.3FA
18606 5406           30E4                       xor	ah,ah
18607 5408           D1E0                       shl	ax,*1
18608 540A           89C3                       mov	bx,ax
18609 540C           2E                         seg	cs
18610 540D           FFA7       5411            br	.3FB[bx]
18611                       00005411            .3FB:
18612 5411                      4E00            .word	.387
18613 5413                      4F00            .word	.39A
18614 5415                      5016            .word	.3AD
18615 5417                      50E4            .word	.3C1
18616 5419                      519B            .word	.3CE
18617 541B                      4F00            .word	.39B
18618 541D                      51EE            .word	.3D2
18619 541F                      5365            .word	.3F2
18620                       00005421            .3FA:
18621 5421           EB           CC            jmp	.3F9
18622                       00005423            .384:
18623 5423           EB           19            jmp .380
18624                                           !BCC_EOS
18625                                           ! 2999     default:
18626                                           ! 3000       ;
18627                       00005425            .3FC:
18628                                           !BCC_EOS
18629                                           ! 3001       FLAGS |= 0x0001;
18630                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18631 5425           8B46         18            mov	ax,$18[bp]
18632 5428           0C                     01  or	al,*1
18633 542A           8946         18            mov	$18[bp],ax
18634                                           !BCC_EOS
18635                                           ! 3002       regs.u.r8.ah = 0x86;
18636                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18637 542D           B0                     86  mov	al,#$86
18638 542F           8846         13            mov	$13[bp],al
18639                                           !BCC_EOS
18640                                           ! 3003       break;
18641 5432           EB           0A            jmp .380
18642                                           !BCC_EOS
18643                                           ! 3004     }
18644                                           ! 3005 }
18645 5434           EB           08            jmp .380
18646                       00005436            .382:
18647 5436           2C                     C2  sub	al,#$C2
18648 5438         0F84         F9BE            beq 	.383
18649 543C           EB           E7            jmp	.3FC
18650                       0000543E            .380:
18651                       FFFFFFF0            ..FFF6	=	-$10
18652 543E           89EC                       mov	sp,bp
18653 5440           5D                         pop	bp
18654 5441           C3                         ret
18655                                           ! 3006 void set_e820_range(ES, DI, start, end, type)
18656                                           ! Register BX used in function int15_function_mouse
18657                                           ! 3007      Bit16u ES;
18658                                           export	_set_e820_range
18659                       00005442            _set_e820_range:
18660                                           !BCC_EOS
18661                                           ! 3008      Bit16u DI;
18662                                           !BCC_EOS
18663                                           ! 3009      Bit32u start;
18664                                           !BCC_EOS
18665                                           ! 3010      Bit32u end;
18666                                           !BCC_EOS
18667                                           ! 3011      Bit16u type;
18668                                           !BCC_EOS
18669                                           ! 3012 {
18670                                           ! 3013     write_word(ES, DI, start);
18671 5442           55                         push	bp
18672 5443           89E5                       mov	bp,sp
18673                                           ! Debug: list unsigned long start = [S+2+6] (used reg = )
18674 5445           FF76         0A            push	$A[bp]
18675 5448           FF76         08            push	8[bp]
18676                                           ! Debug: list unsigned short DI = [S+6+4] (used reg = )
18677 544B           FF76         06            push	6[bp]
18678                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18679 544E           FF76         04            push	4[bp]
18680                                           ! Debug: func () void = write_word+0 (used reg = )
18681 5451           E8         B1DE            call	_write_word
18682 5454           89EC                       mov	sp,bp
18683                                           !BCC_EOS
18684                                           ! 3014     write_word(ES, DI+2, start >> 16);
18685                                           ! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
18686 5456           8B46         08            mov	ax,8[bp]
18687 5459           8B5E         0A            mov	bx,$A[bp]
18688 545C           93                         xchg	bx,ax
18689 545D           31DB                       xor	bx,bx
18690                                           ! Debug: list unsigned long = bx+0 (used reg = )
18691 545F           53                         push	bx
18692 5460           50                         push	ax
18693                                           ! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
18694 5461           8B46         06            mov	ax,6[bp]
18695                                           ! Debug: list unsigned int = ax+2 (used reg = )
18696 5464           40                         inc	ax
18697 5465           40                         inc	ax
18698 5466           50                         push	ax
18699                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18700 5467           FF76         04            push	4[bp]
18701                                           ! Debug: func () void = write_word+0 (used reg = )
18702 546A           E8         B1C5            call	_write_word
18703 546D           89EC                       mov	sp,bp
18704                                           !BCC_EOS
18705                                           ! 3015     write_word(ES, DI+4, 0x00);
18706                                           ! Debug: list int = const 0 (used reg = )
18707 546F           31C0                       xor	ax,ax
18708 5471           50                         push	ax
18709                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
18710 5472           8B46         06            mov	ax,6[bp]
18711                                           ! Debug: list unsigned int = ax+4 (used reg = )
18712 5475           05                   0004  add	ax,*4
18713 5478           50                         push	ax
18714                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18715 5479           FF76         04            push	4[bp]
18716                                           ! Debug: func () void = write_word+0 (used reg = )
18717 547C           E8         B1B3            call	_write_word
18718 547F           89EC                       mov	sp,bp
18719                                           !BCC_EOS
18720                                           ! 3016     write_word(ES, DI+6, 0x00);
18721                                           ! Debug: list int = const 0 (used reg = )
18722 5481           31C0                       xor	ax,ax
18723 5483           50                         push	ax
18724                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
18725 5484           8B46         06            mov	ax,6[bp]
18726                                           ! Debug: list unsigned int = ax+6 (used reg = )
18727 5487           05                   0006  add	ax,*6
18728 548A           50                         push	ax
18729                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18730 548B           FF76         04            push	4[bp]
18731                                           ! Debug: func () void = write_word+0 (used reg = )
18732 548E           E8         B1A1            call	_write_word
18733 5491           89EC                       mov	sp,bp
18734                                           !BCC_EOS
18735                                           ! 3017     end -= start;
18736                                           ! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
18737 5493           8B46         0C            mov	ax,$C[bp]
18738 5496           8B5E         0E            mov	bx,$E[bp]
18739 5499           8D7E         08            lea	di,8[bp]
18740 549C           E8         AC42            call	lsubul
18741 549F           8946         0C            mov	$C[bp],ax
18742 54A2           895E         0E            mov	$E[bp],bx
18743                                           !BCC_EOS
18744                                           ! 3018     write_word(ES, DI+8, end);
18745                                           ! Debug: list unsigned long end = [S+2+$A] (used reg = )
18746 54A5           FF76         0E            push	$E[bp]
18747 54A8           FF76         0C            push	$C[bp]
18748                                           ! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
18749 54AB           8B46         06            mov	ax,6[bp]
18750                                           ! Debug: list unsigned int = ax+8 (used reg = )
18751 54AE           05                   0008  add	ax,*8
18752 54B1           50                         push	ax
18753                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18754 54B2           FF76         04            push	4[bp]
18755                                           ! Debug: func () void = write_word+0 (used reg = )
18756 54B5           E8         B17A            call	_write_word
18757 54B8           89EC                       mov	sp,bp
18758                                           !BCC_EOS
18759                                           ! 3019     write_word(ES, DI+10, end >> 16);
18760                                           ! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
18761 54BA           8B46         0C            mov	ax,$C[bp]
18762 54BD           8B5E         0E            mov	bx,$E[bp]
18763 54C0           93                         xchg	bx,ax
18764 54C1           31DB                       xor	bx,bx
18765                                           ! Debug: list unsigned long = bx+0 (used reg = )
18766 54C3           53                         push	bx
18767 54C4           50                         push	ax
18768                                           ! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
18769 54C5           8B46         06            mov	ax,6[bp]
18770                                           ! Debug: list unsigned int = ax+$A (used reg = )
18771 54C8           05                   000A  add	ax,*$A
18772 54CB           50                         push	ax
18773                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18774 54CC           FF76         04            push	4[bp]
18775                                           ! Debug: func () void = write_word+0 (used reg = )
18776 54CF           E8         B160            call	_write_word
18777 54D2           89EC                       mov	sp,bp
18778                                           !BCC_EOS
18779                                           ! 3020     write_word(ES, DI+12, 0x0000);
18780                                           ! Debug: list int = const 0 (used reg = )
18781 54D4           31C0                       xor	ax,ax
18782 54D6           50                         push	ax
18783                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
18784 54D7           8B46         06            mov	ax,6[bp]
18785                                           ! Debug: list unsigned int = ax+$C (used reg = )
18786 54DA           05                   000C  add	ax,*$C
18787 54DD           50                         push	ax
18788                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18789 54DE           FF76         04            push	4[bp]
18790                                           ! Debug: func () void = write_word+0 (used reg = )
18791 54E1           E8         B14E            call	_write_word
18792 54E4           89EC                       mov	sp,bp
18793                                           !BCC_EOS
18794                                           ! 3021     write_word(ES, DI+14, 0x0000);
18795                                           ! Debug: list int = const 0 (used reg = )
18796 54E6           31C0                       xor	ax,ax
18797 54E8           50                         push	ax
18798                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
18799 54E9           8B46         06            mov	ax,6[bp]
18800                                           ! Debug: list unsigned int = ax+$E (used reg = )
18801 54EC           05                   000E  add	ax,*$E
18802 54EF           50                         push	ax
18803                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18804 54F0           FF76         04            push	4[bp]
18805                                           ! Debug: func () void = write_word+0 (used reg = )
18806 54F3           E8         B13C            call	_write_word
18807 54F6           89EC                       mov	sp,bp
18808                                           !BCC_EOS
18809                                           ! 3022     write_word(ES, DI+16, type
18810                                           ! 3022 );
18811                                           ! Debug: list unsigned short type = [S+2+$E] (used reg = )
18812 54F8           FF76         10            push	$10[bp]
18813                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
18814 54FB           8B46         06            mov	ax,6[bp]
18815                                           ! Debug: list unsigned int = ax+$10 (used reg = )
18816 54FE           05                   0010  add	ax,*$10
18817 5501           50                         push	ax
18818                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18819 5502           FF76         04            push	4[bp]
18820                                           ! Debug: func () void = write_word+0 (used reg = )
18821 5505           E8         B12A            call	_write_word
18822 5508           89EC                       mov	sp,bp
18823                                           !BCC_EOS
18824                                           ! 3023     write_word(ES, DI+18, 0x0);
18825                                           ! Debug: list int = const 0 (used reg = )
18826 550A           31C0                       xor	ax,ax
18827 550C           50                         push	ax
18828                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
18829 550D           8B46         06            mov	ax,6[bp]
18830                                           ! Debug: list unsigned int = ax+$12 (used reg = )
18831 5510           05                   0012  add	ax,*$12
18832 5513           50                         push	ax
18833                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18834 5514           FF76         04            push	4[bp]
18835                                           ! Debug: func () void = write_word+0 (used reg = )
18836 5517           E8         B118            call	_write_word
18837 551A           89EC                       mov	sp,bp
18838                                           !BCC_EOS
18839                                           ! 3024 }
18840 551C           5D                         pop	bp
18841 551D           C3                         ret
18842                                           ! 3025   void
18843                                           ! Register BX used in function set_e820_range
18844                                           ! 3026 int15_function32(regs, ES, DS, FLAGS)
18845                                           ! 3027   pushad_regs_t regs;
18846                                           export	_int15_function32
18847                       0000551E            _int15_function32:
18848                                           !BCC_EOS
18849                                           ! 3028   Bit16u ES, DS, FLAGS;
18850                                           !BCC_EOS
18851                                           ! 3029 {
18852                                           ! 3030   Bit32u extended_memory_size=0;
18853 551E           55                         push	bp
18854 551F           89E5                       mov	bp,sp
18855 5521           83C4                   FC  add	sp,*-4
18856                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
18857 5524           31C0                       xor	ax,ax
18858 5526           31DB                       xor	bx,bx
18859 5528           8946         FC            mov	-4[bp],ax
18860 552B           895E         FE            mov	-2[bp],bx
18861                                           !BCC_EOS
18862                                           ! 3031   Bit16u CX,DX;
18863                                           !BCC_EOS
18864                                           ! 3032   Bit16u off, e820_table_size;
18865                                           !BCC_EOS
18866                                           ! 3033   Bit32u base, type, size;
18867                                           !BCC_EOS
18868                                           ! 3034 ;
18869 552E           83C4                   EC  add	sp,*-$14
18870                                           !BCC_EOS
18871                                           ! 3035   switch (regs.u.r8.ah) {
18872 5531           8A46         21            mov	al,$21[bp]
18873 5534           E9         0341            br 	.3FF
18874                                           ! 3036     case 0x86:
18875                                           ! 3037       CX = regs.u.r16.cx;
18876                       00005537            .400:
18877                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
18878 5537           8B46         1C            mov	ax,$1C[bp]
18879 553A           8946         FA            mov	-6[bp],ax
18880                                           !BCC_EOS
18881                                           ! 3038       DX = regs.u.r16.dx;
18882                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
18883 553D           8B46         18            mov	ax,$18[bp]
18884 5540           8946         F8            mov	-8[bp],ax
18885                                           !BCC_EOS
18886                                           ! 3039 #asm
18887                                           !BCC_EOS
18888                                           !BCC_ASM
18889                       00000012            _int15_function32.CX	set	$12
18890                       FFFFFFFA            .int15_function32.CX	set	-6
18891                       00000014            _int15_function32.extended_memory_size	set	$14
18892                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
18893                       00000040            _int15_function32.FLAGS	set	$40
18894                       00000028            .int15_function32.FLAGS	set	$28
18895                       00000004            _int15_function32.type	set	4
18896                       FFFFFFEC            .int15_function32.type	set	-$14
18897                       0000003E            _int15_function32.DS	set	$3E
18898                       00000026            .int15_function32.DS	set	$26
18899                       00000010            _int15_function32.DX	set	$10
18900                       FFFFFFF8            .int15_function32.DX	set	-8
18901                       00000000            _int15_function32.size	set	0
18902                       FFFFFFE8            .int15_function32.size	set	-$18
18903                       0000003C            _int15_function32.ES	set	$3C
18904                       00000024            .int15_function32.ES	set	$24
18905                       0000000C            _int15_function32.e820_table_size	set	$C
18906                       FFFFFFF4            .int15_function32.e820_table_size	set	-$C
18907                       00000008            _int15_function32.base	set	8
18908                       FFFFFFF0            .int15_function32.base	set	-$10
18909                       0000001C            _int15_function32.regs	set	$1C
18910                       00000004            .int15_function32.regs	set	4
18911                       0000000E            _int15_function32.off	set	$E
18912                       FFFFFFF6            .int15_function32.off	set	-$A
18913 5543           FB                               sti
18914                                                 ;; Get the count in eax
18915 5544           89E3                             mov bx, sp
18916 5546           36                         SEG SS
18917 5547           8B47         12                  mov ax, _int15_function32.CX [bx]
18918 554A     66    C1E0                   10        shl eax, #16
18919 554E           36                         SEG SS
18920 554F           8B47         10                  mov ax, _int15_function32.DX [bx]
18921                                                 ;; convert to numbers of 15usec ticks
18922 5552     66    BB               0000000F        mov ebx, #15
18923 5558     66    31D2                             xor edx, edx
18924 555B     66    F7F3                             div eax, ebx
18925 555E     66    89C1                             mov ecx, eax
18926                                                 ;; wait for ecx number of refresh requests
18927 5561           E4                     61        in al, #0x61
18928 5563           24                     10        and al,#0x10
18929 5565           88C4                             mov ah, al
18930 5567     66    09C9                             or ecx, ecx
18931 556A           74           0E                  je int1586_tick_end
18932                       0000556C            int1586_tick:
18933 556C           E4                     61        in al, #0x61
18934 556E           24                     10        and al,#0x10
18935 5570           38E0                             cmp al, ah
18936 5572           74           F8                  je int1586_tick
18937 5574           88C4                             mov ah, al
18938 5576     66    49                               dec ecx
18939 5578           75           F2                  jnz int1586_tick
18940                       0000557A            int1586_tick_end:
18941                                           ! 3068 endasm
18942                                           !BCC_ENDASM
18943                                           !BCC_EOS
18944                                           ! 3069       break;
18945 557A           E9         0309            br 	.3FD
18946                                           !BCC_EOS
18947                                           ! 3070     case 0xe8:
18948                                           ! 3071         switch(regs.u.r8.al)
18949                       0000557D            .401:
18950 557D           8A46         20            mov	al,$20[bp]
18951                                           ! 3072         {
18952 5580           E9         02D4            br 	.404
18953                                           ! 3073        case 0x20: {
18954                       00005583            .405:
18955                                           ! 3074             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
18956                                           ! Debug: list int = const 0 (used reg = )
18957 5583           31C0                       xor	ax,ax
18958 5585           50                         push	ax
18959                                           ! Debug: list unsigned short = const $EA10 (used reg = )
18960 5586           B8                   EA10  mov	ax,#$EA10
18961 5589           50                         push	ax
18962                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
18963 558A           E8         B07A            call	_read_word
18964 558D           83C4                   04  add	sp,*4
18965                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
18966 5590           B9                   0014  mov	cx,*$14
18967 5593           F7E9                       imul	cx
18968                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
18969 5595           8946         F4            mov	-$C[bp],ax
18970                                           !BCC_EOS
18971                                           ! 3075             if (regs.u.r32.edx != 0x534D4150)
18972                                           ! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
18973                                           ! Debug: expression subtree swapping
18974 5598           B8                   4150  mov	ax,#$4150
18975 559B           BB                   534D  mov	bx,#$534D
18976 559E           53                         push	bx
18977 559F           50                         push	ax
18978 55A0           8B46         18            mov	ax,$18[bp]
18979 55A3           8B5E         1A            mov	bx,$1A[bp]
18980 55A6           8D7E         E4            lea	di,-2+..FFF5[bp]
18981 55A9           E8         AB1F            call	lcmpul
18982 55AC           8D66         E8            lea	sp,2+..FFF5[bp]
18983 55AF           74           06            je  	.406
18984                       000055B1            .407:
18985                                           ! 3076                 goto int15_unimplemented;
18986 55B1           83C4                   00  add	sp,#..FFF4-..FFF5
18987 55B4           E9         02B0            br 	.FFF4
18988                                           !BCC_EOS
18989                                           ! 3077             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
18990                       000055B7            .406:
18991                                           ! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
18992 55B7           8B46         14            mov	ax,$14[bp]
18993 55BA           BB                   0014  mov	bx,*$14
18994 55BD           E8         ABA9            call	idiv_u
18995                                           ! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
18996 55C0           B9                   0014  mov	cx,*$14
18997 55C3           F7E9                       imul	cx
18998                                           ! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
18999 55C5           3B46         14            cmp	ax,$14[bp]
19000 55C8         0F85         0084            bne 	.408
19001                       000055CC            .409:
19002                                           ! 3078                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
19003                                           ! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
19004 55CC           8B46         14            mov	ax,$14[bp]
19005                                           ! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
19006 55CF           05                   0014  add	ax,*$14
19007 55D2           3B46         F4            cmp	ax,-$C[bp]
19008 55D5           77           1B            ja  	.40A
19009                       000055D7            .40B:
19010                                           ! 3079                     memcpyb(ES, regs.u.r16.di,
19011                                           ! 3080                             (Bit16u)(0x000EA100 >> 4), 0x8 + regs.u.r16.bx, 0x14);
19012                                           ! Debug: list int = const $14 (used reg = )
19013 55D7           B8                   0014  mov	ax,*$14
19014 55DA           50                         push	ax
19015                                           ! Debug: add unsigned short regs = [S+$1C+$12] to int = const 8 (used reg = )
19016                                           ! Debug: expression subtree swapping
19017 55DB           8B46         14            mov	ax,$14[bp]
19018                                           ! Debug: list unsigned int = ax+8 (used reg = )
19019 55DE           05                   0008  add	ax,*8
19020 55E1           50                         push	ax
19021                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19022 55E2           B8                   EA10  mov	ax,#$EA10
19023 55E5           50                         push	ax
19024                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
19025 55E6           FF76         04            push	4[bp]
19026                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
19027 55E9           FF76         24            push	$24[bp]
19028                                           ! Debug: func () void = memcpyb+0 (used reg = )
19029 55EC           E8         AA35            call	_memcpyb
19030 55EF           83C4                   0A  add	sp,*$A
19031                                           !BCC_EOS
19032                                           ! 3081                 regs.u.r32.ebx += 0x14;
19033                       000055F2            .40A:
19034                                           ! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
19035 55F2           B8                   0014  mov	ax,*$14
19036 55F5           31DB                       xor	bx,bx
19037 55F7           53                         push	bx
19038 55F8           50                         push	ax
19039 55F9           8B46         14            mov	ax,$14[bp]
19040 55FC           8B5E         16            mov	bx,$16[bp]
19041 55FF           8D7E         E4            lea	di,-2+..FFF5[bp]
19042 5602           E8         AABE            call	laddul
19043 5605           8946         14            mov	$14[bp],ax
19044 5608           895E         16            mov	$16[bp],bx
19045 560B           83C4                   04  add	sp,*4
19046                                           !BCC_EOS
19047                                           ! 3082                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
19048                                           ! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19049 560E           8B46         F4            mov	ax,-$C[bp]
19050 5611           31DB                       xor	bx,bx
19051 5613           53                         push	bx
19052 5614           50                         push	ax
19053                                           ! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
19054                                           ! Debug: expression subtree swapping
19055 5615           B8                   0014  mov	ax,*$14
19056 5618           31DB                       xor	bx,bx
19057 561A           8D7E         14            lea	di,$14[bp]
19058 561D           E8         AAA3            call	laddul
19059                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
19060 5620           53                         push	bx
19061 5621           50                         push	ax
19062 5622           B8                   0001  mov	ax,*1
19063 5625           31DB                       xor	bx,bx
19064 5627           53                         push	bx
19065 5628           50                         push	ax
19066 5629           8B46         E0            mov	ax,-6+..FFF5[bp]
19067 562C           8B5E         E2            mov	bx,-4+..FFF5[bp]
19068 562F           8D7E         DC            lea	di,-$A+..FFF5[bp]
19069 5632           E8         AAAC            call	lsubul
19070 5635           83C4                   08  add	sp,*8
19071                                           ! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
19072 5638           8D7E         E4            lea	di,-2+..FFF5[bp]
19073 563B           E8         AA8D            call	lcmpul
19074 563E           8D66         E8            lea	sp,2+..FFF5[bp]
19075 5641           76           0A            jbe 	.40C
19076                       00005643            .40D:
19077                                           ! 3083                     regs.u.r32.ebx = 0;
19078                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
19079 5643           31C0                       xor	ax,ax
19080 5645           31DB                       xor	bx,bx
19081 5647           8946         14            mov	$14[bp],ax
19082 564A           895E         16            mov	$16[bp],bx
19083                                           !BCC_EOS
19084                                           ! 3084             } else if (regs.u.r16.bx == 1) {
19085                       0000564D            .40C:
19086 564D           E9         00BB            br 	.40E
19087                       00005650            .408:
19088                                           ! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
19089 5650           8B46         14            mov	ax,$14[bp]
19090 5653           3D                   0001  cmp	ax,*1
19091 5656         0F85         00AB            bne 	.40F
19092                       0000565A            .410:
19093                                           ! 3085                 for (off = 0; off < e820_table_size; off += 0x14) {
19094                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
19095 565A           31C0                       xor	ax,ax
19096 565C           8946         F6            mov	-$A[bp],ax
19097                                           !BCC_EOS
19098                                           !BCC_EOS
19099 565F           EB           62            jmp .413
19100                       00005661            .414:
19101                                           ! 3086                     base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
19102                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
19103                                           ! Debug: expression subtree swapping
19104 5661           8B46         F6            mov	ax,-$A[bp]
19105                                           ! Debug: list unsigned int = ax+8 (used reg = )
19106 5664           05                   0008  add	ax,*8
19107 5667           50                         push	ax
19108                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19109 5668           B8                   EA10  mov	ax,#$EA10
19110 566B           50                         push	ax
19111                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19112 566C           E8         AA14            call	_read_dword
19113 566F           89D3                       mov	bx,dx
19114 5671           83C4                   04  add	sp,*4
19115                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19116 5674           8946         F0            mov	-$10[bp],ax
19117 5677           895E         F2            mov	-$E[bp],bx
19118                                           !BCC_EOS
19119                                           ! 3087                     type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
19120                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
19121                                           ! Debug: expression subtree swapping
19122 567A           8B46         F6            mov	ax,-$A[bp]
19123                                           ! Debug: list unsigned int = ax+$18 (used reg = )
19124 567D           05                   0018  add	ax,*$18
19125 5680           50                         push	ax
19126                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19127 5681           B8                   EA10  mov	ax,#$EA10
19128 5684           50                         push	ax
19129                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19130 5685           E8         A9FB            call	_read_dword
19131 5688           89D3                       mov	bx,dx
19132 568A           83C4                   04  add	sp,*4
19133                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
19134 568D           8946         EC            mov	-$14[bp],ax
19135 5690           895E         EE            mov	-$12[bp],bx
19136                                           !BCC_EOS
19137                                           ! 3088                     if ((base >= 0x100000) && (type == 1))
19138                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
19139 5693           31C0                       xor	ax,ax
19140 5695           BB                   0010  mov	bx,*$10
19141 5698           8D7E         F0            lea	di,-$10[bp]
19142 569B           E8         AA2D            call	lcmpul
19143 569E           77           1A            ja  	.415
19144                       000056A0            .417:
19145                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
19146                                           ! Debug: expression subtree swapping
19147 56A0           B8                   0001  mov	ax,*1
19148 56A3           31DB                       xor	bx,bx
19149 56A5           53                         push	bx
19150 56A6           50                         push	ax
19151 56A7           8B46         EC            mov	ax,-$14[bp]
19152 56AA           8B5E         EE            mov	bx,-$12[bp]
19153 56AD           8D7E         E4            lea	di,-2+..FFF5[bp]
19154 56B0           E8         AA18            call	lcmpul
19155 56B3           8D66         E8            lea	sp,2+..FFF5[bp]
19156 56B6           75           02            jne 	.415
19157                       000056B8            .416:
19158                                           ! 3089                         break;
19159 56B8           EB           11            jmp .411
19160                                           !BCC_EOS
19161                                           ! 3090                 }
19162                       000056BA            .415:
19163                                           ! 3091                 if (off == e820_table_size) {
19164                       000056BA            .412:
19165                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19166 56BA           8B46         F6            mov	ax,-$A[bp]
19167 56BD           05                   0014  add	ax,*$14
19168 56C0           8946         F6            mov	-$A[bp],ax
19169                       000056C3            .413:
19170                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19171 56C3           8B46         F6            mov	ax,-$A[bp]
19172 56C6           3B46         F4            cmp	ax,-$C[bp]
19173 56C9           72           96            jb 	.414
19174                       000056CB            .418:
19175                       000056CB            .411:
19176                                           ! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19177 56CB           8B46         F6            mov	ax,-$A[bp]
19178 56CE           3B46         F4            cmp	ax,-$C[bp]
19179 56D1           75           0B            jne 	.419
19180                       000056D3            .41A:
19181                                           ! 3092                
19182                                           ! 3092      FLAGS |= 0x0001;
19183                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19184 56D3           8B46         28            mov	ax,$28[bp]
19185 56D6           0C                     01  or	al,*1
19186 56D8           8946         28            mov	$28[bp],ax
19187                                           !BCC_EOS
19188                                           ! 3093                     break;
19189 56DB           E9         0187            br 	.402
19190                                           !BCC_EOS
19191                                           ! 3094                 }
19192                                           ! 3095                 memcpyb(ES, regs.u.r16.di, (Bit16u)(0x000EA100 >> 4), 0x8 + off, 0x14);
19193                       000056DE            .419:
19194                                           ! Debug: list int = const $14 (used reg = )
19195 56DE           B8                   0014  mov	ax,*$14
19196 56E1           50                         push	ax
19197                                           ! Debug: add unsigned short off = [S+$1C-$C] to int = const 8 (used reg = )
19198                                           ! Debug: expression subtree swapping
19199 56E2           8B46         F6            mov	ax,-$A[bp]
19200                                           ! Debug: list unsigned int = ax+8 (used reg = )
19201 56E5           05                   0008  add	ax,*8
19202 56E8           50                         push	ax
19203                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19204 56E9           B8                   EA10  mov	ax,#$EA10
19205 56EC           50                         push	ax
19206                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
19207 56ED           FF76         04            push	4[bp]
19208                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
19209 56F0           FF76         24            push	$24[bp]
19210                                           ! Debug: func () void = memcpyb+0 (used reg = )
19211 56F3           E8         A92E            call	_memcpyb
19212 56F6           83C4                   0A  add	sp,*$A
19213                                           !BCC_EOS
19214                                           ! 3096                 regs.u.r32.ebx = 0;
19215                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
19216 56F9           31C0                       xor	ax,ax
19217 56FB           31DB                       xor	bx,bx
19218 56FD           8946         14            mov	$14[bp],ax
19219 5700           895E         16            mov	$16[bp],bx
19220                                           !BCC_EOS
19221                                           ! 3097             } else {
19222 5703           EB           06            jmp .41B
19223                       00005705            .40F:
19224                                           ! 3098                 goto int15_unimplemented;
19225 5705           83C4                   00  add	sp,#..FFF4-..FFF5
19226 5708           E9         015C            br 	.FFF4
19227                                           !BCC_EOS
19228                                           ! 3099             }
19229                                           ! 3100             regs.u.r32.eax = 0x534D4150;
19230                       0000570B            .41B:
19231                       0000570B            .40E:
19232                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
19233 570B           B8                   4150  mov	ax,#$4150
19234 570E           BB                   534D  mov	bx,#$534D
19235 5711           8946         20            mov	$20[bp],ax
19236 5714           895E         22            mov	$22[bp],bx
19237                                           !BCC_EOS
19238                                           ! 3101             regs.u.r32.ecx = 0x14;
19239                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
19240 5717           B8                   0014  mov	ax,*$14
19241 571A           31DB                       xor	bx,bx
19242 571C           8946         1C            mov	$1C[bp],ax
19243 571F           895E         1E            mov	$1E[bp],bx
19244                                           !BCC_EOS
19245                                           ! 3102             FLAGS &= 0xfffe;
19246                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19247 5722           8B46         28            mov	ax,$28[bp]
19248 5725           24                     FE  and	al,#$FE
19249 5727           8946         28            mov	$28[bp],ax
19250                                           !BCC_EOS
19251                                           ! 3103             break;
19252 572A           E9         0138            br 	.402
19253                                           !BCC_EOS
19254                                           ! 3104         }
19255                                           ! 3105         case 0x01: {
19256                       0000572D            .41C:
19257                                           ! 3106             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
19258                                           ! Debug: list int = const 0 (used reg = )
19259 572D           31C0                       xor	ax,ax
19260 572F           50                         push	ax
19261                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19262 5730           B8                   EA10  mov	ax,#$EA10
19263 5733           50                         push	ax
19264                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
19265 5734           E8         AED0            call	_read_word
19266 5737           83C4                   04  add	sp,*4
19267                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
19268 573A           B9                   0014  mov	cx,*$14
19269 573D           F7E9                       imul	cx
19270                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19271 573F           8946         F4            mov	-$C[bp],ax
19272                                           !BCC_EOS
19273                                           ! 3107             FLAGS &= 0xfffe;
19274                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19275 5742           8B46         28            mov	ax,$28[bp]
19276 5745           24                     FE  and	al,#$FE
19277 5747           8946         28            mov	$28[bp],ax
19278                                           !BCC_EOS
19279                                           ! 3108             regs.u.r8.cl = inb_cmos(0x30);
19280                                           ! Debug: list int = const $30 (used reg = )
19281 574A           B8                   0030  mov	ax,*$30
19282 574D           50                         push	ax
19283                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19284 574E           E8         AE32            call	_inb_cmos
19285 5751           44                         inc	sp
19286 5752           44                         inc	sp
19287                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
19288 5753           8846         1C            mov	$1C[bp],al
19289                                           !BCC_EOS
19290                                           ! 3109             regs.u.r8.ch = inb_cmos(0x31);
19291                                           ! Debug: list int = const $31 (used reg = )
19292 5756           B8                   0031  mov	ax,*$31
19293 5759           50                         push	ax
19294                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19295 575A           E8         AE26            call	_inb_cmos
19296 575D           44                         inc	sp
19297 575E           44                         inc	sp
19298                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
19299 575F           8846         1D            mov	$1D[bp],al
19300                                           !BCC_EOS
19301                                           ! 3110             if (regs.u.r16.cx > (15*1024))
19302                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19303 5762           8B46         1C            mov	ax,$1C[bp]
19304 5765           3D                   3C00  cmp	ax,#$3C00
19305 5768           76           06            jbe 	.41D
19306                       0000576A            .41E:
19307                                           ! 3111                 regs.u.r16.cx = 15*1024;
19308                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19309 576A           B8                   3C00  mov	ax,#$3C00
19310 576D           8946         1C            mov	$1C[bp],ax
19311                                           !BCC_EOS
19312                                           ! 3112             for (off = 0; off < e820_table_size; off += 0x14) {
19313                       00005770            .41D:
19314                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
19315 5770           31C0                       xor	ax,ax
19316 5772           8946         F6            mov	-$A[bp],ax
19317                                           !BCC_EOS
19318                                           !BCC_EOS
19319 5775           EB           62            jmp .421
19320                       00005777            .422:
19321                                           ! 3113                 base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
19322                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
19323                                           ! Debug: expression subtree swapping
19324 5777           8B46         F6            mov	ax,-$A[bp]
19325                                           ! Debug: list unsigned int = ax+8 (used reg = )
19326 577A           05                   0008  add	ax,*8
19327 577D           50                         push	ax
19328                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19329 577E           B8                   EA10  mov	ax,#$EA10
19330 5781           50                         push	ax
19331                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19332 5782           E8         A8FE            call	_read_dword
19333 5785           89D3                       mov	bx,dx
19334 5787           83C4                   04  add	sp,*4
19335                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19336 578A           8946         F0            mov	-$10[bp],ax
19337 578D           895E         F2            mov	-$E[bp],bx
19338                                           !BCC_EOS
19339                                           ! 3114                 type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
19340                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
19341                                           ! Debug: expression subtree swapping
19342 5790           8B46         F6            mov	ax,-$A[bp]
19343                                           ! Debug: list unsigned int = ax+$18 (used reg = )
19344 5793           05                   0018  add	ax,*$18
19345 5796           50                         push	ax
19346                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19347 5797           B8                   EA10  mov	ax,#$EA10
19348 579A           50                         push	ax
19349                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19350 579B           E8         A8E5            call	_read_dword
19351 579E           89D3                       mov	bx,dx
19352 57A0           83C4                   04  add	sp,*4
19353                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
19354 57A3           8946         EC            mov	-$14[bp],ax
19355 57A6           895E         EE            mov	-$12[bp],bx
19356                                           !BCC_EOS
19357                                           ! 3115                 if ((base >= 0x100000) && (type == 1))
19358                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
19359 57A9           31C0                       xor	ax,ax
19360 57AB           BB                   0010  mov	bx,*$10
19361 57AE           8D7E         F0            lea	di,-$10[bp]
19362 57B1           E8         A917            call	lcmpul
19363 57B4           77           1A            ja  	.423
19364                       000057B6            .425:
19365                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
19366                                           ! Debug: expression subtree swapping
19367 57B6           B8                   0001  mov	ax,*1
19368 57B9           31DB                       xor	bx,bx
19369 57BB           53                         push	bx
19370 57BC           50                         push	ax
19371 57BD           8B46         EC            mov	ax,-$14[bp]
19372 57C0           8B5E         EE            mov	bx,-$12[bp]
19373 57C3           8D7E         E4            lea	di,-2+..FFF5[bp]
19374 57C6           E8         A902            call	lcmpul
19375 57C9           8D66         E8            lea	sp,2+..FFF5[bp]
19376 57CC           75           02            jne 	.423
19377                       000057CE            .424:
19378                                           ! 3116                     break;
19379 57CE           EB           11            jmp .41F
19380                                           !BCC_EOS
19381                                           ! 3117             }
19382                       000057D0            .423:
19383                                           ! 3118             regs.u.r16.dx = 0;
19384                       000057D0            .420:
19385                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19386 57D0           8B46         F6            mov	ax,-$A[bp]
19387 57D3           05                   0014  add	ax,*$14
19388 57D6           8946         F6            mov	-$A[bp],ax
19389                       000057D9            .421:
19390                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19391 57D9           8B46         F6            mov	ax,-$A[bp]
19392 57DC           3B46         F4            cmp	ax,-$C[bp]
19393 57DF           72           96            jb 	.422
19394                       000057E1            .426:
19395                       000057E1            .41F:
19396                                           ! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
19397 57E1           31C0                       xor	ax,ax
19398 57E3           8946         18            mov	$18[bp],ax
19399                                           !BCC_EOS
19400                                           ! 3119             if (off != e820_table_size) {
19401                                           ! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19402 57E6           8B46         F6            mov	ax,-$A[bp]
19403 57E9           3B46         F4            cmp	ax,-$C[bp]
19404 57EC           74           54            je  	.427
19405                       000057EE            .428:
19406                                           ! 3120                 size = base + read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x8 + off);
19407                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
19408                                           ! Debug: expression subtree swapping
19409 57EE           8B46         F6            mov	ax,-$A[bp]
19410                                           ! Debug: list unsigned int = ax+$10 (used reg = )
19411 57F1           05                   0010  add	ax,*$10
19412 57F4           50                         push	ax
19413                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19414 57F5           B8                   EA10  mov	ax,#$EA10
19415 57F8           50                         push	ax
19416                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19417 57F9           E8         A887            call	_read_dword
19418 57FC           89D3                       mov	bx,dx
19419 57FE           83C4                   04  add	sp,*4
19420                                           ! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19421                                           ! Debug: expression subtree swapping
19422 5801           8D7E         F0            lea	di,-$10[bp]
19423 5804           E8         A8BC            call	laddul
19424                                           ! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
19425 5807           8946         E8            mov	-$18[bp],ax
19426 580A           895E         EA            mov	-$16[bp],bx
19427                                           !BCC_EOS
19428                                           ! 3121                 if (size > 0x1000000) {
19429                                           ! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19430 580D           31C0                       xor	ax,ax
19431 580F           BB                   0100  mov	bx,#$100
19432 5812           8D7E         E8            lea	di,-$18[bp]
19433 5815           E8         A8B3            call	lcmpul
19434 5818           73           28            jae 	.429
19435                       0000581A            .42A:
19436                                           ! 3122                     size -= 0x1000000;
19437                                           ! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19438 581A           31C0                       xor	ax,ax
19439 581C           BB                   0100  mov	bx,#$100
19440 581F           53                         push	bx
19441 5820           50                         push	ax
19442 5821           8B46         E8            mov	ax,-$18[bp]
19443 5824           8B5E         EA            mov	bx,-$16[bp]
19444 5827           8D7E         E4            lea	di,-2+..FFF5[bp]
19445 582A           E8         A8B4            call	lsubul
19446 582D           8946         E8            mov	-$18[bp],ax
19447 5830           895E         EA            mov	-$16[bp],bx
19448 5833           83C4                   04  add	sp,*4
19449                                           !BCC_EOS
19450                                           ! 3123                     regs.u.r16.dx = (Bit16u)(size >> 16);
19451                                           ! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
19452 5836           8B46         E8            mov	ax,-$18[bp]
19453 5839           8B5E         EA            mov	bx,-$16[bp]
19454 583C           93                         xchg	bx,ax
19455 583D           31DB                       xor	bx,bx
19456                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
19457                                           ! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
19458 583F           8946         18            mov	$18[bp],ax
19459                                           !BCC_EOS
19460                                           ! 3124                 }
19461                                           ! 3125             }
19462                       00005842            .429:
19463                                           ! 3126             regs.u.r16.ax = regs.u.r16.cx;
19464                       00005842            .427:
19465                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
19466 5842           8B46         1C            mov	ax,$1C[bp]
19467 5845           8946         20            mov	$20[bp],ax
19468                                           !BCC_EOS
19469                                           ! 3127             regs.u.r16.bx = regs.u.r16.dx;
19470                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
19471 5848           8B46         18            mov	ax,$18[bp]
19472 584B           8946         14            mov	$14[bp],ax
19473                                           !BCC_EOS
19474                                           ! 3128             break;
19475 584E           EB           15            jmp .402
19476                                           !BCC_EOS
19477                                           ! 3129         }
19478                                           ! 3130         default:
19479                                           ! 3131             goto int15_unimplemented;
19480                       00005850            .42B:
19481 5850           83C4                   00  add	sp,#..FFF4-..FFF5
19482 5853           EB           12            jmp .FFF4
19483                                           !BCC_EOS
19484                                           ! 3132         }
19485                                           ! 3133         break;
19486 5855           EB           0E            jmp .402
19487                       00005857            .404:
19488 5857           2C                     01  sub	al,*1
19489 5859         0F84         FED0            beq 	.41C
19490 585D           2C                     1F  sub	al,*$1F
19491 585F         0F84         FD20            beq 	.405
19492 5863           EB           EB            jmp	.42B
19493                       00005865            .402:
19494 5865           EB           1F            jmp .3FD
19495                                           !BCC_EOS
19496                                           ! 3134     int15_unimplemented:
19497                       00005867            .FFF4:
19498                                           ! 3135     default:
19499                                           ! 3136       ;
19500                       00005867            .42C:
19501                                           !BCC_EOS
19502                                           ! 3137       FLAGS |= 0x0001;
19503                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19504 5867           8B46         28            mov	ax,$28[bp]
19505 586A           0C                     01  or	al,*1
19506 586C           8946         28            mov	$28[bp],ax
19507                                           !BCC_EOS
19508                                           ! 3138       regs.u.r8.ah = 0x86;
19509                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
19510 586F           B0                     86  mov	al,#$86
19511 5871           8846         21            mov	$21[bp],al
19512                                           !BCC_EOS
19513                                           ! 3139       break;
19514 5874           EB           10            jmp .3FD
19515                                           !BCC_EOS
19516                                           ! 3140     }
19517                                           ! 3141 }
19518 5876           EB           0E            jmp .3FD
19519                       00005878            .3FF:
19520 5878           2C                     86  sub	al,#$86
19521 587A         0F84         FCB9            beq 	.400
19522 587E           2C                     62  sub	al,*$62
19523 5880         0F84         FCF9            beq 	.401
19524 5884           EB           E1            jmp	.42C
19525                       00005886            .3FD:
19526                       FFFFFFE6            ..FFF5	=	-$1A
19527                       FFFFFFE6            ..FFF4	=	-$1A
19528 5886           89EC                       mov	sp,bp
19529 5888           5D                         pop	bp
19530 5889           C3                         ret
19531                                           ! 3142   void
19532                                           ! Register BX used in function int15_function32
19533                                           ! 3143 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
19534                                           ! 3144   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
19535                                           export	_int16_function
19536                       0000588A            _int16_function:
19537                                           !BCC_EOS
19538                                           ! 3145 {
19539                                           ! 3146   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
19540                                           !BCC_EOS
19541                                           ! 3147   Bit16u kbd_code, max;
19542                                           !BCC_EOS
19543                                           ! 3148   ;
19544 588A           55                         push	bp
19545 588B           89E5                       mov	bp,sp
19546 588D           83C4                   F6  add	sp,*-$A
19547                                           !BCC_EOS
19548                                           ! 3149   shift_flags = read_byte(0x0040, 0x17);
19549                                           ! Debug: list int = const $17 (used reg = )
19550 5890           B8                   0017  mov	ax,*$17
19551 5893           50                         push	ax
19552                                           ! Debug: list int = const $40 (used reg = )
19553 5894           B8                   0040  mov	ax,*$40
19554 5897           50                         push	ax
19555                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19556 5898           E8         AD59            call	_read_byte
19557 589B           83C4                   04  add	sp,*4
19558                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
19559 589E           8846         FD            mov	-3[bp],al
19560                                           !BCC_EOS
19561                                           ! 3150   led_flags = read_byte(0x0040, 0x97);
19562                                           ! Debug: list int = const $97 (used reg = )
19563 58A1           B8                   0097  mov	ax,#$97
19564 58A4           50                         push	ax
19565                                           ! Debug: list int = const $40 (used reg = )
19566 58A5           B8                   0040  mov	ax,*$40
19567 58A8           50                         push	ax
19568                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19569 58A9           E8         AD48            call	_read_byte
19570 58AC           83C4                   04  add	sp,*4
19571                                           ! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
19572 58AF           8846         FC            mov	-4[bp],al
19573                                           !BCC_EOS
19574                                           ! 3151   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
19575                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
19576 58B2           8A46         FC            mov	al,-4[bp]
19577 58B5           24                     07  and	al,*7
19578 58B7           50                         push	ax
19579                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
19580 58B8           8A46         FD            mov	al,-3[bp]
19581 58BB           30E4                       xor	ah,ah
19582 58BD           B1                     04  mov	cl,*4
19583 58BF           D3E8                       shr	ax,cl
19584                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
19585 58C1           24                     07  and	al,*7
19586                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
19587 58C3           3246         F4            xor	al,-$C[bp]
19588 58C6           44                         inc	sp
19589 58C7           44                         inc	sp
19590                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
19591 58C8           84C0                       test	al,al
19592 58CA         0F84         00A3            beq 	.42D
19593                       000058CE            .42E:
19594                                           ! 3152 #asm
19595                                           !BCC_EOS
19596                                           !BCC_ASM
19597                       00000012            _int16_function.BP	set	$12
19598                       00000008            .int16_function.BP	set	8
19599                       00000005            _int16_function.count	set	5
19600                       FFFFFFFB            .int16_function.count	set	-5
19601                       0000001A            _int16_function.CX	set	$1A
19602                       00000010            .int16_function.CX	set	$10
19603                       00000008            _int16_function.ascii_code	set	8
19604                       FFFFFFFE            .int16_function.ascii_code	set	-2
19605                       0000000E            _int16_function.DI	set	$E
19606                       00000004            .int16_function.DI	set	4
19607                       0000001E            _int16_function.FLAGS	set	$1E
19608                       00000014            .int16_function.FLAGS	set	$14
19609                       00000002            _int16_function.kbd_code	set	2
19610                       FFFFFFF8            .int16_function.kbd_code	set	-8
19611                       00000009            _int16_function.scan_code	set	9
19612                       FFFFFFFF            .int16_function.scan_code	set	-1
19613                       00000018            _int16_function.DX	set	$18
19614                       0000000E            .int16_function.DX	set	$E
19615                       00000006            _int16_function.led_flags	set	6
19616                       FFFFFFFC            .int16_function.led_flags	set	-4
19617                       00000010            _int16_function.SI	set	$10
19618                       00000006            .int16_function.SI	set	6
19619                       0000001C            _int16_function.AX	set	$1C
19620                       00000012            .int16_function.AX	set	$12
19621                       00000014            _int16_function.SP	set	$14
19622                       0000000A            .int16_function.SP	set	$A
19623                       00000016            _int16_function.BX	set	$16
19624                       0000000C            .int16_function.BX	set	$C
19625                       00000007            _int16_function.shift_flags	set	7
19626                       FFFFFFFD            .int16_function.shift_flags	set	-3
19627                       00000000            _int16_function.max	set	0
19628                       FFFFFFF6            .int16_function.max	set	-$A
19629 58CE           FA                             cli
19630                                           ! 3154 endasm
19631                                           !BCC_ENDASM
19632                                           !BCC_EOS
19633                                           ! 3155     outb(0x60, 0xed);
19634                                           ! Debug: list int = const $ED (used reg = )
19635 58CF           B8                   00ED  mov	ax,#$ED
19636 58D2           50                         push	ax
19637                                           ! Debug: list int = const $60 (used reg = )
19638 58D3           B8                   0060  mov	ax,*$60
19639 58D6           50                         push	ax
19640                                           ! Debug: func () void = outb+0 (used reg = )
19641 58D7           E8         AC7A            call	_outb
19642 58DA           83C4                   04  add	sp,*4
19643                                           !BCC_EOS
19644                                           ! 3156     
19645                                           ! 3156 while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
19646 58DD           EB           0E            jmp .430
19647                       000058DF            .431:
19648                                           ! Debug: list int = const $21 (used reg = )
19649 58DF           B8                   0021  mov	ax,*$21
19650 58E2           50                         push	ax
19651                                           ! Debug: list int = const $80 (used reg = )
19652 58E3           B8                   0080  mov	ax,#$80
19653 58E6           50                         push	ax
19654                                           ! Debug: func () void = outb+0 (used reg = )
19655 58E7           E8         AC6A            call	_outb
19656 58EA           83C4                   04  add	sp,*4
19657                                           !BCC_EOS
19658                                           ! 3157     if ((inb(0x60) == 0xfa)) {
19659                       000058ED            .430:
19660                                           ! Debug: list int = const $64 (used reg = )
19661 58ED           B8                   0064  mov	ax,*$64
19662 58F0           50                         push	ax
19663                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19664 58F1           E8         AC4A            call	_inb
19665 58F4           44                         inc	sp
19666 58F5           44                         inc	sp
19667                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19668 58F6           24                     01  and	al,*1
19669                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19670 58F8           84C0                       test	al,al
19671 58FA           74           E3            je 	.431
19672                       000058FC            .432:
19673                       000058FC            .42F:
19674                                           ! Debug: list int = const $60 (used reg = )
19675 58FC           B8                   0060  mov	ax,*$60
19676 58FF           50                         push	ax
19677                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19678 5900           E8         AC3B            call	_inb
19679 5903           44                         inc	sp
19680 5904           44                         inc	sp
19681                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
19682 5905           3C                     FA  cmp	al,#$FA
19683 5907           75           67            jne 	.433
19684                       00005909            .434:
19685                                           ! 3158       led_flags &= 0xf8;
19686                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
19687 5909           8A46         FC            mov	al,-4[bp]
19688 590C           24                     F8  and	al,#$F8
19689 590E           8846         FC            mov	-4[bp],al
19690                                           !BCC_EOS
19691                                           ! 3159       led_flags |= ((shift_flags >> 4) & 0x07);
19692                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
19693 5911           8A46         FD            mov	al,-3[bp]
19694 5914           30E4                       xor	ah,ah
19695 5916           B1                     04  mov	cl,*4
19696 5918           D3E8                       shr	ax,cl
19697                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
19698 591A           24                     07  and	al,*7
19699                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
19700 591C           0A46         FC            or	al,-4[bp]
19701 591F           8846         FC            mov	-4[bp],al
19702                                           !BCC_EOS
19703                                           ! 3160       outb(0x60, led_flags & 0x07);
19704                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
19705 5922           8A46         FC            mov	al,-4[bp]
19706 5925           24                     07  and	al,*7
19707                                           ! Debug: list unsigned char = al+0 (used reg = )
19708 5927           30E4                       xor	ah,ah
19709 5929           50                         push	ax
19710                                           ! Debug: list int = const $60 (used reg = )
19711 592A           B8                   0060  mov	ax,*$60
19712 592D           50                         push	ax
19713                                           ! Debug: func () void = outb+0 (used reg = )
19714 592E           E8         AC23            call	_outb
19715 5931           83C4                   04  add	sp,*4
19716                                           !BCC_EOS
19717                                           ! 3161       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
19718 5934           EB           0E            jmp .436
19719                       00005936            .437:
19720                                           ! Debug: list int = const $21 (used reg = )
19721 5936           B8                   0021  mov	ax,*$21
19722 5939           50                         push	ax
19723                                           ! Debug: list int = const $80 (used reg = )
19724 593A           B8                   0080  mov	ax,#$80
19725 593D           50                         push	ax
19726                                           ! Debug: func () void = outb+0 (used reg = )
19727 593E           E8         AC13            call	_outb
19728 5941           83C4                   04  add	sp,*4
19729                                           !BCC_EOS
19730                                           ! 3162       inb(0x60);
19731                       00005944            .436:
19732                                           ! Debug: list int = const $64 (used reg = )
19733 5944           B8                   0064  mov	ax,*$64
19734 5947           50                         push	ax
19735                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19736 5948           E8         ABF3            call	_inb
19737 594B           44                         inc	sp
19738 594C           44                         inc	sp
19739                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19740 594D           24                     01  and	al,*1
19741                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19742 594F           84C0                       test	al,al
19743 5951           74           E3            je 	.437
19744                       00005953            .438:
19745                       00005953            .435:
19746                                           ! Debug: list int = const $60 (used reg = )
19747 5953           B8                   0060  mov	ax,*$60
19748 5956           50                         push	ax
19749                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19750 5957           E8         ABE4            call	_inb
19751 595A           44                         inc	sp
19752 595B           44                         inc	sp
19753                                           !BCC_EOS
19754                                           ! 3163       write_byte(0x0040, 0x97, led_flags);
19755                                           ! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
19756 595C           8A46         FC            mov	al,-4[bp]
19757 595F           30E4                       xor	ah,ah
19758 5961           50                         push	ax
19759                                           ! Debug: list int = const $97 (used reg = )
19760 5962           B8                   0097  mov	ax,#$97
19761 5965           50                         push	ax
19762                                           ! Debug: list int = const $40 (used reg = )
19763 5966           B8                   0040  mov	ax,*$40
19764 5969           50                         push	ax
19765                                           ! Debug: func () void = write_byte+0 (used reg = )
19766 596A           E8         ACAD            call	_write_byte
19767 596D           83C4                   06  add	sp,*6
19768                                           !BCC_EOS
19769                                           ! 3164     }
19770                                           ! 3165 #asm
19771                       00005970            .433:
19772                                           !BCC_EOS
19773                                           !BCC_ASM
19774                       00000012            _int16_function.BP	set	$12
19775                       00000008            .int16_function.BP	set	8
19776                       00000005            _int16_function.count	set	5
19777                       FFFFFFFB            .int16_function.count	set	-5
19778                       0000001A            _int16_function.CX	set	$1A
19779                       00000010            .int16_function.CX	set	$10
19780                       00000008            _int16_function.ascii_code	set	8
19781                       FFFFFFFE            .int16_function.ascii_code	set	-2
19782                       0000000E            _int16_function.DI	set	$E
19783                       00000004            .int16_function.DI	set	4
19784                       0000001E            _int16_function.FLAGS	set	$1E
19785                       00000014            .int16_function.FLAGS	set	$14
19786                       00000002            _int16_function.kbd_code	set	2
19787                       FFFFFFF8            .int16_function.kbd_code	set	-8
19788                       00000009            _int16_function.scan_code	set	9
19789                       FFFFFFFF            .int16_function.scan_code	set	-1
19790                       00000018            _int16_function.DX	set	$18
19791                       0000000E            .int16_function.DX	set	$E
19792                       00000006            _int16_function.led_flags	set	6
19793                       FFFFFFFC            .int16_function.led_flags	set	-4
19794                       00000010            _int16_function.SI	set	$10
19795                       00000006            .int16_function.SI	set	6
19796                       0000001C            _int16_function.AX	set	$1C
19797                       00000012            .int16_function.AX	set	$12
19798                       00000014            _int16_function.SP	set	$14
19799                       0000000A            .int16_function.SP	set	$A
19800                       00000016            _int16_function.BX	set	$16
19801                       0000000C            .int16_function.BX	set	$C
19802                       00000007            _int16_function.shift_flags	set	7
19803                       FFFFFFFD            .int16_function.shift_flags	set	-3
19804                       00000000            _int16_function.max	set	0
19805                       FFFFFFF6            .int16_function.max	set	-$A
19806 5970           FB                             sti
19807                                           ! 3167 endasm
19808                                           !BCC_ENDASM
19809                                           !BCC_EOS
19810                                           ! 3168   }
19811                                           ! 3169   switch (( AX >> 8 )) {
19812                       00005971            .42D:
19813                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
19814 5971           8B46         12            mov	ax,$12[bp]
19815 5974           88E0                       mov	al,ah
19816 5976           30E4                       xor	ah,ah
19817 5978           E9         02EE            br 	.43B
19818                                           ! 3170     case 0x00:
19819                                           ! 3171       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
19820                       0000597B            .43C:
19821                                           ! Debug: list int = const 1 (used reg = )
19822 597B           B8                   0001  mov	ax,*1
19823 597E           50                         push	ax
19824                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
19825 597F           8D5E         FE            lea	bx,-2[bp]
19826 5982           53                         push	bx
19827                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
19828 5983           8D5E         FF            lea	bx,-1[bp]
19829 5986           53                         push	bx
19830                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
19831 5987           E8         032D            call	_dequeue_key
19832 598A           83C4                   06  add	sp,*6
19833 598D           85C0                       test	ax,ax
19834 598F           75           0E            jne 	.43D
19835                       00005991            .43E:
19836                                           ! 3172         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
19837                                           ! Debug: list * char = .43F+0 (used reg = )
19838 5991           BB                   D1DC  mov	bx,#.43F
19839 5994           53                         push	bx
19840                                           ! Debug: list int = const 7 (used reg = )
19841 5995           B8                   0007  mov	ax,*7
19842 5998           50                         push	ax
19843                                           ! Debug: func () void = bios_printf+0 (used reg = )
19844 5999           E8         B07F            call	_bios_printf
19845 599C           83C4                   04  add	sp,*4
19846                                           !BCC_EOS
19847                                           ! 3173         }
19848                                           ! 3174       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
19849                       0000599F            .43D:
19850                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
19851 599F           8A46         FF            mov	al,-1[bp]
19852 59A2           84C0                       test	al,al
19853 59A4           74           0E            je  	.440
19854                       000059A6            .442:
19855                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19856 59A6           8A46         FE            mov	al,-2[bp]
19857 59A9           3C                     F0  cmp	al,#$F0
19858 59AB           75           07            jne 	.440
19859                       000059AD            .441:
19860                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19861 59AD           30C0                       xor	al,al
19862 59AF           8846         FE            mov	-2[bp],al
19863                                           !BCC_EOS
19864                                           ! 3175       else if (ascii_code == 0xE0) ascii_code = 0;
19865 59B2           EB           0C            jmp .443
19866                       000059B4            .440:
19867                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19868 59B4           8A46         FE            mov	al,-2[bp]
19869 59B7           3C                     E0  cmp	al,#$E0
19870 59B9           75           05            jne 	.444
19871                       000059BB            .445:
19872                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19873 59BB           30C0                       xor	al,al
19874 59BD           8846         FE            mov	-2[bp],al
19875                                           !BCC_EOS
19876                                           ! 3176       AX = (scan_code << 8) | ascii_code;
19877                       000059C0            .444:
19878                       000059C0            .443:
19879                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
19880 59C0           8A46         FF            mov	al,-1[bp]
19881 59C3           30E4                       xor	ah,ah
19882 59C5           88C4                       mov	ah,al
19883 59C7           30C0                       xor	al,al
19884                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
19885 59C9           0A46         FE            or	al,-2[bp]
19886                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19887 59CC           8946         12            mov	$12[bp],ax
19888                                           !BCC_EOS
19889                                           ! 3177       break;
19890 59CF           E9         02E1            br 	.439
19891                                           !BCC_EOS
19892                                           ! 3178     case 0x01:
19893                                           ! 3179       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
19894                       000059D2            .446:
19895                                           ! Debug: list int = const 0 (used reg = )
19896 59D2           31C0                       xor	ax,ax
19897 59D4           50                         push	ax
19898                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
19899 59D5           8D5E         FE            lea	bx,-2[bp]
19900 59D8           53                         push	bx
19901                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
19902 59D9           8D5E         FF            lea	bx,-1[bp]
19903 59DC           53                         push	bx
19904                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
19905 59DD           E8         02D7            call	_dequeue_key
19906 59E0           83C4                   06  add	sp,*6
19907 59E3           85C0                       test	ax,ax
19908 59E5           75           0C            jne 	.447
19909                       000059E7            .448:
19910                                           ! 3180         FLAGS |= 0x0040;
19911                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
19912 59E7           8B46         14            mov	ax,$14[bp]
19913 59EA           0C                     40  or	al,*$40
19914 59EC           8946         14            mov	$14[bp],ax
19915                                           !BCC_EOS
19916                                           ! 3181         return;
19917 59EF           89EC                       mov	sp,bp
19918 59F1           5D                         pop	bp
19919 59F2           C3                         ret
19920                                           !BCC_EOS
19921                                           ! 3182         }
19922                                           ! 3183       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
19923                       000059F3            .447:
19924                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
19925 59F3           8A46         FF            mov	al,-1[bp]
19926 59F6           84C0                       test	al,al
19927 59F8           74           0E            je  	.449
19928                       000059FA            .44B:
19929                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19930 59FA           8A46         FE            mov	al,-2[bp]
19931 59FD           3C                     F0  cmp	al,#$F0
19932 59FF           75           07            jne 	.449
19933                       00005A01            .44A:
19934                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19935 5A01           30C0                       xor	al,al
19936 5A03           8846         FE            mov	-2[bp],al
19937                                           !BCC_EOS
19938                                           ! 3184       else if (ascii_code == 0xE0) ascii_code = 0;
19939 5A06           EB           0C            jmp .44C
19940                       00005A08            .449:
19941                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19942 5A08           8A46         FE            mov	al,-2[bp]
19943 5A0B           3C                     E0  cmp	al,#$E0
19944 5A0D           75           05            jne 	.44D
19945                       00005A0F            .44E:
19946                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19947 5A0F           30C0                       xor	al,al
19948 5A11           8846         FE            mov	-2[bp],al
19949                                           !BCC_EOS
19950                                           ! 3185       AX = (scan_code << 8) | ascii_code;
19951                       00005A14            .44D:
19952                       00005A14            .44C:
19953                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
19954 5A14           8A46         FF            mov	al,-1[bp]
19955 5A17           30E4                       xor	ah,ah
19956 5A19           88C4                       mov	ah,al
19957 5A1B           30C0                       xor	al,al
19958                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
19959 5A1D           0A46         FE            or	al,-2[bp]
19960                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19961 5A20           8946         12            mov	$12[bp],ax
19962                                           !BCC_EOS
19963                                           ! 3186       FLAGS &= 0xffbf;
19964                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
19965 5A23           8B46         14            mov	ax,$14[bp]
19966 5A26           24                     BF  and	al,#$BF
19967 5A28           8946         14            mov	$14[bp],ax
19968                                           !BCC_EOS
19969                                           ! 3187       break;
19970 5A2B           E9         0285            br 	.439
19971                                           !BCC_EOS
19972                                           ! 3188     case 0x02:
19973                                           ! 3189       shift_flags = read_byte(0x0040, 0x17);
19974                       00005A2E            .44F:
19975                                           ! Debug: list int = const $17 (used reg = )
19976 5A2E           B8                   0017  mov	ax,*$17
19977 5A31           50                         push	ax
19978                                           ! Debug: list int = const $40 (used reg = )
19979 5A32           B8                   0040  mov	ax,*$40
19980 5A35           50                         push	ax
19981                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19982 5A36           E8         ABBB            call	_read_byte
19983 5A39           83C4                   04  add	sp,*4
19984                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
19985 5A3C           8846         FD            mov	-3[bp],al
19986                                           !BCC_EOS
19987                                           ! 3190       AX = ((AX & 0xff00) | (shift_flags));
19988                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
19989 5A3F           8B46         12            mov	ax,$12[bp]
19990 5A42           30C0                       xor	al,al
19991                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
19992 5A44           0A46         FD            or	al,-3[bp]
19993                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19994 5A47           8946         12            mov	$12[bp],ax
19995                                           !BCC_EOS
19996                                           ! 3191       break;
19997 5A4A           E9         0266            br 	.439
19998                                           !BCC_EOS
19999                                           ! 3192     case 0x05:
20000                                           ! 3193       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
20001                       00005A4D            .450:
20002                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
20003 5A4D           8A46         10            mov	al,$10[bp]
20004                                           ! Debug: list unsigned char = al+0 (used reg = )
20005 5A50           30E4                       xor	ah,ah
20006 5A52           50                         push	ax
20007                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
20008 5A53           8B46         10            mov	ax,$10[bp]
20009 5A56           88E0                       mov	al,ah
20010 5A58           30E4                       xor	ah,ah
20011                                           ! Debug: list unsigned int = ax+0 (used reg = )
20012 5A5A           50                         push	ax
20013                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20014 5A5B           E8         0BD7            call	_enqueue_key
20015 5A5E           83C4                   04  add	sp,*4
20016 5A61           85C0                       test	ax,ax
20017 5A63           75           0C            jne 	.451
20018                       00005A65            .452:
20019                                           ! 3194         AX = ((AX & 0xff00) | (1));
20020                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20021 5A65           8B46         12            mov	ax,$12[bp]
20022 5A68           30C0                       xor	al,al
20023                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
20024 5A6A           0C                     01  or	al,*1
20025                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20026 5A6C           8946         12            mov	$12[bp],ax
20027                                           !BCC_EOS
20028                                           ! 3195         }
20029                                           ! 3196       else {
20030 5A6F           EB           0A            jmp .453
20031                       00005A71            .451:
20032                                           ! 3197         AX = ((AX & 0xff00) | (0));
20033                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20034 5A71           8B46         12            mov	ax,$12[bp]
20035 5A74           30C0                       xor	al,al
20036                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
20037 5A76           0C                     00  or	al,*0
20038                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20039 5A78           8946         12            mov	$12[bp],ax
20040                                           !BCC_EOS
20041                                           ! 3198         }
20042                                           ! 3199       break;
20043                       00005A7B            .453:
20044 5A7B           E9         0235            br 	.439
20045                                           !BCC_EOS
20046                                           ! 3200     case 0x09:
20047                                           ! 3201       AX = ((AX & 0xff00) | (0x30));
20048                       00005A7E            .454:
20049                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20050 5A7E           8B46         12            mov	ax,$12[bp]
20051 5A81           30C0                       xor	al,al
20052                                           ! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
20053 5A83           0C                     30  or	al,*$30
20054                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20055 5A85           8946         12            mov	$12[bp],ax
20056                                           !BCC_EOS
20057                                           ! 3202       break;
20058 5A88           E9         0228            br 	.439
20059                                           !BCC_EOS
20060                                           ! 3203     case 0x0A:
20061                                           ! 3204       count = 2;
20062                       00005A8B            .455:
20063                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
20064 5A8B           B0                     02  mov	al,*2
20065 5A8D           8846         FB            mov	-5[bp],al
20066                                           !BCC_EOS
20067                                           ! 3205       kbd_code = 0x0;
20068                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20069 5A90           31C0                       xor	ax,ax
20070 5A92           8946         F8            mov	-8[bp],ax
20071                                           !BCC_EOS
20072                                           ! 3206       outb(0x60, 0xf2);
20073                                           ! Debug: list int = const $F2 (used reg = )
20074 5A95           B8                   00F2  mov	ax,#$F2
20075 5A98           50                         push	ax
20076                                           ! Debug: list int = const $60 (used reg = )
20077 5A99           B8                   0060  mov	ax,*$60
20078 5A9C           50                         push	ax
20079                                           ! Debug: func () void = outb+0 (used reg = )
20080 5A9D           E8         AAB4            call	_outb
20081 5AA0           83C4                   04  add	sp,*4
20082                                           !BCC_EOS
20083                                           ! 3207       max=0xffff;
20084                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20085 5AA3           B8                   FFFF  mov	ax,#$FFFF
20086 5AA6           8946         F6            mov	-$A[bp],ax
20087                                           !BCC_EOS
20088                                           ! 3208       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20089 5AA9           EB           0D            jmp .457
20090                       00005AAB            .458:
20091                                           ! Debug: list int = const 0 (used reg = )
20092 5AAB           31C0                       xor	ax,ax
20093 5AAD           50                         push	ax
20094                                           ! Debug: list int = const $80 (used reg = )
20095 5AAE           B8                   0080  mov	ax,#$80
20096 5AB1           50                         push	ax
20097                                           ! Debug: func () void = outb+0 (used reg = )
20098 5AB2           E8         AA9F            call	_outb
20099 5AB5           83C4                   04  add	sp,*4
20100                                           !BCC_EOS
20101                                           ! 3209       if (max>0x0) {
20102                       00005AB8            .457:
20103                                           ! Debug: list int = const $64 (used reg = )
20104 5AB8           B8                   0064  mov	ax,*$64
20105 5ABB           50                         push	ax
20106                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20107 5ABC           E8         AA7F            call	_inb
20108 5ABF           44                         inc	sp
20109 5AC0           44                         inc	sp
20110                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20111 5AC1           24                     01  and	al,*1
20112                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20113 5AC3           84C0                       test	al,al
20114 5AC5           75           0B            jne 	.459
20115                       00005AC7            .45A:
20116                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20117 5AC7           8B46         F6            mov	ax,-$A[bp]
20118 5ACA           48                         dec	ax
20119 5ACB           8946         F6            mov	-$A[bp],ax
20120                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20121 5ACE           85C0                       test	ax,ax
20122 5AD0           75           D9            jne	.458
20123                       00005AD2            .459:
20124                       00005AD2            .456:
20125                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20126 5AD2           8B46         F6            mov	ax,-$A[bp]
20127 5AD5           85C0                       test	ax,ax
20128 5AD7         0F84         006D            beq 	.45B
20129                       00005ADB            .45C:
20130                                           ! 3210         if ((inb(0x60) == 0xfa)) {
20131                                           ! Debug: list int = const $60 (used reg = )
20132 5ADB           B8                   0060  mov	ax,*$60
20133 5ADE           50                         push	ax
20134                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20135 5ADF           E8         AA5C            call	_inb
20136 5AE2           44                         inc	sp
20137 5AE3           44                         inc	sp
20138                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
20139 5AE4           3C                     FA  cmp	al,#$FA
20140 5AE6           75           60            jne 	.45D
20141                       00005AE8            .45E:
20142                                           ! 3211           do {
20143                       00005AE8            .461:
20144                                           ! 3212             max=0xffff;
20145                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20146 5AE8           B8                   FFFF  mov	ax,#$FFFF
20147 5AEB           8946         F6            mov	-$A[bp],ax
20148                                           !BCC_EOS
20149                                           ! 3213             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20150 5AEE           EB           0D            jmp .463
20151                       00005AF0            .464:
20152                                           ! Debug: list int = const 0 (used reg = )
20153 5AF0           31C0                       xor	ax,ax
20154 5AF2           50                         push	ax
20155                                           ! Debug: list int = const $80 (used reg = )
20156 5AF3           B8                   0080  mov	ax,#$80
20157 5AF6           50                         push	ax
20158                                           ! Debug: func () void = outb+0 (used reg = )
20159 5AF7           E8         AA5A            call	_outb
20160 5AFA           83C4                   04  add	sp,*4
20161                                           !BCC_EOS
20162                                           ! 3214             if (max>0x0) {
20163                       00005AFD            .463:
20164                                           ! Debug: list int = const $64 (used reg = )
20165 5AFD           B8                   0064  mov	ax,*$64
20166 5B00           50                         push	ax
20167                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20168 5B01           E8         AA3A            call	_inb
20169 5B04           44                         inc	sp
20170 5B05           44                         inc	sp
20171                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20172 5B06           24                     01  and	al,*1
20173                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20174 5B08           84C0                       test	al,al
20175 5B0A           75           0B            jne 	.465
20176                       00005B0C            .466:
20177                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20178 5B0C           8B46         F6            mov	ax,-$A[bp]
20179 5B0F           48                         dec	ax
20180 5B10           8946         F6            mov	-$A[bp],ax
20181                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20182 5B13           85C0                       test	ax,ax
20183 5B15           75           D9            jne	.464
20184                       00005B17            .465:
20185                       00005B17            .462:
20186                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20187 5B17           8B46         F6            mov	ax,-$A[bp]
20188 5B1A           85C0                       test	ax,ax
20189 5B1C           74           1F            je  	.467
20190                       00005B1E            .468:
20191                                           ! 3215               kbd_code >>= 8;
20192                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20193 5B1E           8B46         F8            mov	ax,-8[bp]
20194 5B21           88E0                       mov	al,ah
20195 5B23           30E4                       xor	ah,ah
20196 5B25           8946         F8            mov	-8[bp],ax
20197                                           !BCC_EOS
20198                                           ! 3216               kbd_code |= (inb(0x60) << 8);
20199                                           ! Debug: list int = const $60 (used reg = )
20200 5B28           B8                   0060  mov	ax,*$60
20201 5B2B           50                         push	ax
20202                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20203 5B2C           E8         AA0F            call	_inb
20204 5B2F           44                         inc	sp
20205 5B30           44                         inc	sp
20206                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
20207 5B31           30E4                       xor	ah,ah
20208 5B33           88C4                       mov	ah,al
20209 5B35           30C0                       xor	al,al
20210                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20211 5B37           0B46         F8            or	ax,-8[bp]
20212 5B3A           8946         F8            mov	-8[bp],ax
20213                                           !BCC_EOS
20214                                           ! 3217             }
20215                                           ! 3218           } while (--count>0);
20216                       00005B3D            .467:
20217                       00005B3D            .460:
20218                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
20219 5B3D           8A46         FB            mov	al,-5[bp]
20220 5B40           48                         dec	ax
20221 5B41           8846         FB            mov	-5[bp],al
20222                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20223 5B44           84C0                       test	al,al
20224 5B46           75           A0            jne	.461
20225                       00005B48            .469:
20226                                           !BCC_EOS
20227                                           ! 3219         }
20228                       00005B48            .45F:
20229                                           ! 3220       }
20230                       00005B48            .45D:
20231                                           ! 3221       BX=kbd_code;
20232                       00005B48            .45B:
20233                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
20234 5B48           8B46         F8            mov	ax,-8[bp]
20235 5B4B           8946         0C            mov	$C[bp],ax
20236                                           !BCC_EOS
20237                                           ! 3222       break;
20238 5B4E           E9         0162            br 	.439
20239                                           !BCC_EOS
20240                                           ! 3223     case 0x10:
20241                                           ! 3224       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20242                       00005B51            .46A:
20243                                           ! Debug: list int = const 1 (used reg = )
20244 5B51           B8                   0001  mov	ax,*1
20245 5B54           50                         push	ax
20246                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20247 5B55           8D5E         FE            lea	bx,-2[bp]
20248 5B58           53                         push	bx
20249                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20250 5B59           8D5E         FF            lea	bx,-1[bp]
20251 5B5C           53                         push	bx
20252                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20253 5B5D           E8         0157            call	_dequeue_key
20254 5B60           83C4                   06  add	sp,*6
20255 5B63           85C0                       test	ax,ax
20256 5B65           75           0E            jne 	.46B
20257                       00005B67            .46C:
20258                                           ! 3225         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard in
20259                                           ! 3225 put\n");
20260                                           ! Debug: list * char = .46D+0 (used reg = )
20261 5B67           BB                   D1B8  mov	bx,#.46D
20262 5B6A           53                         push	bx
20263                                           ! Debug: list int = const 7 (used reg = )
20264 5B6B           B8                   0007  mov	ax,*7
20265 5B6E           50                         push	ax
20266                                           ! Debug: func () void = bios_printf+0 (used reg = )
20267 5B6F           E8         AEA9            call	_bios_printf
20268 5B72           83C4                   04  add	sp,*4
20269                                           !BCC_EOS
20270                                           ! 3226         }
20271                                           ! 3227       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20272                       00005B75            .46B:
20273                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20274 5B75           8A46         FF            mov	al,-1[bp]
20275 5B78           84C0                       test	al,al
20276 5B7A           74           0C            je  	.46E
20277                       00005B7C            .470:
20278                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20279 5B7C           8A46         FE            mov	al,-2[bp]
20280 5B7F           3C                     F0  cmp	al,#$F0
20281 5B81           75           05            jne 	.46E
20282                       00005B83            .46F:
20283                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20284 5B83           30C0                       xor	al,al
20285 5B85           8846         FE            mov	-2[bp],al
20286                                           !BCC_EOS
20287                                           ! 3228       AX = (scan_code << 8) | ascii_code;
20288                       00005B88            .46E:
20289                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20290 5B88           8A46         FF            mov	al,-1[bp]
20291 5B8B           30E4                       xor	ah,ah
20292 5B8D           88C4                       mov	ah,al
20293 5B8F           30C0                       xor	al,al
20294                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20295 5B91           0A46         FE            or	al,-2[bp]
20296                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20297 5B94           8946         12            mov	$12[bp],ax
20298                                           !BCC_EOS
20299                                           ! 3229       break;
20300 5B97           E9         0119            br 	.439
20301                                           !BCC_EOS
20302                                           ! 3230     case 0x11:
20303                                           ! 3231       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20304                       00005B9A            .471:
20305                                           ! Debug: list int = const 0 (used reg = )
20306 5B9A           31C0                       xor	ax,ax
20307 5B9C           50                         push	ax
20308                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20309 5B9D           8D5E         FE            lea	bx,-2[bp]
20310 5BA0           53                         push	bx
20311                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20312 5BA1           8D5E         FF            lea	bx,-1[bp]
20313 5BA4           53                         push	bx
20314                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20315 5BA5           E8         010F            call	_dequeue_key
20316 5BA8           83C4                   06  add	sp,*6
20317 5BAB           85C0                       test	ax,ax
20318 5BAD           75           0C            jne 	.472
20319                       00005BAF            .473:
20320                                           ! 3232         FLAGS |= 0x0040;
20321                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20322 5BAF           8B46         14            mov	ax,$14[bp]
20323 5BB2           0C                     40  or	al,*$40
20324 5BB4           8946         14            mov	$14[bp],ax
20325                                           !BCC_EOS
20326                                           ! 3233         return;
20327 5BB7           89EC                       mov	sp,bp
20328 5BB9           5D                         pop	bp
20329 5BBA           C3                         ret
20330                                           !BCC_EOS
20331                                           ! 3234         }
20332                                           ! 3235       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20333                       00005BBB            .472:
20334                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20335 5BBB           8A46         FF            mov	al,-1[bp]
20336 5BBE           84C0                       test	al,al
20337 5BC0           74           0C            je  	.474
20338                       00005BC2            .476:
20339                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20340 5BC2           8A46         FE            mov	al,-2[bp]
20341 5BC5           3C                     F0  cmp	al,#$F0
20342 5BC7           75           05            jne 	.474
20343                       00005BC9            .475:
20344                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20345 5BC9           30C0                       xor	al,al
20346 5BCB           8846         FE            mov	-2[bp],al
20347                                           !BCC_EOS
20348                                           ! 3236       AX = (scan_code << 8) | ascii_code;
20349                       00005BCE            .474:
20350                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20351 5BCE           8A46         FF            mov	al,-1[bp]
20352 5BD1           30E4                       xor	ah,ah
20353 5BD3           88C4                       mov	ah,al
20354 5BD5           30C0                       xor	al,al
20355                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20356 5BD7           0A46         FE            or	al,-2[bp]
20357                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20358 5BDA           8946         12            mov	$12[bp],ax
20359                                           !BCC_EOS
20360                                           ! 3237       FLAGS &= 0xffbf;
20361                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20362 5BDD           8B46         14            mov	ax,$14[bp]
20363 5BE0           24                     BF  and	al,#$BF
20364 5BE2           8946         14            mov	$14[bp],ax
20365                                           !BCC_EOS
20366                                           ! 3238       break;
20367 5BE5           E9         00CB            br 	.439
20368                                           !BCC_EOS
20369                                           ! 3239     case 0x12:
20370                                           ! 3240       shift_flags = read_byte(0x0040, 0x17);
20371                       00005BE8            .477:
20372                                           ! Debug: list int = const $17 (used reg = )
20373 5BE8           B8                   0017  mov	ax,*$17
20374 5BEB           50                         push	ax
20375                                           ! Debug: list int = const $40 (used reg = )
20376 5BEC           B8                   0040  mov	ax,*$40
20377 5BEF           50                         push	ax
20378                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20379 5BF0           E8         AA01            call	_read_byte
20380 5BF3           83C4                   04  add	sp,*4
20381                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20382 5BF6           8846         FD            mov	-3[bp],al
20383                                           !BCC_EOS
20384                                           ! 3241       AX = ((AX & 0xff00) | (shift_flags));
20385                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20386 5BF9           8B46         12            mov	ax,$12[bp]
20387 5BFC           30C0                       xor	al,al
20388                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20389 5BFE           0A46         FD            or	al,-3[bp]
20390                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20391 5C01           8946         12            mov	$12[bp],ax
20392                                           !BCC_EOS
20393                                           ! 3242       shift_flags = read_byte(0x0040, 0x18) & 0x73;
20394                                           ! Debug: list int = const $18 (used reg = )
20395 5C04           B8                   0018  mov	ax,*$18
20396 5C07           50                         push	ax
20397                                           ! Debug: list int = const $40 (used reg = )
20398 5C08           B8                   0040  mov	ax,*$40
20399 5C0B           50                         push	ax
20400                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20401 5C0C           E8         A9E5            call	_read_byte
20402 5C0F           83C4                   04  add	sp,*4
20403                                           ! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
20404 5C12           24                     73  and	al,*$73
20405                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20406 5C14           8846         FD            mov	-3[bp],al
20407                                           !BCC_EOS
20408                                           ! 3243       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
20409                                           ! Debug: list int = const $96 (used reg = )
20410 5C17           B8                   0096  mov	ax,#$96
20411 5C1A           50                         push	ax
20412                                           ! Debug: list int = const $40 (used reg = )
20413 5C1B           B8                   0040  mov	ax,*$40
20414 5C1E           50                         push	ax
20415                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20416 5C1F           E8         A9D2            call	_read_byte
20417 5C22           83C4                   04  add	sp,*4
20418                                           ! Debug: and int = const $C to unsigned char = al+0 (used reg = )
20419 5C25           24                     0C  and	al,*$C
20420                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20421 5C27           0A46         FD            or	al,-3[bp]
20422 5C2A           8846         FD            mov	-3[bp],al
20423                                           !BCC_EOS
20424                                           ! 3244       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
20425                                           ! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
20426 5C2D           8A46         FD            mov	al,-3[bp]
20427 5C30           30E4                       xor	ah,ah
20428 5C32           88C4                       mov	ah,al
20429 5C34           30C0                       xor	al,al
20430 5C36           50                         push	ax
20431                                           ! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
20432 5C37           8A46         12            mov	al,$12[bp]
20433                                           ! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20434 5C3A           30E4                       xor	ah,ah
20435 5C3C           0B46         F4            or	ax,0+..FFF3[bp]
20436 5C3F           44                         inc	sp
20437 5C40           44                         inc	sp
20438                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20439 5C41           8946         12            mov	$12[bp],ax
20440                                           !BCC_EOS
20441                                           ! 3245       ;
20442                                           !BCC_EOS
20443                                           ! 3246       break;
20444 5C44           EB           6D            jmp .439
20445                                           !BCC_EOS
20446                                           ! 3247     case 0x92:
20447                                           ! 3248       AX = ((AX & 0x00ff) | ((0x80) << 8));
20448                       00005C46            .478:
20449                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20450 5C46           8A46         12            mov	al,$12[bp]
20451                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
20452 5C49           30E4                       xor	ah,ah
20453 5C4B           0D                   8000  or	ax,#-$8000
20454                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20455 5C4E           8946         12            mov	$12[bp],ax
20456                                           !BCC_EOS
20457                                           ! 3249       break;
20458 5C51           EB           60            jmp .439
20459                                           !BCC_EOS
20460                                           ! 3250     case 0xA2:
20461                                           ! 3251       break;
20462                       00005C53            .479:
20463 5C53           EB           5E            jmp .439
20464                                           !BCC_EOS
20465                                           ! 3252     case 0x6F:
20466                                           ! 3253       if (( AX & 0x00ff ) == 0x08)
20467                       00005C55            .47A:
20468                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20469 5C55           8A46         12            mov	al,$12[bp]
20470                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
20471 5C58           3C                     08  cmp	al,*8
20472 5C5A           75           0B            jne 	.47B
20473                       00005C5C            .47C:
20474                                           ! 3254         AX = ((AX & 0x00ff) | ((0x02) << 8));
20475                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20476 5C5C           8A46         12            mov	al,$12[bp]
20477                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
20478 5C5F           30E4                       xor	ah,ah
20479 5C61           0D                   0200  or	ax,#$200
20480                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20481 5C64           8946         12            mov	$12[bp],ax
20482                                           !BCC_EOS
20483                                           ! 3255     default:
20484                       00005C67            .47B:
20485                                           ! 3256       ;
20486                       00005C67            .47D:
20487                                           !BCC_EOS
20488                                           ! 3257     }
20489                                           ! 3258 }
20490 5C67           EB           4A            jmp .439
20491                       00005C69            .43B:
20492 5C69           2D                   0000  sub	ax,*0
20493 5C6C           7C           F9            jl 	.47D
20494 5C6E           3D                   0012  cmp	ax,*$12
20495 5C71           77           2F            ja  	.47E
20496 5C73           D1E0                       shl	ax,*1
20497 5C75           89C3                       mov	bx,ax
20498 5C77           2E                         seg	cs
20499 5C78           FFA7       5C7C            br	.47F[bx]
20500                       00005C7C            .47F:
20501 5C7C                      597B            .word	.43C
20502 5C7E                      59D2            .word	.446
20503 5C80                      5A2E            .word	.44F
20504 5C82                      5C67            .word	.47D
20505 5C84                      5C67            .word	.47D
20506 5C86                      5A4D            .word	.450
20507 5C88                      5C67            .word	.47D
20508 5C8A                      5C67            .word	.47D
20509 5C8C                      5C67            .word	.47D
20510 5C8E                      5A7E            .word	.454
20511 5C90                      5A8B            .word	.455
20512 5C92                      5C67            .word	.47D
20513 5C94                      5C67            .word	.47D
20514 5C96                      5C67            .word	.47D
20515 5C98                      5C67            .word	.47D
20516 5C9A                      5C67            .word	.47D
20517 5C9C                      5B51            .word	.46A
20518 5C9E                      5B9A            .word	.471
20519 5CA0                      5BE8            .word	.477
20520                       00005CA2            .47E:
20521 5CA2           2D                   006F  sub	ax,*$6F
20522 5CA5           74           AE            je 	.47A
20523 5CA7           2D                   0023  sub	ax,*$23
20524 5CAA           74           9A            je 	.478
20525 5CAC           2D                   0010  sub	ax,*$10
20526 5CAF           74           A2            je 	.479
20527 5CB1           EB           B4            jmp	.47D
20528                       00005CB3            .439:
20529                       FFFFFFF4            ..FFF3	=	-$C
20530 5CB3           89EC                       mov	sp,bp
20531 5CB5           5D                         pop	bp
20532 5CB6           C3                         ret
20533                                           ! 3259   unsigned int
20534                                           ! Register BX used in function int16_function
20535                                           ! 3260 dequeue_key(scan_code, ascii_code, incr)
20536                                           ! 3261   Bit8u *scan_code;
20537                                           export	_dequeue_key
20538                       00005CB7            _dequeue_key:
20539                                           !BCC_EOS
20540                                           ! 3262   Bit8u *ascii_code;
20541                                           !BCC_EOS
20542                                           ! 3263   unsigned int incr;
20543                                           !BCC_EOS
20544                                           ! 3264 {
20545                                           ! 3265   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
20546                                           !BCC_EOS
20547                                           ! 3266   Bit16u ss;
20548                                           !BCC_EOS
20549                                           ! 3267   Bit8u acode, scode;
20550                                           !BCC_EOS
20551                                           ! 3268   buffer_start = read_word(0x0040, 0x0080);
20552 5CB7           55                         push	bp
20553 5CB8           89E5                       mov	bp,sp
20554 5CBA           83C4                   F4  add	sp,*-$C
20555                                           ! Debug: list int = const $80 (used reg = )
20556 5CBD           B8                   0080  mov	ax,#$80
20557 5CC0           50                         push	ax
20558                                           ! Debug: list int = const $40 (used reg = )
20559 5CC1           B8                   0040  mov	ax,*$40
20560 5CC4           50                         push	ax
20561                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20562 5CC5           E8         A93F            call	_read_word
20563 5CC8           83C4                   04  add	sp,*4
20564                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
20565 5CCB           8946         FE            mov	-2[bp],ax
20566                                           !BCC_EOS
20567                                           ! 3269   buffer_end = read_word(0x0040, 0x0082);
20568                                           ! Debug: list int = const $82 (used reg = )
20569 5CCE           B8                   0082  mov	ax,#$82
20570 5CD1           50                         push	ax
20571                                           ! Debug: list int = const $40 (used reg = )
20572 5CD2           B8                   0040  mov	ax,*$40
20573 5CD5           50                         push	ax
20574                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20575 5CD6           E8         A92E            call	_read_word
20576 5CD9           83C4                   04  add	sp,*4
20577                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
20578 5CDC           8946         FC            mov	-4[bp],ax
20579                                           !BCC_EOS
20580                                           ! 3270   buffer_head = read_word(0x0040, 0x001a);
20581                                           ! Debug: list int = const $1A (used reg = )
20582 5CDF           B8                   001A  mov	ax,*$1A
20583 5CE2           50                         push	ax
20584                                           ! Debug: list int = const $40 (used reg = )
20585 5CE3           B8                   0040  mov	ax,*$40
20586 5CE6           50                         push	ax
20587                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20588 5CE7           E8         A91D            call	_read_word
20589 5CEA           83C4                   04  add	sp,*4
20590                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
20591 5CED           8946         FA            mov	-6[bp],ax
20592                                           !BCC_EOS
20593                                           ! 3271   buffer_tail = read_word(0x0040, 0x001c);
20594                                           ! Debug: list int = const $1C (used reg = )
20595 5CF0           B8                   001C  mov	ax,*$1C
20596 5CF3           50                         push	ax
20597                                           ! Debug: list int = const $40 (used reg = )
20598 5CF4           B8                   0040  mov	ax,*$40
20599 5CF7           50                         push	ax
20600                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20601 5CF8           E8         A90C            call	_read_word
20602 5CFB           83C4                   04  add	sp,*4
20603                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20604 5CFE           8946         F8            mov	-8[bp],ax
20605                                           !BCC_EOS
20606                                           ! 3272   if (buffer_head != buffer_tail) {
20607                                           ! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20608 5D01           8B46         FA            mov	ax,-6[bp]
20609 5D04           3B46         F8            cmp	ax,-8[bp]
20610 5D07         0F84         0083            beq 	.480
20611                       00005D0B            .481:
20612                                           ! 3273     ss = get_SS();
20613                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
20614 5D0B           E8         A93F            call	_get_SS
20615                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
20616 5D0E           8946         F6            mov	-$A[bp],ax
20617                                           !BCC_EOS
20618                                           ! 3274     acode = read_byte(0x0040, buffer_head);
20619                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
20620 5D11           FF76         FA            push	-6[bp]
20621                                           ! Debug: list int = const $40 (used reg = )
20622 5D14           B8                   0040  mov	ax,*$40
20623 5D17           50                         push	ax
20624                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20625 5D18           E8         A8D9            call	_read_byte
20626 5D1B           83C4                   04  add	sp,*4
20627                                           ! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
20628 5D1E           8846         F5            mov	-$B[bp],al
20629                                           !BCC_EOS
20630                                           ! 3275     scode = read_byte(0x0040, buffer_head+1);
20631                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
20632 5D21           8B46         FA            mov	ax,-6[bp]
20633                                           ! Debug: list unsigned int = ax+1 (used reg = )
20634 5D24           40                         inc	ax
20635 5D25           50                         push	ax
20636                                           ! Debug: list int = const $40 (used reg = )
20637 5D26           B8                   0040  mov	ax,*$40
20638 5D29           50                         push	ax
20639                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20640 5D2A           E8         A8C7            call	_read_byte
20641 5D2D           83C4                   04  add	sp,*4
20642                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
20643 5D30           8846         F4            mov	-$C[bp],al
20644                                           !BCC_EOS
20645                                           ! 3276     write_byte(ss, ascii_code, acode);
20646                                           ! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
20647 5D33           8A46         F5            mov	al,-$B[bp]
20648 5D36           30E4                       xor	ah,ah
20649 5D38           50                         push	ax
20650                                           ! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
20651 5D39           FF76         06            push	6[bp]
20652                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20653 5D3C           FF76         F6            push	-$A[bp]
20654                                           ! Debug: func () void = write_byte+0 (used reg = )
20655 5D3F           E8         A8D8            call	_write_byte
20656 5D42           83C4                   06  add	sp,*6
20657                                           !BCC_EOS
20658                                           ! 3277     write_byte(ss, scan_code, scode);
20659                                           ! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
20660 5D45           8A46         F4            mov	al,-$C[bp]
20661 5D48           30E4                       xor	ah,ah
20662 5D4A           50                         push	ax
20663                                           ! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
20664 5D4B           FF76         04            push	4[bp]
20665                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20666 5D4E           FF76         F6            push	-$A[bp]
20667                                           ! Debug: func () void = write_byte+0 (used reg = )
20668 5D51           E8         A8C6            call	_write_byte
20669 5D54           83C4                   06  add	sp,*6
20670                                           !BCC_EOS
20671                                           ! 3278     if (incr) {
20672 5D57           8B46         08            mov	ax,8[bp]
20673 5D5A           85C0                       test	ax,ax
20674 5D5C           74           27            je  	.482
20675                       00005D5E            .483:
20676                                           ! 3279       buffer_head += 2;
20677                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
20678 5D5E           8B46         FA            mov	ax,-6[bp]
20679 5D61           40                         inc	ax
20680 5D62           40                         inc	ax
20681 5D63           8946         FA            mov	-6[bp],ax
20682                                           !BCC_EOS
20683                                           ! 3280       if (buffer_head >= buffer_end)
20684                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
20685 5D66           8B46         FA            mov	ax,-6[bp]
20686 5D69           3B46         FC            cmp	ax,-4[bp]
20687 5D6C           72           06            jb  	.484
20688                       00005D6E            .485:
20689                                           ! 3281         buffer_head = buffer_start;
20690                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
20691 5D6E           8B46         FE            mov	ax,-2[bp]
20692 5D71           8946         FA            mov	-6[bp],ax
20693                                           !BCC_EOS
20694                                           ! 3282       write_word(0x0040, 0x001a, buffer_head);
20695                       00005D74            .484:
20696                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
20697 5D74           FF76         FA            push	-6[bp]
20698                                           ! Debug: list int = const $1A (used reg = )
20699 5D77           B8                   001A  mov	ax,*$1A
20700 5D7A           50                         push	ax
20701                                           ! Debug: list int = const $40 (used reg = )
20702 5D7B           B8                   0040  mov	ax,*$40
20703 5D7E           50                         push	ax
20704                                           ! Debug: func () void = write_word+0 (used reg = )
20705 5D7F           E8         A8B0            call	_write_word
20706 5D82           83C4                   06  add	sp,*6
20707                                           !BCC_EOS
20708                                           ! 3283       }
20709                                           ! 3284     return(1);
20710                       00005D85            .482:
20711 5D85           B8                   0001  mov	ax,*1
20712 5D88           89EC                       mov	sp,bp
20713 5D8A           5D                         pop	bp
20714 5D8B           C3                         ret
20715                                           !BCC_EOS
20716                                           ! 3285     }
20717                                           ! 3286   else {
20718 5D8C           EB           06            jmp .486
20719                       00005D8E            .480:
20720                                           ! 3287     return(0);
20721 5D8E           31C0                       xor	ax,ax
20722 5D90           89EC                       mov	sp,bp
20723 5D92           5D                         pop	bp
20724 5D93           C3                         ret
20725                                           !BCC_EOS
20726                                           ! 3288     }
20727                                           ! 3289 }
20728                       00005D94            .486:
20729 5D94           89EC                       mov	sp,bp
20730 5D96           5D                         pop	bp
20731 5D97           C3                         ret
20732                                           ! 3290 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
20733                                           
20734                       00005D98            _panic_msg_keyb_buffer_full:
20735                       00005D98            .487:
20736 5D98                        25            .ascii	"%s: keyboard input buffer full"
20737 5DB6                        0A            .byte	$A
20738 5DB7                        00            .byte	0
20739                                           !BCC_EOS
20740                                           ! 3291   Bit8u
20741                                           ! 3292 inhibit_mouse_int_and_events()
20742                                           ! 3293 {
20743                                           
20744                                           export	_inhibit_mouse_int_and_events
20745                       00005DB8            _inhibit_mouse_int_and_events:
20746                                           ! 3294   Bit8u command_byte, prev_command_byte;
20747                                           !BCC_EOS
20748                                           ! 3295   if ( inb(0x64) & 0x02 )
20749 5DB8           55                         push	bp
20750 5DB9           89E5                       mov	bp,sp
20751 5DBB           4C                         dec	sp
20752 5DBC           4C                         dec	sp
20753                                           ! Debug: list int = const $64 (used reg = )
20754 5DBD           B8                   0064  mov	ax,*$64
20755 5DC0           50                         push	ax
20756                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20757 5DC1           E8         A77A            call	_inb
20758 5DC4           44                         inc	sp
20759 5DC5           44                         inc	sp
20760                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20761 5DC6           24                     02  and	al,*2
20762 5DC8           84C0                       test	al,al
20763 5DCA           74           12            je  	.488
20764                       00005DCC            .489:
20765                                           ! 3296     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
20766                                           ! Debug: list * char = .48A+0 (used reg = )
20767 5DCC           BB                   D1AD  mov	bx,#.48A
20768 5DCF           53                         push	bx
20769                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20770 5DD0           BB                   5D98  mov	bx,#_panic_msg_keyb_buffer_full
20771 5DD3           53                         push	bx
20772                                           ! Debug: list int = const 7 (used reg = )
20773 5DD4           B8                   0007  mov	ax,*7
20774 5DD7           50                         push	ax
20775                                           ! Debug: func () void = bios_printf+0 (used reg = )
20776 5DD8           E8         AC40            call	_bios_printf
20777 5DDB           83C4                   06  add	sp,*6
20778                                           !BCC_EOS
20779                                           ! 3297   outb(0x64, 0x20);
20780                       00005DDE            .488:
20781                                           ! Debug: list int = const $20 (used reg = )
20782 5DDE           B8                   0020  mov	ax,*$20
20783 5DE1           50                         push	ax
20784                                           ! Debug: list int = const $64 (used reg = )
20785 5DE2           B8                   0064  mov	ax,*$64
20786 5DE5           50                         push	ax
20787                                           ! Debug: func () void = outb+0 (used reg = )
20788 5DE6           E8         A76B            call	_outb
20789 5DE9           83C4                   04  add	sp,*4
20790                                           !BCC_EOS
20791                                           ! 3298   while ( (inb(0x64) & 0x01) != 0
20792                                           ! 3298 x01 );
20793 5DEC           EB           00            jmp .48C
20794                       00005DEE            .48D:
20795                                           !BCC_EOS
20796                                           ! 3299   prev_command_byte = inb(0x60);
20797                       00005DEE            .48C:
20798                                           ! Debug: list int = const $64 (used reg = )
20799 5DEE           B8                   0064  mov	ax,*$64
20800 5DF1           50                         push	ax
20801                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20802 5DF2           E8         A749            call	_inb
20803 5DF5           44                         inc	sp
20804 5DF6           44                         inc	sp
20805                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20806 5DF7           24                     01  and	al,*1
20807                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
20808 5DF9           3C                     01  cmp	al,*1
20809 5DFB           75           F1            jne	.48D
20810                       00005DFD            .48E:
20811                       00005DFD            .48B:
20812                                           ! Debug: list int = const $60 (used reg = )
20813 5DFD           B8                   0060  mov	ax,*$60
20814 5E00           50                         push	ax
20815                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20816 5E01           E8         A73A            call	_inb
20817 5E04           44                         inc	sp
20818 5E05           44                         inc	sp
20819                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
20820 5E06           8846         FE            mov	-2[bp],al
20821                                           !BCC_EOS
20822                                           ! 3300   command_byte = prev_command_byte;
20823                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
20824 5E09           8A46         FE            mov	al,-2[bp]
20825 5E0C           8846         FF            mov	-1[bp],al
20826                                           !BCC_EOS
20827                                           ! 3301   if ( inb(0x64) & 0x02 )
20828                                           ! Debug: list int = const $64 (used reg = )
20829 5E0F           B8                   0064  mov	ax,*$64
20830 5E12           50                         push	ax
20831                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20832 5E13           E8         A728            call	_inb
20833 5E16           44                         inc	sp
20834 5E17           44                         inc	sp
20835                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20836 5E18           24                     02  and	al,*2
20837 5E1A           84C0                       test	al,al
20838 5E1C           74           12            je  	.48F
20839                       00005E1E            .490:
20840                                           ! 3302     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
20841                                           ! Debug: list * char = .491+0 (used reg = )
20842 5E1E           BB                   D1A2  mov	bx,#.491
20843 5E21           53                         push	bx
20844                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20845 5E22           BB                   5D98  mov	bx,#_panic_msg_keyb_buffer_full
20846 5E25           53                         push	bx
20847                                           ! Debug: list int = const 7 (used reg = )
20848 5E26           B8                   0007  mov	ax,*7
20849 5E29           50                         push	ax
20850                                           ! Debug: func () void = bios_printf+0 (used reg = )
20851 5E2A           E8         ABEE            call	_bios_printf
20852 5E2D           83C4                   06  add	sp,*6
20853                                           !BCC_EOS
20854                                           ! 3303   command_byte &= 0xfd;
20855                       00005E30            .48F:
20856                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
20857 5E30           8A46         FF            mov	al,-1[bp]
20858 5E33           24                     FD  and	al,#$FD
20859 5E35           8846         FF            mov	-1[bp],al
20860                                           !BCC_EOS
20861                                           ! 3304   command_byte |= 0x20;
20862                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
20863 5E38           8A46         FF            mov	al,-1[bp]
20864 5E3B           0C                     20  or	al,*$20
20865 5E3D           8846         FF            mov	-1[bp],al
20866                                           !BCC_EOS
20867                                           ! 3305   outb(0x64, 0x60);
20868                                           ! Debug: list int = const $60 (used reg = )
20869 5E40           B8                   0060  mov	ax,*$60
20870 5E43           50                         push	ax
20871                                           ! Debug: list int = const $64 (used reg = )
20872 5E44           B8                   0064  mov	ax,*$64
20873 5E47           50                         push	ax
20874                                           ! Debug: func () void = outb+0 (used reg = )
20875 5E48           E8         A709            call	_outb
20876 5E4B           83C4                   04  add	sp,*4
20877                                           !BCC_EOS
20878                                           ! 3306   outb(0x60, command_byte);
20879                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
20880 5E4E           8A46         FF            mov	al,-1[bp]
20881 5E51           30E4                       xor	ah,ah
20882 5E53           50                         push	ax
20883                                           ! Debug: list int = const $60 (used reg = )
20884 5E54           B8                   0060  mov	ax,*$60
20885 5E57           50                         push	ax
20886                                           ! Debug: func () void = outb+0 (used reg = )
20887 5E58           E8         A6F9            call	_outb
20888 5E5B           83C4                   04  add	sp,*4
20889                                           !BCC_EOS
20890                                           ! 3307   return(prev_command_byte);
20891 5E5E           8A46         FE            mov	al,-2[bp]
20892 5E61           89EC                       mov	sp,bp
20893 5E63           5D                         pop	bp
20894 5E64           C3                         ret
20895                                           !BCC_EOS
20896                                           ! 3308 }
20897                                           ! 3309   void
20898                                           ! Register BX used in function inhibit_mouse_int_and_events
20899                                           ! 3310 enable_mouse_int_and_events()
20900                                           ! 3311 {
20901                                           export	_enable_mouse_int_and_events
20902                       00005E65            _enable_mouse_int_and_events:
20903                                           ! 3312   Bit8u command_byte;
20904                                           !BCC_EOS
20905                                           ! 3313   if ( inb(0x64) & 0x02 )
20906 5E65           55                         push	bp
20907 5E66           89E5                       mov	bp,sp
20908 5E68           4C                         dec	sp
20909 5E69           4C                         dec	sp
20910                                           ! Debug: list int = const $64 (used reg = )
20911 5E6A           B8                   0064  mov	ax,*$64
20912 5E6D           50                         push	ax
20913                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20914 5E6E           E8         A6CD            call	_inb
20915 5E71           44                         inc	sp
20916 5E72           44                         inc	sp
20917                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20918 5E73           24                     02  and	al,*2
20919 5E75           84C0                       test	al,al
20920 5E77           74           12            je  	.492
20921                       00005E79            .493:
20922                                           ! 3314     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
20923                                           ! Debug: list * char = .494+0 (used reg = )
20924 5E79           BB                   D198  mov	bx,#.494
20925 5E7C           53                         push	bx
20926                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20927 5E7D           BB                   5D98  mov	bx,#_panic_msg_keyb_buffer_full
20928 5E80           53                         push	bx
20929                                           ! Debug: list int = const 7 (used reg = )
20930 5E81           B8                   0007  mov	ax,*7
20931 5E84           50                         push	ax
20932                                           ! Debug: func () void = bios_printf+0 (used reg = )
20933 5E85           E8         AB93            call	_bios_printf
20934 5E88           83C4                   06  add	sp,*6
20935                                           !BCC_EOS
20936                                           ! 3315   outb(0x64, 0x20);
20937                       00005E8B            .492:
20938                                           ! Debug: list int = const $20 (used reg = )
20939 5E8B           B8                   0020  mov	ax,*$20
20940 5E8E           50                         push	ax
20941                                           ! Debug: list int = const $64 (used reg = )
20942 5E8F           B8                   0064  mov	ax,*$64
20943 5E92           50                         push	ax
20944                                           ! Debug: func () void = outb+0 (used reg = )
20945 5E93           E8         A6BE            call	_outb
20946 5E96           83C4                   04  add	sp,*4
20947                                           !BCC_EOS
20948                                           ! 3316   while ( (inb(0x64) & 0x01) != 0x01 );
20949 5E99           EB           00            jmp .496
20950                       00005E9B            .497:
20951                                           !BCC_EOS
20952                                           ! 3317   command_byte = inb(0x60);
20953                       00005E9B            .496:
20954                                           ! Debug: list int = const $64 (used reg = )
20955 5E9B           B8                   0064  mov	ax,*$64
20956 5E9E           50                         push	ax
20957                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20958 5E9F           E8         A69C            call	_inb
20959 5EA2           44                         inc	sp
20960 5EA3           44                         inc	sp
20961                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20962 5EA4           24                     01  and	al,*1
20963                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
20964 5EA6           3C                     01  cmp	al,*1
20965 5EA8           75           F1            jne	.497
20966                       00005EAA            .498:
20967                       00005EAA            .495:
20968                                           ! Debug: list int = const $60 (used reg = )
20969 5EAA           B8                   0060  mov	ax,*$60
20970 5EAD           50                         push	ax
20971                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20972 5EAE           E8         A68D            call	_inb
20973 5EB1           44                         inc	sp
20974 5EB2           44                         inc	sp
20975                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
20976 5EB3           8846         FF            mov	-1[bp],al
20977                                           !BCC_EOS
20978                                           ! 3318   if ( inb(0x64) & 0x02 )
20979                                           ! Debug: list int = const $64 (used reg = )
20980 5EB6           B8                   0064  mov	ax,*$64
20981 5EB9           50                         push	ax
20982                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20983 5EBA           E8         A681            call	_inb
20984 5EBD           44                         inc	sp
20985 5EBE           44                         inc	sp
20986                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20987 5EBF           24                     02  and	al,*2
20988 5EC1           84C0                       test	al,al
20989 5EC3           74           12            je  	.499
20990                       00005EC5            .49A:
20991                                           ! 3319     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
20992                                           ! Debug: list * char = .49B+0 (used reg = )
20993 5EC5           BB                   D18E  mov	bx,#.49B
20994 5EC8           53                         push	bx
20995                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20996 5EC9           BB                   5D98  mov	bx,#_panic_msg_keyb_buffer_full
20997 5ECC           53                         push	bx
20998                                           ! Debug: list int = const 7 (used reg = )
20999 5ECD           B8                   0007  mov	ax,*7
21000 5ED0           50                         push	ax
21001                                           ! Debug: func () void = bios_printf+0 (used reg = )
21002 5ED1           E8         AB47            call	_bios_printf
21003 5ED4           83C4                   06  add	sp,*6
21004                                           !BCC_EOS
21005                                           ! 3320   command_byte |= 0x02;
21006                       00005ED7            .499:
21007                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
21008 5ED7           8A46         FF            mov	al,-1[bp]
21009 5EDA           0C                     02  or	al,*2
21010 5EDC           8846         FF            mov	-1[bp],al
21011                                           !BCC_EOS
21012                                           ! 3321   command_byte &= 0xdf;
21013                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
21014 5EDF           8A46         FF            mov	al,-1[bp]
21015 5EE2           24                     DF  and	al,#$DF
21016 5EE4           8846         FF            mov	-1[bp],al
21017                                           !BCC_EOS
21018                                           ! 3322   outb(0x64, 0x60);
21019                                           ! Debug: list int = const $60 (used reg = )
21020 5EE7           B8                   0060  mov	ax,*$60
21021 5EEA           50                         push	ax
21022                                           ! Debug: list int = const $64 (used reg = )
21023 5EEB           B8                   0064  mov	ax,*$64
21024 5EEE           50                         push	ax
21025                                           ! Debug: func () void = outb+0 (used reg = )
21026 5EEF           E8         A662            call	_outb
21027 5EF2           83C4                   04  add	sp,*4
21028                                           !BCC_EOS
21029                                           ! 3323   outb(0x60, command_byte);
21030                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21031 5EF5           8A46         FF            mov	al,-1[bp]
21032 5EF8           30E4                       xor	ah,ah
21033 5EFA           50                         push	ax
21034                                           ! Debug: list int = const $60 (used reg = )
21035 5EFB           B8                   0060  mov	ax,*$60
21036 5EFE           50                         push	ax
21037                                           ! Debug: func () void = outb+0 (used reg = )
21038 5EFF           E8         A652            call	_outb
21039 5F02           83C4                   04  add	sp,*4
21040                                           !BCC_EOS
21041                                           ! 3324 }
21042 5F05           89EC                       mov	sp,bp
21043 5F07           5D                         pop	bp
21044 5F08           C3                         ret
21045                                           ! 3325   Bit8u
21046                                           ! Register BX used in function enable_mouse_int_and_events
21047                                           ! 3326 send_to_mouse_ctrl(sendbyte)
21048                                           ! 3327   Bit8u sendbyte;
21049                                           export	_send_to_mouse_ctrl
21050                       00005F09            _send_to_mouse_ctrl:
21051                                           !BCC_EOS
21052                                           ! 3328 {
21053                                           ! 3329   Bit8u response;
21054                                           !BCC_EOS
21055                                           ! 3330   if ( inb(0x64) & 0x02 )
21056 5F09           55                         push	bp
21057 5F0A           89E5                       mov	bp,sp
21058 5F0C           4C                         dec	sp
21059 5F0D           4C                         dec	sp
21060                                           ! Debug: list int = const $64 (used reg = )
21061 5F0E           B8                   0064  mov	ax,*$64
21062 5F11           50                         push	ax
21063                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21064 5F12           E8         A629            call	_inb
21065 5F15           44                         inc	sp
21066 5F16           44                         inc	sp
21067                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21068 5F17           24                     02  and	al,*2
21069 5F19           84C0                       test	al,al
21070 5F1B           74           12            je  	.49C
21071                       00005F1D            .49D:
21072                                           ! 3331     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
21073                                           ! Debug: list * char = .49E+0 (used reg = )
21074 5F1D           BB                   D184  mov	bx,#.49E
21075 5F20           53                         push	bx
21076                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21077 5F21           BB                   5D98  mov	bx,#_panic_msg_keyb_buffer_full
21078 5F24           53                         push	bx
21079                                           ! Debug: list int = const 7 (used reg = )
21080 5F25           B8                   0007  mov	ax,*7
21081 5F28           50                         push	ax
21082                                           ! Debug: func () void = bios_printf+0 (used reg = )
21083 5F29           E8         AAEF            call	_bios_printf
21084 5F2C           83C4                   06  add	sp,*6
21085                                           !BCC_EOS
21086                                           ! 3332   outb(0x64, 0xD4);
21087                       00005F2F            .49C:
21088                                           ! Debug: list int = const $D4 (used reg = )
21089 5F2F           B8                   00D4  mov	ax,#$D4
21090 5F32           50                         push	ax
21091                                           ! Debug: list int = const $64 (used reg = )
21092 5F33           B8                   0064  mov	ax,*$64
21093 5F36           50                         push	ax
21094                                           ! Debug: func () void = outb+0 (used reg = )
21095 5F37           E8         A61A            call	_outb
21096 5F3A           83C4                   04  add	sp,*4
21097                                           !BCC_EOS
21098                                           ! 3333   outb(0x60, sendbyte);
21099                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
21100 5F3D           8A46         04            mov	al,4[bp]
21101 5F40           30E4                       xor	ah,ah
21102 5F42           50                         push	ax
21103                                           ! Debug: list int = const $60 (used reg = )
21104 5F43           B8                   0060  mov	ax,*$60
21105 5F46           50                         push	ax
21106                                           ! Debug: func () void = outb+0 (used reg = )
21107 5F47           E8         A60A            call	_outb
21108 5F4A           83C4                   04  add	sp,*4
21109                                           !BCC_EOS
21110                                           ! 3334   return(0);
21111 5F4D           30C0                       xor	al,al
21112 5F4F           89EC                       mov	sp,bp
21113 5F51           5D                         pop	bp
21114 5F52           C3                         ret
21115                                           !BCC_EOS
21116                                           ! 3335 }
21117                                           ! 3336   Bit8u
21118                                           ! Register BX used in function send_to_mouse_ctrl
21119                                           ! 3337 get_mouse_data(data)
21120                                           ! 3338   Bit8u *data;
21121                                           export	_get_mouse_data
21122                       00005F53            _get_mouse_data:
21123                                           !BCC_EOS
21124                                           ! 3339 {
21125                                           ! 3340   Bit8u response;
21126                                           !BCC_EOS
21127                                           ! 3341   Bit16u ss;
21128                                           !BCC_EOS
21129                                           ! 3342   while ( (inb(0x64) & 0x21) != 0x21 ) {
21130 5F53           55                         push	bp
21131 5F54           89E5                       mov	bp,sp
21132 5F56           83C4                   FC  add	sp,*-4
21133 5F59           EB           00            jmp .4A0
21134                       00005F5B            .4A1:
21135                                           ! 3343     }
21136                                           ! 3344   response = inb(0x60);
21137                       00005F5B            .4A0:
21138                                           ! Debug: list int = const $64 (used reg = )
21139 5F5B           B8                   0064  mov	ax,*$64
21140 5F5E           50                         push	ax
21141                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21142 5F5F           E8         A5DC            call	_inb
21143 5F62           44                         inc	sp
21144 5F63           44                         inc	sp
21145                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
21146 5F64           24                     21  and	al,*$21
21147                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
21148 5F66           3C                     21  cmp	al,*$21
21149 5F68           75           F1            jne	.4A1
21150                       00005F6A            .4A2:
21151                       00005F6A            .49F:
21152                                           ! Debug: list int = const $60 (used reg = )
21153 5F6A           B8                   0060  mov	ax,*$60
21154 5F6D           50                         push	ax
21155                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21156 5F6E           E8         A5CD            call	_inb
21157 5F71           44                         inc	sp
21158 5F72           44                         inc	sp
21159                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
21160 5F73           8846         FF            mov	-1[bp],al
21161                                           !BCC_EOS
21162                                           ! 3345   ss = get_SS();
21163                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21164 5F76           E8         A6D4            call	_get_SS
21165                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
21166 5F79           8946         FC            mov	-4[bp],ax
21167                                           !BCC_EOS
21168                                           ! 3346   write_byte(ss, data, response);
21169                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
21170 5F7C           8A46         FF            mov	al,-1[bp]
21171 5F7F           30E4                       xor	ah,ah
21172 5F81           50                         push	ax
21173                                           ! Debug: list * unsigned char data = [S+8+2] (used reg = )
21174 5F82           FF76         04            push	4[bp]
21175                                           ! Debug: list unsigned short ss = [S+$A-6] (used reg = )
21176 5F85           FF76         FC            push	-4[bp]
21177                                           ! Debug: func () void = write_byte+0 (used reg = )
21178 5F88           E8         A68F            call	_write_byte
21179 5F8B           83C4                   06  add	sp,*6
21180                                           !BCC_EOS
21181                                           ! 3347   return(0);
21182 5F8E           30C0                       xor	al,al
21183 5F90           89EC                       mov	sp,bp
21184 5F92           5D                         pop	bp
21185 5F93           C3                         ret
21186                                           !BCC_EOS
21187                                           ! 3348 }
21188                                           ! 3349   void
21189                                           ! 3350 set_kbd_command_byte(command_byte)
21190                                           ! 3351   Bit8u command_byte;
21191                                           export	_set_kbd_command_byte
21192                       00005F94            _set_kbd_command_byte:
21193                                           !BCC_EOS
21194                                           ! 3352 {
21195                                           ! 3353   if ( inb(0x64) & 0x02 )
21196 5F94           55                         push	bp
21197 5F95           89E5                       mov	bp,sp
21198                                           ! Debug: list int = const $64 (used reg = )
21199 5F97           B8                   0064  mov	ax,*$64
21200 5F9A           50                         push	ax
21201                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21202 5F9B           E8         A5A0            call	_inb
21203 5F9E           89EC                       mov	sp,bp
21204                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21205 5FA0           24                     02  and	al,*2
21206 5FA2           84C0                       test	al,al
21207 5FA4           74           11            je  	.4A3
21208                       00005FA6            .4A4:
21209                                           ! 3354     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
21210                                           ! Debug: list * char = .4A5+0 (used reg = )
21211 5FA6           BB                   D179  mov	bx,#.4A5
21212 5FA9           53                         push	bx
21213                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21214 5FAA           BB                   5D98  mov	bx,#_panic_msg_keyb_buffer_full
21215 5FAD           53                         push	bx
21216                                           ! Debug: list int = const 7 (used reg = )
21217 5FAE           B8                   0007  mov	ax,*7
21218 5FB1           50                         push	ax
21219                                           ! Debug: func () void = bios_printf+0 (used reg = )
21220 5FB2           E8         AA66            call	_bios_printf
21221 5FB5           89EC                       mov	sp,bp
21222                                           !BCC_EOS
21223                                           ! 3355   outb(0x64, 0xD4);
21224                       00005FB7            .4A3:
21225                                           ! Debug: list int = const $D4 (used reg = )
21226 5FB7           B8                   00D4  mov	ax,#$D4
21227 5FBA           50                         push	ax
21228                                           ! Debug: list int = const $64 (used reg = )
21229 5FBB           B8                   0064  mov	ax,*$64
21230 5FBE           50                         push	ax
21231                                           ! Debug: func () void = outb+0 (used reg = )
21232 5FBF           E8         A592            call	_outb
21233 5FC2           89EC                       mov	sp,bp
21234                                           !BCC_EOS
21235                                           ! 3356   outb(0x64, 0x60);
21236                                           ! Debug: list int = const $60 (used reg = )
21237 5FC4           B8                   0060  mov	ax,*$60
21238 5FC7           50                         push	ax
21239                                           ! Debug: list int = const $64 (used reg = )
21240 5FC8           B8                   0064  mov	ax,*$64
21241 5FCB           50                         push	ax
21242                                           ! Debug: func () void = outb+0 (used reg = )
21243 5FCC           E8         A585            call	_outb
21244 5FCF           89EC                       mov	sp,bp
21245                                           !BCC_EOS
21246                                           ! 3357   outb(0x60, command_byte);
21247                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
21248 5FD1           8A46         04            mov	al,4[bp]
21249 5FD4           30E4                       xor	ah,ah
21250 5FD6           50                         push	ax
21251                                           ! Debug: list int = const $60 (used reg = )
21252 5FD7           B8                   0060  mov	ax,*$60
21253 5FDA           50                         push	ax
21254                                           ! Debug: func () void = outb+0 (used reg = )
21255 5FDB           E8         A576            call	_outb
21256 5FDE           89EC                       mov	sp,bp
21257                                           !BCC_EOS
21258                                           ! 3358 }
21259 5FE0           5D                         pop	bp
21260 5FE1           C3                         ret
21261                                           ! 3359   void
21262                                           ! Register BX used in function set_kbd_command_byte
21263                                           ! 3360 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
21264                                           ! 3361   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
21265                                           export	_int09_function
21266                       00005FE2            _int09_function:
21267                                           !BCC_EOS
21268                                           ! 3362 {
21269                                           ! 3363   Bit8u scancode, asciicode, shift_flags;
21270                                           !BCC_EOS
21271                                           ! 3364   Bit8u mf2_flags, mf2_state;
21272                                           !BCC_EOS
21273                                           ! 3365   scancode = ( AX & 0x00ff );
21274 5FE2           55                         push	bp
21275 5FE3           89E5                       mov	bp,sp
21276 5FE5           83C4                   FA  add	sp,*-6
21277                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
21278 5FE8           8A46         12            mov	al,$12[bp]
21279                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
21280 5FEB           8846         FF            mov	-1[bp],al
21281                                           !BCC_EOS
21282                                           ! 3366   if (scancode == 0) {
21283                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
21284 5FEE           8A46         FF            mov	al,-1[bp]
21285 5FF1           84C0                       test	al,al
21286 5FF3           75           04            jne 	.4A6
21287                       00005FF5            .4A7:
21288                                           ! 3367     ;
21289                                           !BCC_EOS
21290                                           ! 3368     return;
21291 5FF5           89EC                       mov	sp,bp
21292 5FF7           5D                         pop	bp
21293 5FF8           C3                         ret
21294                                           !BCC_EOS
21295                                           ! 3369     }
21296                                           ! 3370   shift_flags = read_byte(0x0040, 0x17);
21297                       00005FF9            .4A6:
21298                                           ! Debug: list int = const $17 (used reg = )
21299 5FF9           B8                   0017  mov	ax,*$17
21300 5FFC           50                         push	ax
21301                                           ! Debug: list int = const $40 (used reg = )
21302 5FFD           B8                   0040  mov	ax,*$40
21303 6000           50                         push	ax
21304                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21305 6001           E8         A5F0            call	_read_byte
21306 6004           83C4                   04  add	sp,*4
21307                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
21308 6007           8846         FD            mov	-3[bp],al
21309                                           !BCC_EOS
21310                                           ! 3371   mf2_flags = read_byte(0x0040, 0x18);
21311                                           ! Debug: list int = const $18 (used reg = )
21312 600A           B8                   0018  mov	ax,*$18
21313 600D           50                         push	ax
21314                                           ! Debug: list int = const $40 (used reg = )
21315 600E           B8                   0040  mov	ax,*$40
21316 6011           50                         push	ax
21317                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21318 6012           E8         A5DF            call	_read_byte
21319 6015           83C4                   04  add	sp,*4
21320                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
21321 6018           8846         FC            mov	-4[bp],al
21322                                           !BCC_EOS
21323                                           ! 3372   mf2_state = read_byte(0x0040, 0x96);
21324                                           ! Debug: list int = const $96 (used reg = )
21325 601B           B8                   0096  mov	ax,#$96
21326 601E           50                         push	ax
21327                                           ! Debug: list int = const $40 (used reg = )
21328 601F           B8                   0040  mov	ax,*$40
21329 6022           50                         push	ax
21330                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21331 6023           E8         A5CE            call	_read_byte
21332 6026           83C4                   04  add	sp,*4
21333                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
21334 6029           8846         FB            mov	-5[bp],al
21335                                           !BCC_EOS
21336                                           ! 3373   asciicode = 0;
21337                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
21338 602C           30C0                       xor	al,al
21339 602E           8846         FE            mov	-2[bp],al
21340                                           !BCC_EOS
21341                                           ! 3374   switch (scancode) {
21342 6031           8A46         FF            mov	al,-1[bp]
21343 6034           E9         0570            br 	.4AA
21344                                           ! 3375     case 0x3a:
21345                                           ! 3376       shift_flags ^= 0x40;
21346                       00006037            .4AB:
21347                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
21348 6037           8A46         FD            mov	al,-3[bp]
21349 603A           34                     40  xor	al,*$40
21350 603C           8846         FD            mov	-3[bp],al
21351                                           !BCC_EOS
21352                                           ! 3377       write_byte(0x0040, 0x17, shift_flags);
21353                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21354 603F           8A46         FD            mov	al,-3[bp]
21355 6042           30E4                       xor	ah,ah
21356 6044           50                         push	ax
21357                                           ! Debug: list int = const $17 (used reg = )
21358 6045           B8                   0017  mov	ax,*$17
21359 6048           50                         push	ax
21360                                           ! Debug: list int = const $40 (used reg = )
21361 6049           B8                   0040  mov	ax,*$40
21362 604C           50                         push	ax
21363                                           ! Debug: func () void = write_byte+0 (used reg = )
21364 604D           E8         A5CA            call	_write_byte
21365 6050           83C4                   06  add	sp,*6
21366                                           !BCC_EOS
21367                                           ! 3378       mf2_flags |= 0x40;
21368                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
21369 6053           8A46         FC            mov	al,-4[bp]
21370 6056           0C                     40  or	al,*$40
21371 6058           8846         FC            mov	-4[bp],al
21372                                           !BCC_EOS
21373                                           ! 3379       write_byte(0x0040, 0x18, mf2_flags);
21374                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21375 605B           8A46         FC            mov	al,-4[bp]
21376 605E           30E4                       xor	ah,ah
21377 6060           50                         push	ax
21378                                           ! Debug: list int = const $18 (used reg = )
21379 6061           B8                   0018  mov	ax,*$18
21380 6064           50                         push	ax
21381                                           ! Debug: list int = const $40 (used reg = )
21382 6065           B8                   0040  mov	ax,*$40
21383 6068           50                         push	ax
21384                                           ! Debug: func () void = write_byte+0 (used reg = )
21385 6069           E8         A5AE            call	_write_byte
21386 606C           83C4                   06  add	sp,*6
21387                                           !BCC_EOS
21388                                           ! 3380       break;
21389 606F           E9         0592            br 	.4A8
21390                                           !BCC_EOS
21391                                           ! 3381     case 0xba:
21392                                           ! 3382       mf2_flags &= ~0x40;
21393                       00006072            .4AC:
21394                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
21395 6072           8A46         FC            mov	al,-4[bp]
21396 6075           24                     BF  and	al,#$BF
21397 6077           8846         FC            mov	-4[bp],al
21398                                           !BCC_EOS
21399                                           ! 3383       write_byte(0x
21400                                           ! 3383 0040, 0x18, mf2_flags);
21401                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21402 607A           8A46         FC            mov	al,-4[bp]
21403 607D           30E4                       xor	ah,ah
21404 607F           50                         push	ax
21405                                           ! Debug: list int = const $18 (used reg = )
21406 6080           B8                   0018  mov	ax,*$18
21407 6083           50                         push	ax
21408                                           ! Debug: list int = const $40 (used reg = )
21409 6084           B8                   0040  mov	ax,*$40
21410 6087           50                         push	ax
21411                                           ! Debug: func () void = write_byte+0 (used reg = )
21412 6088           E8         A58F            call	_write_byte
21413 608B           83C4                   06  add	sp,*6
21414                                           !BCC_EOS
21415                                           ! 3384       break;
21416 608E           E9         0573            br 	.4A8
21417                                           !BCC_EOS
21418                                           ! 3385     case 0x2a:
21419                                           ! 3386       shift_flags |= 0x02;
21420                       00006091            .4AD:
21421                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
21422 6091           8A46         FD            mov	al,-3[bp]
21423 6094           0C                     02  or	al,*2
21424 6096           8846         FD            mov	-3[bp],al
21425                                           !BCC_EOS
21426                                           ! 3387       write_byte(0x0040, 0x17, shift_flags);
21427                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21428 6099           8A46         FD            mov	al,-3[bp]
21429 609C           30E4                       xor	ah,ah
21430 609E           50                         push	ax
21431                                           ! Debug: list int = const $17 (used reg = )
21432 609F           B8                   0017  mov	ax,*$17
21433 60A2           50                         push	ax
21434                                           ! Debug: list int = const $40 (used reg = )
21435 60A3           B8                   0040  mov	ax,*$40
21436 60A6           50                         push	ax
21437                                           ! Debug: func () void = write_byte+0 (used reg = )
21438 60A7           E8         A570            call	_write_byte
21439 60AA           83C4                   06  add	sp,*6
21440                                           !BCC_EOS
21441                                           ! 3388       break;
21442 60AD           E9         0554            br 	.4A8
21443                                           !BCC_EOS
21444                                           ! 3389     case 0xaa:
21445                                           ! 3390       shift_flags &= ~0x02;
21446                       000060B0            .4AE:
21447                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
21448 60B0           8A46         FD            mov	al,-3[bp]
21449 60B3           24                     FD  and	al,#$FD
21450 60B5           8846         FD            mov	-3[bp],al
21451                                           !BCC_EOS
21452                                           ! 3391       write_byte(0x0040, 0x17, shift_flags);
21453                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21454 60B8           8A46         FD            mov	al,-3[bp]
21455 60BB           30E4                       xor	ah,ah
21456 60BD           50                         push	ax
21457                                           ! Debug: list int = const $17 (used reg = )
21458 60BE           B8                   0017  mov	ax,*$17
21459 60C1           50                         push	ax
21460                                           ! Debug: list int = const $40 (used reg = )
21461 60C2           B8                   0040  mov	ax,*$40
21462 60C5           50                         push	ax
21463                                           ! Debug: func () void = write_byte+0 (used reg = )
21464 60C6           E8         A551            call	_write_byte
21465 60C9           83C4                   06  add	sp,*6
21466                                           !BCC_EOS
21467                                           ! 3392       break;
21468 60CC           E9         0535            br 	.4A8
21469                                           !BCC_EOS
21470                                           ! 3393     case 0x36:
21471                                           ! 3394       shift_flags |= 0x01;
21472                       000060CF            .4AF:
21473                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
21474 60CF           8A46         FD            mov	al,-3[bp]
21475 60D2           0C                     01  or	al,*1
21476 60D4           8846         FD            mov	-3[bp],al
21477                                           !BCC_EOS
21478                                           ! 3395       write_byte(0x0040, 0x17, shift_flags);
21479                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21480 60D7           8A46         FD            mov	al,-3[bp]
21481 60DA           30E4                       xor	ah,ah
21482 60DC           50                         push	ax
21483                                           ! Debug: list int = const $17 (used reg = )
21484 60DD           B8                   0017  mov	ax,*$17
21485 60E0           50                         push	ax
21486                                           ! Debug: list int = const $40 (used reg = )
21487 60E1           B8                   0040  mov	ax,*$40
21488 60E4           50                         push	ax
21489                                           ! Debug: func () void = write_byte+0 (used reg = )
21490 60E5           E8         A532            call	_write_byte
21491 60E8           83C4                   06  add	sp,*6
21492                                           !BCC_EOS
21493                                           ! 3396       break;
21494 60EB           E9         0516            br 	.4A8
21495                                           !BCC_EOS
21496                                           ! 3397     case 0xb6:
21497                                           ! 3398       shift_flags &= ~0x01;
21498                       000060EE            .4B0:
21499                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
21500 60EE           8A46         FD            mov	al,-3[bp]
21501 60F1           24                     FE  and	al,#$FE
21502 60F3           8846         FD            mov	-3[bp],al
21503                                           !BCC_EOS
21504                                           ! 3399       write_byte(0x0040, 0x17, shift_flags);
21505                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21506 60F6           8A46         FD            mov	al,-3[bp]
21507 60F9           30E4                       xor	ah,ah
21508 60FB           50                         push	ax
21509                                           ! Debug: list int = const $17 (used reg = )
21510 60FC           B8                   0017  mov	ax,*$17
21511 60FF           50                         push	ax
21512                                           ! Debug: list int = const $40 (used reg = )
21513 6100           B8                   0040  mov	ax,*$40
21514 6103           50                         push	ax
21515                                           ! Debug: func () void = write_byte+0 (used reg = )
21516 6104           E8         A513            call	_write_byte
21517 6107           83C4                   06  add	sp,*6
21518                                           !BCC_EOS
21519                                           ! 3400       break;
21520 610A           E9         04F7            br 	.4A8
21521                                           !BCC_EOS
21522                                           ! 3401     case 0x1d:
21523                                           ! 3402       if ((mf2_state & 0x01) == 0) {
21524                       0000610D            .4B1:
21525                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21526 610D           8A46         FB            mov	al,-5[bp]
21527 6110           24                     01  and	al,*1
21528                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21529 6112           84C0                       test	al,al
21530 6114           75           5F            jne 	.4B2
21531                       00006116            .4B3:
21532                                           ! 3403         shift_flags |= 0x04;
21533                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
21534 6116           8A46         FD            mov	al,-3[bp]
21535 6119           0C                     04  or	al,*4
21536 611B           8846         FD            mov	-3[bp],al
21537                                           !BCC_EOS
21538                                           ! 3404         write_byte(0x0040, 0x17, shift_flags);
21539                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21540 611E           8A46         FD            mov	al,-3[bp]
21541 6121           30E4                       xor	ah,ah
21542 6123           50                         push	ax
21543                                           ! Debug: list int = const $17 (used reg = )
21544 6124           B8                   0017  mov	ax,*$17
21545 6127           50                         push	ax
21546                                           ! Debug: list int = const $40 (used reg = )
21547 6128           B8                   0040  mov	ax,*$40
21548 612B           50                         push	ax
21549                                           ! Debug: func () void = write_byte+0 (used reg = )
21550 612C           E8         A4EB            call	_write_byte
21551 612F           83C4                   06  add	sp,*6
21552                                           !BCC_EOS
21553                                           ! 3405         if (mf2_state & 0x02) {
21554                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21555 6132           8A46         FB            mov	al,-5[bp]
21556 6135           24                     02  and	al,*2
21557 6137           84C0                       test	al,al
21558 6139           74           1E            je  	.4B4
21559                       0000613B            .4B5:
21560                                           ! 3406           mf2_state |= 0x04;
21561                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
21562 613B           8A46         FB            mov	al,-5[bp]
21563 613E           0C                     04  or	al,*4
21564 6140           8846         FB            mov	-5[bp],al
21565                                           !BCC_EOS
21566                                           ! 3407           write_byte(0x0040, 0x96, mf2_state);
21567                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21568 6143           8A46         FB            mov	al,-5[bp]
21569 6146           30E4                       xor	ah,ah
21570 6148           50                         push	ax
21571                                           ! Debug: list int = const $96 (used reg = )
21572 6149           B8                   0096  mov	ax,#$96
21573 614C           50                         push	ax
21574                                           ! Debug: list int = const $40 (used reg = )
21575 614D           B8                   0040  mov	ax,*$40
21576 6150           50                         push	ax
21577                                           ! Debug: func () void = write_byte+0 (used reg = )
21578 6151           E8         A4C6            call	_write_byte
21579 6154           83C4                   06  add	sp,*6
21580                                           !BCC_EOS
21581                                           ! 3408         } else {
21582 6157           EB           1C            jmp .4B6
21583                       00006159            .4B4:
21584                                           ! 3409           mf2_flags |= 0x01;
21585                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
21586 6159           8A46         FC            mov	al,-4[bp]
21587 615C           0C                     01  or	al,*1
21588 615E           8846         FC            mov	-4[bp],al
21589                                           !BCC_EOS
21590                                           ! 3410           write_byte(0x0040, 0x18, mf2_flags);
21591                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21592 6161           8A46         FC            mov	al,-4[bp]
21593 6164           30E4                       xor	ah,ah
21594 6166           50                         push	ax
21595                                           ! Debug: list int = const $18 (used reg = )
21596 6167           B8                   0018  mov	ax,*$18
21597 616A           50                         push	ax
21598                                           ! Debug: list int = const $40 (used reg = )
21599 616B           B8                   0040  mov	ax,*$40
21600 616E           50                         push	ax
21601                                           ! Debug: func () void = write_byte+0 (used reg = )
21602 616F           E8         A4A8            call	_write_byte
21603 6172           83C4                   06  add	sp,*6
21604                                           !BCC_EOS
21605                                           ! 3411         }
21606                                           ! 3412       }
21607                       00006175            .4B6:
21608                                           ! 3413       break;
21609                       00006175            .4B2:
21610 6175           E9         048C            br 	.4A8
21611                                           !BCC_EOS
21612                                           ! 3414     case 0x9d:
21613                                           ! 3415       if ((mf2_state & 0x01) == 0) {
21614                       00006178            .4B7:
21615                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21616 6178           8A46         FB            mov	al,-5[bp]
21617 617B           24                     01  and	al,*1
21618                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21619 617D           84C0                       test	al,al
21620 617F           75           5F            jne 	.4B8
21621                       00006181            .4B9:
21622                                           ! 3416         shift_flags &= ~0x04;
21623                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
21624 6181           8A46         FD            mov	al,-3[bp]
21625 6184           24                     FB  and	al,#$FB
21626 6186           8846         FD            mov	-3[bp],al
21627                                           !BCC_EOS
21628                                           ! 3417         write_byte(0x0040, 0x17, shift_flags);
21629                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21630 6189           8A46         FD            mov	al,-3[bp]
21631 618C           30E4                       xor	ah,ah
21632 618E           50                         push	ax
21633                                           ! Debug: list int = const $17 (used reg = )
21634 618F           B8                   0017  mov	ax,*$17
21635 6192           50                         push	ax
21636                                           ! Debug: list int = const $40 (used reg = )
21637 6193           B8                   0040  mov	ax,*$40
21638 6196           50                         push	ax
21639                                           ! Debug: func () void = write_byte+0 (used reg = )
21640 6197           E8         A480            call	_write_byte
21641 619A           83C4                   06  add	sp,*6
21642                                           !BCC_EOS
21643                                           ! 3418         if (mf2_state & 0x02) {
21644                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21645 619D           8A46         FB            mov	al,-5[bp]
21646 61A0           24                     02  and	al,*2
21647 61A2           84C0                       test	al,al
21648 61A4           74           1E            je  	.4BA
21649                       000061A6            .4BB:
21650                                           ! 3419           mf2_state &= ~0x04;
21651                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
21652 61A6           8A46         FB            mov	al,-5[bp]
21653 61A9           24                     FB  and	al,#$FB
21654 61AB           8846         FB            mov	-5[bp],al
21655                                           !BCC_EOS
21656                                           ! 3420           write_byte(0x0040, 0x96, mf2_state);
21657                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21658 61AE           8A46         FB            mov	al,-5[bp]
21659 61B1           30E4                       xor	ah,ah
21660 61B3           50                         push	ax
21661                                           ! Debug: list int = const $96 (used reg = )
21662 61B4           B8                   0096  mov	ax,#$96
21663 61B7           50                         push	ax
21664                                           ! Debug: list int = const $40 (used reg = )
21665 61B8           B8                   0040  mov	ax,*$40
21666 61BB           50                         push	ax
21667                                           ! Debug: func () void = write_byte+0 (used reg = )
21668 61BC           E8         A45B            call	_write_byte
21669 61BF           83C4                   06  add	sp,*6
21670                                           !BCC_EOS
21671                                           ! 3421         } else {
21672 61C2           EB           1C            jmp .4BC
21673                       000061C4            .4BA:
21674                                           ! 3422           mf2_flags &= ~0x01;
21675                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
21676 61C4           8A46         FC            mov	al,-4[bp]
21677 61C7           24                     FE  and	al,#$FE
21678 61C9           8846         FC            mov	-4[bp],al
21679                                           !BCC_EOS
21680                                           ! 3423           write_byte(0x0040, 0x18, mf2_flags);
21681                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21682 61CC           8A46         FC            mov	al,-4[bp]
21683 61CF           30E4                       xor	ah,ah
21684 61D1           50                         push	ax
21685                                           ! Debug: list int = const $18 (used reg = )
21686 61D2           B8                   0018  mov	ax,*$18
21687 61D5           50                         push	ax
21688                                           ! Debug: list int = const $40 (used reg = )
21689 61D6           B8                   0040  mov	ax,*$40
21690 61D9           50                         push	ax
21691                                           ! Debug: func () void = write_byte+0 (used reg = )
21692 61DA           E8         A43D            call	_write_byte
21693 61DD           83C4                   06  add	sp,*6
21694                                           !BCC_EOS
21695                                           ! 3424         }
21696                                           ! 3425       }
21697                       000061E0            .4BC:
21698                                           ! 3426       break;
21699                       000061E0            .4B8:
21700 61E0           E9         0421            br 	.4A8
21701                                           !BCC_EOS
21702                                           ! 3427     case 0x38:
21703                                           ! 3428       shift_flags |= 0x08;
21704                       000061E3            .4BD:
21705                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
21706 61E3           8A46         FD            mov	al,-3[bp]
21707 61E6           0C                     08  or	al,*8
21708 61E8           8846         FD            mov	-3[bp],al
21709                                           !BCC_EOS
21710                                           ! 3429       write_byte(0x0040, 0x17, shift_flags);
21711                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21712 61EB           8A46         FD            mov	al,-3[bp]
21713 61EE           30E4                       xor	ah,ah
21714 61F0           50                         push	ax
21715                                           ! Debug: list int = const $17 (used reg = )
21716 61F1           B8                   0017  mov	ax,*$17
21717 61F4           50                         push	ax
21718                                           ! Debug: list int = const $40 (used reg = )
21719 61F5           B8                   0040  mov	ax,*$40
21720 61F8           50                         push	ax
21721                                           ! Debug: func () void = write_byte+0 (used reg = )
21722 61F9           E8         A41E            call	_write_byte
21723 61FC           83C4                   06  add	sp,*6
21724                                           !BCC_EOS
21725                                           ! 3430       if (mf2_state & 0x02) {
21726                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21727 61FF           8A46         FB            mov	al,-5[bp]
21728 6202           24                     02  and	al,*2
21729 6204           84C0                       test	al,al
21730 6206           74           1E            je  	.4BE
21731                       00006208            .4BF:
21732                                           ! 3431         mf2_state |= 0x08;
21733                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
21734 6208           8A46         FB            mov	al,-5[bp]
21735 620B           0C                     08  or	al,*8
21736 620D           8846         FB            mov	-5[bp],al
21737                                           !BCC_EOS
21738                                           ! 3432         write_byte(0x0040, 0x96, mf2_state);
21739                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21740 6210           8A46         FB            mov	al,-5[bp]
21741 6213           30E4                       xor	ah,ah
21742 6215           50                         push	ax
21743                                           ! Debug: list int = const $96 (used reg = )
21744 6216           B8                   0096  mov	ax,#$96
21745 6219           50                         push	ax
21746                                           ! Debug: list int = const $40 (used reg = )
21747 621A           B8                   0040  mov	ax,*$40
21748 621D           50                         push	ax
21749                                           ! Debug: func () void = write_byte+0 (used reg = )
21750 621E           E8         A3F9            call	_write_byte
21751 6221           83C4                   06  add	sp,*6
21752                                           !BCC_EOS
21753                                           ! 3433       } else {
21754 6224           EB           1C            jmp .4C0
21755                       00006226            .4BE:
21756                                           ! 3434         mf2_flags |= 0x02;
21757                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
21758 6226           8A46         FC            mov	al,-4[bp]
21759 6229           0C                     02  or	al,*2
21760 622B           8846         FC            mov	-4[bp],al
21761                                           !BCC_EOS
21762                                           ! 3435         write_byte(0x0040, 0x18, mf2_flags);
21763                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21764 622E           8A46         FC            mov	al,-4[bp]
21765 6231           30E4                       xor	ah,ah
21766 6233           50                         push	ax
21767                                           ! Debug: list int = const $18 (used reg = )
21768 6234           B8                   0018  mov	ax,*$18
21769 6237           50                         push	ax
21770                                           ! Debug: list int = const $40 (used reg = )
21771 6238           B8                   0040  mov	ax,*$40
21772 623B           50                         push	ax
21773                                           ! Debug: func () void = write_byte+0 (used reg = )
21774 623C           E8         A3DB            call	_write_byte
21775 623F           83C4                   06  add	sp,*6
21776                                           !BCC_EOS
21777                                           ! 3436       }
21778                                           ! 3437       break;
21779                       00006242            .4C0:
21780 6242           E9         03BF            br 	.4A8
21781                                           !BCC_EOS
21782                                           ! 3438     case 0xb8:
21783                                           ! 3439       shift_flags &= ~0x08;
21784                       00006245            .4C1:
21785                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
21786 6245           8A46         FD            mov	al,-3[bp]
21787 6248           24                     F7  and	al,#$F7
21788 624A           8846         FD            mov	-3[bp],al
21789                                           !BCC_EOS
21790                                           ! 3440       write_byte(0x0040, 0x17, shift_flags);
21791                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21792 624D           8A46         FD            mov	al,-3[bp]
21793 6250           30E4                       xor	ah,ah
21794 6252           50                         push	ax
21795                                           ! Debug: list int = const $17 (used reg = )
21796 6253           B8                   0017  mov	ax,*$17
21797 6256           50                         push	ax
21798                                           ! Debug: list int = const $40 (used reg = )
21799 6257           B8                   0040  mov	ax,*$40
21800 625A           50                         push	ax
21801                                           ! Debug: func () void = write_byte+0 (used reg = )
21802 625B           E8         A3BC            call	_write_byte
21803 625E           83C4                   06  add	sp,*6
21804                                           !BCC_EOS
21805                                           ! 3441       if (mf2_state & 0x02) {
21806                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21807 6261           8A46         FB            mov	al,-5[bp]
21808 6264           24                     02  and	al,*2
21809 6266           84C0                       test	al,al
21810 6268           74           1E            je  	.4C2
21811                       0000626A            .4C3:
21812                                           ! 3442         mf2_state &= ~0x08;
21813                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
21814 626A           8A46         FB            mov	al,-5[bp]
21815 626D           24                     F7  and	al,#$F7
21816 626F           8846         FB            mov	-5[bp],al
21817                                           !BCC_EOS
21818                                           ! 3443         write_byte(0x0040, 0x96, mf2_state);
21819                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21820 6272           8A46         FB            mov	al,-5[bp]
21821 6275           30E4                       xor	ah,ah
21822 6277           50                         push	ax
21823                                           ! Debug: list int = const $96 (used reg = )
21824 6278           B8                   0096  mov	ax,#$96
21825 627B           50                         push	ax
21826                                           ! Debug: list int = const $40 (used reg = )
21827 627C           B8                   0040  mov	ax,*$40
21828 627F           50                         push	ax
21829                                           ! Debug: func () void = write_byte+0 (used reg = )
21830 6280           E8         A397            call	_write_byte
21831 6283           83C4                   06  add	sp,*6
21832                                           !BCC_EOS
21833                                           ! 3444       } else {
21834 6286           EB           1C            jmp .4C4
21835                       00006288            .4C2:
21836                                           ! 3445         mf2_flags &= ~0x02;
21837                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
21838 6288           8A46         FC            mov	al,-4[bp]
21839 628B           24                     FD  and	al,#$FD
21840 628D           8846         FC            mov	-4[bp],al
21841                                           !BCC_EOS
21842                                           ! 3446         write_byte(0x0040, 0x18, mf2_flags);
21843                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21844 6290           8A46         FC            mov	al,-4[bp]
21845 6293           30E4                       xor	ah,ah
21846 6295           50                         push	ax
21847                                           ! Debug: list int = const $18 (used reg = )
21848 6296           B8                   0018  mov	ax,*$18
21849 6299           50                         push	ax
21850                                           ! Debug: list int = const $40 (used reg = )
21851 629A           B8                   0040  mov	ax,*$40
21852 629D           50                         push	ax
21853                                           ! Debug: func () void = write_byte+0 (used reg = )
21854 629E           E8         A379            call	_write_byte
21855 62A1           83C4                   06  add	sp,*6
21856                                           !BCC_EOS
21857                                           ! 3447       }
21858                                           ! 3448       break;
21859                       000062A4            .4C4:
21860 62A4           E9         035D            br 	.4A8
21861                                           !BCC_EOS
21862                                           ! 3449     case 0x45:
21863                                           ! 3450       if ((mf2_state & 0x03) == 0) {
21864                       000062A7            .4C5:
21865                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
21866 62A7           8A46         FB            mov	al,-5[bp]
21867 62AA           24                     03  and	al,*3
21868                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21869 62AC           84C0                       test	al,al
21870 62AE           75           38            jne 	.4C6
21871                       000062B0            .4C7:
21872                                           ! 3451         mf2_flags |= 0x20;
21873                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
21874 62B0           8A46         FC            mov	al,-4[bp]
21875 62B3           0C                     20  or	al,*$20
21876 62B5           8846         FC            mov	-4[bp],al
21877                                           !BCC_EOS
21878                                           ! 3452         write_byte(0x0040, 0x18, mf2_flags);
21879                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21880 62B8           8A46         FC            mov	al,-4[bp]
21881 62BB           30E4                       xor	ah,ah
21882 62BD           50                         push	ax
21883                                           ! Debug: list int = const $18 (used reg = )
21884 62BE           B8                   0018  mov	ax,*$18
21885 62C1           50                         push	ax
21886                                           ! Debug: list int = const $40 (used reg = )
21887 62C2           B8                   0040  mov	ax,*$40
21888 62C5           50                         push	ax
21889                                           ! Debug: func () void = write_byte+0 (used reg = )
21890 62C6           E8         A351            call	_write_byte
21891 62C9           83C4                   06  add	sp,*6
21892                                           !BCC_EOS
21893                                           ! 3453         shift_flags ^= 0x20;
21894                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
21895 62CC           8A46         FD            mov	al,-3[bp]
21896 62CF           34                     20  xor	al,*$20
21897 62D1           8846         FD            mov	-3[bp],al
21898                                           !BCC_EOS
21899                                           ! 3454         write_byte(0x0040, 0x17, shift_flags);
21900                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21901 62D4           8A46         FD            mov	al,-3[bp]
21902 62D7           30E4                       xor	ah,ah
21903 62D9           50                         push	ax
21904                                           ! Debug: list int = const $17 (used reg = )
21905 62DA           B8                   0017  mov	ax,*$17
21906 62DD           50                         push	ax
21907                                           ! Debug: list int = const $40 (used reg = )
21908 62DE           B8                   0040  mov	ax,*$40
21909 62E1           50                         push	ax
21910                                           ! Debug: func () void = write_byte+0 (used reg = )
21911 62E2           E8         A335            call	_write_byte
21912 62E5           83C4                   06  add	sp,*6
21913                                           !BCC_EOS
21914                                           ! 3455       }
21915                                           ! 3456       break;
21916                       000062E8            .4C6:
21917 62E8           E9         0319            br 	.4A8
21918                                           !BCC_EOS
21919                                           ! 3457     case 0xc5:
21920                                           ! 3458       if ((mf2_state & 0x03) == 0) {
21921                       000062EB            .4C8:
21922                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
21923 62EB           8A46         FB            mov	al,-5[bp]
21924 62EE           24                     03  and	al,*3
21925                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21926 62F0           84C0                       test	al,al
21927 62F2           75           1C            jne 	.4C9
21928                       000062F4            .4CA:
21929                                           ! 3459         mf2_flag
21930                                           ! 3459 s &= ~0x20;
21931                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
21932 62F4           8A46         FC            mov	al,-4[bp]
21933 62F7           24                     DF  and	al,#$DF
21934 62F9           8846         FC            mov	-4[bp],al
21935                                           !BCC_EOS
21936                                           ! 3460         write_byte(0x0040, 0x18, mf2_flags);
21937                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21938 62FC           8A46         FC            mov	al,-4[bp]
21939 62FF           30E4                       xor	ah,ah
21940 6301           50                         push	ax
21941                                           ! Debug: list int = const $18 (used reg = )
21942 6302           B8                   0018  mov	ax,*$18
21943 6305           50                         push	ax
21944                                           ! Debug: list int = const $40 (used reg = )
21945 6306           B8                   0040  mov	ax,*$40
21946 6309           50                         push	ax
21947                                           ! Debug: func () void = write_byte+0 (used reg = )
21948 630A           E8         A30D            call	_write_byte
21949 630D           83C4                   06  add	sp,*6
21950                                           !BCC_EOS
21951                                           ! 3461       }
21952                                           ! 3462       break;
21953                       00006310            .4C9:
21954 6310           E9         02F1            br 	.4A8
21955                                           !BCC_EOS
21956                                           ! 3463     case 0x46:
21957                                           ! 3464       mf2_flags |= 0x10;
21958                       00006313            .4CB:
21959                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
21960 6313           8A46         FC            mov	al,-4[bp]
21961 6316           0C                     10  or	al,*$10
21962 6318           8846         FC            mov	-4[bp],al
21963                                           !BCC_EOS
21964                                           ! 3465       write_byte(0x0040, 0x18, mf2_flags);
21965                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21966 631B           8A46         FC            mov	al,-4[bp]
21967 631E           30E4                       xor	ah,ah
21968 6320           50                         push	ax
21969                                           ! Debug: list int = const $18 (used reg = )
21970 6321           B8                   0018  mov	ax,*$18
21971 6324           50                         push	ax
21972                                           ! Debug: list int = const $40 (used reg = )
21973 6325           B8                   0040  mov	ax,*$40
21974 6328           50                         push	ax
21975                                           ! Debug: func () void = write_byte+0 (used reg = )
21976 6329           E8         A2EE            call	_write_byte
21977 632C           83C4                   06  add	sp,*6
21978                                           !BCC_EOS
21979                                           ! 3466       shift_flags ^= 0x10;
21980                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
21981 632F           8A46         FD            mov	al,-3[bp]
21982 6332           34                     10  xor	al,*$10
21983 6334           8846         FD            mov	-3[bp],al
21984                                           !BCC_EOS
21985                                           ! 3467       write_byte(0x0040, 0x17, shift_flags);
21986                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21987 6337           8A46         FD            mov	al,-3[bp]
21988 633A           30E4                       xor	ah,ah
21989 633C           50                         push	ax
21990                                           ! Debug: list int = const $17 (used reg = )
21991 633D           B8                   0017  mov	ax,*$17
21992 6340           50                         push	ax
21993                                           ! Debug: list int = const $40 (used reg = )
21994 6341           B8                   0040  mov	ax,*$40
21995 6344           50                         push	ax
21996                                           ! Debug: func () void = write_byte+0 (used reg = )
21997 6345           E8         A2D2            call	_write_byte
21998 6348           83C4                   06  add	sp,*6
21999                                           !BCC_EOS
22000                                           ! 3468       break;
22001 634B           E9         02B6            br 	.4A8
22002                                           !BCC_EOS
22003                                           ! 3469     case 0xc6:
22004                                           ! 3470       mf2_flags &= ~0x10;
22005                       0000634E            .4CC:
22006                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
22007 634E           8A46         FC            mov	al,-4[bp]
22008 6351           24                     EF  and	al,#$EF
22009 6353           8846         FC            mov	-4[bp],al
22010                                           !BCC_EOS
22011                                           ! 3471       write_byte(0x0040, 0x18, mf2_flags);
22012                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22013 6356           8A46         FC            mov	al,-4[bp]
22014 6359           30E4                       xor	ah,ah
22015 635B           50                         push	ax
22016                                           ! Debug: list int = const $18 (used reg = )
22017 635C           B8                   0018  mov	ax,*$18
22018 635F           50                         push	ax
22019                                           ! Debug: list int = const $40 (used reg = )
22020 6360           B8                   0040  mov	ax,*$40
22021 6363           50                         push	ax
22022                                           ! Debug: func () void = write_byte+0 (used reg = )
22023 6364           E8         A2B3            call	_write_byte
22024 6367           83C4                   06  add	sp,*6
22025                                           !BCC_EOS
22026                                           ! 3472       break;
22027 636A           E9         0297            br 	.4A8
22028                                           !BCC_EOS
22029                                           ! 3473     case 0x53:
22030                                           ! 3474         if ((shift_flags & 0x0c) == 0x0c)
22031                       0000636D            .4CD:
22032                                           ! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
22033 636D           8A46         FD            mov	al,-3[bp]
22034 6370           24                     0C  and	al,*$C
22035                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
22036 6372           3C                     0C  cmp	al,*$C
22037 6374           75           03            jne 	.4CE
22038                       00006376            .4CF:
22039                                           ! 3475             machine_reset();
22040                                           ! Debug: func () void = machine_reset+0 (used reg = )
22041 6376           E8         AF4E            call	_machine_reset
22042                                           !BCC_EOS
22043                                           ! 3476     default:
22044                       00006379            .4CE:
22045                                           ! 3477       if (scancode & 0x80) {
22046                       00006379            .4D0:
22047                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
22048 6379           8A46         FF            mov	al,-1[bp]
22049 637C           24                     80  and	al,#$80
22050 637E           84C0                       test	al,al
22051 6380           74           03            je  	.4D1
22052                       00006382            .4D2:
22053                                           ! 3478         break;
22054 6382           E9         027F            br 	.4A8
22055                                           !BCC_EOS
22056                                           ! 3479       }
22057                                           ! 3480       if (scancode > 0x58) {
22058                       00006385            .4D1:
22059                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
22060 6385           8A46         FF            mov	al,-1[bp]
22061 6388           3C                     58  cmp	al,*$58
22062 638A           76           04            jbe 	.4D3
22063                       0000638C            .4D4:
22064                                           ! 3481         ;
22065                                           !BCC_EOS
22066                                           ! 3482         return;
22067 638C           89EC                       mov	sp,bp
22068 638E           5D                         pop	bp
22069 638F           C3                         ret
22070                                           !BCC_EOS
22071                                           ! 3483       }
22072                                           ! 3484       if (shift_flags & 0x08) {
22073                       00006390            .4D3:
22074                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22075 6390           8A46         FD            mov	al,-3[bp]
22076 6393           24                     08  and	al,*8
22077 6395           84C0                       test	al,al
22078 6397           74           3D            je  	.4D5
22079                       00006399            .4D6:
22080                                           ! 3485         asciicode = scan_to_scanascii[scancode].alt;
22081                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22082 6399           8A46         FF            mov	al,-1[bp]
22083 639C           30E4                       xor	ah,ah
22084 639E           89C2                       mov	dx,ax
22085 63A0           D1E0                       shl	ax,*1
22086 63A2           D1E0                       shl	ax,*1
22087 63A4           01D0                       add	ax,dx
22088 63A6           D1E0                       shl	ax,*1
22089 63A8           89C3                       mov	bx,ax
22090 63AA           81C3                 01C4  add	bx,#_scan_to_scanascii
22091                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
22092 63AE           8A47         06            mov	al,6[bx]
22093 63B1           8846         FE            mov	-2[bp],al
22094                                           !BCC_EOS
22095                                           ! 3486         scancode = scan_to_scanascii[scancode].alt >> 8;
22096                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22097 63B4           8A46         FF            mov	al,-1[bp]
22098 63B7           30E4                       xor	ah,ah
22099 63B9           89C2                       mov	dx,ax
22100 63BB           D1E0                       shl	ax,*1
22101 63BD           D1E0                       shl	ax,*1
22102 63BF           01D0                       add	ax,dx
22103 63C1           D1E0                       shl	ax,*1
22104 63C3           89C3                       mov	bx,ax
22105 63C5           81C3                 01C4  add	bx,#_scan_to_scanascii
22106                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
22107 63C9           8B47         06            mov	ax,6[bx]
22108 63CC           88E0                       mov	al,ah
22109 63CE           30E4                       xor	ah,ah
22110                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22111 63D0           8846         FF            mov	-1[bp],al
22112                                           !BCC_EOS
22113                                           ! 3487       } else if (shift_flags & 0x04) {
22114 63D3           E9         01AD            br 	.4D7
22115                       000063D6            .4D5:
22116                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
22117 63D6           8A46         FD            mov	al,-3[bp]
22118 63D9           24                     04  and	al,*4
22119 63DB           84C0                       test	al,al
22120 63DD           74           3D            je  	.4D8
22121                       000063DF            .4D9:
22122                                           ! 3488         asciicode = scan_to_scanascii[scancode].control;
22123                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22124 63DF           8A46         FF            mov	al,-1[bp]
22125 63E2           30E4                       xor	ah,ah
22126 63E4           89C2                       mov	dx,ax
22127 63E6           D1E0                       shl	ax,*1
22128 63E8           D1E0                       shl	ax,*1
22129 63EA           01D0                       add	ax,dx
22130 63EC           D1E0                       shl	ax,*1
22131 63EE           89C3                       mov	bx,ax
22132 63F0           81C3                 01C4  add	bx,#_scan_to_scanascii
22133                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
22134 63F4           8A47         04            mov	al,4[bx]
22135 63F7           8846         FE            mov	-2[bp],al
22136                                           !BCC_EOS
22137                                           ! 3489         scancode = scan_to_scanascii[scancode].control >> 8;
22138                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22139 63FA           8A46         FF            mov	al,-1[bp]
22140 63FD           30E4                       xor	ah,ah
22141 63FF           89C2                       mov	dx,ax
22142 6401           D1E0                       shl	ax,*1
22143 6403           D1E0                       shl	ax,*1
22144 6405           01D0                       add	ax,dx
22145 6407           D1E0                       shl	ax,*1
22146 6409           89C3                       mov	bx,ax
22147 640B           81C3                 01C4  add	bx,#_scan_to_scanascii
22148                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
22149 640F           8B47         04            mov	ax,4[bx]
22150 6412           88E0                       mov	al,ah
22151 6414           30E4                       xor	ah,ah
22152                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22153 6416           8846         FF            mov	-1[bp],al
22154                                           !BCC_EOS
22155                                           ! 3490       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
22156 6419           E9         0167            br 	.4DA
22157                       0000641C            .4D8:
22158                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22159 641C           8A46         FB            mov	al,-5[bp]
22160 641F           24                     02  and	al,*2
22161                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
22162 6421           84C0                       test	al,al
22163 6423           74           32            je  	.4DB
22164                       00006425            .4DD:
22165                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
22166 6425           8A46         FF            mov	al,-1[bp]
22167 6428           3C                     47  cmp	al,*$47
22168 642A           72           2B            jb  	.4DB
22169                       0000642C            .4DE:
22170                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
22171 642C           8A46         FF            mov	al,-1[bp]
22172 642F           3C                     53  cmp	al,*$53
22173 6431           77           24            ja  	.4DB
22174                       00006433            .4DC:
22175                                           ! 3491         asciicode = 0xe0;
22176                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
22177 6433           B0                     E0  mov	al,#$E0
22178 6435           8846         FE            mov	-2[bp],al
22179                                           !BCC_EOS
22180                                           ! 3492         scancode = scan_to_scanascii[scancode].normal >> 8;
22181                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22182 6438           8A46         FF            mov	al,-1[bp]
22183 643B           30E4                       xor	ah,ah
22184 643D           89C2                       mov	dx,ax
22185 643F           D1E0                       shl	ax,*1
22186 6441           D1E0                       shl	ax,*1
22187 6443           01D0                       add	ax,dx
22188 6445           D1E0                       shl	ax,*1
22189 6447           89C3                       mov	bx,ax
22190                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22191 6449           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22192 644D           88E0                       mov	al,ah
22193 644F           30E4                       xor	ah,ah
22194                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22195 6451           8846         FF            mov	-1[bp],al
22196                                           !BCC_EOS
22197                                           ! 3493       } else if (shift_flags & 0x03) {
22198 6454           E9         012C            br 	.4DF
22199                       00006457            .4DB:
22200                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
22201 6457           8A46         FD            mov	al,-3[bp]
22202 645A           24                     03  and	al,*3
22203 645C           84C0                       test	al,al
22204 645E         0F84         0092            beq 	.4E0
22205                       00006462            .4E1:
22206                                           ! 3494         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22207                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22208 6462           8A46         FF            mov	al,-1[bp]
22209 6465           30E4                       xor	ah,ah
22210 6467           89C2                       mov	dx,ax
22211 6469           D1E0                       shl	ax,*1
22212 646B           D1E0                       shl	ax,*1
22213 646D           01D0                       add	ax,dx
22214 646F           D1E0                       shl	ax,*1
22215 6471           89C3                       mov	bx,ax
22216 6473           81C3                 01C4  add	bx,#_scan_to_scanascii
22217                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22218 6477           8A46         FD            mov	al,-3[bp]
22219 647A           2247         08            and	al,8[bx]
22220 647D           84C0                       test	al,al
22221 647F           74           36            je  	.4E2
22222                       00006481            .4E3:
22223                                           ! 3495           asciicode = scan_to_scanascii[scancode].normal;
22224                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22225 6481           8A46         FF            mov	al,-1[bp]
22226 6484           30E4                       xor	ah,ah
22227 6486           89C2                       mov	dx,ax
22228 6488           D1E0                       shl	ax,*1
22229 648A           D1E0                       shl	ax,*1
22230 648C           01D0                       add	ax,dx
22231 648E           D1E0                       shl	ax,*1
22232 6490           89C3                       mov	bx,ax
22233                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22234 6492           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22235 6496           8846         FE            mov	-2[bp],al
22236                                           !BCC_EOS
22237                                           ! 3496           scancode = scan_to_scanascii[scancode].normal >> 8;
22238                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22239 6499           8A46         FF            mov	al,-1[bp]
22240 649C           30E4                       xor	ah,ah
22241 649E           89C2                       mov	dx,ax
22242 64A0           D1E0                       shl	ax,*1
22243 64A2           D1E0                       shl	ax,*1
22244 64A4           01D0                       add	ax,dx
22245 64A6           D1E0                       shl	ax,*1
22246 64A8           89C3                       mov	bx,ax
22247                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22248 64AA           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22249 64AE           88E0                       mov	al,ah
22250 64B0           30E4                       xor	ah,ah
22251                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22252 64B2           8846         FF            mov	-1[bp],al
22253                                           !BCC_EOS
22254                                           ! 3497         } else {
22255 64B5           EB           3A            jmp .4E4
22256                       000064B7            .4E2:
22257                                           ! 3498           asciicode = scan_to_scanascii[scancode].shift;
22258                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22259 64B7           8A46         FF            mov	al,-1[bp]
22260 64BA           30E4                       xor	ah,ah
22261 64BC           89C2                       mov	dx,ax
22262 64BE           D1E0                       shl	ax,*1
22263 64C0           D1E0                       shl	ax,*1
22264 64C2           01D0                       add	ax,dx
22265 64C4           D1E0                       shl	ax,*1
22266 64C6           89C3                       mov	bx,ax
22267 64C8           81C3                 01C4  add	bx,#_scan_to_scanascii
22268                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22269 64CC           8A47         02            mov	al,2[bx]
22270 64CF           8846         FE            mov	-2[bp],al
22271                                           !BCC_EOS
22272                                           ! 3499           scancode = scan_to_scanascii[scancode].shift >> 8;
22273                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22274 64D2           8A46         FF            mov	al,-1[bp]
22275 64D5           30E4                       xor	ah,ah
22276 64D7           89C2                       mov	dx,ax
22277 64D9           D1E0                       shl	ax,*1
22278 64DB           D1E0                       shl	ax,*1
22279 64DD           01D0                       add	ax,dx
22280 64DF           D1E0                       shl	ax,*1
22281 64E1           89C3                       mov	bx,ax
22282 64E3           81C3                 01C4  add	bx,#_scan_to_scanascii
22283                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22284 64E7           8B47         02            mov	ax,2[bx]
22285 64EA           88E0                       mov	al,ah
22286 64EC           30E4                       xor	ah,ah
22287                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22288 64EE           8846         FF            mov	-1[bp],al
22289                                           !BCC_EOS
22290                                           ! 3500         }
22291                                           ! 3501       } else {
22292                       000064F1            .4E4:
22293 64F1           E9         008F            br 	.4E5
22294                       000064F4            .4E0:
22295                                           ! 3502         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22296                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22297 64F4           8A46         FF            mov	al,-1[bp]
22298 64F7           30E4                       xor	ah,ah
22299 64F9           89C2                       mov	dx,ax
22300 64FB           D1E0                       shl	ax,*1
22301 64FD           D1E0                       shl	ax,*1
22302 64FF           01D0                       add	ax,dx
22303 6501           D1E0                       shl	ax,*1
22304 6503           89C3                       mov	bx,ax
22305 6505           81C3                 01C4  add	bx,#_scan_to_scanascii
22306                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22307 6509           8A46         FD            mov	al,-3[bp]
22308 650C           2247         08            and	al,8[bx]
22309 650F           84C0                       test	al,al
22310 6511           74           3C            je  	.4E6
22311                       00006513            .4E7:
22312                                           ! 3503           asciicode = scan_to_scanascii[scancode].shift;
22313                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22314 6513           8A46         FF            mov	al,-1[bp]
22315 6516           30E4                       xor	ah,ah
22316 6518           89C2                       mov	dx,ax
22317 651A           D1E0                       shl	ax,*1
22318 651C           D1E0                       shl	ax,*1
22319 651E           01D0                       add	ax,dx
22320 6520           D1E0                       shl	ax,*1
22321 6522           89C3                       mov	bx,ax
22322 6524           81C3                 01C4  add	bx,#_scan_to_scanascii
22323                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22324 6528           8A47         02            mov	al,2[bx]
22325 652B           8846         FE            mov	-2[bp],al
22326                                           !BCC_EOS
22327                                           ! 3504           scancode = scan_to_scanascii[scancode].shift >> 8;
22328                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22329 652E           8A46         FF            mov	al,-1[bp]
22330 6531           30E4                       xor	ah,ah
22331 6533           89C2                       mov	dx,ax
22332 6535           D1E0                       shl	ax,*1
22333 6537           D1E0                       shl	ax,*1
22334 6539           01D0                       add	ax,dx
22335 653B           D1E0                       shl	ax,*1
22336 653D           89C3                       mov	bx,ax
22337 653F           81C3                 01C4  add	bx,#_scan_to_scanascii
22338                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22339 6543           8B47         02            mov	ax,2[bx]
22340 6546           88E0                       mov	al,ah
22341 6548           30E4                       xor	ah,ah
22342                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22343 654A           8846         FF            mov	-1[bp],al
22344                                           !BCC_EOS
22345                                           ! 3505         } else {
22346 654D           EB           34            jmp .4E8
22347                       0000654F            .4E6:
22348                                           ! 3506           asciicode = scan_to_scanascii[scancode].normal;
22349                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22350 654F           8A46         FF            mov	al,-1[bp]
22351 6552           30E4                       xor	ah,ah
22352 6554           89C2                       mov	dx,ax
22353 6556           D1E0                       shl	ax,*1
22354 6558           D1E0                       shl	ax,*1
22355 655A           01D0                       add	ax,dx
22356 655C           D1E0                       shl	ax,*1
22357 655E           89C3                       mov	bx,ax
22358                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22359 6560           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22360 6564           8846         FE            mov	-2[bp],al
22361                                           !BCC_EOS
22362                                           ! 3507           scancode = scan_to_scanascii[scancode].normal >> 8;
22363                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22364 6567           8A46         FF            mov	al,-1[bp]
22365 656A           30E4                       xor	ah,ah
22366 656C           89C2                       mov	dx,ax
22367 656E           D1E0                       shl	ax,*1
22368 6570           D1E0                       shl	ax,*1
22369 6572           01D0                       add	ax,dx
22370 6574           D1E0                       shl	ax,*1
22371 6576           89C3                       mov	bx,ax
22372                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22373 6578           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22374 657C           88E0                       mov	al,ah
22375 657E           30E4                       xor	ah,ah
22376                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22377 6580           8846         FF            mov	-1[bp],al
22378                                           !BCC_EOS
22379                                           ! 3508         }
22380                                           ! 3509       }
22381                       00006583            .4E8:
22382                                           ! 3510       if (scancode==0 && asciicode==0) {
22383                       00006583            .4E5:
22384                       00006583            .4DF:
22385                       00006583            .4DA:
22386                       00006583            .4D7:
22387                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
22388 6583           8A46         FF            mov	al,-1[bp]
22389 6586           84C0                       test	al,al
22390 6588           75           07            jne 	.4E9
22391                       0000658A            .4EB:
22392                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
22393 658A           8A46         FE            mov	al,-2[bp]
22394 658D           84C0                       test	al,al
22395 658F           75           00            jne 	.4E9
22396                       00006591            .4EA:
22397                                           ! 3511         ;
22398                                           !BCC_EOS
22399                                           ! 3512       }
22400                                           ! 3513       enqueue_key(scancode, asciicode);
22401                       00006591            .4E9:
22402                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
22403 6591           8A46         FE            mov	al,-2[bp]
22404 6594           30E4                       xor	ah,ah
22405 6596           50                         push	ax
22406                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
22407 6597           8A46         FF            mov	al,-1[bp]
22408 659A           30E4                       xor	ah,ah
22409 659C           50                         push	ax
22410                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
22411 659D           E8         0095            call	_enqueue_key
22412 65A0           83C4                   04  add	sp,*4
22413                                           !BCC_EOS
22414                                           ! 3514       break;
22415 65A3           EB           5F            jmp .4A8
22416                                           !BCC_EOS
22417                                           ! 3515   }
22418                                           ! 3516   if ((scancode & 0x7f) != 0x1d) {
22419 65A5           EB           5D            jmp .4A8
22420                       000065A7            .4AA:
22421 65A7           2C                     1D  sub	al,*$1D
22422 65A9         0F84         FB60            beq 	.4B1
22423 65AD           2C                     0D  sub	al,*$D
22424 65AF         0F84         FADE            beq 	.4AD
22425 65B3           2C                     0C  sub	al,*$C
22426 65B5         0F84         FB16            beq 	.4AF
22427 65B9           2C                     02  sub	al,*2
22428 65BB         0F84         FC24            beq 	.4BD
22429 65BF           2C                     02  sub	al,*2
22430 65C1         0F84         FA72            beq 	.4AB
22431 65C5           2C                     0B  sub	al,*$B
22432 65C7         0F84         FCDC            beq 	.4C5
22433 65CB           2C                     01  sub	al,*1
22434 65CD         0F84         FD42            beq 	.4CB
22435 65D1           2C                     0D  sub	al,*$D
22436 65D3         0F84         FD96            beq 	.4CD
22437 65D7           2C                     4A  sub	al,*$4A
22438 65D9         0F84         FB9B            beq 	.4B7
22439 65DD           2C                     0D  sub	al,*$D
22440 65DF         0F84         FACD            beq 	.4AE
22441 65E3           2C                     0C  sub	al,*$C
22442 65E5         0F84         FB05            beq 	.4B0
22443 65E9           2C                     02  sub	al,*2
22444 65EB         0F84         FC56            beq 	.4C1
22445 65EF           2C                     02  sub	al,*2
22446 65F1         0F84         FA7D            beq 	.4AC
22447 65F5           2C                     0B  sub	al,*$B
22448 65F7         0F84         FCF0            beq 	.4C8
22449 65FB           2C                     01  sub	al,*1
22450 65FD         0F84         FD4D            beq 	.4CC
22451 6601           E9         FD75            br 	.4D0
22452                       00006604            .4A8:
22453                       FFFFFFF8            ..FFF2	=	-8
22454                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
22455 6604           8A46         FF            mov	al,-1[bp]
22456 6607           24                     7F  and	al,*$7F
22457                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
22458 6609           3C                     1D  cmp	al,*$1D
22459 660B           74           08            je  	.4EC
22460                       0000660D            .4ED:
22461                                           ! 3517     mf2_state &= ~0x01;
22462                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
22463 660D           8A46         FB            mov	al,-5[bp]
22464 6610           24                     FE  and	al,#$FE
22465 6612           8846         FB            mov	-5[bp],al
22466                                           !BCC_EOS
22467                                           ! 3518   }
22468                                           ! 3519   mf2_state &= ~0x02;
22469                       00006615            .4EC:
22470                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
22471 6615           8A46         FB            mov	al,-5[bp]
22472 6618           24                     FD  and	al,#$FD
22473 661A           8846         FB            mov	-5[bp],al
22474                                           !BCC_EOS
22475                                           ! 3520   write_byte(0x0040, 0x96, mf2_state);
22476                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22477 661D           8A46         FB            mov	al,-5[bp]
22478 6620           30E4                       xor	ah,ah
22479 6622           50                         push	ax
22480                                           ! Debug: list int = const $96 (used reg = )
22481 6623           B8                   0096  mov	ax,#$96
22482 6626           50                         push	ax
22483                                           ! Debug: list int = const $40 (used reg = )
22484 6627           B8                   0040  mov	ax,*$40
22485 662A           50                         push	ax
22486                                           ! Debug: func () void = write_byte+0 (used reg = )
22487 662B           E8         9FEC            call	_write_byte
22488 662E           83C4                   06  add	sp,*6
22489                                           !BCC_EOS
22490                                           ! 3521 }
22491 6631           89EC                       mov	sp,bp
22492 6633           5D                         pop	bp
22493 6634           C3                         ret
22494                                           ! 3522   unsigned int
22495                                           ! Register BX used in function int09_function
22496                                           ! 3523 enqueue_key(scan_code, ascii_c
22497                                           ! 3523 ode)
22498                                           ! 3524   Bit8u scan_code, ascii_code;
22499                                           export	_enqueue_key
22500                       00006635            _enqueue_key:
22501                                           !BCC_EOS
22502                                           ! 3525 {
22503                                           ! 3526   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
22504                                           !BCC_EOS
22505                                           ! 3527   buffer_start = read_word(0x0040, 0x0080);
22506 6635           55                         push	bp
22507 6636           89E5                       mov	bp,sp
22508 6638           83C4                   F6  add	sp,*-$A
22509                                           ! Debug: list int = const $80 (used reg = )
22510 663B           B8                   0080  mov	ax,#$80
22511 663E           50                         push	ax
22512                                           ! Debug: list int = const $40 (used reg = )
22513 663F           B8                   0040  mov	ax,*$40
22514 6642           50                         push	ax
22515                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22516 6643           E8         9FC1            call	_read_word
22517 6646           83C4                   04  add	sp,*4
22518                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
22519 6649           8946         FE            mov	-2[bp],ax
22520                                           !BCC_EOS
22521                                           ! 3528   buffer_end = read_word(0x0040, 0x0082);
22522                                           ! Debug: list int = const $82 (used reg = )
22523 664C           B8                   0082  mov	ax,#$82
22524 664F           50                         push	ax
22525                                           ! Debug: list int = const $40 (used reg = )
22526 6650           B8                   0040  mov	ax,*$40
22527 6653           50                         push	ax
22528                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22529 6654           E8         9FB0            call	_read_word
22530 6657           83C4                   04  add	sp,*4
22531                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
22532 665A           8946         FC            mov	-4[bp],ax
22533                                           !BCC_EOS
22534                                           ! 3529   buffer_head = read_word(0x0040, 0x001A);
22535                                           ! Debug: list int = const $1A (used reg = )
22536 665D           B8                   001A  mov	ax,*$1A
22537 6660           50                         push	ax
22538                                           ! Debug: list int = const $40 (used reg = )
22539 6661           B8                   0040  mov	ax,*$40
22540 6664           50                         push	ax
22541                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22542 6665           E8         9F9F            call	_read_word
22543 6668           83C4                   04  add	sp,*4
22544                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
22545 666B           8946         FA            mov	-6[bp],ax
22546                                           !BCC_EOS
22547                                           ! 3530   buffer_tail = read_word(0x0040, 0x001C);
22548                                           ! Debug: list int = const $1C (used reg = )
22549 666E           B8                   001C  mov	ax,*$1C
22550 6671           50                         push	ax
22551                                           ! Debug: list int = const $40 (used reg = )
22552 6672           B8                   0040  mov	ax,*$40
22553 6675           50                         push	ax
22554                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22555 6676           E8         9F8E            call	_read_word
22556 6679           83C4                   04  add	sp,*4
22557                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22558 667C           8946         F8            mov	-8[bp],ax
22559                                           !BCC_EOS
22560                                           ! 3531   temp_tail = buffer_tail;
22561                                           ! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
22562 667F           8B46         F8            mov	ax,-8[bp]
22563 6682           8946         F6            mov	-$A[bp],ax
22564                                           !BCC_EOS
22565                                           ! 3532   buffer_tail += 2;
22566                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22567 6685           8B46         F8            mov	ax,-8[bp]
22568 6688           40                         inc	ax
22569 6689           40                         inc	ax
22570 668A           8946         F8            mov	-8[bp],ax
22571                                           !BCC_EOS
22572                                           ! 3533   if (buffer_tail >= buffer_end)
22573                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22574 668D           8B46         F8            mov	ax,-8[bp]
22575 6690           3B46         FC            cmp	ax,-4[bp]
22576 6693           72           06            jb  	.4EE
22577                       00006695            .4EF:
22578                                           ! 3534     buffer_tail = buffer_start;
22579                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22580 6695           8B46         FE            mov	ax,-2[bp]
22581 6698           8946         F8            mov	-8[bp],ax
22582                                           !BCC_EOS
22583                                           ! 3535   if (buffer_tail == buffer_head) {
22584                       0000669B            .4EE:
22585                                           ! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22586 669B           8B46         F8            mov	ax,-8[bp]
22587 669E           3B46         FA            cmp	ax,-6[bp]
22588 66A1           75           06            jne 	.4F0
22589                       000066A3            .4F1:
22590                                           ! 3536     return(0);
22591 66A3           31C0                       xor	ax,ax
22592 66A5           89EC                       mov	sp,bp
22593 66A7           5D                         pop	bp
22594 66A8           C3                         ret
22595                                           !BCC_EOS
22596                                           ! 3537     }
22597                                           ! 3538    write_byte(0x0040, temp_tail, ascii_code);
22598                       000066A9            .4F0:
22599                                           ! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
22600 66A9           8A46         06            mov	al,6[bp]
22601 66AC           30E4                       xor	ah,ah
22602 66AE           50                         push	ax
22603                                           ! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
22604 66AF           FF76         F6            push	-$A[bp]
22605                                           ! Debug: list int = const $40 (used reg = )
22606 66B2           B8                   0040  mov	ax,*$40
22607 66B5           50                         push	ax
22608                                           ! Debug: func () void = write_byte+0 (used reg = )
22609 66B6           E8         9F61            call	_write_byte
22610 66B9           83C4                   06  add	sp,*6
22611                                           !BCC_EOS
22612                                           ! 3539    write_byte(0x0040, temp_tail+1, scan_code);
22613                                           ! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
22614 66BC           8A46         04            mov	al,4[bp]
22615 66BF           30E4                       xor	ah,ah
22616 66C1           50                         push	ax
22617                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
22618 66C2           8B46         F6            mov	ax,-$A[bp]
22619                                           ! Debug: list unsigned int = ax+1 (used reg = )
22620 66C5           40                         inc	ax
22621 66C6           50                         push	ax
22622                                           ! Debug: list int = const $40 (used reg = )
22623 66C7           B8                   0040  mov	ax,*$40
22624 66CA           50                         push	ax
22625                                           ! Debug: func () void = write_byte+0 (used reg = )
22626 66CB           E8         9F4C            call	_write_byte
22627 66CE           83C4                   06  add	sp,*6
22628                                           !BCC_EOS
22629                                           ! 3540    write_word(0x0040, 0x001C, buffer_tail);
22630                                           ! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
22631 66D1           FF76         F8            push	-8[bp]
22632                                           ! Debug: list int = const $1C (used reg = )
22633 66D4           B8                   001C  mov	ax,*$1C
22634 66D7           50                         push	ax
22635                                           ! Debug: list int = const $40 (used reg = )
22636 66D8           B8                   0040  mov	ax,*$40
22637 66DB           50                         push	ax
22638                                           ! Debug: func () void = write_word+0 (used reg = )
22639 66DC           E8         9F53            call	_write_word
22640 66DF           83C4                   06  add	sp,*6
22641                                           !BCC_EOS
22642                                           ! 3541    return(1);
22643 66E2           B8                   0001  mov	ax,*1
22644 66E5           89EC                       mov	sp,bp
22645 66E7           5D                         pop	bp
22646 66E8           C3                         ret
22647                                           !BCC_EOS
22648                                           ! 3542 }
22649                                           ! 3543   void
22650                                           ! 3544 int74_function(make_farcall, Z, Y, X, status)
22651                                           ! 3545   Bit16u make_farcall, Z, Y, X, status;
22652                                           export	_int74_function
22653                       000066E9            _int74_function:
22654                                           !BCC_EOS
22655                                           ! 3546 {
22656                                           ! 3547   Bit16u ebda_seg=read_word(0x0040,0x000E);
22657 66E9           55                         push	bp
22658 66EA           89E5                       mov	bp,sp
22659 66EC           4C                         dec	sp
22660 66ED           4C                         dec	sp
22661                                           ! Debug: list int = const $E (used reg = )
22662 66EE           B8                   000E  mov	ax,*$E
22663 66F1           50                         push	ax
22664                                           ! Debug: list int = const $40 (used reg = )
22665 66F2           B8                   0040  mov	ax,*$40
22666 66F5           50                         push	ax
22667                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22668 66F6           E8         9F0E            call	_read_word
22669 66F9           83C4                   04  add	sp,*4
22670                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
22671 66FC           8946         FE            mov	-2[bp],ax
22672                                           !BCC_EOS
22673                                           ! 3548   Bit8u in_byte, index, package_count;
22674                                           !BCC_EOS
22675                                           ! 3549   Bit8u mouse_flags_1, mouse_flags_2;
22676                                           !BCC_EOS
22677                                           ! 3550 ;
22678 66FF           83C4                   FA  add	sp,*-6
22679                                           !BCC_EOS
22680                                           ! 3551   make_farcall = 0;
22681                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
22682 6702           31C0                       xor	ax,ax
22683 6704           8946         04            mov	4[bp],ax
22684                                           !BCC_EOS
22685                                           ! 3552   in_byte = inb(0x64);
22686                                           ! Debug: list int = const $64 (used reg = )
22687 6707           B8                   0064  mov	ax,*$64
22688 670A           50                         push	ax
22689                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22690 670B           E8         9E30            call	_inb
22691 670E           44                         inc	sp
22692 670F           44                         inc	sp
22693                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
22694 6710           8846         FD            mov	-3[bp],al
22695                                           !BCC_EOS
22696                                           ! 3553   if ( (in_byte & 0x21) != 0x21 ) {
22697                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
22698 6713           8A46         FD            mov	al,-3[bp]
22699 6716           24                     21  and	al,*$21
22700                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
22701 6718           3C                     21  cmp	al,*$21
22702 671A           74           04            je  	.4F2
22703                       0000671C            .4F3:
22704                                           ! 3554     return;
22705 671C           89EC                       mov	sp,bp
22706 671E           5D                         pop	bp
22707 671F           C3                         ret
22708                                           !BCC_EOS
22709                                           ! 3555     }
22710                                           ! 3556   in_byte = inb(0x60);
22711                       00006720            .4F2:
22712                                           ! Debug: list int = const $60 (used reg = )
22713 6720           B8                   0060  mov	ax,*$60
22714 6723           50                         push	ax
22715                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22716 6724           E8         9E17            call	_inb
22717 6727           44                         inc	sp
22718 6728           44                         inc	sp
22719                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
22720 6729           8846         FD            mov	-3[bp],al
22721                                           !BCC_EOS
22722                                           ! 3557 ;
22723                                           !BCC_EOS
22724                                           ! 3558   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
22725                                           ! Debug: list int = const $26 (used reg = )
22726 672C           B8                   0026  mov	ax,*$26
22727 672F           50                         push	ax
22728                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22729 6730           FF76         FE            push	-2[bp]
22730                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22731 6733           E8         9EBE            call	_read_byte
22732 6736           83C4                   04  add	sp,*4
22733                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22734 6739           8846         FA            mov	-6[bp],al
22735                                           !BCC_EOS
22736                                           ! 3559   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
22737                                           ! Debug: list int = const $27 (used reg = )
22738 673C           B8                   0027  mov	ax,*$27
22739 673F           50                         push	ax
22740                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22741 6740           FF76         FE            push	-2[bp]
22742                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22743 6743           E8         9EAE            call	_read_byte
22744 6746           83C4                   04  add	sp,*4
22745                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22746 6749           8846         F9            mov	-7[bp],al
22747                                           !BCC_EOS
22748                                           ! 3560   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
22749                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22750 674C           8A46         F9            mov	al,-7[bp]
22751 674F           24                     80  and	al,#$80
22752                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
22753 6751           3C                     80  cmp	al,#$80
22754 6753           74           04            je  	.4F4
22755                       00006755            .4F5:
22756                                           ! 3561       return;
22757 6755           89EC                       mov	sp,bp
22758 6757           5D                         pop	bp
22759 6758           C3                         ret
22760                                           !BCC_EOS
22761                                           ! 3562   }
22762                                           ! 3563   package_count = mouse_flags_2 & 0x07;
22763                       00006759            .4F4:
22764                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22765 6759           8A46         F9            mov	al,-7[bp]
22766 675C           24                     07  and	al,*7
22767                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
22768 675E           8846         FB            mov	-5[bp],al
22769                                           !BCC_EOS
22770                                           ! 3564   index = mouse_flags_1 & 0x07;
22771                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22772 6761           8A46         FA            mov	al,-6[bp]
22773 6764           24                     07  and	al,*7
22774                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
22775 6766           8846         FC            mov	-4[bp],al
22776                                           !BCC_EOS
22777                                           ! 3565   write_byte(ebda_seg, 0x28 + index, in_byte);
22778                                           ! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
22779 6769           8A46         FD            mov	al,-3[bp]
22780 676C           30E4                       xor	ah,ah
22781 676E           50                         push	ax
22782                                           ! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
22783                                           ! Debug: expression subtree swapping
22784 676F           8A46         FC            mov	al,-4[bp]
22785 6772           30E4                       xor	ah,ah
22786                                           ! Debug: list unsigned int = ax+$28 (used reg = )
22787 6774           05                   0028  add	ax,*$28
22788 6777           50                         push	ax
22789                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
22790 6778           FF76         FE            push	-2[bp]
22791                                           ! Debug: func () void = write_byte+0 (used reg = )
22792 677B           E8         9E9C            call	_write_byte
22793 677E           83C4                   06  add	sp,*6
22794                                           !BCC_EOS
22795                                           ! 3566   if ( (index+1) >= package_count ) {
22796                                           ! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
22797 6781           8A46         FC            mov	al,-4[bp]
22798 6784           30E4                       xor	ah,ah
22799                                           ! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
22800 6786           40                         inc	ax
22801 6787           50                         push	ax
22802 6788           8A46         FB            mov	al,-5[bp]
22803 678B           30E4                       xor	ah,ah
22804 678D           3B46         F6            cmp	ax,-$A[bp]
22805 6790           8D66         F8            lea	sp,-8[bp]
22806 6793           77           51            ja  	.4F6
22807                       00006795            .4F7:
22808                                           ! 3567 ;
22809                                           !BCC_EOS
22810                                           ! 3568     status = read_byte(ebda_seg, 0x0028 + 0);
22811                                           ! Debug: list int = const $28 (used reg = )
22812 6795           B8                   0028  mov	ax,*$28
22813 6798           50                         push	ax
22814                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22815 6799           FF76         FE            push	-2[bp]
22816                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22817 679C           E8         9E55            call	_read_byte
22818 679F           83C4                   04  add	sp,*4
22819                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
22820 67A2           30E4                       xor	ah,ah
22821 67A4           8946         0C            mov	$C[bp],ax
22822                                           !BCC_EOS
22823                                           ! 3569     X = read_byte(ebda_seg, 0x0028 + 1);
22824                                           ! Debug: list int = const $29 (used reg = )
22825 67A7           B8                   0029  mov	ax,*$29
22826 67AA           50                         push	ax
22827                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22828 67AB           FF76         FE            push	-2[bp]
22829                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22830 67AE           E8         9E43            call	_read_byte
22831 67B1           83C4                   04  add	sp,*4
22832                                           ! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
22833 67B4           30E4                       xor	ah,ah
22834 67B6           8946         0A            mov	$A[bp],ax
22835                                           !BCC_EOS
22836                                           ! 3570     Y = read_byte(ebda_seg, 0x0028 + 2);
22837                                           ! Debug: list int = const $2A (used reg = )
22838 67B9           B8                   002A  mov	ax,*$2A
22839 67BC           50                         push	ax
22840                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22841 67BD           FF76         FE            push	-2[bp]
22842                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22843 67C0           E8         9E31            call	_read_byte
22844 67C3           83C4                   04  add	sp,*4
22845                                           ! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
22846 67C6           30E4                       xor	ah,ah
22847 67C8           8946         08            mov	8[bp],ax
22848                                           !BCC_EOS
22849                                           ! 3571     Z = 0;
22850                                           ! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
22851 67CB           31C0                       xor	ax,ax
22852 67CD           8946         06            mov	6[bp],ax
22853                                           !BCC_EOS
22854                                           ! 3572     mouse_flags_1 = 0;
22855                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22856 67D0           30C0                       xor	al,al
22857 67D2           8846         FA            mov	-6[bp],al
22858                                           !BCC_EOS
22859                                           ! 3573     if (mouse_flags_2 & 0x80)
22860                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22861 67D5           8A46         F9            mov	al,-7[bp]
22862 67D8           24                     80  and	al,#$80
22863 67DA           84C0                       test	al,al
22864 67DC           74           06            je  	.4F8
22865                       000067DE            .4F9:
22866                                           ! 3574       make_farcall = 1;
22867                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
22868 67DE           B8                   0001  mov	ax,*1
22869 67E1           8946         04            mov	4[bp],ax
22870                                           !BCC_EOS
22871                                           ! 3575     }
22872                       000067E4            .4F8:
22873                                           ! 3576   else {
22874 67E4           EB           07            jmp .4FA
22875                       000067E6            .4F6:
22876                                           ! 3577     mouse_flags_1++;
22877                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22878 67E6           8A46         FA            mov	al,-6[bp]
22879 67E9           40                         inc	ax
22880 67EA           8846         FA            mov	-6[bp],al
22881                                           !BCC_EOS
22882                                           ! 3578     }
22883                                           ! 3579   write_byte(ebda_seg, 0x0026, mouse_flags_1);
22884                       000067ED            .4FA:
22885                                           ! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22886 67ED           8A46         FA            mov	al,-6[bp]
22887 67F0           30E4                       xor	ah,ah
22888 67F2           50                         push	ax
22889                                           ! Debug: list int = const $26 (used reg = )
22890 67F3           B8                   0026  mov	ax,*$26
22891 67F6           50                         push	ax
22892                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
22893 67F7           FF76         FE            push	-2[bp]
22894                                           ! Debug: func () void = write_byte+0 (used reg = )
22895 67FA           E8         9E1D            call	_write_byte
22896 67FD           83C4                   06  add	sp,*6
22897                                           !BCC_EOS
22898                                           ! 3580 }
22899 6800           89EC                       mov	sp,bp
22900 6802           5D                         pop	bp
22901 6803           C3                         ret
22902                                           ! 3581   void
22903                                           ! 3582 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
22904                                           ! 3583   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
22905                                           export	_int13_harddisk
22906                       00006804            _int13_harddisk:
22907                                           !BCC_EOS
22908                                           ! 3584 {
22909                                           ! 3585   Bit32u lba_low, lba_high;
22910                                           !BCC_EOS
22911                                           ! 3586   Bit16u ebda_seg=read_word(0x0040,0x000E);
22912 6804           55                         push	bp
22913 6805           89E5                       mov	bp,sp
22914 6807           83C4                   F6  add	sp,*-$A
22915                                           ! Debug: list int = const $E (used reg = )
22916 680A           B8                   000E  mov	ax,*$E
22917 680D           50                         push	ax
22918                                           ! Debug: list int = const $40 (used reg = )
22919 680E           B8                   0040  mov	ax,*$40
22920 6811           50                         push	ax
22921                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22922 6812           E8         9DF2            call	_read_word
22923 6815           83C4                   04  add	sp,*4
22924                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
22925 6818           8946         F6            mov	-$A[bp],ax
22926                                           !BCC_EOS
22927                                           ! 3587   Bit16u cylinder, head, sector;
22928                                           !BCC_EOS
22929                                           ! 3588   Bit16u segment, offset;
22930                                           !BCC_EOS
22931                                           ! 3589   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
22932                                           !BCC_EOS
22933                                           ! 3590   Bit16u size, count;
22934                                           !BCC_EOS
22935                                           ! 3591   Bit8u device, status;
22936                                           !BCC_EOS
22937                                           ! 3592   ;
22938 681B           83C4                   E4  add	sp,*-$1C
22939                                           !BCC_EOS
22940                                           ! 3593   write_byte(0x0040, 0x008e, 0);
22941                                           ! Debug: list int = const 0 (used reg = )
22942 681E           31C0                       xor	ax,ax
22943 6820           50                         push	ax
22944                                           ! Debug: list int = const $8E (used reg = )
22945 6821           B8                   008E  mov	ax,#$8E
22946 6824           50                         push	ax
22947                                           ! Debug: list int = const $40 (used reg = )
22948 6825           B8                   0040  mov	ax,*$40
22949 6828           50                         push	ax
22950                                           ! Debug: func () void = write_byte+0 (used reg = )
22951 6829           E8         9DEE            call	_write_byte
22952 682C           83C4                   06  add	sp,*6
22953                                           !BCC_EOS
22954                                           ! 3594   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4
22955                                           ! 3594 *2)) ) {
22956                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22957 682F           8A46         10            mov	al,$10[bp]
22958                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
22959 6832           3C                     80  cmp	al,#$80
22960 6834           72           07            jb  	.4FC
22961                       00006836            .4FD:
22962                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22963 6836           8A46         10            mov	al,$10[bp]
22964                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
22965 6839           3C                     88  cmp	al,#$88
22966 683B           72           06            jb  	.4FB
22967                       0000683D            .4FC:
22968                                           ! 3595     ;
22969                                           !BCC_EOS
22970                                           ! 3596     goto int13_fail;
22971 683D           83C4                   00  add	sp,#..FFF1+$28
22972 6840           E9         0E51            br 	.FFF1
22973                                           !BCC_EOS
22974                                           ! 3597     }
22975                                           ! 3598   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
22976                       00006843            .4FB:
22977                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22978 6843           8A46         10            mov	al,$10[bp]
22979                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
22980 6846           30E4                       xor	ah,ah
22981                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
22982 6848           05                   FF80  add	ax,*-$80
22983 684B           89C3                       mov	bx,ax
22984                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
22985                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
22986 684D           81C3                 0233  add	bx,#$233
22987 6851           53                         push	bx
22988                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
22989 6852           FF76         F6            push	-$A[bp]
22990                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22991 6855           E8         9D9C            call	_read_byte
22992 6858           83C4                   04  add	sp,*4
22993                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
22994 685B           8846         DB            mov	-$25[bp],al
22995                                           !BCC_EOS
22996                                           ! 3599   if (device >= (4*2)) {
22997                                           ! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
22998 685E           8A46         DB            mov	al,-$25[bp]
22999 6861           3C                     08  cmp	al,*8
23000 6863           72           06            jb  	.4FE
23001                       00006865            .4FF:
23002                                           ! 3600     ;
23003                                           !BCC_EOS
23004                                           ! 3601     goto int13_fail;
23005 6865           83C4                   00  add	sp,#..FFF1+$28
23006 6868           E9         0E29            br 	.FFF1
23007                                           !BCC_EOS
23008                                           ! 3602     }
23009                                           ! 3603   switch (( AX >> 8 )) {
23010                       0000686B            .4FE:
23011                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23012 686B           8B46         18            mov	ax,$18[bp]
23013 686E           88E0                       mov	al,ah
23014 6870           30E4                       xor	ah,ah
23015 6872           E9         0D9E            br 	.502
23016                                           ! 3604     case 0x00:
23017                                           ! 3605       ata_reset (device);
23018                       00006875            .503:
23019                                           ! Debug: list unsigned char device = [S+$28-$27] (used reg = )
23020 6875           8A46         DB            mov	al,-$25[bp]
23021 6878           30E4                       xor	ah,ah
23022 687A           50                         push	ax
23023                                           ! Debug: func () void = ata_reset+0 (used reg = )
23024 687B           E8         C455            call	_ata_reset
23025 687E           44                         inc	sp
23026 687F           44                         inc	sp
23027                                           !BCC_EOS
23028                                           ! 3606       goto int13_success;
23029 6880           83C4                   0E  add	sp,#..FFEF-..FFF0
23030 6883           E9         0E3B            br 	.FFEF
23031                                           !BCC_EOS
23032                                           ! 3607       break;
23033 6886           E9         0E08            br 	.500
23034                                           !BCC_EOS
23035                                           ! 3608     case 0x01:
23036                                           ! 3609       status = read_byte(0x0040, 0x0074);
23037                       00006889            .504:
23038                                           ! Debug: list int = const $74 (used reg = )
23039 6889           B8                   0074  mov	ax,*$74
23040 688C           50                         push	ax
23041                                           ! Debug: list int = const $40 (used reg = )
23042 688D           B8                   0040  mov	ax,*$40
23043 6890           50                         push	ax
23044                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23045 6891           E8         9D60            call	_read_byte
23046 6894           83C4                   04  add	sp,*4
23047                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23048 6897           8846         DA            mov	-$26[bp],al
23049                                           !BCC_EOS
23050                                           ! 3610       AX = ((AX & 0x00ff) | ((status) << 8));
23051                                           ! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
23052 689A           8A46         DA            mov	al,-$26[bp]
23053 689D           30E4                       xor	ah,ah
23054 689F           88C4                       mov	ah,al
23055 68A1           30C0                       xor	al,al
23056 68A3           50                         push	ax
23057                                           ! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
23058 68A4           8A46         18            mov	al,$18[bp]
23059                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23060 68A7           30E4                       xor	ah,ah
23061 68A9           0B46         CA            or	ax,0+..FFF0[bp]
23062 68AC           44                         inc	sp
23063 68AD           44                         inc	sp
23064                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23065 68AE           8946         18            mov	$18[bp],ax
23066                                           !BCC_EOS
23067                                           ! 3611       write_byte(0x0040, 0x0074, 0);
23068                                           ! Debug: list int = const 0 (used reg = )
23069 68B1           31C0                       xor	ax,ax
23070 68B3           50                         push	ax
23071                                           ! Debug: list int = const $74 (used reg = )
23072 68B4           B8                   0074  mov	ax,*$74
23073 68B7           50                         push	ax
23074                                           ! Debug: list int = const $40 (used reg = )
23075 68B8           B8                   0040  mov	ax,*$40
23076 68BB           50                         push	ax
23077                                           ! Debug: func () void = write_byte+0 (used reg = )
23078 68BC           E8         9D5B            call	_write_byte
23079 68BF           83C4                   06  add	sp,*6
23080                                           !BCC_EOS
23081                                           ! 3612       if (status) goto int13_fail_nostatus;
23082 68C2           8A46         DA            mov	al,-$26[bp]
23083 68C5           84C0                       test	al,al
23084 68C7           74           08            je  	.505
23085                       000068C9            .506:
23086 68C9           83C4                   0E  add	sp,#..FFEE-..FFF0
23087 68CC           E9         0DE6            br 	.FFEE
23088                                           !BCC_EOS
23089                                           ! 3613       else goto int13_success_noah;
23090 68CF           EB           06            jmp .507
23091                       000068D1            .505:
23092 68D1           83C4                   0E  add	sp,#..FFED-..FFF0
23093 68D4           E9         0DF4            br 	.FFED
23094                                           !BCC_EOS
23095                                           ! 3614       break;
23096                       000068D7            .507:
23097 68D7           E9         0DB7            br 	.500
23098                                           !BCC_EOS
23099                                           ! 3615     case 0x02:
23100                                           ! 3616     case 0x03:
23101                       000068DA            .508:
23102                                           ! 3617     case 0x04:
23103                       000068DA            .509:
23104                                           ! 3618       count = ( AX & 0x00ff );
23105                       000068DA            .50A:
23106                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23107 68DA           8A46         18            mov	al,$18[bp]
23108                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23109 68DD           30E4                       xor	ah,ah
23110 68DF           8946         DC            mov	-$24[bp],ax
23111                                           !BCC_EOS
23112                                           ! 3619       cylinder = ( CX >> 8 );
23113                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
23114 68E2           8B46         16            mov	ax,$16[bp]
23115 68E5           88E0                       mov	al,ah
23116 68E7           30E4                       xor	ah,ah
23117                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23118 68E9           8946         F4            mov	-$C[bp],ax
23119                                           !BCC_EOS
23120                                           ! 3620       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
23121                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23122 68EC           8A46         16            mov	al,$16[bp]
23123                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
23124 68EF           30E4                       xor	ah,ah
23125                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
23126 68F1           D1E0                       shl	ax,*1
23127 68F3           D1E0                       shl	ax,*1
23128                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
23129 68F5           25                   0300  and	ax,#$300
23130                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23131 68F8           0B46         F4            or	ax,-$C[bp]
23132 68FB           8946         F4            mov	-$C[bp],ax
23133                                           !BCC_EOS
23134                                           ! 3621       sector = (( CX & 0x00ff ) & 0x3f);
23135                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23136 68FE           8A46         16            mov	al,$16[bp]
23137                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
23138 6901           24                     3F  and	al,*$3F
23139                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
23140 6903           30E4                       xor	ah,ah
23141 6905           8946         F0            mov	-$10[bp],ax
23142                                           !BCC_EOS
23143                                           ! 3622       head = ( DX >> 8 );
23144                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
23145 6908           8B46         14            mov	ax,$14[bp]
23146 690B           88E0                       mov	al,ah
23147 690D           30E4                       xor	ah,ah
23148                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
23149 690F           8946         F2            mov	-$E[bp],ax
23150                                           !BCC_EOS
23151                                           ! 3623       segment = ES;
23152                                           ! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
23153 6912           8B46         08            mov	ax,8[bp]
23154 6915           8946         EE            mov	-$12[bp],ax
23155                                           !BCC_EOS
23156                                           ! 3624       offset = BX;
23157                                           ! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
23158 6918           8B46         12            mov	ax,$12[bp]
23159 691B           8946         EC            mov	-$14[bp],ax
23160                                           !BCC_EOS
23161                                           ! 3625       if ((count > 128) || (count == 0) || (sector == 0)) {
23162                                           ! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
23163 691E           8B46         DC            mov	ax,-$24[bp]
23164 6921           3D                   0080  cmp	ax,#$80
23165 6924           77           0E            ja  	.50C
23166                       00006926            .50E:
23167                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
23168 6926           8B46         DC            mov	ax,-$24[bp]
23169 6929           85C0                       test	ax,ax
23170 692B           74           07            je  	.50C
23171                       0000692D            .50D:
23172                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23173 692D           8B46         F0            mov	ax,-$10[bp]
23174 6930           85C0                       test	ax,ax
23175 6932           75           06            jne 	.50B
23176                       00006934            .50C:
23177                                           ! 3626         ;
23178                                           !BCC_EOS
23179                                           ! 3627         goto int13_fail;
23180 6934           83C4                   0E  add	sp,#..FFF1-..FFF0
23181 6937           E9         0D5A            br 	.FFF1
23182                                           !BCC_EOS
23183                                           ! 3628       }
23184                                           ! 3629       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23185                       0000693A            .50B:
23186                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23187 693A           8A46         DB            mov	al,-$25[bp]
23188 693D           30E4                       xor	ah,ah
23189 693F           B9                   001E  mov	cx,*$1E
23190 6942           F7E9                       imul	cx
23191 6944           89C3                       mov	bx,ax
23192                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23193                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23194 6946           81C3                 014E  add	bx,#$14E
23195 694A           53                         push	bx
23196                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23197 694B           FF76         F6            push	-$A[bp]
23198                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23199 694E           E8         9CB6            call	_read_word
23200 6951           83C4                   04  add	sp,*4
23201                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23202 6954           8946         E4            mov	-$1C[bp],ax
23203                                           !BCC_EOS
23204                                           ! 3630       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23205                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23206 6957           8A46         DB            mov	al,-$25[bp]
23207 695A           30E4                       xor	ah,ah
23208 695C           B9                   001E  mov	cx,*$1E
23209 695F           F7E9                       imul	cx
23210 6961           89C3                       mov	bx,ax
23211                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23212                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23213 6963           81C3                 014C  add	bx,#$14C
23214 6967           53                         push	bx
23215                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23216 6968           FF76         F6            push	-$A[bp]
23217                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23218 696B           E8         9C99            call	_read_word
23219 696E           83C4                   04  add	sp,*4
23220                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23221 6971           8946         E2            mov	-$1E[bp],ax
23222                                           !BCC_EOS
23223                                           ! 3631       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23224                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23225 6974           8A46         DB            mov	al,-$25[bp]
23226 6977           30E4                       xor	ah,ah
23227 6979           B9                   001E  mov	cx,*$1E
23228 697C           F7E9                       imul	cx
23229 697E           89C3                       mov	bx,ax
23230                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23231                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23232 6980           81C3                 0150  add	bx,#$150
23233 6984           53                         push	bx
23234                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23235 6985           FF76         F6            push	-$A[bp]
23236                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23237 6988           E8         9C7C            call	_read_word
23238 698B           83C4                   04  add	sp,*4
23239                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23240 698E           8946         E0            mov	-$20[bp],ax
23241                                           !BCC_EOS
23242                                           ! 3632       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
23243                                           ! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
23244 6991           8B46         F4            mov	ax,-$C[bp]
23245 6994           3B46         E4            cmp	ax,-$1C[bp]
23246 6997           73           10            jae 	.510
23247                       00006999            .512:
23248                                           ! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
23249 6999           8B46         F2            mov	ax,-$E[bp]
23250 699C           3B46         E2            cmp	ax,-$1E[bp]
23251 699F           73           08            jae 	.510
23252                       000069A1            .511:
23253                                           ! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
23254 69A1           8B46         F0            mov	ax,-$10[bp]
23255 69A4           3B46         E0            cmp	ax,-$20[bp]
23256 69A7           76           06            jbe 	.50F
23257                       000069A9            .510:
23258                                           ! 3633         ;
23259                                           !BCC_EOS
23260                                           ! 3634         goto int13_fail;
23261 69A9           83C4                   0E  add	sp,#..FFF1-..FFF0
23262 69AC           E9         0CE5            br 	.FFF1
23263                                           !BCC_EOS
23264                                           ! 3635         }
23265                                           ! 3636       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
23266                       000069AF            .50F:
23267                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23268 69AF           8B46         18            mov	ax,$18[bp]
23269 69B2           88E0                       mov	al,ah
23270 69B4           30E4                       xor	ah,ah
23271                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
23272 69B6           3D                   0004  cmp	ax,*4
23273 69B9           75           06            jne 	.513
23274                       000069BB            .514:
23275 69BB           83C4                   0E  add	sp,#..FFEF-..FFF0
23276 69BE           E9         0D00            br 	.FFEF
23277                                           !BCC_EOS
23278                                           ! 3637       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
23279                       000069C1            .513:
23280                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23281 69C1           8A46         DB            mov	al,-$25[bp]
23282 69C4           30E4                       xor	ah,ah
23283 69C6           B9                   001E  mov	cx,*$1E
23284 69C9           F7E9                       imul	cx
23285 69CB           89C3                       mov	bx,ax
23286                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
23287                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
23288 69CD           81C3                 0152  add	bx,#$152
23289 69D1           53                         push	bx
23290                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23291 69D2           FF76         F6            push	-$A[bp]
23292                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23293 69D5           E8         9C2F            call	_read_word
23294 69D8           83C4                   04  add	sp,*4
23295                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
23296 69DB           8946         E8            mov	-$18[bp],ax
23297                                           !BCC_EOS
23298                                           ! 3638       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
23299                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23300 69DE           8A46         DB            mov	al,-$25[bp]
23301 69E1           30E4                       xor	ah,ah
23302 69E3           B9                   001E  mov	cx,*$1E
23303 69E6           F7E9                       imul	cx
23304 69E8           89C3                       mov	bx,ax
23305                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
23306                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
23307 69EA           81C3                 0156  add	bx,#$156
23308 69EE           53                         push	bx
23309                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23310 69EF           FF76         F6            push	-$A[bp]
23311                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23312 69F2           E8         9C12            call	_read_word
23313 69F5           83C4                   04  add	sp,*4
23314                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
23315 69F8           8946         E6            mov	-$1A[bp],ax
23316                                           !BCC_EOS
23317                                           ! 3639       if ( (nph != nlh) || (npspt != nlspt)) {
23318                                           ! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
23319 69FB           8B46         E8            mov	ax,-$18[bp]
23320 69FE           3B46         E2            cmp	ax,-$1E[bp]
23321 6A01           75           08            jne 	.516
23322                       00006A03            .517:
23323                                           ! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
23324 6A03           8B46         E6            mov	ax,-$1A[bp]
23325 6A06           3B46         E0            cmp	ax,-$20[bp]
23326 6A09           74           72            je  	.515
23327                       00006A0B            .516:
23328                                           ! 3640         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
23329                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23330 6A0B           8B46         F0            mov	ax,-$10[bp]
23331 6A0E           31DB                       xor	bx,bx
23332 6A10           53                         push	bx
23333 6A11           50                         push	ax
23334                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
23335 6A12           8B46         E0            mov	ax,-$20[bp]
23336 6A15           31DB                       xor	bx,bx
23337 6A17           53                         push	bx
23338 6A18           50                         push	ax
23339                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
23340 6A19           8B46         F2            mov	ax,-$E[bp]
23341 6A1C           31DB                       xor	bx,bx
23342 6A1E           53                         push	bx
23343 6A1F           50                         push	ax
23344                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
23345 6A20           8B46         E2            mov	ax,-$1E[bp]
23346 6A23           31DB                       xor	bx,bx
23347 6A25           53                         push	bx
23348 6A26           50                         push	ax
23349                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
23350 6A27           8B46         F4            mov	ax,-$C[bp]
23351 6A2A           31DB                       xor	bx,bx
23352                                           ! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
23353 6A2C           8D7E         BC            lea	di,-$E+..FFF0[bp]
23354 6A2F           E8         96B7            call	lmulul
23355 6A32           83C4                   04  add	sp,*4
23356                                           ! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
23357 6A35           8D7E         C0            lea	di,-$A+..FFF0[bp]
23358 6A38           E8         9688            call	laddul
23359 6A3B           83C4                   04  add	sp,*4
23360                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23361 6A3E           8D7E         C4            lea	di,-6+..FFF0[bp]
23362 6A41           E8         96A5            call	lmulul
23363 6A44           83C4                   04  add	sp,*4
23364                                           ! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23365 6A47           8D7E         C8            lea	di,-2+..FFF0[bp]
23366 6A4A           E8         9676            call	laddul
23367 6A4D           83C4                   04  add	sp,*4
23368                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
23369 6A50           53                         push	bx
23370 6A51           50                         push	ax
23371 6A52           B8                   0001  mov	ax,*1
23372 6A55           31DB                       xor	bx,bx
23373 6A57           53                         push	bx
23374 6A58           50                         push	ax
23375 6A59           8B46         C8            mov	ax,-2+..FFF0[bp]
23376 6A5C           8B5E         CA            mov	bx,0+..FFF0[bp]
23377 6A5F           8D7E         C4            lea	di,-6+..FFF0[bp]
23378 6A62           E8         967C            call	lsubul
23379 6A65           83C4                   08  add	sp,*8
23380                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23381 6A68           8946         FC            mov	-4[bp],ax
23382 6A6B           895E         FE            mov	-2[bp],bx
23383                                           !BCC_EOS
23384                                           ! 3641         lba_high = 0;
23385                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23386 6A6E           31C0                       xor	ax,ax
23387 6A70           31DB                       xor	bx,bx
23388 6A72           8946         F8            mov	-8[bp],ax
23389 6A75           895E         FA            mov	-6[bp],bx
23390                                           !BCC_EOS
23391                                           ! 3642         sector = 0;
23392                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23393 6A78           31C0                       xor	ax,ax
23394 6A7A           8946         F0            mov	-$10[bp],ax
23395                                           !BCC_EOS
23396                                           ! 3643         }
23397                                           ! 3644       if ( ( AX >> 8 ) == 0x02 )
23398                       00006A7D            .515:
23399                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23400 6A7D           8B46         18            mov	ax,$18[bp]
23401 6A80           88E0                       mov	al,ah
23402 6A82           30E4                       xor	ah,ah
23403                                           ! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
23404 6A84           3D                   0002  cmp	ax,*2
23405 6A87           75           33            jne 	.518
23406                       00006A89            .519:
23407                                           ! 3645         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
23408                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23409 6A89           FF76         EC            push	-$14[bp]
23410                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23411 6A8C           FF76         EE            push	-$12[bp]
23412                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23413 6A8F           FF76         FA            push	-6[bp]
23414 6A92           FF76         F8            push	-8[bp]
23415                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23416 6A95           FF76         FE            push	-2[bp]
23417 6A98           FF76         FC            push	-4[bp]
23418                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23419 6A9B           FF76         F0            push	-$10[bp]
23420                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23421 6A9E           FF76         F2            push	-$E[bp]
23422                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23423 6AA1           FF76         F4            push	-$C[bp]
23424                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23425 6AA4           FF76         DC            push	-$24[bp]
23426                                           ! Debug: list int = const $20 (used reg = )
23427 6AA7           B8                   0020  mov	ax,*$20
23428 6AAA           50                         push	ax
23429                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23430 6AAB           8A46         DB            mov	al,-$25[bp]
23431 6AAE           30E4                       xor	ah,ah
23432 6AB0           50                         push	ax
23433                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
23434 6AB1           E8         C373            call	_ata_cmd_data_in
23435 6AB4           83C4                   18  add	sp,*$18
23436                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23437 6AB7           8846         DA            mov	-$26[bp],al
23438                                           !BCC_EOS
23439                                           ! 3646       else
23440                                           ! 3647         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
23441 6ABA           EB           31            jmp .51A
23442                       00006ABC            .518:
23443                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23444 6ABC           FF76         EC            push	-$14[bp]
23445                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23446 6ABF           FF76         EE            push	-$12[bp]
23447                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23448 6AC2           FF76         FA            push	-6[bp]
23449 6AC5           FF76         F8            push	-8[bp]
23450                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23451 6AC8           FF76         FE            push	-2[bp]
23452 6ACB           FF76         FC            push	-4[bp]
23453                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23454 6ACE           FF76         F0            push	-$10[bp]
23455                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23456 6AD1           FF76         F2            push	-$E[bp]
23457                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23458 6AD4           FF76         F4            push	-$C[bp]
23459                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23460 6AD7           FF76         DC            push	-$24[bp]
23461                                           ! Debug: list int = const $30 (used reg = )
23462 6ADA           B8                   0030  mov	ax,*$30
23463 6ADD           50                         push	ax
23464                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23465 6ADE           8A46         DB            mov	al,-$25[bp]
23466 6AE1           30E4                       xor	ah,ah
23467 6AE3           50                         push	ax
23468                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
23469 6AE4           E8         C711            call	_ata_cmd_data_out
23470 6AE7           83C4                   18  add	sp,*$18
23471                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23472 6AEA           8846         DA            mov	-$26[bp],al
23473                                           !BCC_EOS
23474                                           ! 3648       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data
23475                       00006AED            .51A:
23476                                           ! 3648 _t *) 0)->ata.trsfsectors)));
23477                                           ! Debug: list * unsigned short = const $254 (used reg = )
23478 6AED           B8                   0254  mov	ax,#$254
23479 6AF0           50                         push	ax
23480                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23481 6AF1           FF76         F6            push	-$A[bp]
23482                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23483 6AF4           E8         9B10            call	_read_word
23484 6AF7           83C4                   04  add	sp,*4
23485 6AFA           50                         push	ax
23486                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
23487 6AFB           8B46         18            mov	ax,$18[bp]
23488 6AFE           30C0                       xor	al,al
23489                                           ! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
23490 6B00           0B46         CA            or	ax,0+..FFF0[bp]
23491 6B03           44                         inc	sp
23492 6B04           44                         inc	sp
23493                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23494 6B05           8946         18            mov	$18[bp],ax
23495                                           !BCC_EOS
23496                                           ! 3649       if (status != 0) {
23497                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
23498 6B08           8A46         DA            mov	al,-$26[bp]
23499 6B0B           84C0                       test	al,al
23500 6B0D           74           11            je  	.51B
23501                       00006B0F            .51C:
23502                                           ! 3650         ;
23503                                           !BCC_EOS
23504                                           ! 3651         AX = ((AX & 0x00ff) | ((0x0c) << 8));
23505                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23506 6B0F           8A46         18            mov	al,$18[bp]
23507                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
23508 6B12           30E4                       xor	ah,ah
23509 6B14           0D                   0C00  or	ax,#$C00
23510                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23511 6B17           8946         18            mov	$18[bp],ax
23512                                           !BCC_EOS
23513                                           ! 3652         goto int13_fail_noah;
23514 6B1A           83C4                   0E  add	sp,#..FFEC-..FFF0
23515 6B1D           E9         0B7F            br 	.FFEC
23516                                           !BCC_EOS
23517                                           ! 3653         }
23518                                           ! 3654       goto int13_success;
23519                       00006B20            .51B:
23520 6B20           83C4                   0E  add	sp,#..FFEF-..FFF0
23521 6B23           E9         0B9B            br 	.FFEF
23522                                           !BCC_EOS
23523                                           ! 3655       break;
23524 6B26           E9         0B68            br 	.500
23525                                           !BCC_EOS
23526                                           ! 3656     case 0x05:
23527                                           ! 3657       ;
23528                       00006B29            .51D:
23529                                           !BCC_EOS
23530                                           ! 3658       goto int13_success;
23531 6B29           83C4                   0E  add	sp,#..FFEF-..FFF0
23532 6B2C           E9         0B92            br 	.FFEF
23533                                           !BCC_EOS
23534                                           ! 3659       return;
23535 6B2F           89EC                       mov	sp,bp
23536 6B31           5D                         pop	bp
23537 6B32           C3                         ret
23538                                           !BCC_EOS
23539                                           ! 3660       break;
23540 6B33           E9         0B5B            br 	.500
23541                                           !BCC_EOS
23542                                           ! 3661     case 0x08:
23543                                           ! 3662       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23544                       00006B36            .51E:
23545                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23546 6B36           8A46         DB            mov	al,-$25[bp]
23547 6B39           30E4                       xor	ah,ah
23548 6B3B           B9                   001E  mov	cx,*$1E
23549 6B3E           F7E9                       imul	cx
23550 6B40           89C3                       mov	bx,ax
23551                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23552                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23553 6B42           81C3                 014E  add	bx,#$14E
23554 6B46           53                         push	bx
23555                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23556 6B47           FF76         F6            push	-$A[bp]
23557                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23558 6B4A           E8         9ABA            call	_read_word
23559 6B4D           83C4                   04  add	sp,*4
23560                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23561 6B50           8946         E4            mov	-$1C[bp],ax
23562                                           !BCC_EOS
23563                                           ! 3663       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23564                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23565 6B53           8A46         DB            mov	al,-$25[bp]
23566 6B56           30E4                       xor	ah,ah
23567 6B58           B9                   001E  mov	cx,*$1E
23568 6B5B           F7E9                       imul	cx
23569 6B5D           89C3                       mov	bx,ax
23570                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23571                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23572 6B5F           81C3                 014C  add	bx,#$14C
23573 6B63           53                         push	bx
23574                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23575 6B64           FF76         F6            push	-$A[bp]
23576                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23577 6B67           E8         9A9D            call	_read_word
23578 6B6A           83C4                   04  add	sp,*4
23579                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23580 6B6D           8946         E2            mov	-$1E[bp],ax
23581                                           !BCC_EOS
23582                                           ! 3664       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23583                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23584 6B70           8A46         DB            mov	al,-$25[bp]
23585 6B73           30E4                       xor	ah,ah
23586 6B75           B9                   001E  mov	cx,*$1E
23587 6B78           F7E9                       imul	cx
23588 6B7A           89C3                       mov	bx,ax
23589                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23590                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23591 6B7C           81C3                 0150  add	bx,#$150
23592 6B80           53                         push	bx
23593                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23594 6B81           FF76         F6            push	-$A[bp]
23595                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23596 6B84           E8         9A80            call	_read_word
23597 6B87           83C4                   04  add	sp,*4
23598                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23599 6B8A           8946         E0            mov	-$20[bp],ax
23600                                           !BCC_EOS
23601                                           ! 3665       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
23602                                           ! Debug: list * unsigned char = const $232 (used reg = )
23603 6B8D           B8                   0232  mov	ax,#$232
23604 6B90           50                         push	ax
23605                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23606 6B91           FF76         F6            push	-$A[bp]
23607                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23608 6B94           E8         9A5D            call	_read_byte
23609 6B97           83C4                   04  add	sp,*4
23610                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23611 6B9A           30E4                       xor	ah,ah
23612 6B9C           8946         DC            mov	-$24[bp],ax
23613                                           !BCC_EOS
23614                                           ! 3666       nlc = nlc - 2;
23615                                           ! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
23616 6B9F           8B46         E4            mov	ax,-$1C[bp]
23617                                           ! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
23618 6BA2           48                         dec	ax
23619 6BA3           48                         dec	ax
23620 6BA4           8946         E4            mov	-$1C[bp],ax
23621                                           !BCC_EOS
23622                                           ! 3667       AX = ((AX & 0xff00) | (0));
23623                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
23624 6BA7           8B46         18            mov	ax,$18[bp]
23625 6BAA           30C0                       xor	al,al
23626                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
23627 6BAC           0C                     00  or	al,*0
23628                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23629 6BAE           8946         18            mov	$18[bp],ax
23630                                           !BCC_EOS
23631                                           ! 3668       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
23632                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
23633 6BB1           8A46         E4            mov	al,-$1C[bp]
23634                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
23635 6BB4           30E4                       xor	ah,ah
23636 6BB6           88C4                       mov	ah,al
23637 6BB8           30C0                       xor	al,al
23638 6BBA           50                         push	ax
23639                                           ! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
23640 6BBB           8A46         16            mov	al,$16[bp]
23641                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23642 6BBE           30E4                       xor	ah,ah
23643 6BC0           0B46         CA            or	ax,0+..FFF0[bp]
23644 6BC3           44                         inc	sp
23645 6BC4           44                         inc	sp
23646                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
23647 6BC5           8946         16            mov	$16[bp],ax
23648                                           !BCC_EOS
23649                                           ! 3669       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
23650                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
23651 6BC8           8A46         E0            mov	al,-$20[bp]
23652 6BCB           24                     3F  and	al,*$3F
23653 6BCD           50                         push	ax
23654                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
23655 6BCE           8B46         E4            mov	ax,-$1C[bp]
23656 6BD1           D1E8                       shr	ax,*1
23657 6BD3           D1E8                       shr	ax,*1
23658                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
23659 6BD5           24                     C0  and	al,#$C0
23660                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23661 6BD7           0A46         CA            or	al,0+..FFF0[bp]
23662 6BDA           44                         inc	sp
23663 6BDB           44                         inc	sp
23664 6BDC           50                         push	ax
23665                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
23666 6BDD           8B46         16            mov	ax,$16[bp]
23667 6BE0           30C0                       xor	al,al
23668                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
23669 6BE2           0A46         CA            or	al,0+..FFF0[bp]
23670 6BE5           44                         inc	sp
23671 6BE6           44                         inc	sp
23672                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
23673 6BE7           8946         16            mov	$16[bp],ax
23674                                           !BCC_EOS
23675                                           ! 3670       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
23676                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
23677 6BEA           8B46         E2            mov	ax,-$1E[bp]
23678                                           ! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
23679 6BED           48                         dec	ax
23680 6BEE           88C4                       mov	ah,al
23681 6BF0           30C0                       xor	al,al
23682 6BF2           50                         push	ax
23683                                           ! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
23684 6BF3           8A46         14            mov	al,$14[bp]
23685                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23686 6BF6           30E4                       xor	ah,ah
23687 6BF8           0B46         CA            or	ax,0+..FFF0[bp]
23688 6BFB           44                         inc	sp
23689 6BFC           44                         inc	sp
23690                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
23691 6BFD           8946         14            mov	$14[bp],ax
23692                                           !BCC_EOS
23693                                           ! 3671       DX = ((DX & 0xff00) | (count));
23694                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
23695 6C00           8B46         14            mov	ax,$14[bp]
23696 6C03           30C0                       xor	al,al
23697                                           ! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
23698 6C05           0B46         DC            or	ax,-$24[bp]
23699                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
23700 6C08           8946         14            mov	$14[bp],ax
23701                                           !BCC_EOS
23702                                           ! 3672       goto int13_success;
23703 6C0B           83C4                   0E  add	sp,#..FFEF-..FFF0
23704 6C0E           E9         0AB0            br 	.FFEF
23705                                           !BCC_EOS
23706                                           ! 3673       break;
23707 6C11           E9         0A7D            br 	.500
23708                                           !BCC_EOS
23709                                           ! 3674     case 0x10:
23710                                           ! 3675       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
23711                       00006C14            .51F:
23712                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
23713 6C14           8A46         DB            mov	al,-$25[bp]
23714 6C17           30E4                       xor	ah,ah
23715 6C19           D1E8                       shr	ax,*1
23716                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
23717 6C1B           B1                     03  mov	cl,*3
23718 6C1D           D3E0                       shl	ax,cl
23719 6C1F           89C3                       mov	bx,ax
23720                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
23721                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
23722 6C21           81C3                 0124  add	bx,#$124
23723 6C25           53                         push	bx
23724                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23725 6C26           FF76         F6            push	-$A[bp]
23726                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23727 6C29           E8         99DB            call	_read_word
23728 6C2C           83C4                   04  add	sp,*4
23729                                           ! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
23730                                           ! Debug: list unsigned int = ax+7 (used reg = )
23731 6C2F           05                   0007  add	ax,*7
23732 6C32           50                         push	ax
23733                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23734 6C33           E8         9908            call	_inb
23735 6C36           44                         inc	sp
23736 6C37           44                         inc	sp
23737                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23738 6C38           8846         DA            mov	-$26[bp],al
23739                                           !BCC_EOS
23740                                           ! 3676       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
23741                                           ! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
23742 6C3B           8A46         DA            mov	al,-$26[bp]
23743 6C3E           24                     C0  and	al,#$C0
23744                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
23745 6C40           3C                     40  cmp	al,*$40
23746 6C42           75           08            jne 	.520
23747                       00006C44            .521:
23748                                           ! 3677         goto int13_success;
23749 6C44           83C4                   0E  add	sp,#..FFEF-..FFF0
23750 6C47           E9         0A77            br 	.FFEF
23751                                           !BCC_EOS
23752                                           ! 3678         }
23753                                           ! 3679       else {
23754 6C4A           EB           11            jmp .522
23755                       00006C4C            .520:
23756                                           ! 3680         AX = ((AX & 0x00ff) | ((0xAA) << 8));
23757                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23758 6C4C           8A46         18            mov	al,$18[bp]
23759                                           ! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
23760 6C4F           30E4                       xor	ah,ah
23761 6C51           0D                   AA00  or	ax,#-$5600
23762                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23763 6C54           8946         18            mov	$18[bp],ax
23764                                           !BCC_EOS
23765                                           ! 3681         goto int13_fail_noah;
23766 6C57           83C4                   0E  add	sp,#..FFEC-..FFF0
23767 6C5A           E9         0A42            br 	.FFEC
23768                                           !BCC_EOS
23769                                           ! 3682         }
23770                                           ! 3683       break;
23771                       00006C5D            .522:
23772 6C5D           E9         0A31            br 	.500
23773                                           !BCC_EOS
23774                                           ! 3684     case 0x15:
23775                                           ! 3685       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23776                       00006C60            .523:
23777                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23778 6C60           8A46         DB            mov	al,-$25[bp]
23779 6C63           30E4                       xor	ah,ah
23780 6C65           B9                   001E  mov	cx,*$1E
23781 6C68           F7E9                       imul	cx
23782 6C6A           89C3                       mov	bx,ax
23783                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23784                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23785 6C6C           81C3                 014E  add	bx,#$14E
23786 6C70           53                         push	bx
23787                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23788 6C71           FF76         F6            push	-$A[bp]
23789                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23790 6C74           E8         9990            call	_read_word
23791 6C77           83C4                   04  add	sp,*4
23792                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23793 6C7A           8946         E4            mov	-$1C[bp],ax
23794                                           !BCC_EOS
23795                                           ! 3686       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23796                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23797 6C7D           8A46         DB            mov	al,-$25[bp]
23798 6C80           30E4                       xor	ah,ah
23799 6C82           B9                   001E  mov	cx,*$1E
23800 6C85           F7E9                       imul	cx
23801 6C87           89C3                       mov	bx,ax
23802                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23803                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23804 6C89           81C3                 014C  add	bx,#$14C
23805 6C8D           53                         push	bx
23806                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23807 6C8E           FF76         F6            push	-$A[bp]
23808                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23809 6C91           E8         9973            call	_read_word
23810 6C94           83C4                   04  add	sp,*4
23811                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23812 6C97           8946         E2            mov	-$1E[bp],ax
23813                                           !BCC_EOS
23814                                           ! 3687       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23815                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23816 6C9A           8A46         DB            mov	al,-$25[bp]
23817 6C9D           30E4                       xor	ah,ah
23818 6C9F           B9                   001E  mov	cx,*$1E
23819 6CA2           F7E9                       imul	cx
23820 6CA4           89C3                       mov	bx,ax
23821                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23822                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23823 6CA6           81C3                 0150  add	bx,#$150
23824 6CAA           53                         push	bx
23825                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23826 6CAB           FF76         F6            push	-$A[bp]
23827                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23828 6CAE           E8         9956            call	_read_word
23829 6CB1           83C4                   04  add	sp,*4
23830                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23831 6CB4           8946         E0            mov	-$20[bp],ax
23832                                           !BCC_EOS
23833                                           ! 3688       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
23834                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23835 6CB7           8B46         E0            mov	ax,-$20[bp]
23836 6CBA           31DB                       xor	bx,bx
23837 6CBC           53                         push	bx
23838 6CBD           50                         push	ax
23839                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
23840 6CBE           8B46         E2            mov	ax,-$1E[bp]
23841 6CC1           31DB                       xor	bx,bx
23842 6CC3           53                         push	bx
23843 6CC4           50                         push	ax
23844                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
23845 6CC5           8B46         E4            mov	ax,-$1C[bp]
23846                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
23847 6CC8           48                         dec	ax
23848 6CC9           31DB                       xor	bx,bx
23849                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23850 6CCB           8D7E         C4            lea	di,-6+..FFF0[bp]
23851 6CCE           E8         9418            call	lmulul
23852 6CD1           83C4                   04  add	sp,*4
23853                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23854 6CD4           8D7E         C8            lea	di,-2+..FFF0[bp]
23855 6CD7           E8         940F            call	lmulul
23856 6CDA           83C4                   04  add	sp,*4
23857                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23858 6CDD           8946         FC            mov	-4[bp],ax
23859 6CE0           895E         FE            mov	-2[bp],bx
23860                                           !BCC_EOS
23861                                           ! 3689       CX = lba_low >> 16;
23862                                           ! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
23863 6CE3           8B46         FC            mov	ax,-4[bp]
23864 6CE6           8B5E         FE            mov	bx,-2[bp]
23865 6CE9           93                         xchg	bx,ax
23866 6CEA           31DB                       xor	bx,bx
23867                                           ! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
23868 6CEC           8946         16            mov	$16[bp],ax
23869                                           !BCC_EOS
23870                                           ! 3690       DX = lba_low & 0xffff;
23871                                           ! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
23872                                           ! Debug: expression subtree swapping
23873 6CEF           B8                   FFFF  mov	ax,#$FFFF
23874 6CF2           31DB                       xor	bx,bx
23875 6CF4           8D7E         FC            lea	di,-4[bp]
23876 6CF7           E8         93C1            call	landul
23877                                           ! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
23878 6CFA           8946         14            mov	$14[bp],ax
23879                                           !BCC_EOS
23880                                           ! 3691       AX = ((AX & 0x00ff) | ((3) << 8));
23881                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23882 6CFD           8A46         18            mov	al,$18[bp]
23883                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
23884 6D00           30E4                       xor	ah,ah
23885 6D02           0D                   0300  or	ax,#$300
23886                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23887 6D05           8946         18            mov	$18[bp],ax
23888                                           !BCC_EOS
23889                                           ! 3692       goto int13_success_noah;
23890 6D08           83C4                   0E  add	sp,#..FFED-..FFF0
23891 6D0B           E9         09BD            br 	.FFED
23892                                           !BCC_EOS
23893                                           ! 3693       break;
23894 6D0E           E9         0980            br 	.500
23895                                           !BCC_EOS
23896                                           ! 3694     case 0x41:
23897                                           ! 3695       BX=0xaa55;
23898                       00006D11            .524:
23899                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
23900 6D11           B8                   AA55  mov	ax,#$AA55
23901 6D14           8946         12            mov	$12[bp],ax
23902                                           !BCC_EOS
23903                                           ! 3696       AX = ((AX & 0x00ff) | ((0x30) << 8));
23904                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23905 6D17           8A46         18            mov	al,$18[bp]
23906                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
23907 6D1A           30E4                       xor	ah,ah
23908 6D1C           0D                   3000  or	ax,#$3000
23909                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23910 6D1F           8946         18            mov	$18[bp],ax
23911                                           !BCC_EOS
23912                                           ! 3697       CX=0x0007;
23913                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
23914 6D22           B8                   0007  mov	ax,*7
23915 6D25           8946         16            mov	$16[bp],ax
23916                                           !BCC_EOS
23917                                           ! 3698       goto int13_success_noah;
23918 6D28           83C4                   0E  add	sp,#..FFED-..FFF0
23919 6D2B           E9         099D            br 	.FFED
23920                                           !BCC_EOS
23921                                           ! 3699       break;
23922 6D2E           E9         0960            br 	.500
23923                                           !BCC_EOS
23924                                           ! 3700     case 0x42:
23925                                           ! 3701     case 0x43:
23926                       00006D31            .525:
23927                                           ! 3702     case 0x44:
23928                       00006D31            .526:
23929                                           ! 3703     case 0x47:
23930                       00006D31            .527:
23931                                           ! 3704       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
23932                       00006D31            .528:
23933                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23934 6D31           8B46         0C            mov	ax,$C[bp]
23935                                           ! Debug: list unsigned int = ax+2 (used reg = )
23936 6D34           40                         inc	ax
23937 6D35           40                         inc	ax
23938 6D36           50                         push	ax
23939                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23940 6D37           FF76         06            push	6[bp]
23941                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23942 6D3A           E8         98CA            call	_read_word
23943 6D3D           83C4                   04  add	sp,*4
23944                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
23945 6D40           8946         DC            mov	-$24[bp],ax
23946                                           !BCC_EOS
23947                                           ! 3705       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
23948                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
23949 6D43           8B46         0C            mov	ax,$C[bp]
23950                                           ! Debug: list unsigned int = ax+6 (used reg = )
23951 6D46           05                   0006  add	ax,*6
23952 6D49           50                         push	ax
23953                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23954 6D4A           FF76         06            push	6[bp]
23955                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23956 6D4D           E8         98B7            call	_read_word
23957 6D50           83C4                   04  add	sp,*4
23958                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
23959 6D53           8946         EE            mov	-$12[bp],ax
23960                                           !BCC_EOS
23961                                           ! 3706   
23962                                           ! 3706     offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
23963                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
23964 6D56           8B46         0C            mov	ax,$C[bp]
23965                                           ! Debug: list unsigned int = ax+4 (used reg = )
23966 6D59           05                   0004  add	ax,*4
23967 6D5C           50                         push	ax
23968                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23969 6D5D           FF76         06            push	6[bp]
23970                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23971 6D60           E8         98A4            call	_read_word
23972 6D63           83C4                   04  add	sp,*4
23973                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
23974 6D66           8946         EC            mov	-$14[bp],ax
23975                                           !BCC_EOS
23976                                           ! 3707       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
23977                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
23978 6D69           8B46         0C            mov	ax,$C[bp]
23979                                           ! Debug: list unsigned int = ax+$C (used reg = )
23980 6D6C           05                   000C  add	ax,*$C
23981 6D6F           50                         push	ax
23982                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23983 6D70           FF76         06            push	6[bp]
23984                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
23985 6D73           E8         930D            call	_read_dword
23986 6D76           89D3                       mov	bx,dx
23987 6D78           83C4                   04  add	sp,*4
23988                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23989 6D7B           8946         F8            mov	-8[bp],ax
23990 6D7E           895E         FA            mov	-6[bp],bx
23991                                           !BCC_EOS
23992                                           ! 3708       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
23993                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23994 6D81           8A46         DB            mov	al,-$25[bp]
23995 6D84           30E4                       xor	ah,ah
23996 6D86           B9                   001E  mov	cx,*$1E
23997 6D89           F7E9                       imul	cx
23998 6D8B           89C3                       mov	bx,ax
23999                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24000                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24001 6D8D           81C3                 015C  add	bx,#$15C
24002 6D91           53                         push	bx
24003                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24004 6D92           FF76         F6            push	-$A[bp]
24005                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24006 6D95           E8         92EB            call	_read_dword
24007 6D98           89D3                       mov	bx,dx
24008 6D9A           83C4                   04  add	sp,*4
24009                                           ! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24010 6D9D           8D7E         F8            lea	di,-8[bp]
24011 6DA0           E8         9328            call	lcmpul
24012 6DA3           73           06            jae 	.529
24013                       00006DA5            .52A:
24014                                           ! 3709         ;
24015                                           !BCC_EOS
24016                                           ! 3710         goto int13_fail;
24017 6DA5           83C4                   0E  add	sp,#..FFF1-..FFF0
24018 6DA8           E9         08E9            br 	.FFF1
24019                                           !BCC_EOS
24020                                           ! 3711         }
24021                                           ! 3712       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
24022                       00006DAB            .529:
24023                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
24024 6DAB           8B46         0C            mov	ax,$C[bp]
24025                                           ! Debug: list unsigned int = ax+8 (used reg = )
24026 6DAE           05                   0008  add	ax,*8
24027 6DB1           50                         push	ax
24028                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24029 6DB2           FF76         06            push	6[bp]
24030                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24031 6DB5           E8         92CB            call	_read_dword
24032 6DB8           89D3                       mov	bx,dx
24033 6DBA           83C4                   04  add	sp,*4
24034                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24035 6DBD           8946         FC            mov	-4[bp],ax
24036 6DC0           895E         FE            mov	-2[bp],bx
24037                                           !BCC_EOS
24038                                           ! 3713       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
24039                                           ! 3714           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
24040                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24041 6DC3           8A46         DB            mov	al,-$25[bp]
24042 6DC6           30E4                       xor	ah,ah
24043 6DC8           B9                   001E  mov	cx,*$1E
24044 6DCB           F7E9                       imul	cx
24045 6DCD           89C3                       mov	bx,ax
24046                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24047                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24048 6DCF           81C3                 015C  add	bx,#$15C
24049 6DD3           53                         push	bx
24050                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24051 6DD4           FF76         F6            push	-$A[bp]
24052                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24053 6DD7           E8         92A9            call	_read_dword
24054 6DDA           89D3                       mov	bx,dx
24055 6DDC           83C4                   04  add	sp,*4
24056                                           ! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24057                                           ! Debug: expression subtree swapping
24058 6DDF           8D7E         F8            lea	di,-8[bp]
24059 6DE2           E8         92E6            call	lcmpul
24060 6DE5           75           2A            jne 	.52B
24061                       00006DE7            .52D:
24062                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24063 6DE7           8A46         DB            mov	al,-$25[bp]
24064 6DEA           30E4                       xor	ah,ah
24065 6DEC           B9                   001E  mov	cx,*$1E
24066 6DEF           F7E9                       imul	cx
24067 6DF1           89C3                       mov	bx,ax
24068                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24069                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24070 6DF3           81C3                 0158  add	bx,#$158
24071 6DF7           53                         push	bx
24072                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24073 6DF8           FF76         F6            push	-$A[bp]
24074                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24075 6DFB           E8         9285            call	_read_dword
24076 6DFE           89D3                       mov	bx,dx
24077 6E00           83C4                   04  add	sp,*4
24078                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24079 6E03           8D7E         FC            lea	di,-4[bp]
24080 6E06           E8         92C2            call	lcmpul
24081 6E09           77           06            ja  	.52B
24082                       00006E0B            .52C:
24083                                           ! 3715         ;
24084                                           !BCC_EOS
24085                                           ! 3716         goto int13_fail;
24086 6E0B           83C4                   0E  add	sp,#..FFF1-..FFF0
24087 6E0E           E9         0883            br 	.FFF1
24088                                           !BCC_EOS
24089                                           ! 3717         }
24090                                           ! 3718       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
24091                       00006E11            .52B:
24092                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24093 6E11           8B46         18            mov	ax,$18[bp]
24094 6E14           88E0                       mov	al,ah
24095 6E16           30E4                       xor	ah,ah
24096                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
24097 6E18           3D                   0044  cmp	ax,*$44
24098 6E1B           74           0C            je  	.52F
24099                       00006E1D            .530:
24100                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24101 6E1D           8B46         18            mov	ax,$18[bp]
24102 6E20           88E0                       mov	al,ah
24103 6E22           30E4                       xor	ah,ah
24104                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
24105 6E24           3D                   0047  cmp	ax,*$47
24106 6E27           75           06            jne 	.52E
24107                       00006E29            .52F:
24108                                           ! 3719         goto int13_success;
24109 6E29           83C4                   0E  add	sp,#..FFEF-..FFF0
24110 6E2C           E9         0892            br 	.FFEF
24111                                           !BCC_EOS
24112                                           ! 3720       if ( ( AX >> 8 ) == 0x42 )
24113                       00006E2F            .52E:
24114                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24115 6E2F           8B46         18            mov	ax,$18[bp]
24116 6E32           88E0                       mov	al,ah
24117 6E34           30E4                       xor	ah,ah
24118                                           ! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
24119 6E36           3D                   0042  cmp	ax,*$42
24120 6E39           75           33            jne 	.531
24121                       00006E3B            .532:
24122                                           ! 3721         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24123                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24124 6E3B           FF76         EC            push	-$14[bp]
24125                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24126 6E3E           FF76         EE            push	-$12[bp]
24127                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24128 6E41           FF76         FA            push	-6[bp]
24129 6E44           FF76         F8            push	-8[bp]
24130                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24131 6E47           FF76         FE            push	-2[bp]
24132 6E4A           FF76         FC            push	-4[bp]
24133                                           ! Debug: list int = const 0 (used reg = )
24134 6E4D           31C0                       xor	ax,ax
24135 6E4F           50                         push	ax
24136                                           ! Debug: list int = const 0 (used reg = )
24137 6E50           31C0                       xor	ax,ax
24138 6E52           50                         push	ax
24139                                           ! Debug: list int = const 0 (used reg = )
24140 6E53           31C0                       xor	ax,ax
24141 6E55           50                         push	ax
24142                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24143 6E56           FF76         DC            push	-$24[bp]
24144                                           ! Debug: list int = const $20 (used reg = )
24145 6E59           B8                   0020  mov	ax,*$20
24146 6E5C           50                         push	ax
24147                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24148 6E5D           8A46         DB            mov	al,-$25[bp]
24149 6E60           30E4                       xor	ah,ah
24150 6E62           50                         push	ax
24151                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
24152 6E63           E8         BFC1            call	_ata_cmd_data_in
24153 6E66           83C4                   18  add	sp,*$18
24154                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24155 6E69           8846         DA            mov	-$26[bp],al
24156                                           !BCC_EOS
24157                                           ! 3722       else
24158                                           ! 3723         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24159 6E6C           EB           31            jmp .533
24160                       00006E6E            .531:
24161                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24162 6E6E           FF76         EC            push	-$14[bp]
24163                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24164 6E71           FF76         EE            push	-$12[bp]
24165                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24166 6E74           FF76         FA            push	-6[bp]
24167 6E77           FF76         F8            push	-8[bp]
24168                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24169 6E7A           FF76         FE            push	-2[bp]
24170 6E7D           FF76         FC            push	-4[bp]
24171                                           ! Debug: list int = const 0 (used reg = )
24172 6E80           31C0                       xor	ax,ax
24173 6E82           50                         push	ax
24174                                           ! Debug: list int = const 0 (used reg = )
24175 6E83           31C0                       xor	ax,ax
24176 6E85           50                         push	ax
24177                                           ! Debug: list int = const 0 (used reg = )
24178 6E86           31C0                       xor	ax,ax
24179 6E88           50                         push	ax
24180                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24181 6E89           FF76         DC            push	-$24[bp]
24182                                           ! Debug: list int = const $30 (used reg = )
24183 6E8C           B8                   0030  mov	ax,*$30
24184 6E8F           50                         push	ax
24185                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24186 6E90           8A46         DB            mov	al,-$25[bp]
24187 6E93           30E4                       xor	ah,ah
24188 6E95           50                         push	ax
24189                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24190 6E96           E8         C35F            call	_ata_cmd_data_out
24191 6E99           83C4                   18  add	sp,*$18
24192                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24193 6E9C           8846         DA            mov	-$26[bp],al
24194                                           !BCC_EOS
24195                                           ! 3724       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
24196                       00006E9F            .533:
24197                                           ! Debug: list * unsigned short = const $254 (used reg = )
24198 6E9F           B8                   0254  mov	ax,#$254
24199 6EA2           50                         push	ax
24200                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24201 6EA3           FF76         F6            push	-$A[bp]
24202                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24203 6EA6           E8         975E            call	_read_word
24204 6EA9           83C4                   04  add	sp,*4
24205                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24206 6EAC           8946         DC            mov	-$24[bp],ax
24207                                           !BCC_EOS
24208                                           ! 3725       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
24209                                           ! Debug: list unsigned short count = [S+$28-$26] (used reg = )
24210 6EAF           FF76         DC            push	-$24[bp]
24211                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
24212 6EB2           8B46         0C            mov	ax,$C[bp]
24213                                           ! Debug: list unsigned int = ax+2 (used reg = )
24214 6EB5           40                         inc	ax
24215 6EB6           40                         inc	ax
24216 6EB7           50                         push	ax
24217                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
24218 6EB8           FF76         06            push	6[bp]
24219                                           ! Debug: func () void = write_word+0 (used reg = )
24220 6EBB           E8         9774            call	_write_word
24221 6EBE           83C4                   06  add	sp,*6
24222                                           !BCC_EOS
24223                                           ! 3726       if (status != 0) {
24224                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24225 6EC1           8A46         DA            mov	al,-$26[bp]
24226 6EC4           84C0                       test	al,al
24227 6EC6           74           11            je  	.534
24228                       00006EC8            .535:
24229                                           ! 3727         ;
24230                                           !BCC_EOS
24231                                           ! 3728         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24232                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24233 6EC8           8A46         18            mov	al,$18[bp]
24234                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24235 6ECB           30E4                       xor	ah,ah
24236 6ECD           0D                   0C00  or	ax,#$C00
24237                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24238 6ED0           8946         18            mov	$18[bp],ax
24239                                           !BCC_EOS
24240                                           ! 3729         goto int13_fail_noah;
24241 6ED3           83C4                   0E  add	sp,#..FFEC-..FFF0
24242 6ED6           E9         07C6            br 	.FFEC
24243                                           !BCC_EOS
24244                                           ! 3730         }
24245                                           ! 3731       goto int13_success;
24246                       00006ED9            .534:
24247 6ED9           83C4                   0E  add	sp,#..FFEF-..FFF0
24248 6EDC           E9         07E2            br 	.FFEF
24249                                           !BCC_EOS
24250                                           ! 3732       break;
24251 6EDF           E9         07AF            br 	.500
24252                                           !BCC_EOS
24253                                           ! 3733     case 0x45:
24254                                           ! 3734     case 0x49:
24255                       00006EE2            .536:
24256                                           ! 3735       goto int13_success;
24257                       00006EE2            .537:
24258 6EE2           83C4                   0E  add	sp,#..FFEF-..FFF0
24259 6EE5           E9         07D9            br 	.FFEF
24260                                           !BCC_EOS
24261                                           ! 3736       break;
24262 6EE8           E9         07A6            br 	.500
24263                                           !BCC_EOS
24264                                           ! 3737     case 0x46:
24265                                           ! 3738       AX = ((AX & 0x00ff) | ((0xb2) << 8));
24266                       00006EEB            .538:
24267                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24268 6EEB           8A46         18            mov	al,$18[bp]
24269                                           ! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
24270 6EEE           30E4                       xor	ah,ah
24271 6EF0           0D                   B200  or	ax,#-$4E00
24272                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24273 6EF3           8946         18            mov	$18[bp],ax
24274                                           !BCC_EOS
24275                                           ! 3739       goto int13_fail_noah;
24276 6EF6           83C4                   0E  add	sp,#..FFEC-..FFF0
24277 6EF9           E9         07A3            br 	.FFEC
24278                                           !BCC_EOS
24279                                           ! 3740       break;
24280 6EFC           E9         0792            br 	.500
24281                                           !BCC_EOS
24282                                           ! 3741     case 0x48:
24283                                           ! 3742       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
24284                       00006EFF            .539:
24285                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
24286 6EFF           8B46         0C            mov	ax,$C[bp]
24287                                           ! Debug: list unsigned int = ax+0 (used reg = )
24288 6F02           50                         push	ax
24289                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24290 6F03           FF76         06            push	6[bp]
24291                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24292 6F06           E8         96FE            call	_read_word
24293 6F09           83C4                   04  add	sp,*4
24294                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
24295 6F0C           8946         DE            mov	-$22[bp],ax
24296                                           !BCC_EOS
24297                                           ! 3743       if(size < 0x1a)
24298                                           ! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24299 6F0F           8B46         DE            mov	ax,-$22[bp]
24300 6F12           3D                   001A  cmp	ax,*$1A
24301 6F15           73           06            jae 	.53A
24302                       00006F17            .53B:
24303                                           ! 3744         goto int13_fail;
24304 6F17           83C4                   0E  add	sp,#..FFF1-..FFF0
24305 6F1A           E9         0777            br 	.FFF1
24306                                           !BCC_EOS
24307                                           ! 3745       if(size >= 0x1a) {
24308                       00006F1D            .53A:
24309                                           ! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24310 6F1D           8B46         DE            mov	ax,-$22[bp]
24311 6F20           3D                   001A  cmp	ax,*$1A
24312 6F23         0F82         01E3            blo 	.53C
24313                       00006F27            .53D:
24314                                           ! 3746         Bit16u blksize;
24315                                           !BCC_EOS
24316                                           ! 3747         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
24317                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24318 6F27           8A46         DB            mov	al,-$25[bp]
24319 6F2A           30E4                       xor	ah,ah
24320 6F2C           B9                   001E  mov	cx,*$1E
24321 6F2F           F7E9                       imul	cx
24322 6F31           89C3                       mov	bx,ax
24323                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
24324                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
24325 6F33           81C3                 0154  add	bx,#$154
24326 6F37           53                         push	bx
24327                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24328 6F38           FF76         F6            push	-$A[bp]
24329                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24330 6F3B           E8         96C9            call	_read_word
24331 6F3E           83C4                   04  add	sp,*4
24332                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
24333 6F41           8946         EA            mov	-$16[bp],ax
24334                                           !BCC_EOS
24335                                           ! 3748         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
24336                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24337 6F44           8A46         DB            mov	al,-$25[bp]
24338 6F47           30E4                       xor	ah,ah
24339 6F49           B9                   001E  mov	cx,*$1E
24340 6F4C           F7E9                       imul	cx
24341 6F4E           89C3                       mov	bx,ax
24342                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
24343                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
24344 6F50           81C3                 0152  add	bx,#$152
24345 6F54           53                         push	bx
24346                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24347 6F55           FF76         F6            push	-$A[bp]
24348                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24349 6F58           E8         96AC            call	_read_word
24350 6F5B           83C4                   04  add	sp,*4
24351                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24352 6F5E           8946         E8            mov	-$18[bp],ax
24353                                           !BCC_EOS
24354                                           ! 3749         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
24355                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24356 6F61           8A46         DB            mov	al,-$25[bp]
24357 6F64           30E4                       xor	ah,ah
24358 6F66           B9                   001E  mov	cx,*$1E
24359 6F69           F7E9                       imul	cx
24360 6F6B           89C3                       mov	bx,ax
24361                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
24362                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
24363 6F6D           81C3                 0156  add	bx,#$156
24364 6F71           53                         push	bx
24365                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24366 6F72           FF76         F6            push	-$A[bp]
24367                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24368 6F75           E8         968F            call	_read_word
24369 6F78           83C4                   04  add	sp,*4
24370                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
24371 6F7B           8946         E6            mov	-$1A[bp],ax
24372                                           !BCC_EOS
24373                                           ! 3750         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
24374                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24375 6F7E           8A46         DB            mov	al,-$25[bp]
24376 6F81           30E4                       xor	ah,ah
24377 6F83           B9                   001E  mov	cx,*$1E
24378 6F86           F7E9                       imul	cx
24379 6F88           89C3                       mov	bx,ax
24380                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24381                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24382 6F8A           81C3                 0158  add	bx,#$158
24383 6F8E           53                         push	bx
24384                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24385 6F8F           FF76         F6            push	-$A[bp]
24386                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24387 6F92           E8         90EE            call	_read_dword
24388 6F95           89D3                       mov	bx,dx
24389 6F97           83C4                   04  add	sp,*4
24390                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
24391 6F9A           8946         FC            mov	-4[bp],ax
24392 6F9D           895E         FE            mov	-2[bp],bx
24393                                           !BCC_EOS
24394                                           ! 3751         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
24395                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24396 6FA0           8A46         DB            mov	al,-$25[bp]
24397 6FA3           30E4                       xor	ah,ah
24398 6FA5           B9                   001E  mov	cx,*$1E
24399 6FA8           F7E9                       imul	cx
24400 6FAA           89C3                       mov	bx,ax
24401                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24402                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24403 6FAC           81C3                 015C  add	bx,#$15C
24404 6FB0           53                         push	bx
24405                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24406 6FB1           FF76         F6            push	-$A[bp]
24407                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24408 6FB4           E8         90CC            call	_read_dword
24409 6FB7           89D3                       mov	bx,dx
24410 6FB9           83C4                   04  add	sp,*4
24411                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
24412 6FBC           8946         F8            mov	-8[bp],ax
24413 6FBF           895E         FA            mov	-6[bp],bx
24414                                           !BCC_EOS
24415                                           ! 3752         blksize = 
24416                                           ! 3752 read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
24417                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24418 6FC2           8A46         DB            mov	al,-$25[bp]
24419 6FC5           30E4                       xor	ah,ah
24420 6FC7           B9                   001E  mov	cx,*$1E
24421 6FCA           F7E9                       imul	cx
24422 6FCC           89C3                       mov	bx,ax
24423                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
24424                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
24425 6FCE           81C3                 0148  add	bx,#$148
24426 6FD2           53                         push	bx
24427                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24428 6FD3           FF76         F6            push	-$A[bp]
24429                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24430 6FD6           E8         962E            call	_read_word
24431 6FD9           83C4                   04  add	sp,*4
24432                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
24433 6FDC           8946         D8            mov	-$28[bp],ax
24434                                           !BCC_EOS
24435                                           ! 3753         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
24436                                           ! Debug: list int = const $1A (used reg = )
24437 6FDF           B8                   001A  mov	ax,*$1A
24438 6FE2           50                         push	ax
24439                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
24440 6FE3           8B46         0C            mov	ax,$C[bp]
24441                                           ! Debug: list unsigned int = ax+0 (used reg = )
24442 6FE6           50                         push	ax
24443                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24444 6FE7           FF76         06            push	6[bp]
24445                                           ! Debug: func () void = write_word+0 (used reg = )
24446 6FEA           E8         9645            call	_write_word
24447 6FED           83C4                   06  add	sp,*6
24448                                           !BCC_EOS
24449                                           ! 3754         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
24450 6FF0           8B46         F8            mov	ax,-8[bp]
24451 6FF3           8B5E         FA            mov	bx,-6[bp]
24452 6FF6           E8         911B            call	ltstl
24453 6FF9           75           50            jne 	.53F
24454                       00006FFB            .540:
24455                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24456 6FFB           8B46         E8            mov	ax,-$18[bp]
24457 6FFE           31DB                       xor	bx,bx
24458 7000           53                         push	bx
24459 7001           50                         push	ax
24460                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
24461 7002           8B46         E6            mov	ax,-$1A[bp]
24462 7005           31DB                       xor	bx,bx
24463                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
24464 7007           53                         push	bx
24465 7008           50                         push	ax
24466 7009           8B46         FC            mov	ax,-4[bp]
24467 700C           8B5E         FE            mov	bx,-2[bp]
24468 700F           8D7E         C4            lea	di,-6+..FFF0[bp]
24469 7012           E8         9159            call	ldivul
24470 7015           83C4                   04  add	sp,*4
24471                                           ! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
24472 7018           8D7E         C8            lea	di,-2+..FFF0[bp]
24473 701B           E8         9150            call	ldivul
24474 701E           83C4                   04  add	sp,*4
24475                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
24476 7021           53                         push	bx
24477 7022           50                         push	ax
24478 7023           B8                   3FFF  mov	ax,#$3FFF
24479 7026           31DB                       xor	bx,bx
24480 7028           53                         push	bx
24481 7029           50                         push	ax
24482 702A           8B46         C8            mov	ax,-2+..FFF0[bp]
24483 702D           8B5E         CA            mov	bx,0+..FFF0[bp]
24484 7030           8D7E         C4            lea	di,-6+..FFF0[bp]
24485 7033           E8         9095            call	lcmpul
24486 7036           76           04            jbe	.541
24487 7038           B0                     01  mov	al,*1
24488 703A           EB           02            jmp	.542
24489                       0000703C            .541:
24490 703C           30C0                       xor	al,al
24491                       0000703E            .542:
24492 703E           83C4                   08  add	sp,*8
24493                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
24494 7041           30E4                       xor	ah,ah
24495 7043           99                         cwd
24496 7044           89D3                       mov	bx,dx
24497 7046           E8         90CB            call	ltstl
24498 7049           74           28            je  	.53E
24499                       0000704B            .53F:
24500                                           ! 3755         {
24501                                           ! 3756           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
24502                                           ! Debug: list int = const 0 (used reg = )
24503 704B           31C0                       xor	ax,ax
24504 704D           50                         push	ax
24505                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
24506 704E           8B46         0C            mov	ax,$C[bp]
24507                                           ! Debug: list unsigned int = ax+2 (used reg = )
24508 7051           40                         inc	ax
24509 7052           40                         inc	ax
24510 7053           50                         push	ax
24511                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24512 7054           FF76         06            push	6[bp]
24513                                           ! Debug: func () void = write_word+0 (used reg = )
24514 7057           E8         95D8            call	_write_word
24515 705A           83C4                   06  add	sp,*6
24516                                           !BCC_EOS
24517                                           ! 3757           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
24518                                           ! Debug: list int = const $3FFF (used reg = )
24519 705D           B8                   3FFF  mov	ax,#$3FFF
24520 7060           50                         push	ax
24521                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
24522 7061           8B46         0C            mov	ax,$C[bp]
24523                                           ! Debug: list unsigned int = ax+4 (used reg = )
24524 7064           05                   0004  add	ax,*4
24525 7067           50                         push	ax
24526                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24527 7068           FF76         06            push	6[bp]
24528                                           ! Debug: func () void = write_dword+0 (used reg = )
24529 706B           E8         902D            call	_write_dword
24530 706E           83C4                   06  add	sp,*6
24531                                           !BCC_EOS
24532                                           ! 3758         }
24533                                           ! 3759         else
24534                                           ! 3760         {
24535 7071           EB           2A            jmp .544
24536                       00007073            .53E:
24537                                           ! 3761           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
24538                                           ! Debug: list int = const 2 (used reg = )
24539 7073           B8                   0002  mov	ax,*2
24540 7076           50                         push	ax
24541                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
24542 7077           8B46         0C            mov	ax,$C[bp]
24543                                           ! Debug: list unsigned int = ax+2 (used reg = )
24544 707A           40                         inc	ax
24545 707B           40                         inc	ax
24546 707C           50                         push	ax
24547                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24548 707D           FF76         06            push	6[bp]
24549                                           ! Debug: func () void = write_word+0 (used reg = )
24550 7080           E8         95AF            call	_write_word
24551 7083           83C4                   06  add	sp,*6
24552                                           !BCC_EOS
24553                                           ! 3762           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
24554                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
24555 7086           8B46         EA            mov	ax,-$16[bp]
24556 7089           31DB                       xor	bx,bx
24557                                           ! Debug: list unsigned long = bx+0 (used reg = )
24558 708B           53                         push	bx
24559 708C           50                         push	ax
24560                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
24561 708D           8B46         0C            mov	ax,$C[bp]
24562                                           ! Debug: list unsigned int = ax+4 (used reg = )
24563 7090           05                   0004  add	ax,*4
24564 7093           50                         push	ax
24565                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24566 7094           FF76         06            push	6[bp]
24567                                           ! Debug: func () void = write_dword+0 (used reg = )
24568 7097           E8         9001            call	_write_dword
24569 709A           83C4                   08  add	sp,*8
24570                                           !BCC_EOS
24571                                           ! 3763         }
24572                                           ! 3764         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
24573                       0000709D            .544:
24574                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24575 709D           8B46         E8            mov	ax,-$18[bp]
24576 70A0           31DB                       xor	bx,bx
24577                                           ! Debug: list unsigned long = bx+0 (used reg = )
24578 70A2           53                         push	bx
24579 70A3           50                         push	ax
24580                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
24581 70A4           8B46         0C            mov	ax,$C[bp]
24582                                           ! Debug: list unsigned int = ax+8 (used reg = )
24583 70A7           05                   0008  add	ax,*8
24584 70AA           50                         push	ax
24585                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24586 70AB           FF76         06            push	6[bp]
24587                                           ! Debug: func () void = write_dword+0 (used reg = )
24588 70AE           E8         8FEA            call	_write_dword
24589 70B1           83C4                   08  add	sp,*8
24590                                           !BCC_EOS
24591                                           ! 3765         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
24592                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
24593 70B4           8B46         E6            mov	ax,-$1A[bp]
24594 70B7           31DB                       xor	bx,bx
24595                                           ! Debug: list unsigned long = bx+0 (used reg = )
24596 70B9           53                         push	bx
24597 70BA           50                         push	ax
24598                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
24599 70BB           8B46         0C            mov	ax,$C[bp]
24600                                           ! Debug: list unsigned int = ax+$C (used reg = )
24601 70BE           05                   000C  add	ax,*$C
24602 70C1           50                         push	ax
24603                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24604 70C2           FF76         06            push	6[bp]
24605                                           ! Debug: func () void = write_dword+0 (used reg = )
24606 70C5           E8         8FD3            call	_write_dword
24607 70C8           83C4                   08  add	sp,*8
24608                                           !BCC_EOS
24609                                           ! 3766         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
24610                                           ! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
24611 70CB           FF76         FE            push	-2[bp]
24612 70CE           FF76         FC            push	-4[bp]
24613                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
24614 70D1           8B46         0C            mov	ax,$C[bp]
24615                                           ! Debug: list unsigned int = ax+$10 (used reg = )
24616 70D4           05                   0010  add	ax,*$10
24617 70D7           50                         push	ax
24618                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24619 70D8           FF76         06            push	6[bp]
24620                                           ! Debug: func () void = write_dword+0 (used reg = )
24621 70DB           E8         8FBD            call	_write_dword
24622 70DE           83C4                   08  add	sp,*8
24623                                           !BCC_EOS
24624                                           ! 3767         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
24625                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
24626 70E1           FF76         FA            push	-6[bp]
24627 70E4           FF76         F8            push	-8[bp]
24628                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
24629 70E7           8B46         0C            mov	ax,$C[bp]
24630                                           ! Debug: list unsigned int = ax+$14 (used reg = )
24631 70EA           05                   0014  add	ax,*$14
24632 70ED           50                         push	ax
24633                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24634 70EE           FF76         06            push	6[bp]
24635                                           ! Debug: func () void = write_dword+0 (used reg = )
24636 70F1           E8         8FA7            call	_write_dword
24637 70F4           83C4                   08  add	sp,*8
24638                                           !BCC_EOS
24639                                           ! 3768         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
24640                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
24641 70F7           FF76         D8            push	-$28[bp]
24642                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
24643 70FA           8B46         0C            mov	ax,$C[bp]
24644                                           ! Debug: list unsigned int = ax+$18 (used reg = )
24645 70FD           05                   0018  add	ax,*$18
24646 7100           50                         push	ax
24647                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24648 7101           FF76         06            push	6[bp]
24649                                           ! Debug: func () void = write_word+0 (used reg = )
24650 7104           E8         952B            call	_write_word
24651 7107           83C4                   06  add	sp,*6
24652                                           !BCC_EOS
24653                                           ! 3769         }
24654                                           ! 3770       if(size >= 0x1e) {
24655                       0000710A            .53C:
24656                                           ! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
24657 710A           8B46         DE            mov	ax,-$22[bp]
24658 710D           3D                   001E  cmp	ax,*$1E
24659 7110         0F82         0273            blo 	.545
24660                       00007114            .546:
24661                                           ! 3771         Bit8u channel, dev, irq, mode, checksum, i, translation;
24662                                           !BCC_EOS
24663                                           ! 3772         Bit16u iobase1, iobase2, options;
24664                                           !BCC_EOS
24665                                           ! 3773         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
24666                                           ! Debug: list int = const $1E (used reg = )
24667 7114           B8                   001E  mov	ax,*$1E
24668 7117           50                         push	ax
24669                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
24670 7118           8B46         0C            mov	ax,$C[bp]
24671                                           ! Debug: list unsigned int = ax+0 (used reg = )
24672 711B           50                         push	ax
24673                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24674 711C           FF76         06            push	6[bp]
24675                                           ! Debug: func () void = write_word+0 (used reg = )
24676 711F           E8         9510            call	_write_word
24677 7122           83C4                   06  add	sp,*6
24678                                           !BCC_EOS
24679                                           ! 3774         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
24680                                           ! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
24681 7125           FF76         F6            push	-$A[bp]
24682                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
24683 7128           8B46         0C            mov	ax,$C[bp]
24684                                           ! Debug: list unsigned int = ax+$1C (used reg = )
24685 712B           05                   001C  add	ax,*$1C
24686 712E           50                         push	ax
24687                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24688 712F           FF76         06            push	6[bp]
24689                                           ! Debug: func () void = write_word+0 (used reg = )
24690 7132           E8         94FD            call	_write_word
24691 7135           83C4                   06  add	sp,*6
24692                                           !BCC_EOS
24693                                           ! 3775         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
24694                                           ! Debug: list * struct  = const $244 (used reg = )
24695 7138           B8                   0244  mov	ax,#$244
24696 713B           50                         push	ax
24697                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
24698 713C           8B46         0C            mov	ax,$C[bp]
24699                                           ! Debug: list unsigned int = ax+$1A (used reg = )
24700 713F           05                   001A  add	ax,*$1A
24701 7142           50                         push	ax
24702                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24703 7143           FF76         06            push	6[bp]
24704                                           ! Debug: func () void = write_word+0 (used reg = )
24705 7146           E8         94E9            call	_write_word
24706 7149           83C4                   06  add	sp,*6
24707                                           !BCC_EOS
24708                                           ! 3776         channel = device / 2;
24709                                           ! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
24710 714C           8A46         DB            mov	al,-$25[bp]
24711 714F           30E4                       xor	ah,ah
24712 7151           D1E8                       shr	ax,*1
24713                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
24714 7153           8846         D9            mov	-$27[bp],al
24715                                           !BCC_EOS
24716                                           ! 3777         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
24717                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24718 7156           8A46         D9            mov	al,-$27[bp]
24719 7159           30E4                       xor	ah,ah
24720 715B           B1                     03  mov	cl,*3
24721 715D           D3E0                       shl	ax,cl
24722 715F           89C3                       mov	bx,ax
24723                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
24724                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
24725 7161           81C3                 0124  add	bx,#$124
24726 7165           53                         push	bx
24727                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24728 7166           FF76         F6            push	-$A[bp]
24729                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24730 7169           E8         949B            call	_read_word
24731 716C           83C4                   04  add	sp,*4
24732                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
24733 716F           8946         D0            mov	-$30[bp],ax
24734                                           !BCC_EOS
24735                                           ! 3778         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
24736                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24737 7172           8A46         D9            mov	al,-$27[bp]
24738 7175           30E4                       xor	ah,ah
24739 7177           B1                     03  mov	cl,*3
24740 7179           D3E0                       shl	ax,cl
24741 717B           89C3                       mov	bx,ax
24742                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
24743                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
24744 717D           81C3                 0126  add	bx,#$126
24745 7181           53                         push	bx
24746                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24747 7182           FF76         F6            push	-$A[bp]
24748                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24749 7185           E8         947F            call	_read_word
24750 7188           83C4                   04  add	sp,*4
24751                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
24752 718B           8946         CE            mov	-$32[bp],ax
24753                                           !BCC_EOS
24754                                           ! 3779         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
24755                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24756 718E           8A46         D9            mov	al,-$27[bp]
24757 7191           30E4                       xor	ah,ah
24758 7193           B1                     03  mov	cl,*3
24759 7195           D3E0                       shl	ax,cl
24760 7197           89C3                       mov	bx,ax
24761                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
24762                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
24763 7199           81C3                 0128  add	bx,#$128
24764 719D           53                         push	bx
24765                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24766 719E           FF76         F6            push	-$A[bp]
24767                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24768 71A1           E8         9450            call	_read_byte
24769 71A4           83C4                   04  add	sp,*4
24770                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
24771 71A7           8846         D7            mov	-$29[bp],al
24772                                           !BCC_EOS
24773                                           ! 3780         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
24774                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
24775 71AA           8A46         DB            mov	al,-$25[bp]
24776 71AD           30E4                       xor	ah,ah
24777 71AF           B9                   001E  mov	cx,*$1E
24778 71B2           F7E9                       imul	cx
24779 71B4           89C3                       mov	bx,ax
24780                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
24781                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
24782 71B6           81C3                 0146  add	bx,#$146
24783 71BA           53                         push	bx
24784                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24785 71BB           FF76         F6            push	-$A[bp]
24786                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24787 71BE           E8         9433            call	_read_byte
24788 71C1           83C4                   04  add	sp,*4
24789                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
24790 71C4           8846         D6            mov	-$2A[bp],al
24791                                           !BCC_EOS
24792                                           ! 3781         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
24793                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
24794 71C7           8A46         DB            mov	al,-$25[bp]
24795 71CA           30E4                       xor	ah,ah
24796 71CC           B9                   001E  mov	cx,*$1E
24797 71CF           F7E9                       imul	cx
24798 71D1           89C3                       mov	bx,ax
24799                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
24800                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
24801 71D3           81C3                 014A  add	bx,#$14A
24802 71D7           53                         push	bx
24803                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24804 71D8           FF76         F6            push	-$A[bp]
24805                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24806 71DB           E8         9416            call	_read_byte
24807 71DE           83C4                   04  add	sp,*4
24808                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
24809 71E1           8846         D3            mov	-$2D[bp],al
24810                                           !BCC_EOS
24811                                           ! 3782         options = (translation==0?0:1)<<3;
24812                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
24813 71E4           8A46         D3            mov	al,-$2D[bp]
24814 71E7           84C0                       test	al,al
24815 71E9           75           04            jne 	.547
24816                       000071EB            .548:
24817 71EB           30C0                       xor	al,al
24818 71ED           EB           02            jmp .549
24819                       000071EF            .547:
24820 71EF           B0                     01  mov	al,*1
24821                       000071F1            .549:
24822                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
24823 71F1           30E4                       xor	ah,ah
24824 71F3           B1                     03  mov	cl,*3
24825 71F5           D3E0                       shl	ax,cl
24826                                           ! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24827 71F7           8946         CC            mov	-$34[bp],ax
24828                                           !BCC_EOS
24829                                           ! 3783         options |= (1<<4);
24830                                           ! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
24831 71FA           8B46         CC            mov	ax,-$34[bp]
24832 71FD           0C                     10  or	al,*$10
24833 71FF           8946         CC            mov	-$34[bp],ax
24834                                           !BCC_EOS
24835                                           ! 3784         options |= (mode==0x01?1:0)<<7;
24836                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
24837 7202           8A46         D6            mov	al,-$2A[bp]
24838 7205           3C                     01  cmp	al,*1
24839 7207           75           04            jne 	.54A
24840                       00007209            .54B:
24841 7209           B0                     01  mov	al,*1
24842 720B           EB           02            jmp .54C
24843                       0000720D            .54A:
24844 720D           30C0                       xor	al,al
24845                       0000720F            .54C:
24846                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
24847 720F           30E4                       xor	ah,ah
24848 7211           B1                     07  mov	cl,*7
24849 7213           D3E0                       shl	ax,cl
24850                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24851 7215           0B46         CC            or	ax,-$34[bp]
24852 7218           8946         CC            mov	-$34[bp],ax
24853                                           !BCC_EOS
24854                                           ! 3785         options |= (translation==1?1:0)<<9;
24855                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
24856 721B           8A46         D3            mov	al,-$2D[bp]
24857 721E           3C                     01  cmp	al,*1
24858 7220           75           04            jne 	.54D
24859                       00007222            .54E:
24860 7222           B0                     01  mov	al,*1
24861 7224           EB           02            jmp .54F
24862                       00007226            .54D:
24863 7226           30C0                       xor	al,al
24864                       00007228            .54F:
24865                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
24866 7228           30E4                       xor	ah,ah
24867 722A           88C4                       mov	ah,al
24868 722C           30C0                       xor	al,al
24869 722E           D1E0                       shl	ax,*1
24870                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24871 7230           0B46         CC            or	ax,-$34[bp]
24872 7233           8946         CC            mov	-$34[bp],ax
24873                                           !BCC_EOS
24874                                           ! 3786         options |= (translation==3?3:0)<<9;
24875                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
24876 7236           8A46         D3            mov	al,-$2D[bp]
24877 7239           3C                     03  cmp	al,*3
24878 723B           75           04            jne 	.550
24879                       0000723D            .551:
24880 723D           B0                     03  mov	al,*3
24881 723F           EB           02            jmp .552
24882                       00007241            .550:
24883 7241           30C0                       xor	al,al
24884                       00007243            .552:
24885                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
24886 7243           30E4                       xor	ah,ah
24887 7245           88C4                       mov	ah,al
24888 7247           30C0                       xor	al,al
24889 7249           D1E0                       shl	ax,*1
24890                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24891 724B           0B46         CC            or	ax,-$34[bp]
24892 724E           8946         CC            mov	-$34[bp],ax
24893                                           !BCC_EOS
24894                                           ! 3787         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
24895                                           ! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
24896 7251           FF76         D0            push	-$30[bp]
24897                                           ! Debug: list * unsigned short = const $244 (used reg = )
24898 7254           B8                   0244  mov	ax,#$244
24899 7257           50                         push	ax
24900                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24901 7258           FF76         F6            push	-$A[bp]
24902                                           ! Debug: func () void = write_word+0 (used reg = )
24903 725B           E8         93D4            call	_write_word
24904 725E           83C4                   06  add	sp,*6
24905                                           !BCC_EOS
24906                                           ! 3788         write_word(ebda_
24907                                           ! 3788 seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
24908                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
24909 7261           8B46         CE            mov	ax,-$32[bp]
24910                                           ! Debug: list unsigned int = ax+6 (used reg = )
24911 7264           05                   0006  add	ax,*6
24912 7267           50                         push	ax
24913                                           ! Debug: list * unsigned short = const $246 (used reg = )
24914 7268           B8                   0246  mov	ax,#$246
24915 726B           50                         push	ax
24916                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24917 726C           FF76         F6            push	-$A[bp]
24918                                           ! Debug: func () void = write_word+0 (used reg = )
24919 726F           E8         93C0            call	_write_word
24920 7272           83C4                   06  add	sp,*6
24921                                           !BCC_EOS
24922                                           ! 3789         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
24923                                           ! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
24924 7275           8A46         DB            mov	al,-$25[bp]
24925 7278           30E4                       xor	ah,ah
24926 727A           24                     01  and	al,*1
24927                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
24928                                           ! Debug: expression subtree swapping
24929 727C           0C                     0E  or	al,*$E
24930                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
24931 727E           30E4                       xor	ah,ah
24932 7280           B1                     04  mov	cl,*4
24933 7282           D3E0                       shl	ax,cl
24934                                           ! Debug: list unsigned int = ax+0 (used reg = )
24935 7284           50                         push	ax
24936                                           ! Debug: list * unsigned char = const $248 (used reg = )
24937 7285           B8                   0248  mov	ax,#$248
24938 7288           50                         push	ax
24939                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24940 7289           FF76         F6            push	-$A[bp]
24941                                           ! Debug: func () void = write_byte+0 (used reg = )
24942 728C           E8         938B            call	_write_byte
24943 728F           83C4                   06  add	sp,*6
24944                                           !BCC_EOS
24945                                           ! 3790         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
24946                                           ! Debug: list int = const $CB (used reg = )
24947 7292           B8                   00CB  mov	ax,#$CB
24948 7295           50                         push	ax
24949                                           ! Debug: list * unsigned char = const $249 (used reg = )
24950 7296           B8                   0249  mov	ax,#$249
24951 7299           50                         push	ax
24952                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24953 729A           FF76         F6            push	-$A[bp]
24954                                           ! Debug: func () void = write_byte+0 (used reg = )
24955 729D           E8         937A            call	_write_byte
24956 72A0           83C4                   06  add	sp,*6
24957                                           !BCC_EOS
24958                                           ! 3791         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
24959                                           ! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
24960 72A3           8A46         D7            mov	al,-$29[bp]
24961 72A6           30E4                       xor	ah,ah
24962 72A8           50                         push	ax
24963                                           ! Debug: list * unsigned char = const $24A (used reg = )
24964 72A9           B8                   024A  mov	ax,#$24A
24965 72AC           50                         push	ax
24966                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24967 72AD           FF76         F6            push	-$A[bp]
24968                                           ! Debug: func () void = write_byte+0 (used reg = )
24969 72B0           E8         9367            call	_write_byte
24970 72B3           83C4                   06  add	sp,*6
24971                                           !BCC_EOS
24972                                           ! 3792         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
24973                                           ! Debug: list int = const 1 (used reg = )
24974 72B6           B8                   0001  mov	ax,*1
24975 72B9           50                         push	ax
24976                                           ! Debug: list * unsigned char = const $24B (used reg = )
24977 72BA           B8                   024B  mov	ax,#$24B
24978 72BD           50                         push	ax
24979                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24980 72BE           FF76         F6            push	-$A[bp]
24981                                           ! Debug: func () void = write_byte+0 (used reg = )
24982 72C1           E8         9356            call	_write_byte
24983 72C4           83C4                   06  add	sp,*6
24984                                           !BCC_EOS
24985                                           ! 3793         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
24986                                           ! Debug: list int = const 0 (used reg = )
24987 72C7           31C0                       xor	ax,ax
24988 72C9           50                         push	ax
24989                                           ! Debug: list * unsigned char = const $24C (used reg = )
24990 72CA           B8                   024C  mov	ax,#$24C
24991 72CD           50                         push	ax
24992                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24993 72CE           FF76         F6            push	-$A[bp]
24994                                           ! Debug: func () void = write_byte+0 (used reg = )
24995 72D1           E8         9346            call	_write_byte
24996 72D4           83C4                   06  add	sp,*6
24997                                           !BCC_EOS
24998                                           ! 3794         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
24999                                           ! Debug: list int = const 0 (used reg = )
25000 72D7           31C0                       xor	ax,ax
25001 72D9           50                         push	ax
25002                                           ! Debug: list * unsigned char = const $24D (used reg = )
25003 72DA           B8                   024D  mov	ax,#$24D
25004 72DD           50                         push	ax
25005                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25006 72DE           FF76         F6            push	-$A[bp]
25007                                           ! Debug: func () void = write_byte+0 (used reg = )
25008 72E1           E8         9336            call	_write_byte
25009 72E4           83C4                   06  add	sp,*6
25010                                           !BCC_EOS
25011                                           ! 3795         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
25012                                           ! Debug: list unsigned short options = [S+$36-$36] (used reg = )
25013 72E7           FF76         CC            push	-$34[bp]
25014                                           ! Debug: list * unsigned short = const $24E (used reg = )
25015 72EA           B8                   024E  mov	ax,#$24E
25016 72ED           50                         push	ax
25017                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25018 72EE           FF76         F6            push	-$A[bp]
25019                                           ! Debug: func () void = write_word+0 (used reg = )
25020 72F1           E8         933E            call	_write_word
25021 72F4           83C4                   06  add	sp,*6
25022                                           !BCC_EOS
25023                                           ! 3796         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
25024                                           ! Debug: list int = const 0 (used reg = )
25025 72F7           31C0                       xor	ax,ax
25026 72F9           50                         push	ax
25027                                           ! Debug: list * unsigned short = const $250 (used reg = )
25028 72FA           B8                   0250  mov	ax,#$250
25029 72FD           50                         push	ax
25030                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25031 72FE           FF76         F6            push	-$A[bp]
25032                                           ! Debug: func () void = write_word+0 (used reg = )
25033 7301           E8         932E            call	_write_word
25034 7304           83C4                   06  add	sp,*6
25035                                           !BCC_EOS
25036                                           ! 3797         if (size >=0x42)
25037                                           ! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
25038 7307           8B46         DE            mov	ax,-$22[bp]
25039 730A           3D                   0042  cmp	ax,*$42
25040 730D           72           13            jb  	.553
25041                       0000730F            .554:
25042                                           ! 3798           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
25043                                           ! Debug: list int = const $11 (used reg = )
25044 730F           B8                   0011  mov	ax,*$11
25045 7312           50                         push	ax
25046                                           ! Debug: list * unsigned char = const $252 (used reg = )
25047 7313           B8                   0252  mov	ax,#$252
25048 7316           50                         push	ax
25049                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25050 7317           FF76         F6            push	-$A[bp]
25051                                           ! Debug: func () void = write_byte+0 (used reg = )
25052 731A           E8         92FD            call	_write_byte
25053 731D           83C4                   06  add	sp,*6
25054                                           !BCC_EOS
25055                                           ! 3799         else
25056                                           ! 3800           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
25057 7320           EB           11            jmp .555
25058                       00007322            .553:
25059                                           ! Debug: list int = const $10 (used reg = )
25060 7322           B8                   0010  mov	ax,*$10
25061 7325           50                         push	ax
25062                                           ! Debug: list * unsigned char = const $252 (used reg = )
25063 7326           B8                   0252  mov	ax,#$252
25064 7329           50                         push	ax
25065                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25066 732A           FF76         F6            push	-$A[bp]
25067                                           ! Debug: func () void = write_byte+0 (used reg = )
25068 732D           E8         92EA            call	_write_byte
25069 7330           83C4                   06  add	sp,*6
25070                                           !BCC_EOS
25071                                           ! 3801         checksum=0;
25072                       00007333            .555:
25073                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25074 7333           30C0                       xor	al,al
25075 7335           8846         D5            mov	-$2B[bp],al
25076                                           !BCC_EOS
25077                                           ! 3802         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
25078                                           ! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
25079 7338           30C0                       xor	al,al
25080 733A           8846         D4            mov	-$2C[bp],al
25081                                           !BCC_EOS
25082                                           !BCC_EOS
25083 733D           EB           24            jmp .558
25084                       0000733F            .559:
25085                                           ! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
25086 733F           8A46         D4            mov	al,-$2C[bp]
25087 7342           30E4                       xor	ah,ah
25088                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
25089 7344           05                   0244  add	ax,#$244
25090 7347           50                         push	ax
25091                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25092 7348           FF76         F6            push	-$A[bp]
25093                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25094 734B           E8         92A6            call	_read_byte
25095 734E           83C4                   04  add	sp,*4
25096                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25097 7351           30E4                       xor	ah,ah
25098 7353           0246         D5            add	al,-$2B[bp]
25099 7356           80D4                   00  adc	ah,*0
25100 7359           8846         D5            mov	-$2B[bp],al
25101                                           !BCC_EOS
25102                                           ! 3803         checksum = ~checksum;
25103                       0000735C            .557:
25104                                           ! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
25105 735C           8A46         D4            mov	al,-$2C[bp]
25106 735F           40                         inc	ax
25107 7360           8846         D4            mov	-$2C[bp],al
25108                       00007363            .558:
25109                                           ! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
25110 7363           8A46         D4            mov	al,-$2C[bp]
25111 7366           3C                     0F  cmp	al,*$F
25112 7368           72           D5            jb 	.559
25113                       0000736A            .55A:
25114                       0000736A            .556:
25115                                           ! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
25116 736A           8A46         D5            mov	al,-$2B[bp]
25117 736D           30E4                       xor	ah,ah
25118 736F           F7D0                       not	ax
25119                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25120 7371           8846         D5            mov	-$2B[bp],al
25121                                           !BCC_EOS
25122                                           ! 3804         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
25123                                           ! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
25124 7374           8A46         D5            mov	al,-$2B[bp]
25125 7377           30E4                       xor	ah,ah
25126 7379           50                         push	ax
25127                                           ! Debug: list * unsigned char = const $253 (used reg = )
25128 737A           B8                   0253  mov	ax,#$253
25129 737D           50                         push	ax
25130                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25131 737E           FF76         F6            push	-$A[bp]
25132                                           ! Debug: func () void = write_byte+0 (used reg = )
25133 7381           E8         9296            call	_write_byte
25134 7384           83C4                   06  add	sp,*6
25135                                           !BCC_EOS
25136                                           ! 3805         }
25137                                           ! 3806       if(size >= 0x42) {
25138                       00007387            .545:
25139                                           ! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
25140 7387           8B46         DE            mov	ax,-$22[bp]
25141 738A           3D                   0042  cmp	ax,*$42
25142 738D         0F82         023B            blo 	.55B
25143                       00007391            .55C:
25144                                           ! 3807         Bit8u channel, iface, checksum, i;
25145                                           !BCC_EOS
25146                                           ! 3808         Bit16u iobase1;
25147                                           !BCC_EOS
25148                                           ! 3809         channel = device / 2;
25149                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25150 7391           8A46         DB            mov	al,-$25[bp]
25151 7394           30E4                       xor	ah,ah
25152 7396           D1E8                       shr	ax,*1
25153                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
25154 7398           8846         D9            mov	-$27[bp],al
25155                                           !BCC_EOS
25156                                           ! 3810         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
25157                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25158 739B           8A46         D9            mov	al,-$27[bp]
25159 739E           30E4                       xor	ah,ah
25160 73A0           B1                     03  mov	cl,*3
25161 73A2           D3E0                       shl	ax,cl
25162 73A4           89C3                       mov	bx,ax
25163                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
25164                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
25165 73A6           81C3                 0122  add	bx,#$122
25166 73AA           53                         push	bx
25167                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25168 73AB           FF76         F6            push	-$A[bp]
25169                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25170 73AE           E8         9243            call	_read_byte
25171 73B1           83C4                   04  add	sp,*4
25172                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25173 73B4           8846         D8            mov	-$28[bp],al
25174                                           !BCC_EOS
25175                                           ! 3811         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25176                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25177 73B7           8A46         D9            mov	al,-$27[bp]
25178 73BA           30E4                       xor	ah,ah
25179 73BC           B1                     03  mov	cl,*3
25180 73BE           D3E0                       shl	ax,cl
25181 73C0           89C3                       mov	bx,ax
25182                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25183                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25184 73C2           81C3                 0124  add	bx,#$124
25185 73C6           53                         push	bx
25186                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25187 73C7           FF76         F6            push	-$A[bp]
25188                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25189 73CA           E8         923A            call	_read_word
25190 73CD           83C4                   04  add	sp,*4
25191                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25192 73D0           8946         D4            mov	-$2C[bp],ax
25193                                           !BCC_EOS
25194                                           ! 3812         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
25195                                           ! Debug: list int = const $42 (used reg = )
25196 73D3           B8                   0042  mov	ax,*$42
25197 73D6           50                         push	ax
25198                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
25199 73D7           8B46         0C            mov	ax,$C[bp]
25200                                           ! Debug: list unsigned int = ax+0 (used reg = )
25201 73DA           50                         push	ax
25202                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25203 73DB           FF76         06            push	6[bp]
25204                                           ! Debug: func () void = write_word+0 (used reg = )
25205 73DE           E8         9251            call	_write_word
25206 73E1           83C4                   06  add	sp,*6
25207                                           !BCC_EOS
25208                                           ! 3813         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
25209                                           ! Debug: list unsigned int = const $BEDD (used reg = )
25210 73E4           B8                   BEDD  mov	ax,#$BEDD
25211 73E7           50                         push	ax
25212                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
25213 73E8           8B46         0C            mov	ax,$C[bp]
25214                                           ! Debug: list unsigned int = ax+$1E (used reg = )
25215 73EB           05                   001E  add	ax,*$1E
25216 73EE           50                         push	ax
25217                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25218 73EF           FF76         06            push	6[bp]
25219                                           ! Debug: func () void = write_word+0 (used reg = )
25220 73F2           E8         923D            call	_write_word
25221 73F5           83C4                   06  add	sp,*6
25222                                           !BCC_EOS
25223                                           ! 3814         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
25224                                           ! Debug: list int = const $24 (used reg = )
25225 73F8           B8                   0024  mov	ax,*$24
25226 73FB           50                         push	ax
25227                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
25228 73FC           8B46         0C            mov	ax,$C[bp]
25229                                           ! Debug: list unsigned int = ax+$20 (used reg = )
25230 73FF           05                   0020  add	ax,*$20
25231 7402           50                         push	ax
25232                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25233 7403           FF76         06            push	6[bp]
25234                                           ! Debug: func () void = write_byte+0 (used reg = )
25235 7406           E8         9211            call	_write_byte
25236 7409           83C4                   06  add	sp,*6
25237                                           !BCC_EOS
25238                                           ! 3815         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
25239                                           ! Debug: list int = const 0 (used reg = )
25240 740C           31C0                       xor	ax,ax
25241 740E           50                         push	ax
25242                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
25243 740F           8B46         0C            mov	ax,$C[bp]
25244                                           ! Debug: list unsigned int = ax+$21 (used reg = )
25245 7412           05                   0021  add	ax,*$21
25246 7415           50                         push	ax
25247                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25248 7416           FF76         06            push	6[bp]
25249                                           ! Debug: func () void = write_byte+0 (used reg = )
25250 7419           E8         91FE            call	_write_byte
25251 741C           83C4                   06  add	sp,*6
25252                                           !BCC_EOS
25253                                           ! 3816         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
25254                                           ! Debug: list int = const 0 (used reg = )
25255 741F           31C0                       xor	ax,ax
25256 7421           50                         push	ax
25257                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
25258 7422           8B46         0C            mov	ax,$C[bp]
25259                                           ! Debug: list unsigned int = ax+$22 (used reg = )
25260 7425           05                   0022  add	ax,*$22
25261 7428           50                         push	ax
25262                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25263 7429           FF76         06            push	6[bp]
25264                                           ! Debug: func () void = write_word+0 (used reg = )
25265 742C           E8         9203            call	_write_word
25266 742F           83C4                   06  add	sp,*6
25267                                           !BCC_EOS
25268                                           ! 3817         if (iface==0x00) {
25269                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25270 7432           8A46         D8            mov	al,-$28[bp]
25271 7435           84C0                       test	al,al
25272 7437           75           51            jne 	.55D
25273                       00007439            .55E:
25274                                           ! 3818           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
25275                                           ! Debug: list int = const $49 (used reg = )
25276 7439           B8                   0049  mov	ax,*$49
25277 743C           50                         push	ax
25278                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
25279 743D           8B46         0C            mov	ax,$C[bp]
25280                                           ! Debug: list unsigned int = ax+$24 (used reg = )
25281 7440           05                   0024  add	ax,*$24
25282 7443           50                         push	ax
25283                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25284 7444           FF76         06            push	6[bp]
25285                                           ! Debug: func () void = write_byte+0 (used reg = )
25286 7447           E8         91D0            call	_write_byte
25287 744A           83C4                   06  add	sp,*6
25288                                           !BCC_EOS
25289                                           ! 3819           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
25290                                           ! Debug: list int = const $53 (used reg = )
25291 744D           B8                   0053  mov	ax,*$53
25292 7450           50                         push	ax
25293                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
25294 7451           8B46         0C            mov	ax,$C[bp]
25295                                           ! Debug: list unsigned int = ax+$25 (used reg = )
25296 7454           05                   0025  add	ax,*$25
25297 7457           50                         push	ax
25298                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25299 7458           FF76         06            push	6[bp]
25300                                           ! Debug: func () void = write_byte+0 (used reg = )
25301 745B           E8         91BC            call	_write_byte
25302 745E           83C4                   06  add	sp,*6
25303                                           !BCC_EOS
25304                                           ! 3820           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
25305                                           ! Debug: list int = const $41 (used reg = )
25306 7461           B8                   0041  mov	ax,*$41
25307 7464           50                         push	ax
25308                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
25309 7465           8B46         0C            mov	ax,$C[bp]
25310                                           ! Debug: list unsigned int = ax+$26 (used reg = )
25311 7468           05                   0026  add	ax,*$26
25312 746B           50                         push	ax
25313                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25314 746C           FF76         06            push	6[bp]
25315                                           ! Debug: func () void = write_byte+0 (used reg = )
25316 746F           E8         91A8            call	_write_byte
25317 7472           83C4                   06  add	sp,*6
25318                                           !BCC_EOS
25319                                           ! 3821           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 
25320                                           ! 3821 0);
25321                                           ! Debug: list int = const 0 (used reg = )
25322 7475           31C0                       xor	ax,ax
25323 7477           50                         push	ax
25324                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
25325 7478           8B46         0C            mov	ax,$C[bp]
25326                                           ! Debug: list unsigned int = ax+$27 (used reg = )
25327 747B           05                   0027  add	ax,*$27
25328 747E           50                         push	ax
25329                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25330 747F           FF76         06            push	6[bp]
25331                                           ! Debug: func () void = write_byte+0 (used reg = )
25332 7482           E8         9195            call	_write_byte
25333 7485           83C4                   06  add	sp,*6
25334                                           !BCC_EOS
25335                                           ! 3822           }
25336                                           ! 3823         else {
25337 7488           EB           00            jmp .55F
25338                       0000748A            .55D:
25339                                           ! 3824           }
25340                                           ! 3825         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
25341                       0000748A            .55F:
25342                                           ! Debug: list int = const $41 (used reg = )
25343 748A           B8                   0041  mov	ax,*$41
25344 748D           50                         push	ax
25345                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
25346 748E           8B46         0C            mov	ax,$C[bp]
25347                                           ! Debug: list unsigned int = ax+$28 (used reg = )
25348 7491           05                   0028  add	ax,*$28
25349 7494           50                         push	ax
25350                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25351 7495           FF76         06            push	6[bp]
25352                                           ! Debug: func () void = write_byte+0 (used reg = )
25353 7498           E8         917F            call	_write_byte
25354 749B           83C4                   06  add	sp,*6
25355                                           !BCC_EOS
25356                                           ! 3826         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
25357                                           ! Debug: list int = const $54 (used reg = )
25358 749E           B8                   0054  mov	ax,*$54
25359 74A1           50                         push	ax
25360                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
25361 74A2           8B46         0C            mov	ax,$C[bp]
25362                                           ! Debug: list unsigned int = ax+$29 (used reg = )
25363 74A5           05                   0029  add	ax,*$29
25364 74A8           50                         push	ax
25365                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25366 74A9           FF76         06            push	6[bp]
25367                                           ! Debug: func () void = write_byte+0 (used reg = )
25368 74AC           E8         916B            call	_write_byte
25369 74AF           83C4                   06  add	sp,*6
25370                                           !BCC_EOS
25371                                           ! 3827         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
25372                                           ! Debug: list int = const $41 (used reg = )
25373 74B2           B8                   0041  mov	ax,*$41
25374 74B5           50                         push	ax
25375                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
25376 74B6           8B46         0C            mov	ax,$C[bp]
25377                                           ! Debug: list unsigned int = ax+$2A (used reg = )
25378 74B9           05                   002A  add	ax,*$2A
25379 74BC           50                         push	ax
25380                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25381 74BD           FF76         06            push	6[bp]
25382                                           ! Debug: func () void = write_byte+0 (used reg = )
25383 74C0           E8         9157            call	_write_byte
25384 74C3           83C4                   06  add	sp,*6
25385                                           !BCC_EOS
25386                                           ! 3828         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
25387                                           ! Debug: list int = const 0 (used reg = )
25388 74C6           31C0                       xor	ax,ax
25389 74C8           50                         push	ax
25390                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
25391 74C9           8B46         0C            mov	ax,$C[bp]
25392                                           ! Debug: list unsigned int = ax+$2B (used reg = )
25393 74CC           05                   002B  add	ax,*$2B
25394 74CF           50                         push	ax
25395                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25396 74D0           FF76         06            push	6[bp]
25397                                           ! Debug: func () void = write_byte+0 (used reg = )
25398 74D3           E8         9144            call	_write_byte
25399 74D6           83C4                   06  add	sp,*6
25400                                           !BCC_EOS
25401                                           ! 3829         if (iface==0x00) {
25402                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25403 74D9           8A46         D8            mov	al,-$28[bp]
25404 74DC           84C0                       test	al,al
25405 74DE           75           3E            jne 	.560
25406                       000074E0            .561:
25407                                           ! 3830           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
25408                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25409 74E0           FF76         D4            push	-$2C[bp]
25410                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
25411 74E3           8B46         0C            mov	ax,$C[bp]
25412                                           ! Debug: list unsigned int = ax+$30 (used reg = )
25413 74E6           05                   0030  add	ax,*$30
25414 74E9           50                         push	ax
25415                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25416 74EA           FF76         06            push	6[bp]
25417                                           ! Debug: func () void = write_word+0 (used reg = )
25418 74ED           E8         9142            call	_write_word
25419 74F0           83C4                   06  add	sp,*6
25420                                           !BCC_EOS
25421                                           ! 3831           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
25422                                           ! Debug: list int = const 0 (used reg = )
25423 74F3           31C0                       xor	ax,ax
25424 74F5           50                         push	ax
25425                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
25426 74F6           8B46         0C            mov	ax,$C[bp]
25427                                           ! Debug: list unsigned int = ax+$32 (used reg = )
25428 74F9           05                   0032  add	ax,*$32
25429 74FC           50                         push	ax
25430                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25431 74FD           FF76         06            push	6[bp]
25432                                           ! Debug: func () void = write_word+0 (used reg = )
25433 7500           E8         912F            call	_write_word
25434 7503           83C4                   06  add	sp,*6
25435                                           !BCC_EOS
25436                                           ! 3832           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
25437                                           ! Debug: list long = const 0 (used reg = )
25438 7506           31C0                       xor	ax,ax
25439 7508           31DB                       xor	bx,bx
25440 750A           53                         push	bx
25441 750B           50                         push	ax
25442                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
25443 750C           8B46         0C            mov	ax,$C[bp]
25444                                           ! Debug: list unsigned int = ax+$34 (used reg = )
25445 750F           05                   0034  add	ax,*$34
25446 7512           50                         push	ax
25447                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
25448 7513           FF76         06            push	6[bp]
25449                                           ! Debug: func () void = write_dword+0 (used reg = )
25450 7516           E8         8B82            call	_write_dword
25451 7519           83C4                   08  add	sp,*8
25452                                           !BCC_EOS
25453                                           ! 3833           }
25454                                           ! 3834         else {
25455 751C           EB           00            jmp .562
25456                       0000751E            .560:
25457                                           ! 3835           }
25458                                           ! 3836         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
25459                       0000751E            .562:
25460                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25461 751E           8A46         DB            mov	al,-$25[bp]
25462 7521           30E4                       xor	ah,ah
25463 7523           24                     01  and	al,*1
25464                                           ! Debug: list unsigned char = al+0 (used reg = )
25465 7525           30E4                       xor	ah,ah
25466 7527           50                         push	ax
25467                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
25468 7528           8B46         0C            mov	ax,$C[bp]
25469                                           ! Debug: list unsigned int = ax+$38 (used reg = )
25470 752B           05                   0038  add	ax,*$38
25471 752E           50                         push	ax
25472                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25473 752F           FF76         06            push	6[bp]
25474                                           ! Debug: func () void = write_byte+0 (used reg = )
25475 7532           E8         90E5            call	_write_byte
25476 7535           83C4                   06  add	sp,*6
25477                                           !BCC_EOS
25478                                           ! 3837         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
25479                                           ! Debug: list int = const 0 (used reg = )
25480 7538           31C0                       xor	ax,ax
25481 753A           50                         push	ax
25482                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
25483 753B           8B46         0C            mov	ax,$C[bp]
25484                                           ! Debug: list unsigned int = ax+$39 (used reg = )
25485 753E           05                   0039  add	ax,*$39
25486 7541           50                         push	ax
25487                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25488 7542           FF76         06            push	6[bp]
25489                                           ! Debug: func () void = write_byte+0 (used reg = )
25490 7545           E8         90D2            call	_write_byte
25491 7548           83C4                   06  add	sp,*6
25492                                           !BCC_EOS
25493                                           ! 3838         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
25494                                           ! Debug: list int = const 0 (used reg = )
25495 754B           31C0                       xor	ax,ax
25496 754D           50                         push	ax
25497                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
25498 754E           8B46         0C            mov	ax,$C[bp]
25499                                           ! Debug: list unsigned int = ax+$3A (used reg = )
25500 7551           05                   003A  add	ax,*$3A
25501 7554           50                         push	ax
25502                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25503 7555           FF76         06            push	6[bp]
25504                                           ! Debug: func () void = write_word+0 (used reg = )
25505 7558           E8         90D7            call	_write_word
25506 755B           83C4                   06  add	sp,*6
25507                                           !BCC_EOS
25508                                           ! 3839         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
25509                                           ! Debug: list long = const 0 (used reg = )
25510 755E           31C0                       xor	ax,ax
25511 7560           31DB                       xor	bx,bx
25512 7562           53                         push	bx
25513 7563           50                         push	ax
25514                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
25515 7564           8B46         0C            mov	ax,$C[bp]
25516                                           ! Debug: list unsigned int = ax+$3C (used reg = )
25517 7567           05                   003C  add	ax,*$3C
25518 756A           50                         push	ax
25519                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
25520 756B           FF76         06            push	6[bp]
25521                                           ! Debug: func () void = write_dword+0 (used reg = )
25522 756E           E8         8B2A            call	_write_dword
25523 7571           83C4                   08  add	sp,*8
25524                                           !BCC_EOS
25525                                           ! 3840         checksum=0;
25526                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25527 7574           30C0                       xor	al,al
25528 7576           8846         D7            mov	-$29[bp],al
25529                                           !BCC_EOS
25530                                           ! 3841         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
25531                                           ! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
25532 7579           B0                     1E  mov	al,*$1E
25533 757B           8846         D6            mov	-$2A[bp],al
25534                                           !BCC_EOS
25535                                           !BCC_EOS
25536 757E           EB           25            jmp .565
25537                       00007580            .566:
25538                                           ! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
25539 7580           8B46         0C            mov	ax,$C[bp]
25540 7583           0246         D6            add	al,-$2A[bp]
25541 7586           80D4                   00  adc	ah,*0
25542                                           ! Debug: list unsigned int = ax+0 (used reg = )
25543 7589           50                         push	ax
25544                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25545 758A           FF76         06            push	6[bp]
25546                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25547 758D           E8         9064            call	_read_byte
25548 7590           83C4                   04  add	sp,*4
25549                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25550 7593           30E4                       xor	ah,ah
25551 7595           0246         D7            add	al,-$29[bp]
25552 7598           80D4                   00  adc	ah,*0
25553 759B           8846         D7            mov	-$29[bp],al
25554                                           !BCC_EOS
25555                                           ! 3842         checksum = ~checksum;
25556                       0000759E            .564:
25557                                           ! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
25558 759E           8A46         D6            mov	al,-$2A[bp]
25559 75A1           40                         inc	ax
25560 75A2           8846         D6            mov	-$2A[bp],al
25561                       000075A5            .565:
25562                                           ! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
25563 75A5           8A46         D6            mov	al,-$2A[bp]
25564 75A8           3C                     40  cmp	al,*$40
25565 75AA           72           D4            jb 	.566
25566                       000075AC            .567:
25567                       000075AC            .563:
25568                                           ! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
25569 75AC           8A46         D7            mov	al,-$29[bp]
25570 75AF           30E4                       xor	ah,ah
25571 75B1           F7D0                       not	ax
25572                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25573 75B3           8846         D7            mov	-$29[bp],al
25574                                           !BCC_EOS
25575                                           ! 3843         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
25576                                           ! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
25577 75B6           8A46         D7            mov	al,-$29[bp]
25578 75B9           30E4                       xor	ah,ah
25579 75BB           50                         push	ax
25580                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
25581 75BC           8B46         0C            mov	ax,$C[bp]
25582                                           ! Debug: list unsigned int = ax+$41 (used reg = )
25583 75BF           05                   0041  add	ax,*$41
25584 75C2           50                         push	ax
25585                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25586 75C3           FF76         06            push	6[bp]
25587                                           ! Debug: func () void = write_byte+0 (used reg = )
25588 75C6           E8         9051            call	_write_byte
25589 75C9           83C4                   06  add	sp,*6
25590                                           !BCC_EOS
25591                                           ! 3844         }
25592                                           ! 3845       goto int13_success;
25593                       000075CC            .55B:
25594 75CC           83C4                   0E  add	sp,#..FFEF-..FFF0
25595 75CF           E9         00EF            br 	.FFEF
25596                                           !BCC_EOS
25597                                           ! 3846       break;
25598 75D2           E9         00BC            br 	.500
25599                                           !BCC_EOS
25600                                           ! 3847     case 0x4e:
25601                                           ! 3848       switch (( AX & 0x00ff )) {
25602                       000075D5            .568:
25603                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25604 75D5           8A46         18            mov	al,$18[bp]
25605 75D8           EB           10            jmp .56B
25606                                           ! 3849         case 0x01:
25607                                           ! 3850         case 0x03:
25608                       000075DA            .56C:
25609                                           ! 3851         case 0x04:
25610                       000075DA            .56D:
25611                                           ! 3852         case 0x06:
25612                       000075DA            .56E:
25613                                           ! 3853           goto int13_success;
25614                       000075DA            .56F:
25615 75DA           83C4                   0E  add	sp,#..FFEF-..FFF0
25616 75DD           E9         00E1            br 	.FFEF
25617                                           !BCC_EOS
25618                                           ! 3854           break;
25619 75E0           EB           1A            jmp .569
25620                                           !BCC_EOS
25621                                           ! 3855         default :
25622                                           ! 3856           goto int13_fail;
25623                       000075E2            .570:
25624 75E2           83C4                   0E  add	sp,#..FFF1-..FFF0
25625 75E5           E9         00AC            br 	.FFF1
25626                                           !BCC_EOS
25627                                           ! 3857         }
25628                                           ! 3858       break;
25629 75E8           EB           12            jmp .569
25630                       000075EA            .56B:
25631 75EA           2C                     01  sub	al,*1
25632 75EC           74           EC            je 	.56C
25633 75EE           2C                     02  sub	al,*2
25634 75F0           74           E8            je 	.56D
25635 75F2           2C                     01  sub	al,*1
25636 75F4           74           E4            je 	.56E
25637 75F6           2C                     02  sub	al,*2
25638 75F8           74           E0            je 	.56F
25639 75FA           EB           E6            jmp	.570
25640                       000075FC            .569:
25641 75FC           E9         0092            br 	.500
25642                                           !BCC_EOS
25643                                           ! 3859     case 0x09:
25644                                           ! 3860     case 0x0c:
25645                       000075FF            .571:
25646                                           ! 3861     case 0x0d:
25647                       000075FF            .572:
25648                                           ! 3862     case 0x11:
25649                       000075FF            .573:
25650                                           ! 3863     case 0x14:
25651                       000075FF            .574:
25652                                           ! 3864       ;
25653                       000075FF            .575:
25654                                           !BCC_EOS
25655                                           ! 3865       goto int13_success;
25656 75FF           83C4                   0E  add	sp,#..FFEF-..FFF0
25657 7602           E9         00BC            br 	.FFEF
25658                                           !BCC_EOS
25659                                           ! 3866       break;
25660 7605           E9         0089            br 	.500
25661                                           !BCC_EOS
25662                                           ! 3867     case 0x0a:
25663                                           ! 3868     case 0x0b:
25664                       00007608            .576:
25665                                           ! 3869     case 0x18:
25666                       00007608            .577:
25667                                           ! 3870     case 0x50:
25668                       00007608            .578:
25669                                           ! 3871     default:
25670                       00007608            .579:
25671                                           ! 3872       ;
25672                       00007608            .57A:
25673                                           !BCC_EOS
25674                                           ! 3873       goto int13_fail;
25675 7608           83C4                   0E  add	sp,#..FFF1-..FFF0
25676 760B           E9         0086            br 	.FFF1
25677                                           !BCC_EOS
25678                                           ! 3874       break;
25679 760E           E9         0080            br 	.500
25680                                           !BCC_EOS
25681                                           ! 3875     }
25682                                           ! 3876 int13_fail:
25683 7611           EB           7E            jmp .500
25684                       00007613            .502:
25685 7613           83C4                   F2  add	sp,*-$E
25686 7616           2D                   0000  sub	ax,*0
25687 7619           7C           ED            jl 	.57A
25688 761B           3D                   0018  cmp	ax,*$18
25689 761E           77           3B            ja  	.57B
25690 7620           D1E0                       shl	ax,*1
25691 7622           89C3                       mov	bx,ax
25692 7624           2E                         seg	cs
25693 7625           FFA7       7629            br	.57C[bx]
25694                       00007629            .57C:
25695 7629                      6875            .word	.503
25696 762B                      6889            .word	.504
25697 762D                      68DA            .word	.508
25698 762F                      68DA            .word	.509
25699 7631                      68DA            .word	.50A
25700 7633                      6B29            .word	.51D
25701 7635                      7608            .word	.57A
25702 7637                      7608            .word	.57A
25703 7639                      6B36            .word	.51E
25704 763B                      75FF            .word	.571
25705 763D                      7608            .word	.576
25706 763F                      7608            .word	.577
25707 7641                      75FF            .word	.572
25708 7643                      75FF            .word	.573
25709 7645                      7608            .word	.57A
25710 7647                      7608            .word	.57A
25711 7649                      6C14            .word	.51F
25712 764B                      75FF            .word	.574
25713 764D                      7608            .word	.57A
25714 764F                      7608            .word	.57A
25715 7651                      75FF            .word	.575
25716 7653                      6C60            .word	.523
25717 7655                      7608            .word	.57A
25718 7657                      7608            .word	.57A
25719 7659                      7608            .word	.578
25720                       0000765B            .57B:
25721 765B           2D                   0041  sub	ax,*$41
25722 765E           72           A8            jb 	.57A
25723 7660           3D                   000F  cmp	ax,*$F
25724 7663           77           29            ja  	.57D
25725 7665           D1E0                       shl	ax,*1
25726 7667           89C3                       mov	bx,ax
25727 7669           2E                         seg	cs
25728 766A           FFA7       766E            br	.57E[bx]
25729                       0000766E            .57E:
25730 766E                      6D11            .word	.524
25731 7670                      6D31            .word	.525
25732 7672                      6D31            .word	.526
25733 7674                      6D31            .word	.527
25734 7676                      6EE2            .word	.536
25735 7678                      6EEB            .word	.538
25736 767A                      6D31            .word	.528
25737 767C                      6EFF            .word	.539
25738 767E                      6EE2            .word	.537
25739 7680                      7608            .word	.57A
25740 7682                      7608            .word	.57A
25741 7684                      7608            .word	.57A
25742 7686                      7608            .word	.57A
25743 7688                      75D5            .word	.568
25744 768A                      7608            .word	.57A
25745 768C                      7608            .word	.579
25746                       0000768E            .57D:
25747 768E           E9         FF77            br 	.57A
25748                       00007691            .500:
25749                       FFFFFFCA            ..FFF0	=	-$36
25750 7691           83C4                   0E  add	sp,*$E
25751                       00007694            .FFF1:
25752                       FFFFFFD8            ..FFF1	=	-$28
25753                                           ! 3877     AX = ((AX & 0x00ff) | ((0x01) << 8));
25754                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25755 7694           8A46         18            mov	al,$18[bp]
25756                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
25757 7697           30E4                       xor	ah,ah
25758 7699           0D                   0100  or	ax,#$100
25759                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
25760 769C           8946         18            mov	$18[bp],ax
25761                                           !BCC_EOS
25762                                           ! 3878 int13_fail_noah:
25763                       0000769F            .FFEC:
25764                       FFFFFFD8            ..FFEC	=	-$28
25765                                           ! 3879     write_byte(0x0040, 0x0074, ( AX >> 8 ));
25766                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
25767 769F           8B46         18            mov	ax,$18[bp]
25768 76A2           88E0                       mov	al,ah
25769 76A4           30E4                       xor	ah,ah
25770                                           ! Debug: list unsigned int = ax+0 (used reg = )
25771 76A6           50                         push	ax
25772                                           ! Debug: list int = const $74 (used reg = )
25773 76A7           B8                   0074  mov	ax,*$74
25774 76AA           50                         push	ax
25775                                           ! Debug: list int = const $40 (used reg = )
25776 76AB           B8                   0040  mov	ax,*$40
25777 76AE           50                         push	ax
25778                                           ! Debug: func () void = write_byte+0 (used reg = )
25779 76AF           E8         8F68            call	_write_byte
25780 76B2           83C4                   06  add	sp,*6
25781                                           !BCC_EOS
25782                                           ! 3880 int13_fail_nostatus:
25783                       000076B5            .FFEE:
25784                       FFFFFFD8            ..FFEE	=	-$28
25785                                           ! 3881     FLAGS |= 0x0001;
25786                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
25787 76B5           8B46         1E            mov	ax,$1E[bp]
25788 76B8           0C                     01  or	al,*1
25789 76BA           8946         1E            mov	$1E[bp],ax
25790                                           !BCC_EOS
25791                                           ! 3882     return;
25792 76BD           89EC                       mov	sp,bp
25793 76BF           5D                         pop	bp
25794 76C0           C3                         ret
25795                                           !BCC_EOS
25796                                           ! 3883 int13_success:
25797                       000076C1            .FFEF:
25798                       FFFFFFD8            ..FFEF	=	-$28
25799                                           ! 3884     AX = ((AX & 0x00ff) | ((0x00) << 8));
25800                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25801 76C1           8A46         18            mov	al,$18[bp]
25802                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
25803 76C4           0C                     00  or	al,*0
25804                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
25805 76C6           30E4                       xor	ah,ah
25806 76C8           8946         18            mov	$18[bp],ax
25807                                           !BCC_EOS
25808                                           ! 3885 int13_success_noah:
25809                       000076CB            .FFED:
25810                       FFFFFFD8            ..FFED	=	-$28
25811                                           ! 3886     write_byte(0x0040, 0x0074, 0x00);
25812                                           ! Debug: list int = const 0 (used reg = )
25813 76CB           31C0                       xor	ax,ax
25814 76CD           50                         push	ax
25815                                           ! Debug: list int = const $74 (used reg = )
25816 76CE           B8                   0074  mov	ax,*$74
25817 76D1           50                         push	ax
25818                                           ! Debug: list int = const $40 (used reg = )
25819 76D2           B8                   0040  mov	ax,*$40
25820 76D5           50                         push	ax
25821                                           ! Debug: func () void = write_byte+0 (used reg = )
25822 76D6           E8         8F41            call	_write_byte
25823 76D9           83C4                   06  add	sp,*6
25824                                           !BCC_EOS
25825                                           ! 3887     FLAGS &= 0xfffe;
25826                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
25827 76DC           8B46         1E            mov	ax,$1E[bp]
25828 76DF           24                     FE  and	al,#$FE
25829 76E1           8946         1E            mov	$1E[bp],ax
25830                                           !BCC_EOS
25831                                           ! 3888     return;
25832 76E4           89EC                       mov	sp,bp
25833 76E6           5D                         pop	bp
25834 76E7           C3                         ret
25835                                           !BCC_EOS
25836                                           ! 3889 }
25837                                           ! 3890   void
25838                                           ! Register BX used in function int13_harddisk
25839                                           ! 3891 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
25840                                           ! 3892   Bit16u EHBX, DS, ES, DI, S
25841                                           export	_int13_cdrom
25842                       000076E8            _int13_cdrom:
25843                                           ! 3892 I, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
25844                                           !BCC_EOS
25845                                           ! 3893 {
25846                                           ! 3894   Bit16u ebda_seg=read_word(0x0040,0x000E);
25847 76E8           55                         push	bp
25848 76E9           89E5                       mov	bp,sp
25849 76EB           4C                         dec	sp
25850 76EC           4C                         dec	sp
25851                                           ! Debug: list int = const $E (used reg = )
25852 76ED           B8                   000E  mov	ax,*$E
25853 76F0           50                         push	ax
25854                                           ! Debug: list int = const $40 (used reg = )
25855 76F1           B8                   0040  mov	ax,*$40
25856 76F4           50                         push	ax
25857                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25858 76F5           E8         8F0F            call	_read_word
25859 76F8           83C4                   04  add	sp,*4
25860                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
25861 76FB           8946         FE            mov	-2[bp],ax
25862                                           !BCC_EOS
25863                                           ! 3895   Bit8u device, status, locks;
25864                                           !BCC_EOS
25865                                           ! 3896   Bit8u atacmd[12];
25866                                           !BCC_EOS
25867                                           ! 3897   Bit32u lba;
25868                                           !BCC_EOS
25869                                           ! 3898   Bit16u count, segment, offset, i, size;
25870                                           !BCC_EOS
25871                                           ! 3899   ;
25872 76FE           83C4                   E2  add	sp,*-$1E
25873                                           !BCC_EOS
25874                                           ! 3900   write_byte(0x0040, 0x0074, 0x00);
25875                                           ! Debug: list int = const 0 (used reg = )
25876 7701           31C0                       xor	ax,ax
25877 7703           50                         push	ax
25878                                           ! Debug: list int = const $74 (used reg = )
25879 7704           B8                   0074  mov	ax,*$74
25880 7707           50                         push	ax
25881                                           ! Debug: list int = const $40 (used reg = )
25882 7708           B8                   0040  mov	ax,*$40
25883 770B           50                         push	ax
25884                                           ! Debug: func () void = write_byte+0 (used reg = )
25885 770C           E8         8F0B            call	_write_byte
25886 770F           83C4                   06  add	sp,*6
25887                                           !BCC_EOS
25888                                           ! 3901   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
25889                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25890 7712           8A46         10            mov	al,$10[bp]
25891                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
25892 7715           3C                     E0  cmp	al,#$E0
25893 7717           72           07            jb  	.580
25894                       00007719            .581:
25895                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25896 7719           8A46         10            mov	al,$10[bp]
25897                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
25898 771C           3C                     E8  cmp	al,#$E8
25899 771E           72           06            jb  	.57F
25900                       00007720            .580:
25901                                           ! 3902     ;
25902                                           !BCC_EOS
25903                                           ! 3903     goto int13_fail;
25904 7720           83C4                   00  add	sp,#..FFEB+$22
25905 7723           E9         0A33            br 	.FFEB
25906                                           !BCC_EOS
25907                                           ! 3904     }
25908                                           ! 3905   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
25909                       00007726            .57F:
25910                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25911 7726           8A46         10            mov	al,$10[bp]
25912                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
25913 7729           30E4                       xor	ah,ah
25914                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
25915 772B           05                   FF20  add	ax,#-$E0
25916 772E           89C3                       mov	bx,ax
25917                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
25918                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
25919 7730           81C3                 023C  add	bx,#$23C
25920 7734           53                         push	bx
25921                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
25922 7735           FF76         FE            push	-2[bp]
25923                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25924 7738           E8         8EB9            call	_read_byte
25925 773B           83C4                   04  add	sp,*4
25926                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
25927 773E           8846         FD            mov	-3[bp],al
25928                                           !BCC_EOS
25929                                           ! 3906   if (device >= (4*2)) {
25930                                           ! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
25931 7741           8A46         FD            mov	al,-3[bp]
25932 7744           3C                     08  cmp	al,*8
25933 7746           72           06            jb  	.582
25934                       00007748            .583:
25935                                           ! 3907     ;
25936                                           !BCC_EOS
25937                                           ! 3908     goto int13_fail;
25938 7748           83C4                   00  add	sp,#..FFEB+$22
25939 774B           E9         0A0B            br 	.FFEB
25940                                           !BCC_EOS
25941                                           ! 3909     }
25942                                           ! 3910   switch (( AX >> 8 )) {
25943                       0000774E            .582:
25944                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
25945 774E           8B46         18            mov	ax,$18[bp]
25946 7751           88E0                       mov	al,ah
25947 7753           30E4                       xor	ah,ah
25948 7755           E9         0980            br 	.586
25949                                           ! 3911     case 0x00:
25950                                           ! 3912     case 0x09:
25951                       00007758            .587:
25952                                           ! 3913     case 0x0c:
25953                       00007758            .588:
25954                                           ! 3914     case 0x0d:
25955                       00007758            .589:
25956                                           ! 3915     case 0x10:
25957                       00007758            .58A:
25958                                           ! 3916     case 0x11:
25959                       00007758            .58B:
25960                                           ! 3917     case 0x14:
25961                       00007758            .58C:
25962                                           ! 3918     case 0x16:
25963                       00007758            .58D:
25964                                           ! 3919       goto int13_success;
25965                       00007758            .58E:
25966 7758           83C4                   0C  add	sp,#..FFE9-..FFEA
25967 775B           E9         0A28            br 	.FFE9
25968                                           !BCC_EOS
25969                                           ! 3920       break;
25970 775E           E9         09F5            br 	.584
25971                                           !BCC_EOS
25972                                           ! 3921     case 0x03:
25973                                           ! 3922     case 0x05:
25974                       00007761            .58F:
25975                                           ! 3923     case 0x43:
25976                       00007761            .590:
25977                                           ! 3924       AX = ((AX & 0x00ff) | ((0x03) << 8));
25978                       00007761            .591:
25979                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
25980 7761           8A46         18            mov	al,$18[bp]
25981                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
25982 7764           30E4                       xor	ah,ah
25983 7766           0D                   0300  or	ax,#$300
25984                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
25985 7769           8946         18            mov	$18[bp],ax
25986                                           !BCC_EOS
25987                                           ! 3925       goto int13_fail_noah;
25988 776C           83C4                   0C  add	sp,#..FFE8-..FFEA
25989 776F           E9         09F2            br 	.FFE8
25990                                           !BCC_EOS
25991                                           ! 3926       break;
25992 7772           E9         09E1            br 	.584
25993                                           !BCC_EOS
25994                                           ! 3927     case 0x01:
25995                                           ! 3928       status = read_byte(0x0040, 0x0074);
25996                       00007775            .592:
25997                                           ! Debug: list int = const $74 (used reg = )
25998 7775           B8                   0074  mov	ax,*$74
25999 7778           50                         push	ax
26000                                           ! Debug: list int = const $40 (used reg = )
26001 7779           B8                   0040  mov	ax,*$40
26002 777C           50                         push	ax
26003                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26004 777D           E8         8E74            call	_read_byte
26005 7780           83C4                   04  add	sp,*4
26006                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
26007 7783           8846         FC            mov	-4[bp],al
26008                                           !BCC_EOS
26009                                           ! 3929       AX = ((AX & 0x00ff) | ((status) << 8));
26010                                           ! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
26011 7786           8A46         FC            mov	al,-4[bp]
26012 7789           30E4                       xor	ah,ah
26013 778B           88C4                       mov	ah,al
26014 778D           30C0                       xor	al,al
26015 778F           50                         push	ax
26016                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
26017 7790           8A46         18            mov	al,$18[bp]
26018                                           ! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
26019 7793           30E4                       xor	ah,ah
26020 7795           0B46         D2            or	ax,0+..FFEA[bp]
26021 7798           44                         inc	sp
26022 7799           44                         inc	sp
26023                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26024 779A           8946         18            mov	$18[bp],ax
26025                                           !BCC_EOS
26026                                           ! 3930       write_byte(0x0040, 0x0074, 0);
26027                                           ! Debug: list int = const 0 (used reg = )
26028 779D           31C0                       xor	ax,ax
26029 779F           50                         push	ax
26030                                           ! Debug: list int = const $74 (used reg = )
26031 77A0           B8                   0074  mov	ax,*$74
26032 77A3           50                         push	ax
26033                                           ! Debug: list int = const $40 (used reg = )
26034 77A4           B8                   0040  mov	ax,*$40
26035 77A7           50                         push	ax
26036                                           ! Debug: func () void = write_byte+0 (used reg = )
26037 77A8           E8         8E6F            call	_write_byte
26038 77AB           83C4                   06  add	sp,*6
26039                                           !BCC_EOS
26040                                           ! 3931       if (status) goto int13_fail_nostatus;
26041 77AE           8A46         FC            mov	al,-4[bp]
26042 77B1           84C0                       test	al,al
26043 77B3           74           08            je  	.593
26044                       000077B5            .594:
26045 77B5           83C4                   0C  add	sp,#..FFE7-..FFEA
26046 77B8           E9         09BF            br 	.FFE7
26047                                           !BCC_EOS
26048                                           ! 3932       else goto int13_success_noah;
26049 77BB           EB           06            jmp .595
26050                       000077BD            .593:
26051 77BD           83C4                   0C  add	sp,#..FFE6-..FFEA
26052 77C0           E9         09CD            br 	.FFE6
26053                                           !BCC_EOS
26054                                           ! 3933       break;
26055                       000077C3            .595:
26056 77C3           E9         0990            br 	.584
26057                                           !BCC_EOS
26058                                           ! 3934     case 0x15:
26059                                           ! 3935       AX = ((AX & 0x00ff) | ((0x02) << 8));
26060                       000077C6            .596:
26061                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26062 77C6           8A46         18            mov	al,$18[bp]
26063                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
26064 77C9           30E4                       xor	ah,ah
26065 77CB           0D                   0200  or	ax,#$200
26066                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26067 77CE           8946         18            mov	$18[bp],ax
26068                                           !BCC_EOS
26069                                           ! 3936       goto int13_fail_noah;
26070 77D1           83C4                   0C  add	sp,#..FFE8-..FFEA
26071 77D4           E9         098D            br 	.FFE8
26072                                           !BCC_EOS
26073                                           ! 3937       break;
26074 77D7           E9         097C            br 	.584
26075                                           !BCC_EOS
26076                                           ! 3938     case 0x41:
26077                                           ! 3939       BX=0xaa55;
26078                       000077DA            .597:
26079                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
26080 77DA           B8                   AA55  mov	ax,#$AA55
26081 77DD           8946         12            mov	$12[bp],ax
26082                                           !BCC_EOS
26083                                           ! 3940       AX = ((AX & 0x00ff) | ((0x30) << 8));
26084                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26085 77E0           8A46         18            mov	al,$18[bp]
26086                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
26087 77E3           30E4                       xor	ah,ah
26088 77E5           0D                   3000  or	ax,#$3000
26089                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26090 77E8           8946         18            mov	$18[bp],ax
26091                                           !BCC_EOS
26092                                           ! 3941       CX=0x0007;
26093                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
26094 77EB           B8                   0007  mov	ax,*7
26095 77EE           8946         16            mov	$16[bp],ax
26096                                           !BCC_EOS
26097                                           ! 3942       goto int13_success_noah;
26098 77F1           83C4                   0C  add	sp,#..FFE6-..FFEA
26099 77F4           E9         0999            br 	.FFE6
26100                                           !BCC_EOS
26101                                           ! 3943       break;
26102 77F7           E9         095C            br 	.584
26103                                           !BCC_EOS
26104                                           ! 3944     case 0x42:
26105                                           ! 3945     case 0x44:
26106                       000077FA            .598:
26107                                           ! 3946     case 0x47:
26108                       000077FA            .599:
26109                                           ! 3947       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
26110                       000077FA            .59A:
26111                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
26112 77FA           8B46         0C            mov	ax,$C[bp]
26113                                           ! Debug: list unsigned int = ax+2 (used reg = )
26114 77FD           40                         inc	ax
26115 77FE           40                         inc	ax
26116 77FF           50                         push	ax
26117                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26118 7800           FF76         06            push	6[bp]
26119                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26120 7803           E8         8E01            call	_read_word
26121 7806           83C4                   04  add	sp,*4
26122                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26123 7809           8946         E8            mov	-$18[bp],ax
26124                                           !BCC_EOS
26125                                           ! 3948       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
26126                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
26127 780C           8B46         0C            mov	ax,$C[bp]
26128                                           ! Debug: list unsigned int = ax+6 (used reg = )
26129 780F           05                   0006  add	ax,*6
26130 7812           50                         push	ax
26131                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26132 7813           FF76         06            push	6[bp]
26133                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26134 7816           E8         8DEE            call	_read_word
26135 7819           83C4                   04  add	sp,*4
26136                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
26137 781C           8946         E6            mov	-$1A[bp],ax
26138                                           !BCC_EOS
26139                                           ! 3949       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
26140                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
26141 781F           8B46         0C            mov	ax,$C[bp]
26142                                           ! Debug: list unsigned int = ax+4 (used reg = )
26143 7822           05                   0004  add	ax,*4
26144 7825           50                         push	ax
26145                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26146 7826           FF76         06            push	6[bp]
26147                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26148 7829           E8         8DDB            call	_read_word
26149 782C           83C4                   04  add	sp,*4
26150                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
26151 782F           8946         E4            mov	-$1C[bp],ax
26152                                           !BCC_EOS
26153                                           ! 3950       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
26154                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
26155 7832           8B46         0C            mov	ax,$C[bp]
26156                                           ! Debug: list unsigned int = ax+$C (used reg = )
26157 7835           05                   000C  add	ax,*$C
26158 7838           50                         push	ax
26159                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26160 7839           FF76         06            push	6[bp]
26161                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26162 783C           E8         8844            call	_read_dword
26163 783F           89D3                       mov	bx,dx
26164 7841           83C4                   04  add	sp,*4
26165                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26166 7844           8946         EA            mov	-$16[bp],ax
26167 7847           895E         EC            mov	-$14[bp],bx
26168                                           !BCC_EOS
26169                                           ! 3951       if (lba != 0L) {
26170                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
26171                                           ! Debug: expression subtree swapping
26172 784A           31C0                       xor	ax,ax
26173 784C           31DB                       xor	bx,bx
26174 784E           53                         push	bx
26175 784F           50                         push	ax
26176 7850           8B46         EA            mov	ax,-$16[bp]
26177 7853           8B5E         EC            mov	bx,-$14[bp]
26178 7856           8D7E         D0            lea	di,-2+..FFEA[bp]
26179 7859           E8         886F            call	lcmpul
26180 785C           8D66         D4            lea	sp,2+..FFEA[bp]
26181 785F           74           1C            je  	.59B
26182                       00007861            .59C:
26183                                           ! 3952         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
26184                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26185 7861           8B46         18            mov	ax,$18[bp]
26186 7864           88E0                       mov	al,ah
26187 7866           30E4                       xor	ah,ah
26188                                           ! Debug: list unsigned int = ax+0 (used reg = )
26189 7868           50                         push	ax
26190                                           ! Debug: list * char = .59D+0 (used reg = )
26191 7869           BB                   D147  mov	bx,#.59D
26192 786C           53                         push	bx
26193                                           ! Debug: list int = const 7 (used reg = )
26194 786D           B8                   0007  mov	ax,*7
26195 7870           50                         push	ax
26196                                           ! Debug: func () void = bios_printf+0 (used reg = )
26197 7871           E8         91A7            call	_bios_printf
26198 7874           83C4                   06  add	sp,*6
26199                                           !BCC_EOS
26200                                           ! 3953         goto int13_fail;
26201 7877           83C4                   0C  add	sp,#..FFEB-..FFEA
26202 787A           E9         08DC            br 	.FFEB
26203                                           !BCC_EOS
26204                                           ! 3954         }
26205                                           ! 3955       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
26206                       0000787D            .59B:
26207                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
26208 787D           8B46         0C            mov	ax,$C[bp]
26209                                           ! Debug: list unsigned int = ax+8 (used reg = )
26210 7880           05                   0008  add	ax,*8
26211 7883           50                         push	ax
26212                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26213 7884           FF76         06            push	6[bp]
26214                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26215 7887           E8         87F9            call	_read_dword
26216 788A           89D3                       mov	bx,dx
26217 788C           83C4                   04  add	sp,*4
26218                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26219 788F           8946         EA            mov	-$16[bp],ax
26220 7892           895E         EC            mov	-$14[bp],bx
26221                                           !BCC_EOS
26222                                           ! 3956       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
26223                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26224 7895           8B46         18            mov	ax,$18[bp]
26225 7898           88E0                       mov	al,ah
26226 789A           30E4                       xor	ah,ah
26227                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
26228 789C           3D                   0044  cmp	ax,*$44
26229 789F           74           0C            je  	.59F
26230                       000078A1            .5A0:
26231                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26232 78A1           8B46         18            mov	ax,$18[bp]
26233 78A4           88E0                       mov	al,ah
26234 78A6           30E4                       xor	ah,ah
26235                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
26236 78A8           3D                   0047  cmp	ax,*$47
26237 78AB           75           06            jne 	.59E
26238                       000078AD            .59F:
26239                                           ! 3957         goto int13_success;
26240 78AD           83C4                   0C  add	sp,#..FFE9-..FFEA
26241 78B0           E9         08D3            br 	.FFE9
26242                                           !BCC_EOS
26243                                           ! 3958       memsetb(get_SS(),atacmd,0,12);
26244                       000078B3            .59E:
26245                                           ! Debug: list int = const $C (used reg = )
26246 78B3           B8                   000C  mov	ax,*$C
26247 78B6           50                         push	ax
26248                                           ! Debug: list int = const 0 (used reg = )
26249 78B7           31C0                       xor	ax,ax
26250 78B9           50                         push	ax
26251                                           ! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
26252 78BA           8D5E         EF            lea	bx,-$11[bp]
26253 78BD           53                         push	bx
26254                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26255 78BE           E8         8D8C            call	_get_SS
26256                                           ! Debug: list unsigned short = ax+0 (used reg = )
26257 78C1           50                         push	ax
26258                                           ! Debug: func () void = memsetb+0 (used reg = )
26259 78C2           E8         873B            call	_memsetb
26260 78C5           83C4                   08  add	sp,*8
26261                                           !BCC_EOS
26262                                           ! 3959       atacmd[0]=0x28;
26263                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
26264 78C8           B0                     28  mov	al,*$28
26265 78CA           8846         EF            mov	-$11[bp],al
26266                                           !BCC_EOS
26267                                           ! 3960       atacmd[7]=(count & 0xff00) >> 8;
26268                                           ! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
26269 78CD           8B46         E8            mov	ax,-$18[bp]
26270 78D0           30C0                       xor	al,al
26271                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
26272 78D2           88E0                       mov	al,ah
26273 78D4           30E4                       xor	ah,ah
26274                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
26275 78D6           8846         F6            mov	-$A[bp],al
26276                                           !BCC_EOS
26277                                           ! 3961       atacmd[8]=(count & 0x00ff);
26278                                           ! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
26279 78D9           8A46         E8            mov	al,-$18[bp]
26280                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
26281 78DC           8846         F7            mov	-9[bp],al
26282                                           !BCC_EOS
26283                                           ! 3962       atacmd[2]=(
26284                                           ! 3962 lba & 0xff000000) >> 24;
26285                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
26286                                           ! Debug: expression subtree swapping
26287 78DF           31C0                       xor	ax,ax
26288 78E1           BB                   FF00  mov	bx,#$FF00
26289 78E4           8D7E         EA            lea	di,-$16[bp]
26290 78E7           E8         87D1            call	landul
26291                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
26292 78EA           93                         xchg	bx,ax
26293 78EB           88E0                       mov	al,ah
26294 78ED           30E4                       xor	ah,ah
26295 78EF           31DB                       xor	bx,bx
26296                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
26297 78F1           8846         F1            mov	-$F[bp],al
26298                                           !BCC_EOS
26299                                           ! 3963       atacmd[3]=(lba & 0x00ff0000) >> 16;
26300                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
26301                                           ! Debug: expression subtree swapping
26302 78F4           31C0                       xor	ax,ax
26303 78F6           BB                   00FF  mov	bx,#$FF
26304 78F9           8D7E         EA            lea	di,-$16[bp]
26305 78FC           E8         87BC            call	landul
26306                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
26307 78FF           93                         xchg	bx,ax
26308 7900           31DB                       xor	bx,bx
26309                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
26310 7902           8846         F2            mov	-$E[bp],al
26311                                           !BCC_EOS
26312                                           ! 3964       atacmd[4]=(lba & 0x0000ff00) >> 8;
26313                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
26314                                           ! Debug: expression subtree swapping
26315 7905           B8                   FF00  mov	ax,#$FF00
26316 7908           31DB                       xor	bx,bx
26317 790A           8D7E         EA            lea	di,-$16[bp]
26318 790D           E8         87AB            call	landul
26319                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
26320 7910           88E0                       mov	al,ah
26321 7912           88DC                       mov	ah,bl
26322 7914           88FB                       mov	bl,bh
26323 7916           28FF                       sub	bh,bh
26324                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
26325 7918           8846         F3            mov	-$D[bp],al
26326                                           !BCC_EOS
26327                                           ! 3965       atacmd[5]=(lba & 0x000000ff);
26328                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
26329                                           ! Debug: expression subtree swapping
26330 791B           B8                   00FF  mov	ax,#$FF
26331 791E           31DB                       xor	bx,bx
26332 7920           8D7E         EA            lea	di,-$16[bp]
26333 7923           E8         8795            call	landul
26334                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
26335 7926           8846         F4            mov	-$C[bp],al
26336                                           !BCC_EOS
26337                                           ! 3966       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
26338                                           ! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
26339 7929           FF76         E4            push	-$1C[bp]
26340                                           ! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
26341 792C           FF76         E6            push	-$1A[bp]
26342                                           ! Debug: list int = const 1 (used reg = )
26343 792F           B8                   0001  mov	ax,*1
26344 7932           50                         push	ax
26345                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
26346 7933           8B46         E8            mov	ax,-$18[bp]
26347 7936           31DB                       xor	bx,bx
26348                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
26349 7938           53                         push	bx
26350 7939           50                         push	ax
26351 793A           B8                   0800  mov	ax,#$800
26352 793D           31DB                       xor	bx,bx
26353 793F           53                         push	bx
26354 7940           50                         push	ax
26355 7941           8B46         CA            mov	ax,-8+..FFEA[bp]
26356 7944           8B5E         CC            mov	bx,-6+..FFEA[bp]
26357 7947           8D7E         C6            lea	di,-$C+..FFEA[bp]
26358 794A           E8         879C            call	lmulul
26359 794D           83C4                   08  add	sp,*8
26360                                           ! Debug: list unsigned long = bx+0 (used reg = )
26361 7950           53                         push	bx
26362 7951           50                         push	ax
26363                                           ! Debug: list int = const 0 (used reg = )
26364 7952           31C0                       xor	ax,ax
26365 7954           50                         push	ax
26366                                           ! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
26367 7955           8D5E         EF            lea	bx,-$11[bp]
26368 7958           53                         push	bx
26369                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26370 7959           E8         8CF1            call	_get_SS
26371                                           ! Debug: list unsigned short = ax+0 (used reg = )
26372 795C           50                         push	ax
26373                                           ! Debug: list int = const $C (used reg = )
26374 795D           B8                   000C  mov	ax,*$C
26375 7960           50                         push	ax
26376                                           ! Debug: list unsigned char device = [S+$34-5] (used reg = )
26377 7961           8A46         FD            mov	al,-3[bp]
26378 7964           30E4                       xor	ah,ah
26379 7966           50                         push	ax
26380                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
26381 7967           E8         BC5C            call	_ata_cmd_packet
26382 796A           83C4                   14  add	sp,*$14
26383                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
26384 796D           8846         FC            mov	-4[bp],al
26385                                           !BCC_EOS
26386                                           ! 3967       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
26387                                           ! Debug: list * unsigned long = const $256 (used reg = )
26388 7970           B8                   0256  mov	ax,#$256
26389 7973           50                         push	ax
26390                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26391 7974           FF76         FE            push	-2[bp]
26392                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26393 7977           E8         8709            call	_read_dword
26394 797A           89D3                       mov	bx,dx
26395 797C           83C4                   04  add	sp,*4
26396                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
26397 797F           88E0                       mov	al,ah
26398 7981           88DC                       mov	ah,bl
26399 7983           88FB                       mov	bl,bh
26400 7985           28FF                       sub	bh,bh
26401 7987           BF                   0003  mov	di,*3
26402 798A           E8         879C            call	lsrul
26403                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
26404                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26405 798D           8946         E8            mov	-$18[bp],ax
26406                                           !BCC_EOS
26407                                           ! 3968       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
26408                                           ! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
26409 7990           FF76         E8            push	-$18[bp]
26410                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
26411 7993           8B46         0C            mov	ax,$C[bp]
26412                                           ! Debug: list unsigned int = ax+2 (used reg = )
26413 7996           40                         inc	ax
26414 7997           40                         inc	ax
26415 7998           50                         push	ax
26416                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
26417 7999           FF76         06            push	6[bp]
26418                                           ! Debug: func () void = write_word+0 (used reg = )
26419 799C           E8         8C93            call	_write_word
26420 799F           83C4                   06  add	sp,*6
26421                                           !BCC_EOS
26422                                           ! 3969       if (status != 0) {
26423                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
26424 79A2           8A46         FC            mov	al,-4[bp]
26425 79A5           84C0                       test	al,al
26426 79A7           74           11            je  	.5A1
26427                       000079A9            .5A2:
26428                                           ! 3970         ;
26429                                           !BCC_EOS
26430                                           ! 3971         AX = ((AX & 0x00ff) | ((0x0c) << 8));
26431                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26432 79A9           8A46         18            mov	al,$18[bp]
26433                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
26434 79AC           30E4                       xor	ah,ah
26435 79AE           0D                   0C00  or	ax,#$C00
26436                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26437 79B1           8946         18            mov	$18[bp],ax
26438                                           !BCC_EOS
26439                                           ! 3972         goto int13_fail_noah;
26440 79B4           83C4                   0C  add	sp,#..FFE8-..FFEA
26441 79B7           E9         07AA            br 	.FFE8
26442                                           !BCC_EOS
26443                                           ! 3973         }
26444                                           ! 3974       goto int13_success;
26445                       000079BA            .5A1:
26446 79BA           83C4                   0C  add	sp,#..FFE9-..FFEA
26447 79BD           E9         07C6            br 	.FFE9
26448                                           !BCC_EOS
26449                                           ! 3975       break;
26450 79C0           E9         0793            br 	.584
26451                                           !BCC_EOS
26452                                           ! 3976     case 0x45:
26453                                           ! 3977       if (( AX & 0x00ff ) > 2) goto int13_fail;
26454                       000079C3            .5A3:
26455                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26456 79C3           8A46         18            mov	al,$18[bp]
26457                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
26458 79C6           3C                     02  cmp	al,*2
26459 79C8           76           06            jbe 	.5A4
26460                       000079CA            .5A5:
26461 79CA           83C4                   0C  add	sp,#..FFEB-..FFEA
26462 79CD           E9         0789            br 	.FFEB
26463                                           !BCC_EOS
26464                                           ! 3978       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
26465                       000079D0            .5A4:
26466                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
26467 79D0           8A46         FD            mov	al,-3[bp]
26468 79D3           30E4                       xor	ah,ah
26469 79D5           B9                   001E  mov	cx,*$1E
26470 79D8           F7E9                       imul	cx
26471 79DA           89C3                       mov	bx,ax
26472                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26473                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26474 79DC           81C3                 0145  add	bx,#$145
26475 79E0           53                         push	bx
26476                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26477 79E1           FF76         FE            push	-2[bp]
26478                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26479 79E4           E8         8C0D            call	_read_byte
26480 79E7           83C4                   04  add	sp,*4
26481                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
26482 79EA           8846         FB            mov	-5[bp],al
26483                                           !BCC_EOS
26484                                           ! 3979       switch (( AX & 0x00ff )) {
26485                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26486 79ED           8A46         18            mov	al,$18[bp]
26487 79F0           E9         00D5            br 	.5A8
26488                                           ! 3980         case 0 :
26489                                           ! 3981           if (locks == 0xff) {
26490                       000079F3            .5A9:
26491                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
26492 79F3           8A46         FB            mov	al,-5[bp]
26493 79F6           3C                     FF  cmp	al,#$FF
26494 79F8           75           1B            jne 	.5AA
26495                       000079FA            .5AB:
26496                                           ! 3982             AX = ((AX & 0x00ff) | ((0xb4) << 8));
26497                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26498 79FA           8A46         18            mov	al,$18[bp]
26499                                           ! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
26500 79FD           30E4                       xor	ah,ah
26501 79FF           0D                   B400  or	ax,#-$4C00
26502                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26503 7A02           8946         18            mov	$18[bp],ax
26504                                           !BCC_EOS
26505                                           ! 3983             AX = ((AX & 0xff00) | (1));
26506                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26507 7A05           8B46         18            mov	ax,$18[bp]
26508 7A08           30C0                       xor	al,al
26509                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
26510 7A0A           0C                     01  or	al,*1
26511                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26512 7A0C           8946         18            mov	$18[bp],ax
26513                                           !BCC_EOS
26514                                           ! 3984             goto int13_fail_noah;
26515 7A0F           83C4                   0C  add	sp,#..FFE8-..FFEA
26516 7A12           E9         074F            br 	.FFE8
26517                                           !BCC_EOS
26518                                           ! 3985             }
26519                                           ! 3986           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
26520                       00007A15            .5AA:
26521                                           ! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
26522 7A15           8A46         FB            mov	al,-5[bp]
26523 7A18           40                         inc	ax
26524 7A19           8846         FB            mov	-5[bp],al
26525                                           ! Debug: list unsigned char = al+0 (used reg = )
26526 7A1C           30E4                       xor	ah,ah
26527 7A1E           50                         push	ax
26528                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
26529 7A1F           8A46         FD            mov	al,-3[bp]
26530 7A22           30E4                       xor	ah,ah
26531 7A24           B9                   001E  mov	cx,*$1E
26532 7A27           F7E9                       imul	cx
26533 7A29           89C3                       mov	bx,ax
26534                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26535                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26536 7A2B           81C3                 0145  add	bx,#$145
26537 7A2F           53                         push	bx
26538                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
26539 7A30           FF76         FE            push	-2[bp]
26540                                           ! Debug: func () void = write_byte+0 (used reg = )
26541 7A33           E8         8BE4            call	_write_byte
26542 7A36           83C4                   06  add	sp,*6
26543                                           !BCC_EOS
26544                                           ! 3987           AX = ((AX & 0xff00) | (1));
26545                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26546 7A39           8B46         18            mov	ax,$18[bp]
26547 7A3C           30C0                       xor	al,al
26548                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
26549 7A3E           0C                     01  or	al,*1
26550                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26551 7A40           8946         18            mov	$18[bp],ax
26552                                           !BCC_EOS
26553                                           ! 3988           break;
26554 7A43           E9         0092            br 	.5A6
26555                                           !BCC_EOS
26556                                           ! 3989         case 1 :
26557                                           ! 3990           if (locks == 0x00) {
26558                       00007A46            .5AC:
26559                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26560 7A46           8A46         FB            mov	al,-5[bp]
26561 7A49           84C0                       test	al,al
26562 7A4B           75           1B            jne 	.5AD
26563                       00007A4D            .5AE:
26564                                           ! 3991             AX = ((AX & 0x00ff) | ((0xb0) << 8));
26565                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26566 7A4D           8A46         18            mov	al,$18[bp]
26567                                           ! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
26568 7A50           30E4                       xor	ah,ah
26569 7A52           0D                   B000  or	ax,#-$5000
26570                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26571 7A55           8946         18            mov	$18[bp],ax
26572                                           !BCC_EOS
26573                                           ! 3992             AX = ((AX & 0xff00) | (0));
26574                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26575 7A58           8B46         18            mov	ax,$18[bp]
26576 7A5B           30C0                       xor	al,al
26577                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
26578 7A5D           0C                     00  or	al,*0
26579                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26580 7A5F           8946         18            mov	$18[bp],ax
26581                                           !BCC_EOS
26582                                           ! 3993             goto int13_fail_noah;
26583 7A62           83C4                   0C  add	sp,#..FFE8-..FFEA
26584 7A65           E9         06FC            br 	.FFE8
26585                                           !BCC_EOS
26586                                           ! 3994             }
26587                                           ! 3995           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
26588                       00007A68            .5AD:
26589                                           ! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
26590 7A68           8A46         FB            mov	al,-5[bp]
26591 7A6B           48                         dec	ax
26592 7A6C           8846         FB            mov	-5[bp],al
26593                                           ! Debug: list unsigned char = al+0 (used reg = )
26594 7A6F           30E4                       xor	ah,ah
26595 7A71           50                         push	ax
26596                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
26597 7A72           8A46         FD            mov	al,-3[bp]
26598 7A75           30E4                       xor	ah,ah
26599 7A77           B9                   001E  mov	cx,*$1E
26600 7A7A           F7E9                       imul	cx
26601 7A7C           89C3                       mov	bx,ax
26602                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26603                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26604 7A7E           81C3                 0145  add	bx,#$145
26605 7A82           53                         push	bx
26606                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
26607 7A83           FF76         FE            push	-2[bp]
26608                                           ! Debug: func () void = write_byte+0 (used reg = )
26609 7A86           E8         8B91            call	_write_byte
26610 7A89           83C4                   06  add	sp,*6
26611                                           !BCC_EOS
26612                                           ! 3996           AX = ((AX & 0xff00) | (locks==0?0:1));
26613                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26614 7A8C           8A46         FB            mov	al,-5[bp]
26615 7A8F           84C0                       test	al,al
26616 7A91           75           04            jne 	.5AF
26617                       00007A93            .5B0:
26618 7A93           30C0                       xor	al,al
26619 7A95           EB           02            jmp .5B1
26620                       00007A97            .5AF:
26621 7A97           B0                     01  mov	al,*1
26622                       00007A99            .5B1:
26623 7A99           50                         push	ax
26624                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
26625 7A9A           8B46         18            mov	ax,$18[bp]
26626 7A9D           30C0                       xor	al,al
26627                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
26628 7A9F           0A46         D2            or	al,0+..FFEA[bp]
26629 7AA2           44                         inc	sp
26630 7AA3           44                         inc	sp
26631                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26632 7AA4           8946         18            mov	$18[bp],ax
26633                                           !BCC_EOS
26634                                           ! 3997           break;
26635 7AA7           EB           2F            jmp .5A6
26636                                           !BCC_EOS
26637                                           ! 3998         case 2 :
26638                                           ! 3999           AX = ((AX & 0xff00) | (locks==0?0:1));
26639                       00007AA9            .5B2:
26640                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26641 7AA9           8A46         FB            mov	al,-5[bp]
26642 7AAC           84C0                       test	al,al
26643 7AAE           75           04            jne 	.5B3
26644                       00007AB0            .5B4:
26645 7AB0           30C0                       xor	al,al
26646 7AB2           EB           02            jmp .5B5
26647                       00007AB4            .5B3:
26648 7AB4           B0                     01  mov	al,*1
26649                       00007AB6            .5B5:
26650 7AB6           50                         push	ax
26651                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
26652 7AB7           8B46         18            mov	ax,$18[bp]
26653 7ABA           30C0                       xor	al,al
26654                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
26655 7ABC           0A46         D2            or	al,0+..FFEA[bp]
26656 7ABF           44                         inc	sp
26657 7AC0           44                         inc	sp
26658                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26659 7AC1           8946         18            mov	$18[bp],ax
26660                                           !BCC_EOS
26661                                           ! 4000           break;
26662 7AC4           EB           12            jmp .5A6
26663                                           !BCC_EOS
26664                                           ! 4001         }
26665                                           ! 4002       goto int13_success;
26666 7AC6           EB           10            jmp .5A6
26667                       00007AC8            .5A8:
26668 7AC8           2C                     00  sub	al,*0
26669 7ACA         0F84         FF25            beq 	.5A9
26670 7ACE           2C                     01  sub	al,*1
26671 7AD0         0F84         FF72            beq 	.5AC
26672 7AD4           2C                     01  sub	al,*1
26673 7AD6           74           D1            je 	.5B2
26674                       00007AD8            .5A6:
26675 7AD8           83C4                   0C  add	sp,#..FFE9-..FFEA
26676 7ADB           E9         06A8            br 	.FFE9
26677                                           !BCC_EOS
26678                                           ! 4003       break;
26679 7ADE           E9         0675            br 	.584
26680                                           !BCC_EOS
26681                                           ! 4004     case 0x46:
26682                                           ! 4005       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
26683                       00007AE1            .5B6:
26684                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
26685 7AE1           8A46         FD            mov	al,-3[bp]
26686 7AE4           30E4                       xor	ah,ah
26687 7AE6           B9                   001E  mov	cx,*$1E
26688 7AE9           F7E9                       imul	cx
26689 7AEB           89C3                       mov	bx,ax
26690                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26691                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26692 7AED           81C3                 0145  add	bx,#$145
26693 7AF1           53                         push	bx
26694                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26695 7AF2           FF76         FE            push	-2[bp]
26696                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26697 7AF5           E8         8AFC            call	_read_byte
26698 7AF8           83C4                   04  add	sp,*4
26699                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
26700 7AFB           8846         FB            mov	-5[bp],al
26701                                           !BCC_EOS
26702                                           ! 4006       if (locks != 0) {
26703                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26704 7AFE           8A46         FB            mov	al,-5[bp]
26705 7B01           84C0                       test	al,al
26706 7B03           74           11            je  	.5B7
26707                       00007B05            .5B8:
26708                                           ! 4007         AX = ((AX & 0x00ff) | ((0xb1) << 8));
26709                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26710 7B05           8A46         18            mov	al,$18[bp]
26711                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
26712 7B08           30E4                       xor	ah,ah
26713 7B0A           0D                   B100  or	ax,#-$4F00
26714                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26715 7B0D           8946         18            mov	$18[bp],ax
26716                                           !BCC_EOS
26717                                           ! 4008         goto int13_fail_noah;
26718 7B10           83C4                   0C  add	sp,#..FFE8-..FFEA
26719 7B13           E9         064E            br 	.FFE8
26720                                           !BCC_EOS
26721                                           ! 4009         }
26722                                           ! 4010 #asm
26723                       00007B16            .5B7:
26724                                           !BCC_EOS
26725                                           !BCC_ASM
26726                       0000002E            _int13_cdrom.BP	set	$2E
26727                       0000000E            .int13_cdrom.BP	set	$E
26728                       00000024            _int13_cdrom.EHBX	set	$24
26729                       00000004            .int13_cdrom.EHBX	set	4
26730                       0000003C            _int13_cdrom.CS	set	$3C
26731                       0000001C            .int13_cdrom.CS	set	$1C
26732                       00000008            _int13_cdrom.count	set	8
26733                       FFFFFFE8            .int13_cdrom.count	set	-$18
26734                       00000036            _int13_cdrom.CX	set	$36
26735                       00000016            .int13_cdrom.CX	set	$16
26736                       00000006            _int13_cdrom.segment	set	6
26737                       FFFFFFE6            .int13_cdrom.segment	set	-$1A
26738                       0000002A            _int13_cdrom.DI	set	$2A
26739                       0000000A            .int13_cdrom.DI	set	$A
26740                       0000003E            _int13_cdrom.FLAGS	set	$3E
26741                       0000001E            .int13_cdrom.FLAGS	set	$1E
26742                       00000026            _int13_cdrom.DS	set	$26
26743                       00000006            .int13_cdrom.DS	set	6
26744                       00000030            _int13_cdrom.ELDX	set	$30
26745                       00000010            .int13_cdrom.ELDX	set	$10
26746                       00000034            _int13_cdrom.DX	set	$34
26747                       00000014            .int13_cdrom.DX	set	$14
26748                       00000000            _int13_cdrom.size	set	0
26749                       FFFFFFE0            .int13_cdrom.size	set	-$20
26750                       00000002            _int13_cdrom.i	set	2
26751                       FFFFFFE2            .int13_cdrom.i	set	-$1E
26752                       0000001D            _int13_cdrom.device	set	$1D
26753                       FFFFFFFD            .int13_cdrom.device	set	-3
26754                       00000028            _int13_cdrom.ES	set	$28
26755                       00000008            .int13_cdrom.ES	set	8
26756                       0000001E            _int13_cdrom.ebda_seg	set	$1E
26757                       FFFFFFFE            .int13_cdrom.ebda_seg	set	-2
26758                       0000002C            _int13_cdrom.SI	set	$2C
26759                       0000000C            .int13_cdrom.SI	set	$C
26760                       0000003A            _int13_cdrom.IP	set	$3A
26761                       0000001A            .int13_cdrom.IP	set	$1A
26762                       0000000A            _int13_cdrom.lba	set	$A
26763                       FFFFFFEA            .int13_cdrom.lba	set	-$16
26764                       0000001C            _int13_cdrom.status	set	$1C
26765                       FFFFFFFC            .int13_cdrom.status	set	-4
26766                       0000000F            _int13_cdrom.atacmd	set	$F
26767                       FFFFFFEF            .int13_cdrom.atacmd	set	-$11
26768                       00000038            _int13_cdrom.AX	set	$38
26769                       00000018            .int13_cdrom.AX	set	$18
26770                       00000004            _int13_cdrom.offset	set	4
26771                       FFFFFFE4            .int13_cdrom.offset	set	-$1C
26772                       00000032            _int13_cdrom.BX	set	$32
26773                       00000012            .int13_cdrom.BX	set	$12
26774                       0000001B            _int13_cdrom.locks	set	$1B
26775                       FFFFFFFB            .int13_cdrom.locks	set	-5
26776 7B16           55                                 push bp
26777 7B17           89E5                               mov bp, sp
26778 7B19           B4                     52          mov ah, #0x52
26779 7B1B           CD                     15          int #0x15
26780 7B1D           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
26781 7B20           73           06                    jnc int13_cdrom_rme_end
26782 7B22           C706       001C      0001          mov _int13_cdrom.status, #1
26783                       00007B28            int13_cdrom_rme_end:
26784 7B28           5D                                 pop bp
26785                                           ! 4020 endasm
26786                                           !BCC_ENDASM
26787                                           !BCC_EOS
26788                                           ! 4021       if (status != 0) {
26789                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
26790 7B29           8A46         FC            mov	al,-4[bp]
26791 7B2C           84C0                       test	al,al
26792 7B2E           74           11            je  	.5B9
26793                       00007B30            .5BA:
26794                                           ! 4022         AX = ((AX & 0x00ff) | ((0xb1)
26795                                           ! 4022  << 8));
26796                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26797 7B30           8A46         18            mov	al,$18[bp]
26798                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
26799 7B33           30E4                       xor	ah,ah
26800 7B35           0D                   B100  or	ax,#-$4F00
26801                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26802 7B38           8946         18            mov	$18[bp],ax
26803                                           !BCC_EOS
26804                                           ! 4023         goto int13_fail_noah;
26805 7B3B           83C4                   0C  add	sp,#..FFE8-..FFEA
26806 7B3E           E9         0623            br 	.FFE8
26807                                           !BCC_EOS
26808                                           ! 4024       }
26809                                           ! 4025       goto int13_success;
26810                       00007B41            .5B9:
26811 7B41           83C4                   0C  add	sp,#..FFE9-..FFEA
26812 7B44           E9         063F            br 	.FFE9
26813                                           !BCC_EOS
26814                                           ! 4026       break;
26815 7B47           E9         060C            br 	.584
26816                                           !BCC_EOS
26817                                           ! 4027     case 0x48:
26818                                           ! 4028       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
26819                       00007B4A            .5BB:
26820                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
26821 7B4A           8B46         0C            mov	ax,$C[bp]
26822                                           ! Debug: list unsigned int = ax+0 (used reg = )
26823 7B4D           50                         push	ax
26824                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26825 7B4E           FF76         06            push	6[bp]
26826                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26827 7B51           E8         8AB3            call	_read_word
26828 7B54           83C4                   04  add	sp,*4
26829                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
26830 7B57           8946         E0            mov	-$20[bp],ax
26831                                           !BCC_EOS
26832                                           ! 4029       if(size < 0x1a)
26833                                           ! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
26834 7B5A           8B46         E0            mov	ax,-$20[bp]
26835 7B5D           3D                   001A  cmp	ax,*$1A
26836 7B60           73           06            jae 	.5BC
26837                       00007B62            .5BD:
26838                                           ! 4030         goto int13_fail;
26839 7B62           83C4                   0C  add	sp,#..FFEB-..FFEA
26840 7B65           E9         05F1            br 	.FFEB
26841                                           !BCC_EOS
26842                                           ! 4031       if(size >= 0x1a) {
26843                       00007B68            .5BC:
26844                                           ! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
26845 7B68           8B46         E0            mov	ax,-$20[bp]
26846 7B6B           3D                   001A  cmp	ax,*$1A
26847 7B6E         0F82         00CC            blo 	.5BE
26848                       00007B72            .5BF:
26849                                           ! 4032         Bit16u cylinders, heads, spt, blksize;
26850                                           !BCC_EOS
26851                                           ! 4033         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
26852                                           ! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
26853 7B72           8A46         FD            mov	al,-3[bp]
26854 7B75           30E4                       xor	ah,ah
26855 7B77           B9                   001E  mov	cx,*$1E
26856 7B7A           F7E9                       imul	cx
26857 7B7C           89C3                       mov	bx,ax
26858                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
26859                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
26860 7B7E           81C3                 0148  add	bx,#$148
26861 7B82           53                         push	bx
26862                                           ! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
26863 7B83           FF76         FE            push	-2[bp]
26864                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26865 7B86           E8         8A7E            call	_read_word
26866 7B89           83C4                   04  add	sp,*4
26867                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
26868 7B8C           8946         D8            mov	-$28[bp],ax
26869                                           !BCC_EOS
26870                                           ! 4034         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
26871                                           ! Debug: list int = const $1A (used reg = )
26872 7B8F           B8                   001A  mov	ax,*$1A
26873 7B92           50                         push	ax
26874                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
26875 7B93           8B46         0C            mov	ax,$C[bp]
26876                                           ! Debug: list unsigned int = ax+0 (used reg = )
26877 7B96           50                         push	ax
26878                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26879 7B97           FF76         06            push	6[bp]
26880                                           ! Debug: func () void = write_word+0 (used reg = )
26881 7B9A           E8         8A95            call	_write_word
26882 7B9D           83C4                   06  add	sp,*6
26883                                           !BCC_EOS
26884                                           ! 4035         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
26885                                           ! Debug: list int = const $74 (used reg = )
26886 7BA0           B8                   0074  mov	ax,*$74
26887 7BA3           50                         push	ax
26888                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
26889 7BA4           8B46         0C            mov	ax,$C[bp]
26890                                           ! Debug: list unsigned int = ax+2 (used reg = )
26891 7BA7           40                         inc	ax
26892 7BA8           40                         inc	ax
26893 7BA9           50                         push	ax
26894                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26895 7BAA           FF76         06            push	6[bp]
26896                                           ! Debug: func () void = write_word+0 (used reg = )
26897 7BAD           E8         8A82            call	_write_word
26898 7BB0           83C4                   06  add	sp,*6
26899                                           !BCC_EOS
26900                                           ! 4036         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
26901                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26902 7BB3           B8                   FFFF  mov	ax,#$FFFF
26903 7BB6           BB                   FFFF  mov	bx,#$FFFF
26904 7BB9           53                         push	bx
26905 7BBA           50                         push	ax
26906                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
26907 7BBB           8B46         0C            mov	ax,$C[bp]
26908                                           ! Debug: list unsigned int = ax+4 (used reg = )
26909 7BBE           05                   0004  add	ax,*4
26910 7BC1           50                         push	ax
26911                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26912 7BC2           FF76         06            push	6[bp]
26913                                           ! Debug: func () void = write_dword+0 (used reg = )
26914 7BC5           E8         84D3            call	_write_dword
26915 7BC8           83C4                   08  add	sp,*8
26916                                           !BCC_EOS
26917                                           ! 4037         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
26918                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26919 7BCB           B8                   FFFF  mov	ax,#$FFFF
26920 7BCE           BB                   FFFF  mov	bx,#$FFFF
26921 7BD1           53                         push	bx
26922 7BD2           50                         push	ax
26923                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
26924 7BD3           8B46         0C            mov	ax,$C[bp]
26925                                           ! Debug: list unsigned int = ax+8 (used reg = )
26926 7BD6           05                   0008  add	ax,*8
26927 7BD9           50                         push	ax
26928                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26929 7BDA           FF76         06            push	6[bp]
26930                                           ! Debug: func () void = write_dword+0 (used reg = )
26931 7BDD           E8         84BB            call	_write_dword
26932 7BE0           83C4                   08  add	sp,*8
26933                                           !BCC_EOS
26934                                           ! 4038         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
26935                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26936 7BE3           B8                   FFFF  mov	ax,#$FFFF
26937 7BE6           BB                   FFFF  mov	bx,#$FFFF
26938 7BE9           53                         push	bx
26939 7BEA           50                         push	ax
26940                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
26941 7BEB           8B46         0C            mov	ax,$C[bp]
26942                                           ! Debug: list unsigned int = ax+$C (used reg = )
26943 7BEE           05                   000C  add	ax,*$C
26944 7BF1           50                         push	ax
26945                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26946 7BF2           FF76         06            push	6[bp]
26947                                           ! Debug: func () void = write_dword+0 (used reg = )
26948 7BF5           E8         84A3            call	_write_dword
26949 7BF8           83C4                   08  add	sp,*8
26950                                           !BCC_EOS
26951                                           ! 4039         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
26952                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26953 7BFB           B8                   FFFF  mov	ax,#$FFFF
26954 7BFE           BB                   FFFF  mov	bx,#$FFFF
26955 7C01           53                         push	bx
26956 7C02           50                         push	ax
26957                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
26958 7C03           8B46         0C            mov	ax,$C[bp]
26959                                           ! Debug: list unsigned int = ax+$10 (used reg = )
26960 7C06           05                   0010  add	ax,*$10
26961 7C09           50                         push	ax
26962                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26963 7C0A           FF76         06            push	6[bp]
26964                                           ! Debug: func () void = write_dword+0 (used reg = )
26965 7C0D           E8         848B            call	_write_dword
26966 7C10           83C4                   08  add	sp,*8
26967                                           !BCC_EOS
26968                                           ! 4040         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
26969                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26970 7C13           B8                   FFFF  mov	ax,#$FFFF
26971 7C16           BB                   FFFF  mov	bx,#$FFFF
26972 7C19           53                         push	bx
26973 7C1A           50                         push	ax
26974                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
26975 7C1B           8B46         0C            mov	ax,$C[bp]
26976                                           ! Debug: list unsigned int = ax+$14 (used reg = )
26977 7C1E           05                   0014  add	ax,*$14
26978 7C21           50                         push	ax
26979                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26980 7C22           FF76         06            push	6[bp]
26981                                           ! Debug: func () void = write_dword+0 (used reg = )
26982 7C25           E8         8473            call	_write_dword
26983 7C28           83C4                   08  add	sp,*8
26984                                           !BCC_EOS
26985                                           ! 4041         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
26986                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
26987 7C2B           FF76         D8            push	-$28[bp]
26988                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
26989 7C2E           8B46         0C            mov	ax,$C[bp]
26990                                           ! Debug: list unsigned int = ax+$18 (used reg = )
26991 7C31           05                   0018  add	ax,*$18
26992 7C34           50                         push	ax
26993                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26994 7C35           FF76         06            push	6[bp]
26995                                           ! Debug: func () void = write_word+0 (used reg = )
26996 7C38           E8         89F7            call	_write_word
26997 7C3B           83C4                   06  add	sp,*6
26998                                           !BCC_EOS
26999                                           ! 4042         }
27000                                           ! 4043       if(size >= 0x1e) {
27001                       00007C3E            .5BE:
27002                                           ! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
27003 7C3E           8B46         E0            mov	ax,-$20[bp]
27004 7C41           3D                   001E  cmp	ax,*$1E
27005 7C44         0F82         01F9            blo 	.5C0
27006                       00007C48            .5C1:
27007                                           ! 4044         Bit8u channel, dev, irq, mode, checksum, i;
27008                                           !BCC_EOS
27009                                           ! 4045         Bit16u iobase1, iobase2, options;
27010                                           !BCC_EOS
27011                                           ! 4046         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
27012                                           ! Debug: list int = const $1E (used reg = )
27013 7C48           B8                   001E  mov	ax,*$1E
27014 7C4B           50                         push	ax
27015                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
27016 7C4C           8B46         0C            mov	ax,$C[bp]
27017                                           ! Debug: list unsigned int = ax+0 (used reg = )
27018 7C4F           50                         push	ax
27019                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27020 7C50           FF76         06            push	6[bp]
27021                                           ! Debug: func () void = write_word+0 (used reg = )
27022 7C53           E8         89DC            call	_write_word
27023 7C56           83C4                   06  add	sp,*6
27024                                           !BCC_EOS
27025                                           ! 4047         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
27026                                           ! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
27027 7C59           FF76         FE            push	-2[bp]
27028                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
27029 7C5C           8B46         0C            mov	ax,$C[bp]
27030                                           ! Debug: list unsigned int = ax+$1C (used reg = )
27031 7C5F           05                   001C  add	ax,*$1C
27032 7C62           50                         push	ax
27033                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27034 7C63           FF76         06            push	6[bp]
27035                                           ! Debug: func () void = write_word+0 (used reg = )
27036 7C66           E8         89C9            call	_write_word
27037 7C69           83C4                   06  add	sp,*6
27038                                           !BCC_EOS
27039                                           ! 4048         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
27040                                           ! Debug: list * struct  = const $244 (used reg = )
27041 7C6C           B8                   0244  mov	ax,#$244
27042 7C6F           50                         push	ax
27043                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
27044 7C70           8B46         0C            mov	ax,$C[bp]
27045                                           ! Debug: list unsigned int = ax+$1A (used reg = )
27046 7C73           05                   001A  add	ax,*$1A
27047 7C76           50                         push	ax
27048                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27049 7C77           FF76         06            push	6[bp]
27050                                           ! Debug: func () void = write_word+0 (used reg = )
27051 7C7A           E8         89B5            call	_write_word
27052 7C7D           83C4                   06  add	sp,*6
27053                                           !BCC_EOS
27054                                           ! 4049         channel = device / 2;
27055                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27056 7C80           8A46         FD            mov	al,-3[bp]
27057 7C83           30E4                       xor	ah,ah
27058 7C85           D1E8                       shr	ax,*1
27059                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
27060 7C87           8846         DF            mov	-$21[bp],al
27061                                           !BCC_EOS
27062                                           ! 4050         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27063                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27064 7C8A           8A46         DF            mov	al,-$21[bp]
27065 7C8D           30E4                       xor	ah,ah
27066 7C8F           B1                     03  mov	cl,*3
27067 7C91           D3E0                       shl	ax,cl
27068 7C93           89C3                       mov	bx,ax
27069                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27070                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27071 7C95           81C3                 0124  add	bx,#$124
27072 7C99           53                         push	bx
27073                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27074 7C9A           FF76         FE            push	-2[bp]
27075                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27076 7C9D           E8         8967            call	_read_word
27077 7CA0           83C4                   04  add	sp,*4
27078                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27079 7CA3           8946         D8            mov	-$28[bp],ax
27080                                           !BCC_EOS
27081                                           ! 4051         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
27082                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27083 7CA6           8A46         DF            mov	al,-$21[bp]
27084 7CA9           30E4                       xor	ah,ah
27085 7CAB           B1                     03  mov	cl,*3
27086 7CAD           D3E0                       shl	ax,cl
27087 7CAF           89C3                       mov	bx,ax
27088                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
27089                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
27090 7CB1           81C3                 0126  add	bx,#$126
27091 7CB5           53                         push	bx
27092                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27093 7CB6           FF76         FE            push	-2[bp]
27094                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27095 7CB9           E8         894B            call	_read_word
27096 7CBC           83C4                   04  add	sp,*4
27097                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27098 7CBF           8946         D6            mov	-$2A[bp],ax
27099                                           !BCC_EOS
27100                                           ! 4052         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
27101                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27102 7CC2           8A46         DF            mov	al,-$21[bp]
27103 7CC5           30E4                       xor	ah,ah
27104 7CC7           B1                     03  mov	cl,*3
27105 7CC9           D3E0                       shl	ax,cl
27106 7CCB           89C3                       mov	bx,ax
27107                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
27108                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
27109 7CCD           81C3                 0128  add	bx,#$128
27110 7CD1           53                         push	bx
27111                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27112 7CD2           FF76         FE            push	-2[bp]
27113                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27114 7CD5           E8         891C            call	_read_byte
27115 7CD8           83C4                   04  add	sp,*4
27116                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
27117 7CDB           8846         DD            mov	-$23[bp],al
27118                                           !BCC_EOS
27119                                           ! 4053         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
27120                                           ! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
27121 7CDE           8A46         FD            mov	al,-3[bp]
27122 7CE1           30E4                       xor	ah,ah
27123 7CE3           B9                   001E  mov	cx,*$1E
27124 7CE6           F7E9                       imul	cx
27125 7CE8           89C3                       mov	bx,ax
27126                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
27127                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
27128 7CEA           81C3                 0146  add	bx,#$146
27129 7CEE           53                         push	bx
27130                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27131 7CEF           FF76         FE            push	-2[bp]
27132                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27133 7CF2           E8         88FF            call	_read_byte
27134 7CF5           83C4                   04  add	sp,*4
27135                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
27136 7CF8           8846         DC            mov	-$24[bp],al
27137                                           !BCC_EOS
27138                                           ! 4054         options = (1<<4);
27139                                           ! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
27140 7CFB           B8                   0010  mov	ax,*$10
27141 7CFE           8946         D4            mov	-$2C[bp],ax
27142                                           !BCC_EOS
27143                                           ! 4055         options |= (1<<5);
27144                                           ! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
27145 7D01           8B46         D4            mov	ax,-$2C[bp]
27146 7D04           0C                     20  or	al,*$20
27147 7D06           8946         D4            mov	-$2C[bp],ax
27148                                           !BCC_EOS
27149                                           ! 4056         options |= (1<<6);
27150                                           ! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
27151 7D09           8B46         D4            mov	ax,-$2C[bp]
27152 7D0C           0C                     40  or	al,*$40
27153 7D0E           8946         D4            mov	-$2C[bp],ax
27154                                           !BCC_EOS
27155                                           ! 4057         options |= (mode==0x01?1:0<<7);
27156                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
27157 7D11           8A46         DC            mov	al,-$24[bp]
27158 7D14           3C                     01  cmp	al,*1
27159 7D16           75           04            jne 	.5C2
27160                       00007D18            .5C3:
27161 7D18           B0                     01  mov	al,*1
27162 7D1A           EB           02            jmp .5C4
27163                       00007D1C            .5C2:
27164 7D1C           30C0                       xor	al,al
27165                       00007D1E            .5C4:
27166                                           ! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
27167 7D1E           30E4                       xor	ah,ah
27168 7D20           0B46         D4            or	ax,-$2C[bp]
27169 7D23           8946         D4            mov	-$2C[bp],ax
27170                                           !BCC_EOS
27171                                           ! 4058         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
27172                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27173 7D26           FF76         D8            push	-$28[bp]
27174                                           ! Debug: list * unsigned short = const $244 (used reg = )
27175 7D29           B8                   0244  mov	ax,#$244
27176 7D2C           50                         push	ax
27177                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27178 7D2D           FF76         FE            push	-2[bp]
27179                                           ! Debug: func () void = write_word+0 (used reg = )
27180 7D30           E8         88FF            call	_write_word
27181 7D33           83C4                   06  add	sp,*6
27182                                           !BCC_EOS
27183                                           ! 4059         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
27184                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27185 7D36           8B46         D6            mov	ax,-$2A[bp]
27186                                           ! Debug: list unsigned int = ax+6 (used reg = )
27187 7D39           05                   0006  add	ax,*6
27188 7D3C           50                         push	ax
27189                                           ! Debug: list * unsigned short = const $246 (used reg = )
27190 7D3D           B8                   0246  mov	ax,#$246
27191 7D40           50                         push	ax
27192                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27193 7D41           FF76         FE            push	-2[bp]
27194                                           ! Debug: func () void = write_word+0 (used reg = )
27195 7D44           E8         88EB            call	_write_word
27196 7D47           83C4                   06  add	sp,*6
27197                                           !BCC_EOS
27198                                           ! 4060         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (d
27199                                           ! 4060 evice % 2))<<4 );
27200                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27201 7D4A           8A46         FD            mov	al,-3[bp]
27202 7D4D           30E4                       xor	ah,ah
27203 7D4F           24                     01  and	al,*1
27204                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
27205                                           ! Debug: expression subtree swapping
27206 7D51           0C                     0E  or	al,*$E
27207                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
27208 7D53           30E4                       xor	ah,ah
27209 7D55           B1                     04  mov	cl,*4
27210 7D57           D3E0                       shl	ax,cl
27211                                           ! Debug: list unsigned int = ax+0 (used reg = )
27212 7D59           50                         push	ax
27213                                           ! Debug: list * unsigned char = const $248 (used reg = )
27214 7D5A           B8                   0248  mov	ax,#$248
27215 7D5D           50                         push	ax
27216                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27217 7D5E           FF76         FE            push	-2[bp]
27218                                           ! Debug: func () void = write_byte+0 (used reg = )
27219 7D61           E8         88B6            call	_write_byte
27220 7D64           83C4                   06  add	sp,*6
27221                                           !BCC_EOS
27222                                           ! 4061         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
27223                                           ! Debug: list int = const $CB (used reg = )
27224 7D67           B8                   00CB  mov	ax,#$CB
27225 7D6A           50                         push	ax
27226                                           ! Debug: list * unsigned char = const $249 (used reg = )
27227 7D6B           B8                   0249  mov	ax,#$249
27228 7D6E           50                         push	ax
27229                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27230 7D6F           FF76         FE            push	-2[bp]
27231                                           ! Debug: func () void = write_byte+0 (used reg = )
27232 7D72           E8         88A5            call	_write_byte
27233 7D75           83C4                   06  add	sp,*6
27234                                           !BCC_EOS
27235                                           ! 4062         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
27236                                           ! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
27237 7D78           8A46         DD            mov	al,-$23[bp]
27238 7D7B           30E4                       xor	ah,ah
27239 7D7D           50                         push	ax
27240                                           ! Debug: list * unsigned char = const $24A (used reg = )
27241 7D7E           B8                   024A  mov	ax,#$24A
27242 7D81           50                         push	ax
27243                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27244 7D82           FF76         FE            push	-2[bp]
27245                                           ! Debug: func () void = write_byte+0 (used reg = )
27246 7D85           E8         8892            call	_write_byte
27247 7D88           83C4                   06  add	sp,*6
27248                                           !BCC_EOS
27249                                           ! 4063         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
27250                                           ! Debug: list int = const 1 (used reg = )
27251 7D8B           B8                   0001  mov	ax,*1
27252 7D8E           50                         push	ax
27253                                           ! Debug: list * unsigned char = const $24B (used reg = )
27254 7D8F           B8                   024B  mov	ax,#$24B
27255 7D92           50                         push	ax
27256                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27257 7D93           FF76         FE            push	-2[bp]
27258                                           ! Debug: func () void = write_byte+0 (used reg = )
27259 7D96           E8         8881            call	_write_byte
27260 7D99           83C4                   06  add	sp,*6
27261                                           !BCC_EOS
27262                                           ! 4064         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
27263                                           ! Debug: list int = const 0 (used reg = )
27264 7D9C           31C0                       xor	ax,ax
27265 7D9E           50                         push	ax
27266                                           ! Debug: list * unsigned char = const $24C (used reg = )
27267 7D9F           B8                   024C  mov	ax,#$24C
27268 7DA2           50                         push	ax
27269                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27270 7DA3           FF76         FE            push	-2[bp]
27271                                           ! Debug: func () void = write_byte+0 (used reg = )
27272 7DA6           E8         8871            call	_write_byte
27273 7DA9           83C4                   06  add	sp,*6
27274                                           !BCC_EOS
27275                                           ! 4065         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
27276                                           ! Debug: list int = const 0 (used reg = )
27277 7DAC           31C0                       xor	ax,ax
27278 7DAE           50                         push	ax
27279                                           ! Debug: list * unsigned char = const $24D (used reg = )
27280 7DAF           B8                   024D  mov	ax,#$24D
27281 7DB2           50                         push	ax
27282                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27283 7DB3           FF76         FE            push	-2[bp]
27284                                           ! Debug: func () void = write_byte+0 (used reg = )
27285 7DB6           E8         8861            call	_write_byte
27286 7DB9           83C4                   06  add	sp,*6
27287                                           !BCC_EOS
27288                                           ! 4066         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
27289                                           ! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
27290 7DBC           FF76         D4            push	-$2C[bp]
27291                                           ! Debug: list * unsigned short = const $24E (used reg = )
27292 7DBF           B8                   024E  mov	ax,#$24E
27293 7DC2           50                         push	ax
27294                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27295 7DC3           FF76         FE            push	-2[bp]
27296                                           ! Debug: func () void = write_word+0 (used reg = )
27297 7DC6           E8         8869            call	_write_word
27298 7DC9           83C4                   06  add	sp,*6
27299                                           !BCC_EOS
27300                                           ! 4067         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
27301                                           ! Debug: list int = const 0 (used reg = )
27302 7DCC           31C0                       xor	ax,ax
27303 7DCE           50                         push	ax
27304                                           ! Debug: list * unsigned short = const $250 (used reg = )
27305 7DCF           B8                   0250  mov	ax,#$250
27306 7DD2           50                         push	ax
27307                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27308 7DD3           FF76         FE            push	-2[bp]
27309                                           ! Debug: func () void = write_word+0 (used reg = )
27310 7DD6           E8         8859            call	_write_word
27311 7DD9           83C4                   06  add	sp,*6
27312                                           !BCC_EOS
27313                                           ! 4068         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
27314                                           ! Debug: list int = const $11 (used reg = )
27315 7DDC           B8                   0011  mov	ax,*$11
27316 7DDF           50                         push	ax
27317                                           ! Debug: list * unsigned char = const $252 (used reg = )
27318 7DE0           B8                   0252  mov	ax,#$252
27319 7DE3           50                         push	ax
27320                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27321 7DE4           FF76         FE            push	-2[bp]
27322                                           ! Debug: func () void = write_byte+0 (used reg = )
27323 7DE7           E8         8830            call	_write_byte
27324 7DEA           83C4                   06  add	sp,*6
27325                                           !BCC_EOS
27326                                           ! 4069         checksum=0;
27327                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27328 7DED           30C0                       xor	al,al
27329 7DEF           8846         DB            mov	-$25[bp],al
27330                                           !BCC_EOS
27331                                           ! 4070         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
27332                                           ! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
27333 7DF2           30C0                       xor	al,al
27334 7DF4           8846         DA            mov	-$26[bp],al
27335                                           !BCC_EOS
27336                                           !BCC_EOS
27337 7DF7           EB           24            jmp .5C7
27338                       00007DF9            .5C8:
27339                                           ! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
27340 7DF9           8A46         DA            mov	al,-$26[bp]
27341 7DFC           30E4                       xor	ah,ah
27342                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
27343 7DFE           05                   0244  add	ax,#$244
27344 7E01           50                         push	ax
27345                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27346 7E02           FF76         FE            push	-2[bp]
27347                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27348 7E05           E8         87EC            call	_read_byte
27349 7E08           83C4                   04  add	sp,*4
27350                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27351 7E0B           30E4                       xor	ah,ah
27352 7E0D           0246         DB            add	al,-$25[bp]
27353 7E10           80D4                   00  adc	ah,*0
27354 7E13           8846         DB            mov	-$25[bp],al
27355                                           !BCC_EOS
27356                                           ! 4071         checksum = ~checksum;
27357                       00007E16            .5C6:
27358                                           ! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
27359 7E16           8A46         DA            mov	al,-$26[bp]
27360 7E19           40                         inc	ax
27361 7E1A           8846         DA            mov	-$26[bp],al
27362                       00007E1D            .5C7:
27363                                           ! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
27364 7E1D           8A46         DA            mov	al,-$26[bp]
27365 7E20           3C                     0F  cmp	al,*$F
27366 7E22           72           D5            jb 	.5C8
27367                       00007E24            .5C9:
27368                       00007E24            .5C5:
27369                                           ! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
27370 7E24           8A46         DB            mov	al,-$25[bp]
27371 7E27           30E4                       xor	ah,ah
27372 7E29           F7D0                       not	ax
27373                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27374 7E2B           8846         DB            mov	-$25[bp],al
27375                                           !BCC_EOS
27376                                           ! 4072         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
27377                                           ! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
27378 7E2E           8A46         DB            mov	al,-$25[bp]
27379 7E31           30E4                       xor	ah,ah
27380 7E33           50                         push	ax
27381                                           ! Debug: list * unsigned char = const $253 (used reg = )
27382 7E34           B8                   0253  mov	ax,#$253
27383 7E37           50                         push	ax
27384                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27385 7E38           FF76         FE            push	-2[bp]
27386                                           ! Debug: func () void = write_byte+0 (used reg = )
27387 7E3B           E8         87DC            call	_write_byte
27388 7E3E           83C4                   06  add	sp,*6
27389                                           !BCC_EOS
27390                                           ! 4073         }
27391                                           ! 4074       if(size >= 0x42) {
27392                       00007E41            .5C0:
27393                                           ! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
27394 7E41           8B46         E0            mov	ax,-$20[bp]
27395 7E44           3D                   0042  cmp	ax,*$42
27396 7E47         0F82         023B            blo 	.5CA
27397                       00007E4B            .5CB:
27398                                           ! 4075         Bit8u channel, iface, checksum, i;
27399                                           !BCC_EOS
27400                                           ! 4076         Bit16u iobase1;
27401                                           !BCC_EOS
27402                                           ! 4077         channel = device / 2;
27403                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
27404 7E4B           8A46         FD            mov	al,-3[bp]
27405 7E4E           30E4                       xor	ah,ah
27406 7E50           D1E8                       shr	ax,*1
27407                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
27408 7E52           8846         DF            mov	-$21[bp],al
27409                                           !BCC_EOS
27410                                           ! 4078         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
27411                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
27412 7E55           8A46         DF            mov	al,-$21[bp]
27413 7E58           30E4                       xor	ah,ah
27414 7E5A           B1                     03  mov	cl,*3
27415 7E5C           D3E0                       shl	ax,cl
27416 7E5E           89C3                       mov	bx,ax
27417                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
27418                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
27419 7E60           81C3                 0122  add	bx,#$122
27420 7E64           53                         push	bx
27421                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
27422 7E65           FF76         FE            push	-2[bp]
27423                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27424 7E68           E8         8789            call	_read_byte
27425 7E6B           83C4                   04  add	sp,*4
27426                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
27427 7E6E           8846         DE            mov	-$22[bp],al
27428                                           !BCC_EOS
27429                                           ! 4079         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27430                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
27431 7E71           8A46         DF            mov	al,-$21[bp]
27432 7E74           30E4                       xor	ah,ah
27433 7E76           B1                     03  mov	cl,*3
27434 7E78           D3E0                       shl	ax,cl
27435 7E7A           89C3                       mov	bx,ax
27436                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27437                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27438 7E7C           81C3                 0124  add	bx,#$124
27439 7E80           53                         push	bx
27440                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
27441 7E81           FF76         FE            push	-2[bp]
27442                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27443 7E84           E8         8780            call	_read_word
27444 7E87           83C4                   04  add	sp,*4
27445                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
27446 7E8A           8946         DA            mov	-$26[bp],ax
27447                                           !BCC_EOS
27448                                           ! 4080         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
27449                                           ! Debug: list int = const $42 (used reg = )
27450 7E8D           B8                   0042  mov	ax,*$42
27451 7E90           50                         push	ax
27452                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
27453 7E91           8B46         0C            mov	ax,$C[bp]
27454                                           ! Debug: list unsigned int = ax+0 (used reg = )
27455 7E94           50                         push	ax
27456                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27457 7E95           FF76         06            push	6[bp]
27458                                           ! Debug: func () void = write_word+0 (used reg = )
27459 7E98           E8         8797            call	_write_word
27460 7E9B           83C4                   06  add	sp,*6
27461                                           !BCC_EOS
27462                                           ! 4081         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
27463                                           ! Debug: list unsigned int = const $BEDD (used reg = )
27464 7E9E           B8                   BEDD  mov	ax,#$BEDD
27465 7EA1           50                         push	ax
27466                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
27467 7EA2           8B46         0C            mov	ax,$C[bp]
27468                                           ! Debug: list unsigned int = ax+$1E (used reg = )
27469 7EA5           05                   001E  add	ax,*$1E
27470 7EA8           50                         push	ax
27471                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27472 7EA9           FF76         06            push	6[bp]
27473                                           ! Debug: func () void = write_word+0 (used reg = )
27474 7EAC           E8         8783            call	_write_word
27475 7EAF           83C4                   06  add	sp,*6
27476                                           !BCC_EOS
27477                                           ! 4082         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
27478                                           ! Debug: list int = const $24 (used reg = )
27479 7EB2           B8                   0024  mov	ax,*$24
27480 7EB5           50                         push	ax
27481                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
27482 7EB6           8B46         0C            mov	ax,$C[bp]
27483                                           ! Debug: list unsigned int = ax+$20 (used reg = )
27484 7EB9           05                   0020  add	ax,*$20
27485 7EBC           50                         push	ax
27486                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27487 7EBD           FF76         06            push	6[bp]
27488                                           ! Debug: func () void = write_byte+0 (used reg = )
27489 7EC0           E8         8757            call	_write_byte
27490 7EC3           83C4                   06  add	sp,*6
27491                                           !BCC_EOS
27492                                           ! 4083         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
27493                                           ! Debug: list int = const 0 (used reg = )
27494 7EC6           31C0                       xor	ax,ax
27495 7EC8           50                         push	ax
27496                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
27497 7EC9           8B46         0C            mov	ax,$C[bp]
27498                                           ! Debug: list unsigned int = ax+$21 (used reg = )
27499 7ECC           05                   0021  add	ax,*$21
27500 7ECF           50                         push	ax
27501                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27502 7ED0           FF76         06            push	6[bp]
27503                                           ! Debug: func () void = write_byte+0 (used reg = )
27504 7ED3           E8         8744            call	_write_byte
27505 7ED6           83C4                   06  add	sp,*6
27506                                           !BCC_EOS
27507                                           ! 4084         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
27508                                           ! Debug: list int = const 0 (used reg = )
27509 7ED9           31C0                       xor	ax,ax
27510 7EDB           50                         push	ax
27511                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
27512 7EDC           8B46         0C            mov	ax,$C[bp]
27513                                           ! Debug: list unsigned int = ax+$22 (used reg = )
27514 7EDF           05                   0022  add	ax,*$22
27515 7EE2           50                         push	ax
27516                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27517 7EE3           FF76         06            push	6[bp]
27518                                           ! Debug: func () void = write_word+0 (used reg = )
27519 7EE6           E8         8749            call	_write_word
27520 7EE9           83C4                   06  add	sp,*6
27521                                           !BCC_EOS
27522                                           ! 4085         if (iface==0x00) {
27523                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
27524 7EEC           8A46         DE            mov	al,-$22[bp]
27525 7EEF           84C0                       test	al,al
27526 7EF1           75           51            jne 	.5CC
27527                       00007EF3            .5CD:
27528                                           ! 4086           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
27529                                           ! Debug: list int = const $49 (used reg = )
27530 7EF3           B8                   0049  mov	ax,*$49
27531 7EF6           50                         push	ax
27532                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
27533 7EF7           8B46         0C            mov	ax,$C[bp]
27534                                           ! Debug: list unsigned int = ax+$24 (used reg = )
27535 7EFA           05                   0024  add	ax,*$24
27536 7EFD           50                         push	ax
27537                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27538 7EFE           FF76         06            push	6[bp]
27539                                           ! Debug: func () void = write_byte+0 (used reg = )
27540 7F01           E8         8716            call	_write_byte
27541 7F04           83C4                   06  add	sp,*6
27542                                           !BCC_EOS
27543                                           ! 4087           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
27544                                           ! Debug: list int = const $53 (used reg = )
27545 7F07           B8                   0053  mov	ax,*$53
27546 7F0A           50                         push	ax
27547                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
27548 7F0B           8B46         0C            mov	ax,$C[bp]
27549                                           ! Debug: list unsigned int = ax+$25 (used reg = )
27550 7F0E           05                   0025  add	ax,*$25
27551 7F11           50                         push	ax
27552                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27553 7F12           FF76         06            push	6[bp]
27554                                           ! Debug: func () void = write_byte+0 (used reg = )
27555 7F15           E8         8702            call	_write_byte
27556 7F18           83C4                   06  add	sp,*6
27557                                           !BCC_EOS
27558                                           ! 4088           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
27559                                           ! Debug: list int = const $41 (used reg = )
27560 7F1B           B8                   0041  mov	ax,*$41
27561 7F1E           50                         push	ax
27562                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
27563 7F1F           8B46         0C            mov	ax,$C[bp]
27564                                           ! Debug: list unsigned int = ax+$26 (used reg = )
27565 7F22           05                   0026  add	ax,*$26
27566 7F25           50                         push	ax
27567                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27568 7F26           FF76         06            push	6[bp]
27569                                           ! Debug: func () void = write_byte+0 (used reg = )
27570 7F29           E8         86EE            call	_write_byte
27571 7F2C           83C4                   06  add	sp,*6
27572                                           !BCC_EOS
27573                                           ! 4089           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
27574                                           ! Debug: list int = const 0 (used reg = )
27575 7F2F           31C0                       xor	ax,ax
27576 7F31           50                         push	ax
27577                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
27578 7F32           8B46         0C            mov	ax,$C[bp]
27579                                           ! Debug: list unsigned int = ax+$27 (used reg = )
27580 7F35           05                   0027  add	ax,*$27
27581 7F38           50                         push	ax
27582                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27583 7F39           FF76         06            push	6[bp]
27584                                           ! Debug: func () void = write_byte+0 (used reg = )
27585 7F3C           E8         86DB            call	_write_byte
27586 7F3F           83C4                   06  add	sp,*6
27587                                           !BCC_EOS
27588                                           ! 4090           }
27589                                           ! 4091         else {
27590 7F42           EB           00            jmp .5CE
27591                       00007F44            .5CC:
27592                                           ! 4092           }
27593                                           ! 4093         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
27594                       00007F44            .5CE:
27595                                           ! Debug: list int = const $41 (used reg = )
27596 7F44           B8                   0041  mov	ax,*$41
27597 7F47           50                         push	ax
27598                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
27599 7F48           8B46         0C            mov	ax,$C[bp]
27600                                           ! Debug: list unsigned int = ax+$28 (used reg = )
27601 7F4B           05                   0028  add	ax,*$28
27602 7F4E           50                         push	ax
27603                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27604 7F4F           FF76         06            push	6[bp]
27605                                           ! Debug: func () void = write_byte+0 (used reg = )
27606 7F52           E8         86C5            call	_write_byte
27607 7F55           83C4                   06  add	sp,*6
27608                                           !BCC_EOS
27609                                           ! 4094         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
27610                                           ! Debug: list int = const $54 (used reg = )
27611 7F58           B8                   0054  mov	ax,*$54
27612 7F5B           50                         push	ax
27613                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
27614 7F5C           8B46         0C            mov	ax,$C[bp]
27615                                           ! Debug: list unsigned int = ax+$29 (used reg = )
27616 7F5F           05                   0029  add	ax,*$29
27617 7F62           50                         push	ax
27618                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27619 7F63           FF76         06            push	6[bp]
27620                                           ! Debug: func () void = write_byte+0 (used reg = )
27621 7F66           E8         86B1            call	_write_byte
27622 7F69           83C4                   06  add	sp,*6
27623                                           !BCC_EOS
27624                                           ! 4095         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
27625                                           ! 4095 
27626                                           ! Debug: list int = const $41 (used reg = )
27627 7F6C           B8                   0041  mov	ax,*$41
27628 7F6F           50                         push	ax
27629                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
27630 7F70           8B46         0C            mov	ax,$C[bp]
27631                                           ! Debug: list unsigned int = ax+$2A (used reg = )
27632 7F73           05                   002A  add	ax,*$2A
27633 7F76           50                         push	ax
27634                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27635 7F77           FF76         06            push	6[bp]
27636                                           ! Debug: func () void = write_byte+0 (used reg = )
27637 7F7A           E8         869D            call	_write_byte
27638 7F7D           83C4                   06  add	sp,*6
27639                                           !BCC_EOS
27640                                           ! 4096         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
27641                                           ! Debug: list int = const 0 (used reg = )
27642 7F80           31C0                       xor	ax,ax
27643 7F82           50                         push	ax
27644                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
27645 7F83           8B46         0C            mov	ax,$C[bp]
27646                                           ! Debug: list unsigned int = ax+$2B (used reg = )
27647 7F86           05                   002B  add	ax,*$2B
27648 7F89           50                         push	ax
27649                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27650 7F8A           FF76         06            push	6[bp]
27651                                           ! Debug: func () void = write_byte+0 (used reg = )
27652 7F8D           E8         868A            call	_write_byte
27653 7F90           83C4                   06  add	sp,*6
27654                                           !BCC_EOS
27655                                           ! 4097         if (iface==0x00) {
27656                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
27657 7F93           8A46         DE            mov	al,-$22[bp]
27658 7F96           84C0                       test	al,al
27659 7F98           75           3E            jne 	.5CF
27660                       00007F9A            .5D0:
27661                                           ! 4098           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
27662                                           ! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
27663 7F9A           FF76         DA            push	-$26[bp]
27664                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
27665 7F9D           8B46         0C            mov	ax,$C[bp]
27666                                           ! Debug: list unsigned int = ax+$30 (used reg = )
27667 7FA0           05                   0030  add	ax,*$30
27668 7FA3           50                         push	ax
27669                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27670 7FA4           FF76         06            push	6[bp]
27671                                           ! Debug: func () void = write_word+0 (used reg = )
27672 7FA7           E8         8688            call	_write_word
27673 7FAA           83C4                   06  add	sp,*6
27674                                           !BCC_EOS
27675                                           ! 4099           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
27676                                           ! Debug: list int = const 0 (used reg = )
27677 7FAD           31C0                       xor	ax,ax
27678 7FAF           50                         push	ax
27679                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
27680 7FB0           8B46         0C            mov	ax,$C[bp]
27681                                           ! Debug: list unsigned int = ax+$32 (used reg = )
27682 7FB3           05                   0032  add	ax,*$32
27683 7FB6           50                         push	ax
27684                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27685 7FB7           FF76         06            push	6[bp]
27686                                           ! Debug: func () void = write_word+0 (used reg = )
27687 7FBA           E8         8675            call	_write_word
27688 7FBD           83C4                   06  add	sp,*6
27689                                           !BCC_EOS
27690                                           ! 4100           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
27691                                           ! Debug: list long = const 0 (used reg = )
27692 7FC0           31C0                       xor	ax,ax
27693 7FC2           31DB                       xor	bx,bx
27694 7FC4           53                         push	bx
27695 7FC5           50                         push	ax
27696                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
27697 7FC6           8B46         0C            mov	ax,$C[bp]
27698                                           ! Debug: list unsigned int = ax+$34 (used reg = )
27699 7FC9           05                   0034  add	ax,*$34
27700 7FCC           50                         push	ax
27701                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27702 7FCD           FF76         06            push	6[bp]
27703                                           ! Debug: func () void = write_dword+0 (used reg = )
27704 7FD0           E8         80C8            call	_write_dword
27705 7FD3           83C4                   08  add	sp,*8
27706                                           !BCC_EOS
27707                                           ! 4101           }
27708                                           ! 4102         else {
27709 7FD6           EB           00            jmp .5D1
27710                       00007FD8            .5CF:
27711                                           ! 4103           }
27712                                           ! 4104         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
27713                       00007FD8            .5D1:
27714                                           ! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
27715 7FD8           8A46         FD            mov	al,-3[bp]
27716 7FDB           30E4                       xor	ah,ah
27717 7FDD           24                     01  and	al,*1
27718                                           ! Debug: list unsigned char = al+0 (used reg = )
27719 7FDF           30E4                       xor	ah,ah
27720 7FE1           50                         push	ax
27721                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
27722 7FE2           8B46         0C            mov	ax,$C[bp]
27723                                           ! Debug: list unsigned int = ax+$38 (used reg = )
27724 7FE5           05                   0038  add	ax,*$38
27725 7FE8           50                         push	ax
27726                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27727 7FE9           FF76         06            push	6[bp]
27728                                           ! Debug: func () void = write_byte+0 (used reg = )
27729 7FEC           E8         862B            call	_write_byte
27730 7FEF           83C4                   06  add	sp,*6
27731                                           !BCC_EOS
27732                                           ! 4105         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
27733                                           ! Debug: list int = const 0 (used reg = )
27734 7FF2           31C0                       xor	ax,ax
27735 7FF4           50                         push	ax
27736                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
27737 7FF5           8B46         0C            mov	ax,$C[bp]
27738                                           ! Debug: list unsigned int = ax+$39 (used reg = )
27739 7FF8           05                   0039  add	ax,*$39
27740 7FFB           50                         push	ax
27741                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27742 7FFC           FF76         06            push	6[bp]
27743                                           ! Debug: func () void = write_byte+0 (used reg = )
27744 7FFF           E8         8618            call	_write_byte
27745 8002           83C4                   06  add	sp,*6
27746                                           !BCC_EOS
27747                                           ! 4106         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
27748                                           ! Debug: list int = const 0 (used reg = )
27749 8005           31C0                       xor	ax,ax
27750 8007           50                         push	ax
27751                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
27752 8008           8B46         0C            mov	ax,$C[bp]
27753                                           ! Debug: list unsigned int = ax+$3A (used reg = )
27754 800B           05                   003A  add	ax,*$3A
27755 800E           50                         push	ax
27756                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27757 800F           FF76         06            push	6[bp]
27758                                           ! Debug: func () void = write_word+0 (used reg = )
27759 8012           E8         861D            call	_write_word
27760 8015           83C4                   06  add	sp,*6
27761                                           !BCC_EOS
27762                                           ! 4107         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
27763                                           ! Debug: list long = const 0 (used reg = )
27764 8018           31C0                       xor	ax,ax
27765 801A           31DB                       xor	bx,bx
27766 801C           53                         push	bx
27767 801D           50                         push	ax
27768                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
27769 801E           8B46         0C            mov	ax,$C[bp]
27770                                           ! Debug: list unsigned int = ax+$3C (used reg = )
27771 8021           05                   003C  add	ax,*$3C
27772 8024           50                         push	ax
27773                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27774 8025           FF76         06            push	6[bp]
27775                                           ! Debug: func () void = write_dword+0 (used reg = )
27776 8028           E8         8070            call	_write_dword
27777 802B           83C4                   08  add	sp,*8
27778                                           !BCC_EOS
27779                                           ! 4108         checksum=0;
27780                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
27781 802E           30C0                       xor	al,al
27782 8030           8846         DD            mov	-$23[bp],al
27783                                           !BCC_EOS
27784                                           ! 4109         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
27785                                           ! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
27786 8033           B0                     1E  mov	al,*$1E
27787 8035           8846         DC            mov	-$24[bp],al
27788                                           !BCC_EOS
27789                                           !BCC_EOS
27790 8038           EB           25            jmp .5D4
27791                       0000803A            .5D5:
27792                                           ! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
27793 803A           8B46         0C            mov	ax,$C[bp]
27794 803D           0246         DC            add	al,-$24[bp]
27795 8040           80D4                   00  adc	ah,*0
27796                                           ! Debug: list unsigned int = ax+0 (used reg = )
27797 8043           50                         push	ax
27798                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
27799 8044           FF76         06            push	6[bp]
27800                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27801 8047           E8         85AA            call	_read_byte
27802 804A           83C4                   04  add	sp,*4
27803                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
27804 804D           30E4                       xor	ah,ah
27805 804F           0246         DD            add	al,-$23[bp]
27806 8052           80D4                   00  adc	ah,*0
27807 8055           8846         DD            mov	-$23[bp],al
27808                                           !BCC_EOS
27809                                           ! 4110         checksum = ~checksum;
27810                       00008058            .5D3:
27811                                           ! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
27812 8058           8A46         DC            mov	al,-$24[bp]
27813 805B           40                         inc	ax
27814 805C           8846         DC            mov	-$24[bp],al
27815                       0000805F            .5D4:
27816                                           ! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
27817 805F           8A46         DC            mov	al,-$24[bp]
27818 8062           3C                     40  cmp	al,*$40
27819 8064           72           D4            jb 	.5D5
27820                       00008066            .5D6:
27821                       00008066            .5D2:
27822                                           ! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
27823 8066           8A46         DD            mov	al,-$23[bp]
27824 8069           30E4                       xor	ah,ah
27825 806B           F7D0                       not	ax
27826                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
27827 806D           8846         DD            mov	-$23[bp],al
27828                                           !BCC_EOS
27829                                           ! 4111         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
27830                                           ! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
27831 8070           8A46         DD            mov	al,-$23[bp]
27832 8073           30E4                       xor	ah,ah
27833 8075           50                         push	ax
27834                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
27835 8076           8B46         0C            mov	ax,$C[bp]
27836                                           ! Debug: list unsigned int = ax+$41 (used reg = )
27837 8079           05                   0041  add	ax,*$41
27838 807C           50                         push	ax
27839                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27840 807D           FF76         06            push	6[bp]
27841                                           ! Debug: func () void = write_byte+0 (used reg = )
27842 8080           E8         8597            call	_write_byte
27843 8083           83C4                   06  add	sp,*6
27844                                           !BCC_EOS
27845                                           ! 4112         }
27846                                           ! 4113       goto int13_success;
27847                       00008086            .5CA:
27848 8086           83C4                   0C  add	sp,#..FFE9-..FFEA
27849 8089           E9         00FA            br 	.FFE9
27850                                           !BCC_EOS
27851                                           ! 4114       break;
27852 808C           E9         00C7            br 	.584
27853                                           !BCC_EOS
27854                                           ! 4115     case 0x49:
27855                                           ! 4116       AX = ((AX & 0x00ff) | ((06) << 8));
27856                       0000808F            .5D7:
27857                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27858 808F           8A46         18            mov	al,$18[bp]
27859                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
27860 8092           30E4                       xor	ah,ah
27861 8094           0D                   0600  or	ax,#$600
27862                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27863 8097           8946         18            mov	$18[bp],ax
27864                                           !BCC_EOS
27865                                           ! 4117       goto int13_fail_nostatus;
27866 809A           83C4                   0C  add	sp,#..FFE7-..FFEA
27867 809D           E9         00DA            br 	.FFE7
27868                                           !BCC_EOS
27869                                           ! 4118       break;
27870 80A0           E9         00B3            br 	.584
27871                                           !BCC_EOS
27872                                           ! 4119     case 0x4e:
27873                                           ! 4120       switch (( AX & 0x00ff )) {
27874                       000080A3            .5D8:
27875                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27876 80A3           8A46         18            mov	al,$18[bp]
27877 80A6           EB           10            jmp .5DB
27878                                           ! 4121         case 0x01:
27879                                           ! 4122         case 0x03:
27880                       000080A8            .5DC:
27881                                           ! 4123         case 0x04:
27882                       000080A8            .5DD:
27883                                           ! 4124         case 0x06:
27884                       000080A8            .5DE:
27885                                           ! 4125           goto int13_success;
27886                       000080A8            .5DF:
27887 80A8           83C4                   0C  add	sp,#..FFE9-..FFEA
27888 80AB           E9         00D8            br 	.FFE9
27889                                           !BCC_EOS
27890                                           ! 4126           break;
27891 80AE           EB           1A            jmp .5D9
27892                                           !BCC_EOS
27893                                           ! 4127         default :
27894                                           ! 4128           goto int13_fail;
27895                       000080B0            .5E0:
27896 80B0           83C4                   0C  add	sp,#..FFEB-..FFEA
27897 80B3           E9         00A3            br 	.FFEB
27898                                           !BCC_EOS
27899                                           ! 4129         }
27900                                           ! 4130       break;
27901 80B6           EB           12            jmp .5D9
27902                       000080B8            .5DB:
27903 80B8           2C                     01  sub	al,*1
27904 80BA           74           EC            je 	.5DC
27905 80BC           2C                     02  sub	al,*2
27906 80BE           74           E8            je 	.5DD
27907 80C0           2C                     01  sub	al,*1
27908 80C2           74           E4            je 	.5DE
27909 80C4           2C                     02  sub	al,*2
27910 80C6           74           E0            je 	.5DF
27911 80C8           EB           E6            jmp	.5E0
27912                       000080CA            .5D9:
27913 80CA           E9         0089            br 	.584
27914                                           !BCC_EOS
27915                                           ! 4131     case 0x02:
27916                                           ! 4132     case 0x04:
27917                       000080CD            .5E1:
27918                                           ! 4133     case 0x08:
27919                       000080CD            .5E2:
27920                                           ! 4134     case 0x0a:
27921                       000080CD            .5E3:
27922                                           ! 4135     case 0x0b:
27923                       000080CD            .5E4:
27924                                           ! 4136     case 0x18:
27925                       000080CD            .5E5:
27926                                           ! 4137     case 0x50:
27927                       000080CD            .5E6:
27928                                           ! 4138     default:
27929                       000080CD            .5E7:
27930                                           ! 4139       ;
27931                       000080CD            .5E8:
27932                                           !BCC_EOS
27933                                           ! 4140       goto int13_fail;
27934 80CD           83C4                   0C  add	sp,#..FFEB-..FFEA
27935 80D0           E9         0086            br 	.FFEB
27936                                           !BCC_EOS
27937                                           ! 4141       break;
27938 80D3           E9         0080            br 	.584
27939                                           !BCC_EOS
27940                                           ! 4142     }
27941                                           ! 4143 int13_fail:
27942 80D6           EB           7E            jmp .584
27943                       000080D8            .586:
27944 80D8           83C4                   F4  add	sp,*-$C
27945 80DB           2D                   0000  sub	ax,*0
27946 80DE           7C           ED            jl 	.5E8
27947 80E0           3D                   0018  cmp	ax,*$18
27948 80E3           77           3B            ja  	.5E9
27949 80E5           D1E0                       shl	ax,*1
27950 80E7           89C3                       mov	bx,ax
27951 80E9           2E                         seg	cs
27952 80EA           FFA7       80EE            br	.5EA[bx]
27953                       000080EE            .5EA:
27954 80EE                      7758            .word	.587
27955 80F0                      7775            .word	.592
27956 80F2                      80CD            .word	.5E1
27957 80F4                      7761            .word	.58F
27958 80F6                      80CD            .word	.5E2
27959 80F8                      7761            .word	.590
27960 80FA                      80CD            .word	.5E8
27961 80FC                      80CD            .word	.5E8
27962 80FE                      80CD            .word	.5E3
27963 8100                      7758            .word	.588
27964 8102                      80CD            .word	.5E4
27965 8104                      80CD            .word	.5E5
27966 8106                      7758            .word	.589
27967 8108                      7758            .word	.58A
27968 810A                      80CD            .word	.5E8
27969 810C                      80CD            .word	.5E8
27970 810E                      7758            .word	.58B
27971 8110                      7758            .word	.58C
27972 8112                      80CD            .word	.5E8
27973 8114                      80CD            .word	.5E8
27974 8116                      7758            .word	.58D
27975 8118                      77C6            .word	.596
27976 811A                      7758            .word	.58E
27977 811C                      80CD            .word	.5E8
27978 811E                      80CD            .word	.5E6
27979                       00008120            .5E9:
27980 8120           2D                   0041  sub	ax,*$41
27981 8123           72           A8            jb 	.5E8
27982 8125           3D                   000F  cmp	ax,*$F
27983 8128           77           29            ja  	.5EB
27984 812A           D1E0                       shl	ax,*1
27985 812C           89C3                       mov	bx,ax
27986 812E           2E                         seg	cs
27987 812F           FFA7       8133            br	.5EC[bx]
27988                       00008133            .5EC:
27989 8133                      77DA            .word	.597
27990 8135                      77FA            .word	.598
27991 8137                      7761            .word	.591
27992 8139                      77FA            .word	.599
27993 813B                      79C3            .word	.5A3
27994 813D                      7AE1            .word	.5B6
27995 813F                      77FA            .word	.59A
27996 8141                      7B4A            .word	.5BB
27997 8143                      808F            .word	.5D7
27998 8145                      80CD            .word	.5E8
27999 8147                      80CD            .word	.5E8
28000 8149                      80CD            .word	.5E8
28001 814B                      80CD            .word	.5E8
28002 814D                      80A3            .word	.5D8
28003 814F                      80CD            .word	.5E8
28004 8151                      80CD            .word	.5E7
28005                       00008153            .5EB:
28006 8153           E9         FF77            br 	.5E8
28007                       00008156            .584:
28008                       FFFFFFD2            ..FFEA	=	-$2E
28009 8156           83C4                   0C  add	sp,*$C
28010                       00008159            .FFEB:
28011                       FFFFFFDE            ..FFEB	=	-$22
28012                                           ! 4144     AX = ((AX & 0x00ff) | ((0x01) << 8));
28013                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28014 8159           8A46         18            mov	al,$18[bp]
28015                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28016 815C           30E4                       xor	ah,ah
28017 815E           0D                   0100  or	ax,#$100
28018                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28019 8161           8946         18            mov	$18[bp],ax
28020                                           !BCC_EOS
28021                                           ! 4145 int13_fail_noah:
28022                       00008164            .FFE8:
28023                       FFFFFFDE            ..FFE8	=	-$22
28024                                           ! 4146     write_byte(0x0040, 0x0074, ( AX >> 8 ));
28025                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28026 8164           8B46         18            mov	ax,$18[bp]
28027 8167           88E0                       mov	al,ah
28028 8169           30E4                       xor	ah,ah
28029                                           ! Debug: list unsigned int = ax+0 (used reg = )
28030 816B           50                         push	ax
28031                                           ! Debug: list int = const $74 (used reg = )
28032 816C           B8                   0074  mov	ax,*$74
28033 816F           50                         push	ax
28034                                           ! Debug: list int = const $40 (used reg = )
28035 8170           B8                   0040  mov	ax,*$40
28036 8173           50                         push	ax
28037                                           ! Debug: func () void = write_byte+0 (used reg = )
28038 8174           E8         84A3            call	_write_byte
28039 8177           83C4                   06  add	sp,*6
28040                                           !BCC_EOS
28041                                           ! 4147 int13_fail_nostatus:
28042                       0000817A            .FFE7:
28043                       FFFFFFDE            ..FFE7	=	-$22
28044                                           ! 4148     FLAGS |= 0x0001;
28045                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28046 817A           8B46         1E            mov	ax,$1E[bp]
28047 817D           0C                     01  or	al,*1
28048 817F           8946         1E            mov	$1E[bp],ax
28049                                           !BCC_EOS
28050                                           ! 4149     return;
28051 8182           89EC                       mov	sp,bp
28052 8184           5D                         pop	bp
28053 8185           C3                         ret
28054                                           !BCC_EOS
28055                                           ! 4150 int13_success:
28056                       00008186            .FFE9:
28057                       FFFFFFDE            ..FFE9	=	-$22
28058                                           ! 4151     AX = ((AX & 0x00ff) | ((0x00) << 8));
28059                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28060 8186           8A46         18            mov	al,$18[bp]
28061                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28062 8189           0C                     00  or	al,*0
28063                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
28064 818B           30E4                       xor	ah,ah
28065 818D           8946         18            mov	$18[bp],ax
28066                                           !BCC_EOS
28067                                           ! 4152 int13_success_noah:
28068                       00008190            .FFE6:
28069                       FFFFFFDE            ..FFE6	=	-$22
28070                                           ! 4153     write_byte(0x0040, 0x0074, 0x00);
28071                                           ! Debug: list int = const 0 (used reg = )
28072 8190           31C0                       xor	ax,ax
28073 8192           50                         push	ax
28074                                           ! Debug: list int = const $74 (used reg = )
28075 8193           B8                   0074  mov	ax,*$74
28076 8196           50                         push	ax
28077                                           ! Debug: list int = const $40 (used reg = )
28078 8197           B8                   0040  mov	ax,*$40
28079 819A           50                         push	ax
28080                                           ! Debug: func () void = write_byte+0 (used reg = )
28081 819B           E8         847C            call	_write_byte
28082 819E           83C4                   06  add	sp,*6
28083                                           !BCC_EOS
28084                                           ! 4154     FLAGS &= 0xfffe;
28085                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28086 81A1           8B46         1E            mov	ax,$1E[bp]
28087 81A4           24                     FE  and	al,#$FE
28088 81A6           8946         1E            mov	$1E[bp],ax
28089                                           !BCC_EOS
28090                                           ! 4155     return;
28091 81A9           89EC                       mov	sp,bp
28092 81AB           5D                         pop	bp
28093 81AC           C3                         ret
28094                                           !BCC_EOS
28095                                           ! 4156 }
28096                                           ! 4157   void
28097                                           ! Register BX used in function int13_cdrom
28098                                           ! 4158 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28099                                           ! 4159   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28100                                           export	_int13_eltorito
28101                       000081AD            _int13_eltorito:
28102                                           !BCC_EOS
28103                                           ! 4160 {
28104                                           ! 4161   Bit16u ebda_seg=read_word(0x0040,0x000E);
28105 81AD           55                         push	bp
28106 81AE           89E5                       mov	bp,sp
28107 81B0           4C                         dec	sp
28108 81B1           4C                         dec	sp
28109                                           ! Debug: list int = const $E (used reg = )
28110 81B2           B8                   000E  mov	ax,*$E
28111 81B5           50                         push	ax
28112                                           ! Debug: list int = const $40 (used reg = )
28113 81B6           B8                   0040  mov	ax,*$40
28114 81B9           50                         push	ax
28115                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28116 81BA           E8         844A            call	_read_word
28117 81BD           83C4                   04  add	sp,*4
28118                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28119 81C0           8946         FE            mov	-2[bp],ax
28120                                           !BCC_EOS
28121                                           ! 4162   ;
28122                                           !BCC_EOS
28123                                           ! 4163   switch (( AX >> 8 )) {
28124                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28125 81C3           8B46         16            mov	ax,$16[bp]
28126 81C6           88E0                       mov	al,ah
28127 81C8           30E4                       xor	ah,ah
28128 81CA           E9         01A8            br 	.5EF
28129                                           ! 4164     case 0x4a:
28130                                           ! 4165     case 0x4c:
28131                       000081CD            .5F0:
28132                                           ! 4166     case 0x4d:
28133                       000081CD            .5F1:
28134                                           ! 4167       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report
28135                       000081CD            .5F2:
28136                                           ! 4167 \n",AX);
28137                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
28138 81CD           FF76         16            push	$16[bp]
28139                                           ! Debug: list * char = .5F3+0 (used reg = )
28140 81D0           BB                   D116  mov	bx,#.5F3
28141 81D3           53                         push	bx
28142                                           ! Debug: list int = const 7 (used reg = )
28143 81D4           B8                   0007  mov	ax,*7
28144 81D7           50                         push	ax
28145                                           ! Debug: func () void = bios_printf+0 (used reg = )
28146 81D8           E8         8840            call	_bios_printf
28147 81DB           83C4                   06  add	sp,*6
28148                                           !BCC_EOS
28149                                           ! 4168       goto int13_fail;
28150 81DE           83C4                   00  add	sp,#..FFE4-..FFE5
28151 81E1           E9         01AF            br 	.FFE4
28152                                           !BCC_EOS
28153                                           ! 4169       break;
28154 81E4           E9         01AC            br 	.5ED
28155                                           !BCC_EOS
28156                                           ! 4170     case 0x4b:
28157                                           ! 4171       write_byte(DS,SI+0x00,0x13);
28158                       000081E7            .5F4:
28159                                           ! Debug: list int = const $13 (used reg = )
28160 81E7           B8                   0013  mov	ax,*$13
28161 81EA           50                         push	ax
28162                                           ! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
28163 81EB           8B46         0A            mov	ax,$A[bp]
28164                                           ! Debug: list unsigned int = ax+0 (used reg = )
28165 81EE           50                         push	ax
28166                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28167 81EF           FF76         04            push	4[bp]
28168                                           ! Debug: func () void = write_byte+0 (used reg = )
28169 81F2           E8         8425            call	_write_byte
28170 81F5           83C4                   06  add	sp,*6
28171                                           !BCC_EOS
28172                                           ! 4172       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
28173                                           ! Debug: list * unsigned char = const $25B (used reg = )
28174 81F8           B8                   025B  mov	ax,#$25B
28175 81FB           50                         push	ax
28176                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28177 81FC           FF76         FE            push	-2[bp]
28178                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28179 81FF           E8         83F2            call	_read_byte
28180 8202           83C4                   04  add	sp,*4
28181                                           ! Debug: list unsigned char = al+0 (used reg = )
28182 8205           30E4                       xor	ah,ah
28183 8207           50                         push	ax
28184                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
28185 8208           8B46         0A            mov	ax,$A[bp]
28186                                           ! Debug: list unsigned int = ax+1 (used reg = )
28187 820B           40                         inc	ax
28188 820C           50                         push	ax
28189                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28190 820D           FF76         04            push	4[bp]
28191                                           ! Debug: func () void = write_byte+0 (used reg = )
28192 8210           E8         8407            call	_write_byte
28193 8213           83C4                   06  add	sp,*6
28194                                           !BCC_EOS
28195                                           ! 4173       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
28196                                           ! Debug: list * unsigned char = const $25C (used reg = )
28197 8216           B8                   025C  mov	ax,#$25C
28198 8219           50                         push	ax
28199                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28200 821A           FF76         FE            push	-2[bp]
28201                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28202 821D           E8         83D4            call	_read_byte
28203 8220           83C4                   04  add	sp,*4
28204                                           ! Debug: list unsigned char = al+0 (used reg = )
28205 8223           30E4                       xor	ah,ah
28206 8225           50                         push	ax
28207                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
28208 8226           8B46         0A            mov	ax,$A[bp]
28209                                           ! Debug: list unsigned int = ax+2 (used reg = )
28210 8229           40                         inc	ax
28211 822A           40                         inc	ax
28212 822B           50                         push	ax
28213                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28214 822C           FF76         04            push	4[bp]
28215                                           ! Debug: func () void = write_byte+0 (used reg = )
28216 822F           E8         83E8            call	_write_byte
28217 8232           83C4                   06  add	sp,*6
28218                                           !BCC_EOS
28219                                           ! 4174       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
28220                                           ! Debug: list * unsigned char = const $25D (used reg = )
28221 8235           B8                   025D  mov	ax,#$25D
28222 8238           50                         push	ax
28223                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28224 8239           FF76         FE            push	-2[bp]
28225                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28226 823C           E8         83B5            call	_read_byte
28227 823F           83C4                   04  add	sp,*4
28228                                           ! Debug: list unsigned char = al+0 (used reg = )
28229 8242           30E4                       xor	ah,ah
28230 8244           50                         push	ax
28231                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
28232 8245           8B46         0A            mov	ax,$A[bp]
28233                                           ! Debug: list unsigned int = ax+3 (used reg = )
28234 8248           05                   0003  add	ax,*3
28235 824B           50                         push	ax
28236                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28237 824C           FF76         04            push	4[bp]
28238                                           ! Debug: func () void = write_byte+0 (used reg = )
28239 824F           E8         83C8            call	_write_byte
28240 8252           83C4                   06  add	sp,*6
28241                                           !BCC_EOS
28242                                           ! 4175       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
28243                                           ! Debug: list * unsigned long = const $260 (used reg = )
28244 8255           B8                   0260  mov	ax,#$260
28245 8258           50                         push	ax
28246                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28247 8259           FF76         FE            push	-2[bp]
28248                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
28249 825C           E8         7E24            call	_read_dword
28250 825F           89D3                       mov	bx,dx
28251 8261           83C4                   04  add	sp,*4
28252                                           ! Debug: list unsigned long = bx+0 (used reg = )
28253 8264           53                         push	bx
28254 8265           50                         push	ax
28255                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
28256 8266           8B46         0A            mov	ax,$A[bp]
28257                                           ! Debug: list unsigned int = ax+4 (used reg = )
28258 8269           05                   0004  add	ax,*4
28259 826C           50                         push	ax
28260                                           ! Debug: list unsigned short DS = [S+$A+2] (used reg = )
28261 826D           FF76         04            push	4[bp]
28262                                           ! Debug: func () void = write_dword+0 (used reg = )
28263 8270           E8         7E28            call	_write_dword
28264 8273           83C4                   08  add	sp,*8
28265                                           !BCC_EOS
28266                                           ! 4176       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
28267                                           ! Debug: list * unsigned short = const $25E (used reg = )
28268 8276           B8                   025E  mov	ax,#$25E
28269 8279           50                         push	ax
28270                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28271 827A           FF76         FE            push	-2[bp]
28272                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28273 827D           E8         8387            call	_read_word
28274 8280           83C4                   04  add	sp,*4
28275                                           ! Debug: list unsigned short = ax+0 (used reg = )
28276 8283           50                         push	ax
28277                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
28278 8284           8B46         0A            mov	ax,$A[bp]
28279                                           ! Debug: list unsigned int = ax+8 (used reg = )
28280 8287           05                   0008  add	ax,*8
28281 828A           50                         push	ax
28282                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28283 828B           FF76         04            push	4[bp]
28284                                           ! Debug: func () void = write_word+0 (used reg = )
28285 828E           E8         83A1            call	_write_word
28286 8291           83C4                   06  add	sp,*6
28287                                           !BCC_EOS
28288                                           ! 4177       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
28289                                           ! Debug: list * unsigned short = const $264 (used reg = )
28290 8294           B8                   0264  mov	ax,#$264
28291 8297           50                         push	ax
28292                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28293 8298           FF76         FE            push	-2[bp]
28294                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28295 829B           E8         8369            call	_read_word
28296 829E           83C4                   04  add	sp,*4
28297                                           ! Debug: list unsigned short = ax+0 (used reg = )
28298 82A1           50                         push	ax
28299                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
28300 82A2           8B46         0A            mov	ax,$A[bp]
28301                                           ! Debug: list unsigned int = ax+$A (used reg = )
28302 82A5           05                   000A  add	ax,*$A
28303 82A8           50                         push	ax
28304                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28305 82A9           FF76         04            push	4[bp]
28306                                           ! Debug: func () void = write_word+0 (used reg = )
28307 82AC           E8         8383            call	_write_word
28308 82AF           83C4                   06  add	sp,*6
28309                                           !BCC_EOS
28310                                           ! 4178       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
28311                                           ! Debug: list * unsigned short = const $266 (used reg = )
28312 82B2           B8                   0266  mov	ax,#$266
28313 82B5           50                         push	ax
28314                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28315 82B6           FF76         FE            push	-2[bp]
28316                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28317 82B9           E8         834B            call	_read_word
28318 82BC           83C4                   04  add	sp,*4
28319                                           ! Debug: list unsigned short = ax+0 (used reg = )
28320 82BF           50                         push	ax
28321                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
28322 82C0           8B46         0A            mov	ax,$A[bp]
28323                                           ! Debug: list unsigned int = ax+$C (used reg = )
28324 82C3           05                   000C  add	ax,*$C
28325 82C6           50                         push	ax
28326                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28327 82C7           FF76         04            push	4[bp]
28328                                           ! Debug: func () void = write_word+0 (used reg = )
28329 82CA           E8         8365            call	_write_word
28330 82CD           83C4                   06  add	sp,*6
28331                                           !BCC_EOS
28332                                           ! 4179       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
28333                                           ! Debug: list * unsigned short = const $268 (used reg = )
28334 82D0           B8                   0268  mov	ax,#$268
28335 82D3           50                         push	ax
28336                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28337 82D4           FF76         FE            push	-2[bp]
28338                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28339 82D7           E8         832D            call	_read_word
28340 82DA           83C4                   04  add	sp,*4
28341                                           ! Debug: list unsigned short = ax+0 (used reg = )
28342 82DD           50                         push	ax
28343                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
28344 82DE           8B46         0A            mov	ax,$A[bp]
28345                                           ! Debug: list unsigned int = ax+$E (used reg = )
28346 82E1           05                   000E  add	ax,*$E
28347 82E4           50                         push	ax
28348                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28349 82E5           FF76         04            push	4[bp]
28350                                           ! Debug: func () void = write_word+0 (used reg = )
28351 82E8           E8         8347            call	_write_word
28352 82EB           83C4                   06  add	sp,*6
28353                                           !BCC_EOS
28354                                           ! 4180       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
28355                                           ! Debug: list * unsigned short = const $26C (used reg = )
28356 82EE           B8                   026C  mov	ax,#$26C
28357 82F1           50                         push	ax
28358                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28359 82F2           FF76         FE            push	-2[bp]
28360                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28361 82F5           E8         82FC            call	_read_byte
28362 82F8           83C4                   04  add	sp,*4
28363                                           ! Debug: list unsigned char = al+0 (used reg = )
28364 82FB           30E4                       xor	ah,ah
28365 82FD           50                         push	ax
28366                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
28367 82FE           8B46         0A            mov	ax,$A[bp]
28368                                           ! Debug: list unsigned int = ax+$10 (used reg = )
28369 8301           05                   0010  add	ax,*$10
28370 8304           50                         push	ax
28371                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28372 8305           FF76         04            push	4[bp]
28373                                           ! Debug: func () void = write_byte+0 (used reg = )
28374 8308           E8         830F            call	_write_byte
28375 830B           83C4                   06  add	sp,*6
28376                                           !BCC_EOS
28377                                           ! 4181       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
28378                                           ! Debug: list * unsigned short = const $26E (used reg = )
28379 830E           B8                   026E  mov	ax,#$26E
28380 8311           50                         push	ax
28381                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28382 8312           FF76         FE            push	-2[bp]
28383                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28384 8315           E8         82DC            call	_read_byte
28385 8318           83C4                   04  add	sp,*4
28386                                           ! Debug: list unsigned char = al+0 (used reg = )
28387 831B           30E4                       xor	ah,ah
28388 831D           50                         push	ax
28389                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
28390 831E           8B46         0A            mov	ax,$A[bp]
28391                                           ! Debug: list unsigned int = ax+$11 (used reg = )
28392 8321           05                   0011  add	ax,*$11
28393 8324           50                         push	ax
28394                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28395 8325           FF76         04            push	4[bp]
28396                                           ! Debug: func () void = write_byte+0 (used reg = )
28397 8328           E8         82EF            call	_write_byte
28398 832B           83C4                   06  add	sp,*6
28399                                           !BCC_EOS
28400                                           ! 4182       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
28401                                           ! Debug: list * unsigned short = const $26A (used reg = )
28402 832E           B8                   026A  mov	ax,#$26A
28403 8331           50                         push	ax
28404                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28405 8332           FF76         FE            push	-2[bp]
28406                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28407 8335           E8         82BC            call	_read_byte
28408 8338           83C4                   04  add	sp,*4
28409                                           ! Debug: list unsigned char = al+0 (used reg = )
28410 833B           30E4                       xor	ah,ah
28411 833D           50                         push	ax
28412                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
28413 833E           8B46         0A            mov	ax,$A[bp]
28414                                           ! Debug: list unsigned int = ax+$12 (used reg = )
28415 8341           05                   0012  add	ax,*$12
28416 8344           50                         push	ax
28417                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28418 8345           FF76         04            push	4[bp]
28419                                           ! Debug: func () void = write_byte+0 (used reg = )
28420 8348           E8         82CF            call	_write_byte
28421 834B           83C4                   06  add	sp,*6
28422                                           !BCC_EOS
28423                                           ! 4183       if(( AX & 0x00ff ) == 0x00) {
28424                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28425 834E           8A46         16            mov	al,$16[bp]
28426                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
28427 8351           84C0                       test	al,al
28428 8353           75           10            jne 	.5F5
28429                       00008355            .5F6:
28430                                           ! 4184         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
28431                                           ! Debug: list int = const 0 (used reg = )
28432 8355           31C0                       xor	ax,ax
28433 8357           50                         push	ax
28434                                           ! Debug: list * unsigned char = const $25A (used reg = )
28435 8358           B8                   025A  mov	ax,#$25A
28436 835B           50                         push	ax
28437                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
28438 835C           FF76         FE            push	-2[bp]
28439                                           ! Debug: func () void = write_byte+0 (used reg = )
28440 835F           E8         82B8            call	_write_byte
28441 8362           83C4                   06  add	sp,*6
28442                                           !BCC_EOS
28443                                           ! 4185         }
28444                                           ! 4186       goto int13_success;
28445                       00008365            .5F5:
28446 8365           83C4                   00  add	sp,#..FFE3-..FFE5
28447 8368           EB           56            jmp .FFE3
28448                                           !BCC_EOS
28449                                           ! 4187       break;
28450 836A           EB           27            jmp .5ED
28451                                           !BCC_EOS
28452                                           ! 4188     default:
28453                                           ! 4189       ;
28454                       0000836C            .5F7:
28455                                           !BCC_EOS
28456                                           ! 4190       goto int13_fail;
28457 836C           83C4                   00  add	sp,#..FFE4-..FFE5
28458 836F           EB           22            jmp .FFE4
28459                                           !BCC_EOS
28460                                           ! 4191       break;
28461 8371           EB           20            jmp .5ED
28462                                           !BCC_EOS
28463                                           ! 4192     }
28464                                           ! 4193 int13_fail:
28465 8373           EB           1E            jmp .5ED
28466                       00008375            .5EF:
28467 8375           2D                   004A  sub	ax,*$4A
28468 8378         0F84         FE51            beq 	.5F0
28469 837C           2D                   0001  sub	ax,*1
28470 837F         0F84         FE64            beq 	.5F4
28471 8383           2D                   0001  sub	ax,*1
28472 8386         0F84         FE43            beq 	.5F1
28473 838A           2D                   0001  sub	ax,*1
28474 838D         0F84         FE3C            beq 	.5F2
28475 8391           EB           D9            jmp	.5F7
28476                       00008393            .5ED:
28477                       FFFFFFFC            ..FFE5	=	-4
28478                       00008393            .FFE4:
28479                       FFFFFFFC            ..FFE4	=	-4
28480                                           ! 4194     AX = ((AX & 0x00ff) | ((0x01) << 8));
28481                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28482 8393           8A46         16            mov	al,$16[bp]
28483                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28484 8396           30E4                       xor	ah,ah
28485 8398           0D                   0100  or	ax,#$100
28486                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
28487 839B           8946         16            mov	$16[bp],ax
28488                                           !BCC_EOS
28489                                           ! 4195     write_byte(0x0040, 0x0074, ( AX >> 8 ));
28490                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28491 839E           8B46         16            mov	ax,$16[bp]
28492 83A1           88E0                       mov	al,ah
28493 83A3           30E4                       xor	ah,ah
28494                                           ! Debug: list unsigned int = ax+0 (used reg = )
28495 83A5           50                         push	ax
28496                                           ! Debug: list int = const $74 (used reg = )
28497 83A6           B8                   0074  mov	ax,*$74
28498 83A9           50                         push	ax
28499                                           ! Debug: list int = const $40 (used reg = )
28500 83AA           B8                   0040  mov	ax,*$40
28501 83AD           50                         push	ax
28502                                           ! Debug: func () void = write_byte+0 (used reg = )
28503 83AE           E8         8269            call	_write_byte
28504 83B1           83C4                   06  add	sp,*6
28505                                           !BCC_EOS
28506                                           ! 4196     FLAGS |= 0x0001;
28507                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
28508 83B4           8B46         1C            mov	ax,$1C[bp]
28509 83B7           0C                     01  or	al,*1
28510 83B9           8946         1C            mov	$1C[bp],ax
28511                                           !BCC_EOS
28512                                           ! 4197     return;
28513 83BC           89EC                       mov	sp,bp
28514 83BE           5D                         pop	bp
28515 83BF           C3                         ret
28516                                           !BCC_EOS
28517                                           ! 4198 int13_success:
28518                       000083C0            .FFE3:
28519                       FFFFFFFC            ..FFE3	=	-4
28520                                           ! 4199     AX = ((AX & 0x00ff) | ((0x00) << 8));
28521                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28522 83C0           8A46         16            mov	al,$16[bp]
28523                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28524 83C3           0C                     00  or	al,*0
28525                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
28526 83C5           30E4                       xor	ah,ah
28527 83C7           8946         16            mov	$16[bp],ax
28528                                           !BCC_EOS
28529                                           ! 4200     write_byte(0x0040, 0x0074, 0x00);
28530                                           ! Debug: list int = const 0 (used reg = )
28531 83CA           31C0                       xor	ax,ax
28532 83CC           50                         push	ax
28533                                           ! Debug: list int = const $74 (used reg = )
28534 83CD           B8                   0074  mov	ax,*$74
28535 83D0           50                         push	ax
28536                                           ! Debug: list int = const $40 (used reg = )
28537 83D1           B8                   0040  mov	ax,*$40
28538 83D4           50                         push	ax
28539                                           ! Debug: func () void = write_byte+0 (used reg = )
28540 83D5           E8         8242            call	_write_byte
28541 83D8           83C4                   06  add	sp,*6
28542                                           !BCC_EOS
28543                                           ! 4201     FLAGS &= 0xfffe;
28544                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
28545 83DB           8B46         1C            mov	ax,$1C[bp]
28546 83DE           24                     FE  and	al,#$FE
28547 83E0           8946         1C            mov	$1C[bp],ax
28548                                           !BCC_EOS
28549                                           ! 4202     return;
28550 83E3           89EC                       mov	sp,bp
28551 83E5           5D                         pop	bp
28552 83E6           C3                         ret
28553                                           !BCC_EOS
28554                                           ! 4203 }
28555                                           ! 4204   void
28556                                           ! Register BX used in function int13_eltorito
28557                                           ! 4205 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28558                                           ! 4206   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28559                                           export	_int13_cdemu
28560                       000083E7            _int13_cdemu:
28561                                           !BCC_EOS
28562                                           ! 4207 {
28563                                           ! 4208   Bit16u ebda_seg=read_word(0x0040,0x000E);
28564 83E7           55                         push	bp
28565 83E8           89E5                       mov	bp,sp
28566 83EA           4C                         dec	sp
28567 83EB           4C                         dec	sp
28568                                           ! Debug: list int = const $E (used reg = )
28569 83EC           B8                   000E  mov	ax,*$E
28570 83EF           50                         push	ax
28571                                           ! Debug: list int = const $40 (used reg = )
28572 83F0           B8                   0040  mov	ax,*$40
28573 83F3           50                         push	ax
28574                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28575 83F4           E8         8210            call	_read_word
28576 83F7           83C4                   04  add	sp,*4
28577                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28578 83FA           8946         FE            mov	-2[bp],ax
28579                                           !BCC_EOS
28580                                           ! 4209   Bit8u device, status;
28581                                           !BCC_EOS
28582                                           ! 4210   Bit16u vheads, vspt, vcylinders;
28583                                           !BCC_EOS
28584                                           ! 4211   Bit16u head, sector, cylinder, nbsectors;
28585                                           !BCC_EOS
28586                                           ! 4212   Bit32u vlba, ilba, slba, elba;
28587                                           !BCC_EOS
28588                                           ! 4213   Bit16u before, segment, offset;
28589                                           !BCC_EOS
28590                                           ! 4214   Bit8u atacmd[12];
28591                                           !BCC_EOS
28592                                           ! 4215   ;
28593 83FD           83C4                   CE  add	sp,*-$32
28594                                           !BCC_EOS
28595                                           ! 4216   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
28596                                           ! Debug: list * unsigned char = const $25D (used reg = )
28597 8400           B8                   025D  mov	ax,#$25D
28598 8403           50                         push	ax
28599                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28600 8404           FF76         FE            push	-2[bp]
28601                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28602 8407           E8         81EA            call	_read_byte
28603 840A           83C4                   04  add	sp,*4
28604                                           ! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
28605 840D           30E4                       xor	ah,ah
28606 840F           D1E0                       shl	ax,*1
28607                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
28608 8411           8846         FD            mov	-3[bp],al
28609                                           !BCC_EOS
28610                                           ! 4217   device += r
28611                                           ! 4217 ead_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
28612                                           ! Debug: list * unsigned short = const $25E (used reg = )
28613 8414           B8                   025E  mov	ax,#$25E
28614 8417           50                         push	ax
28615                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28616 8418           FF76         FE            push	-2[bp]
28617                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28618 841B           E8         81D6            call	_read_byte
28619 841E           83C4                   04  add	sp,*4
28620                                           ! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
28621 8421           30E4                       xor	ah,ah
28622 8423           0246         FD            add	al,-3[bp]
28623 8426           80D4                   00  adc	ah,*0
28624 8429           8846         FD            mov	-3[bp],al
28625                                           !BCC_EOS
28626                                           ! 4218   write_byte(0x0040, 0x0074, 0x00);
28627                                           ! Debug: list int = const 0 (used reg = )
28628 842C           31C0                       xor	ax,ax
28629 842E           50                         push	ax
28630                                           ! Debug: list int = const $74 (used reg = )
28631 842F           B8                   0074  mov	ax,*$74
28632 8432           50                         push	ax
28633                                           ! Debug: list int = const $40 (used reg = )
28634 8433           B8                   0040  mov	ax,*$40
28635 8436           50                         push	ax
28636                                           ! Debug: func () void = write_byte+0 (used reg = )
28637 8437           E8         81E0            call	_write_byte
28638 843A           83C4                   06  add	sp,*6
28639                                           !BCC_EOS
28640                                           ! 4219   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
28641                                           ! 4220    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
28642                                           ! Debug: list * unsigned char = const $25A (used reg = )
28643 843D           B8                   025A  mov	ax,#$25A
28644 8440           50                         push	ax
28645                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28646 8441           FF76         FE            push	-2[bp]
28647                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28648 8444           E8         81AD            call	_read_byte
28649 8447           83C4                   04  add	sp,*4
28650                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
28651 844A           84C0                       test	al,al
28652 844C           74           19            je  	.5F9
28653                       0000844E            .5FA:
28654                                           ! Debug: expression subtree swapping
28655                                           ! Debug: list * unsigned char = const $25C (used reg = )
28656 844E           B8                   025C  mov	ax,#$25C
28657 8451           50                         push	ax
28658                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28659 8452           FF76         FE            push	-2[bp]
28660                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28661 8455           E8         819C            call	_read_byte
28662 8458           83C4                   04  add	sp,*4
28663 845B           50                         push	ax
28664                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
28665 845C           8A46         12            mov	al,$12[bp]
28666                                           ! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
28667 845F           3A46         CA            cmp	al,-$36[bp]
28668 8462           8D66         CC            lea	sp,-$34[bp]
28669 8465           74           06            je  	.5F8
28670                       00008467            .5F9:
28671                                           ! 4221     ;
28672                                           !BCC_EOS
28673                                           ! 4222     goto int13_fail;
28674 8467           83C4                   00  add	sp,#..FFE2+$36
28675 846A           E9         0531            br 	.FFE2
28676                                           !BCC_EOS
28677                                           ! 4223     }
28678                                           ! 4224   switch (( AX >> 8 )) {
28679                       0000846D            .5F8:
28680                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
28681 846D           8B46         16            mov	ax,$16[bp]
28682 8470           88E0                       mov	al,ah
28683 8472           30E4                       xor	ah,ah
28684 8474           E9         04AC            br 	.5FD
28685                                           ! 4225     case 0x00:
28686                                           ! 4226     case 0x09:
28687                       00008477            .5FE:
28688                                           ! 4227     case 0x0c:
28689                       00008477            .5FF:
28690                                           ! 4228     case 0x0d:
28691                       00008477            .600:
28692                                           ! 4229     case 0x10:
28693                       00008477            .601:
28694                                           ! 4230     case 0x11:
28695                       00008477            .602:
28696                                           ! 4231     case 0x14:
28697                       00008477            .603:
28698                                           ! 4232     case 0x16:
28699                       00008477            .604:
28700                                           ! 4233       goto int13_success;
28701                       00008477            .605:
28702 8477           83C4                   00  add	sp,#..FFE0-..FFE1
28703 847A           E9         054E            br 	.FFE0
28704                                           !BCC_EOS
28705                                           ! 4234       break;
28706 847D           E9         051E            br 	.5FB
28707                                           !BCC_EOS
28708                                           ! 4235     case 0x03:
28709                                           ! 4236     case 0x05:
28710                       00008480            .606:
28711                                           ! 4237       AX = ((AX & 0x00ff) | ((0x03) << 8));
28712                       00008480            .607:
28713                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
28714 8480           8A46         16            mov	al,$16[bp]
28715                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
28716 8483           30E4                       xor	ah,ah
28717 8485           0D                   0300  or	ax,#$300
28718                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
28719 8488           8946         16            mov	$16[bp],ax
28720                                           !BCC_EOS
28721                                           ! 4238       goto int13_fail_noah;
28722 848B           83C4                   00  add	sp,#..FFDF-..FFE1
28723 848E           E9         0518            br 	.FFDF
28724                                           !BCC_EOS
28725                                           ! 4239       break;
28726 8491           E9         050A            br 	.5FB
28727                                           !BCC_EOS
28728                                           ! 4240     case 0x01:
28729                                           ! 4241       status=read_byte(0x0040, 0x0074);
28730                       00008494            .608:
28731                                           ! Debug: list int = const $74 (used reg = )
28732 8494           B8                   0074  mov	ax,*$74
28733 8497           50                         push	ax
28734                                           ! Debug: list int = const $40 (used reg = )
28735 8498           B8                   0040  mov	ax,*$40
28736 849B           50                         push	ax
28737                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28738 849C           E8         8155            call	_read_byte
28739 849F           83C4                   04  add	sp,*4
28740                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
28741 84A2           8846         FC            mov	-4[bp],al
28742                                           !BCC_EOS
28743                                           ! 4242       AX = ((AX & 0x00ff) | ((status) << 8));
28744                                           ! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
28745 84A5           8A46         FC            mov	al,-4[bp]
28746 84A8           30E4                       xor	ah,ah
28747 84AA           88C4                       mov	ah,al
28748 84AC           30C0                       xor	al,al
28749 84AE           50                         push	ax
28750                                           ! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
28751 84AF           8A46         16            mov	al,$16[bp]
28752                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
28753 84B2           30E4                       xor	ah,ah
28754 84B4           0B46         CA            or	ax,0+..FFE1[bp]
28755 84B7           44                         inc	sp
28756 84B8           44                         inc	sp
28757                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
28758 84B9           8946         16            mov	$16[bp],ax
28759                                           !BCC_EOS
28760                                           ! 4243       write_byte(0x0040, 0x0074, 0);
28761                                           ! Debug: list int = const 0 (used reg = )
28762 84BC           31C0                       xor	ax,ax
28763 84BE           50                         push	ax
28764                                           ! Debug: list int = const $74 (used reg = )
28765 84BF           B8                   0074  mov	ax,*$74
28766 84C2           50                         push	ax
28767                                           ! Debug: list int = const $40 (used reg = )
28768 84C3           B8                   0040  mov	ax,*$40
28769 84C6           50                         push	ax
28770                                           ! Debug: func () void = write_byte+0 (used reg = )
28771 84C7           E8         8150            call	_write_byte
28772 84CA           83C4                   06  add	sp,*6
28773                                           !BCC_EOS
28774                                           ! 4244       if (status) goto int13_fail_nostatus;
28775 84CD           8A46         FC            mov	al,-4[bp]
28776 84D0           84C0                       test	al,al
28777 84D2           74           08            je  	.609
28778                       000084D4            .60A:
28779 84D4           83C4                   00  add	sp,#..FFDE-..FFE1
28780 84D7           E9         04E5            br 	.FFDE
28781                                           !BCC_EOS
28782                                           ! 4245       else goto int13_success_noah;
28783 84DA           EB           06            jmp .60B
28784                       000084DC            .609:
28785 84DC           83C4                   00  add	sp,#..FFDD-..FFE1
28786 84DF           E9         04F3            br 	.FFDD
28787                                           !BCC_EOS
28788                                           ! 4246       break;
28789                       000084E2            .60B:
28790 84E2           E9         04B9            br 	.5FB
28791                                           !BCC_EOS
28792                                           ! 4247     case 0x02:
28793                                           ! 4248     case 0x04:
28794                       000084E5            .60C:
28795                                           ! 4249       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
28796                       000084E5            .60D:
28797                                           ! Debug: list * unsigned short = const $26E (used reg = )
28798 84E5           B8                   026E  mov	ax,#$26E
28799 84E8           50                         push	ax
28800                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28801 84E9           FF76         FE            push	-2[bp]
28802                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28803 84EC           E8         8118            call	_read_word
28804 84EF           83C4                   04  add	sp,*4
28805                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
28806 84F2           8946         F8            mov	-8[bp],ax
28807                                           !BCC_EOS
28808                                           ! 4250       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
28809                                           ! Debug: list * unsigned short = const $26C (used reg = )
28810 84F5           B8                   026C  mov	ax,#$26C
28811 84F8           50                         push	ax
28812                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28813 84F9           FF76         FE            push	-2[bp]
28814                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28815 84FC           E8         8108            call	_read_word
28816 84FF           83C4                   04  add	sp,*4
28817                                           ! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
28818 8502           8946         F6            mov	-$A[bp],ax
28819                                           !BCC_EOS
28820                                           ! 4251       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
28821                                           ! Debug: list * unsigned short = const $26A (used reg = )
28822 8505           B8                   026A  mov	ax,#$26A
28823 8508           50                         push	ax
28824                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28825 8509           FF76         FE            push	-2[bp]
28826                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28827 850C           E8         80F8            call	_read_word
28828 850F           83C4                   04  add	sp,*4
28829                                           ! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
28830 8512           8946         FA            mov	-6[bp],ax
28831                                           !BCC_EOS
28832                                           ! 4252       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
28833                                           ! Debug: list * unsigned long = const $260 (used reg = )
28834 8515           B8                   0260  mov	ax,#$260
28835 8518           50                         push	ax
28836                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28837 8519           FF76         FE            push	-2[bp]
28838                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
28839 851C           E8         7B64            call	_read_dword
28840 851F           89D3                       mov	bx,dx
28841 8521           83C4                   04  add	sp,*4
28842                                           ! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
28843 8524           8946         E6            mov	-$1A[bp],ax
28844 8527           895E         E8            mov	-$18[bp],bx
28845                                           !BCC_EOS
28846                                           ! 4253       sector = ( CX & 0x00ff ) & 0x003f;
28847                                           ! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
28848 852A           8A46         14            mov	al,$14[bp]
28849                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
28850 852D           24                     3F  and	al,*$3F
28851                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
28852 852F           30E4                       xor	ah,ah
28853 8531           8946         F2            mov	-$E[bp],ax
28854                                           !BCC_EOS
28855                                           ! 4254       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
28856                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
28857 8534           8B46         14            mov	ax,$14[bp]
28858 8537           88E0                       mov	al,ah
28859 8539           30E4                       xor	ah,ah
28860 853B           50                         push	ax
28861                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
28862 853C           8A46         14            mov	al,$14[bp]
28863                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
28864 853F           24                     C0  and	al,#$C0
28865                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
28866 8541           30E4                       xor	ah,ah
28867 8543           D1E0                       shl	ax,*1
28868 8545           D1E0                       shl	ax,*1
28869                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
28870 8547           0B46         CA            or	ax,0+..FFE1[bp]
28871 854A           44                         inc	sp
28872 854B           44                         inc	sp
28873                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
28874 854C           8946         F0            mov	-$10[bp],ax
28875                                           !BCC_EOS
28876                                           ! 4255       head = ( DX >> 8 );
28877                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
28878 854F           8B46         12            mov	ax,$12[bp]
28879 8552           88E0                       mov	al,ah
28880 8554           30E4                       xor	ah,ah
28881                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
28882 8556           8946         F4            mov	-$C[bp],ax
28883                                           !BCC_EOS
28884                                           ! 4256       nbsectors = ( AX & 0x00ff );
28885                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
28886 8559           8A46         16            mov	al,$16[bp]
28887                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
28888 855C           30E4                       xor	ah,ah
28889 855E           8946         EE            mov	-$12[bp],ax
28890                                           !BCC_EOS
28891                                           ! 4257       segment = ES;
28892                                           ! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
28893 8561           8B46         06            mov	ax,6[bp]
28894 8564           8946         DA            mov	-$26[bp],ax
28895                                           !BCC_EOS
28896                                           ! 4258       offset = BX;
28897                                           ! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
28898 8567           8B46         10            mov	ax,$10[bp]
28899 856A           8946         D8            mov	-$28[bp],ax
28900                                           !BCC_EOS
28901                                           ! 4259       if(nbsectors==0) goto int13_success;
28902                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
28903 856D           8B46         EE            mov	ax,-$12[bp]
28904 8570           85C0                       test	ax,ax
28905 8572           75           06            jne 	.60E
28906                       00008574            .60F:
28907 8574           83C4                   00  add	sp,#..FFE0-..FFE1
28908 8577           E9         0451            br 	.FFE0
28909                                           !BCC_EOS
28910                                           ! 4260       if ((sector > vspt)
28911                       0000857A            .60E:
28912                                           ! 4261        || (cylinder >= vcylinders)
28913                                           ! 4262        || (head >= vheads)) {
28914                                           ! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
28915 857A           8B46         F2            mov	ax,-$E[bp]
28916 857D           3B46         F8            cmp	ax,-8[bp]
28917 8580           77           10            ja  	.611
28918                       00008582            .613:
28919                                           ! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
28920 8582           8B46         F0            mov	ax,-$10[bp]
28921 8585           3B46         F6            cmp	ax,-$A[bp]
28922 8588           73           08            jae 	.611
28923                       0000858A            .612:
28924                                           ! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
28925 858A           8B46         F4            mov	ax,-$C[bp]
28926 858D           3B46         FA            cmp	ax,-6[bp]
28927 8590           72           06            jb  	.610
28928                       00008592            .611:
28929                                           ! 4263         goto int13_fail;
28930 8592           83C4                   00  add	sp,#..FFE2-..FFE1
28931 8595           E9         0406            br 	.FFE2
28932                                           !BCC_EOS
28933                                           ! 4264         }
28934                                           ! 4265       if (( AX >> 8 ) == 0x04) goto int13_success;
28935                       00008598            .610:
28936                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
28937 8598           8B46         16            mov	ax,$16[bp]
28938 859B           88E0                       mov	al,ah
28939 859D           30E4                       xor	ah,ah
28940                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
28941 859F           3D                   0004  cmp	ax,*4
28942 85A2           75           06            jne 	.614
28943                       000085A4            .615:
28944 85A4           83C4                   00  add	sp,#..FFE0-..FFE1
28945 85A7           E9         0421            br 	.FFE0
28946                                           !BCC_EOS
28947                                           ! 4266       segment = ES+(BX / 16);
28948                       000085AA            .614:
28949                                           ! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
28950 85AA           8B46         10            mov	ax,$10[bp]
28951 85AD           B1                     04  mov	cl,*4
28952 85AF           D3E8                       shr	ax,cl
28953                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
28954                                           ! Debug: expression subtree swapping
28955 85B1           0346         06            add	ax,6[bp]
28956                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
28957 85B4           8946         DA            mov	-$26[bp],ax
28958                                           !BCC_EOS
28959                                           ! 4267       offset = BX % 16;
28960                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
28961 85B7           8B46         10            mov	ax,$10[bp]
28962 85BA           24                     0F  and	al,*$F
28963                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
28964 85BC           30E4                       xor	ah,ah
28965 85BE           8946         D8            mov	-$28[bp],ax
28966                                           !BCC_EOS
28967                                           ! 4268       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
28968                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
28969 85C1           8B46         F2            mov	ax,-$E[bp]
28970                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
28971 85C4           48                         dec	ax
28972 85C5           31DB                       xor	bx,bx
28973 85C7           53                         push	bx
28974 85C8           50                         push	ax
28975                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
28976 85C9           8B46         F8            mov	ax,-8[bp]
28977 85CC           31DB                       xor	bx,bx
28978 85CE           53                         push	bx
28979 85CF           50                         push	ax
28980                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
28981 85D0           8B46         F4            mov	ax,-$C[bp]
28982 85D3           31DB                       xor	bx,bx
28983 85D5           53                         push	bx
28984 85D6           50                         push	ax
28985                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
28986 85D7           8B46         FA            mov	ax,-6[bp]
28987 85DA           31DB                       xor	bx,bx
28988 85DC           53                         push	bx
28989 85DD           50                         push	ax
28990                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
28991 85DE           8B46         F0            mov	ax,-$10[bp]
28992 85E1           31DB                       xor	bx,bx
28993                                           ! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
28994 85E3           8D7E         BC            lea	di,-$E+..FFE1[bp]
28995 85E6           E8         7B00            call	lmulul
28996 85E9           83C4                   04  add	sp,*4
28997                                           ! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
28998 85EC           8D7E         C0            lea	di,-$A+..FFE1[bp]
28999 85EF           E8         7AD1            call	laddul
29000 85F2           83C4                   04  add	sp,*4
29001                                           ! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
29002 85F5           8D7E         C4            lea	di,-6+..FFE1[bp]
29003 85F8           E8         7AEE            call	lmulul
29004 85FB           83C4                   04  add	sp,*4
29005                                           ! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
29006 85FE           8D7E         C8            lea	di,-2+..FFE1[bp]
29007 8601           E8         7ABF            call	laddul
29008 8604           83C4                   04  add	sp,*4
29009                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29010 8607           8946         EA            mov	-$16[bp],ax
29011 860A           895E         EC            mov	-$14[bp],bx
29012                                           !BCC_EOS
29013                                           ! 4269       AX = ((AX & 0xff00) | (nbsectors));
29014                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29015 860D           8B46         16            mov	ax,$16[bp]
29016 8610           30C0                       xor	al,al
29017                                           ! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
29018 8612           0B46         EE            or	ax,-$12[bp]
29019                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29020 8615           8946         16            mov	$16[bp],ax
29021                                           !BCC_EOS
29022                                           ! 4270       slba = (Bit32u)vlba/4;
29023                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
29024 8618           B8                   0004  mov	ax,*4
29025 861B           31DB                       xor	bx,bx
29026 861D           53                         push	bx
29027 861E           50                         push	ax
29028 861F           8B46         EA            mov	ax,-$16[bp]
29029 8622           8B5E         EC            mov	bx,-$14[bp]
29030 8625           8D7E         C8            lea	di,-2+..FFE1[bp]
29031 8628           E8         7B43            call	ldivul
29032 862B           83C4                   04  add	sp,*4
29033                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
29034 862E           8946         E2            mov	-$1E[bp],ax
29035 8631           895E         E4            mov	-$1C[bp],bx
29036                                           !BCC_EOS
29037                                           ! 4271       before= (Bit16u)vlba%4;
29038                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
29039 8634           8B46         EA            mov	ax,-$16[bp]
29040 8637           24                     03  and	al,*3
29041                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
29042 8639           30E4                       xor	ah,ah
29043 863B           8946         DC            mov	-$24[bp],ax
29044                                           !BCC_EOS
29045                                           ! 4272       elba = (Bit32u)(vlba+nbsectors-1)/4;
29046                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29047 863E           8B46         EE            mov	ax,-$12[bp]
29048 8641           31DB                       xor	bx,bx
29049                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29050                                           ! Debug: expression subtree swapping
29051 8643           8D7E         EA            lea	di,-$16[bp]
29052 8646           E8         7A7A            call	laddul
29053                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29054 8649           53                         push	bx
29055 864A           50                         push	ax
29056 864B           B8                   0001  mov	ax,*1
29057 864E           31DB                       xor	bx,bx
29058 8650           53                         push	bx
29059 8651           50                         push	ax
29060 8652           8B46         C8            mov	ax,-2+..FFE1[bp]
29061 8655           8B5E         CA            mov	bx,0+..FFE1[bp]
29062 8658           8D7E         C4            lea	di,-6+..FFE1[bp]
29063 865B           E8         7A83            call	lsubul
29064 865E           83C4                   08  add	sp,*8
29065                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
29066                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
29067 8661           53                         push	bx
29068 8662           50                         push	ax
29069 8663           B8                   0004  mov	ax,*4
29070 8666           31DB                       xor	bx,bx
29071 8668           53                         push	bx
29072 8669           50                         push	ax
29073 866A           8B46         C8            mov	ax,-2+..FFE1[bp]
29074 866D           8B5E         CA            mov	bx,0+..FFE1[bp]
29075 8670           8D7E         C4            lea	di,-6+..FFE1[bp]
29076 8673           E8         7AF8            call	ldivul
29077 8676           83C4                   08  add	sp,*8
29078                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
29079 8679           8946         DE            mov	-$22[bp],ax
29080 867C           895E         E0            mov	-$20[bp],bx
29081                                           !BCC_EOS
29082                                           ! 4273       memsetb(get_SS(),atacmd,0,12);
29083                                           ! Debug: list int = const $C (used reg = )
29084 867F           B8                   000C  mov	ax,*$C
29085 8682           50                         push	ax
29086                                           ! Debug: list int = const 0 (used reg = )
29087 8683           31C0                       xor	ax,ax
29088 8685           50                         push	ax
29089                                           ! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
29090 8686           8D5E         CC            lea	bx,-$34[bp]
29091 8689           53                         push	bx
29092                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29093 868A           E8         7FC0            call	_get_SS
29094                                           ! Debug: list unsigned short = ax+0 (used reg = )
29095 868D           50                         push	ax
29096                                           ! Debug: func () void = memsetb+0 (used reg = )
29097 868E           E8         796F            call	_memsetb
29098 8691           83C4                   08  add	sp,*8
29099                                           !BCC_EOS
29100                                           ! 4274       atacmd[0]=0x28;
29101                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
29102 8694           B0                     28  mov	al,*$28
29103 8696           8846         CC            mov	-$34[bp],al
29104                                           !BCC_EOS
29105                                           ! 4275       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
29106                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29107 8699           8B46         DE            mov	ax,-$22[bp]
29108 869C           8B5E         E0            mov	bx,-$20[bp]
29109 869F           8D7E         E2            lea	di,-$1E[bp]
29110 86A2           E8         7A3C            call	lsubul
29111                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29112 86A5           53                         push	bx
29113 86A6           50                         push	ax
29114 86A7           B8                   0001  mov	ax,*1
29115 86AA           31DB                       xor	bx,bx
29116 86AC           53                         push	bx
29117 86AD           50                         push	ax
29118 86AE           8B46         C8            mov	ax,-2+..FFE1[bp]
29119 86B1           8B5E         CA            mov	bx,0+..FFE1[bp]
29120 86B4           8D7E         C4            lea	di,-6+..FFE1[bp]
29121 86B7           E8         7A09            call	laddul
29122 86BA           83C4                   08  add	sp,*8
29123                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29124                                           ! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
29125 86BD           30C0                       xor	al,al
29126                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
29127 86BF           88E0                       mov	al,ah
29128 86C1           30E4                       xor	ah,ah
29129                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
29130 86C3           8846         D3            mov	-$2D[bp],al
29131                                           !BCC_EOS
29132                                           ! 4276       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
29133                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29134 86C6           8B46         DE            mov	ax,-$22[bp]
29135 86C9           8B5E         E0            mov	bx,-$20[bp]
29136 86CC           8D7E         E2            lea	di,-$1E[bp]
29137 86CF           E8         7A0F            call	lsubul
29138                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29139 86D2           53                         push	bx
29140 86D3           50                         push	ax
29141 86D4           B8                   0001  mov	ax,*1
29142 86D7           31DB                       xor	bx,bx
29143 86D9           53                         push	bx
29144 86DA           50                         push	ax
29145 86DB           8B46         C8            mov	ax,-2+..FFE1[bp]
29146 86DE           8B5E         CA            mov	bx,0+..FFE1[bp]
29147 86E1           8D7E         C4            lea	di,-6+..FFE1[bp]
29148 86E4           E8         79DC            call	laddul
29149 86E7           83C4                   08  add	sp,*8
29150                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29151                                           ! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
29152                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
29153 86EA           8846         D4            mov	-$2C[bp],al
29154                                           !BCC_EOS
29155                                           ! 4277       a
29156                                           ! 4277 tacmd[2]=(ilba+slba & 0xff000000) >> 24;
29157                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29158 86ED           8B46         E6            mov	ax,-$1A[bp]
29159 86F0           8B5E         E8            mov	bx,-$18[bp]
29160 86F3           8D7E         E2            lea	di,-$1E[bp]
29161 86F6           E8         79CA            call	laddul
29162                                           ! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
29163 86F9           53                         push	bx
29164 86FA           50                         push	ax
29165 86FB           31C0                       xor	ax,ax
29166 86FD           BB                   FF00  mov	bx,#$FF00
29167 8700           53                         push	bx
29168 8701           50                         push	ax
29169 8702           8B46         C8            mov	ax,-2+..FFE1[bp]
29170 8705           8B5E         CA            mov	bx,0+..FFE1[bp]
29171 8708           8D7E         C4            lea	di,-6+..FFE1[bp]
29172 870B           E8         79AD            call	landul
29173 870E           83C4                   08  add	sp,*8
29174                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
29175 8711           93                         xchg	bx,ax
29176 8712           88E0                       mov	al,ah
29177 8714           30E4                       xor	ah,ah
29178 8716           31DB                       xor	bx,bx
29179                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
29180 8718           8846         CE            mov	-$32[bp],al
29181                                           !BCC_EOS
29182                                           ! 4278       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
29183                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29184 871B           8B46         E6            mov	ax,-$1A[bp]
29185 871E           8B5E         E8            mov	bx,-$18[bp]
29186 8721           8D7E         E2            lea	di,-$1E[bp]
29187 8724           E8         799C            call	laddul
29188                                           ! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
29189 8727           53                         push	bx
29190 8728           50                         push	ax
29191 8729           31C0                       xor	ax,ax
29192 872B           BB                   00FF  mov	bx,#$FF
29193 872E           53                         push	bx
29194 872F           50                         push	ax
29195 8730           8B46         C8            mov	ax,-2+..FFE1[bp]
29196 8733           8B5E         CA            mov	bx,0+..FFE1[bp]
29197 8736           8D7E         C4            lea	di,-6+..FFE1[bp]
29198 8739           E8         797F            call	landul
29199 873C           83C4                   08  add	sp,*8
29200                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
29201 873F           93                         xchg	bx,ax
29202 8740           31DB                       xor	bx,bx
29203                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
29204 8742           8846         CF            mov	-$31[bp],al
29205                                           !BCC_EOS
29206                                           ! 4279       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
29207                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29208 8745           8B46         E6            mov	ax,-$1A[bp]
29209 8748           8B5E         E8            mov	bx,-$18[bp]
29210 874B           8D7E         E2            lea	di,-$1E[bp]
29211 874E           E8         7972            call	laddul
29212                                           ! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
29213 8751           53                         push	bx
29214 8752           50                         push	ax
29215 8753           B8                   FF00  mov	ax,#$FF00
29216 8756           31DB                       xor	bx,bx
29217 8758           53                         push	bx
29218 8759           50                         push	ax
29219 875A           8B46         C8            mov	ax,-2+..FFE1[bp]
29220 875D           8B5E         CA            mov	bx,0+..FFE1[bp]
29221 8760           8D7E         C4            lea	di,-6+..FFE1[bp]
29222 8763           E8         7955            call	landul
29223 8766           83C4                   08  add	sp,*8
29224                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
29225 8769           88E0                       mov	al,ah
29226 876B           88DC                       mov	ah,bl
29227 876D           88FB                       mov	bl,bh
29228 876F           28FF                       sub	bh,bh
29229                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
29230 8771           8846         D0            mov	-$30[bp],al
29231                                           !BCC_EOS
29232                                           ! 4280       atacmd[5]=(ilba+slba & 0x000000ff);
29233                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29234 8774           8B46         E6            mov	ax,-$1A[bp]
29235 8777           8B5E         E8            mov	bx,-$18[bp]
29236 877A           8D7E         E2            lea	di,-$1E[bp]
29237 877D           E8         7943            call	laddul
29238                                           ! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
29239 8780           53                         push	bx
29240 8781           50                         push	ax
29241 8782           B8                   00FF  mov	ax,#$FF
29242 8785           31DB                       xor	bx,bx
29243 8787           53                         push	bx
29244 8788           50                         push	ax
29245 8789           8B46         C8            mov	ax,-2+..FFE1[bp]
29246 878C           8B5E         CA            mov	bx,0+..FFE1[bp]
29247 878F           8D7E         C4            lea	di,-6+..FFE1[bp]
29248 8792           E8         7926            call	landul
29249 8795           83C4                   08  add	sp,*8
29250                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
29251 8798           8846         D1            mov	-$2F[bp],al
29252                                           !BCC_EOS
29253                                           ! 4281       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
29254                                           ! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
29255 879B           FF76         D8            push	-$28[bp]
29256                                           ! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
29257 879E           FF76         DA            push	-$26[bp]
29258                                           ! Debug: list int = const 1 (used reg = )
29259 87A1           B8                   0001  mov	ax,*1
29260 87A4           50                         push	ax
29261                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
29262 87A5           8B46         EE            mov	ax,-$12[bp]
29263 87A8           31DB                       xor	bx,bx
29264                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
29265 87AA           53                         push	bx
29266 87AB           50                         push	ax
29267 87AC           B8                   0200  mov	ax,#$200
29268 87AF           31DB                       xor	bx,bx
29269 87B1           53                         push	bx
29270 87B2           50                         push	ax
29271 87B3           8B46         C2            mov	ax,-8+..FFE1[bp]
29272 87B6           8B5E         C4            mov	bx,-6+..FFE1[bp]
29273 87B9           8D7E         BE            lea	di,-$C+..FFE1[bp]
29274 87BC           E8         792A            call	lmulul
29275 87BF           83C4                   08  add	sp,*8
29276                                           ! Debug: list unsigned long = bx+0 (used reg = )
29277 87C2           53                         push	bx
29278 87C3           50                         push	ax
29279                                           ! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
29280 87C4           8B46         DC            mov	ax,-$24[bp]
29281 87C7           B9                   0200  mov	cx,#$200
29282 87CA           F7E9                       imul	cx
29283                                           ! Debug: list unsigned int = ax+0 (used reg = )
29284 87CC           50                         push	ax
29285                                           ! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
29286 87CD           8D5E         CC            lea	bx,-$34[bp]
29287 87D0           53                         push	bx
29288                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29289 87D1           E8         7E79            call	_get_SS
29290                                           ! Debug: list unsigned short = ax+0 (used reg = )
29291 87D4           50                         push	ax
29292                                           ! Debug: list int = const $C (used reg = )
29293 87D5           B8                   000C  mov	ax,*$C
29294 87D8           50                         push	ax
29295                                           ! Debug: list unsigned char device = [S+$48-5] (used reg = )
29296 87D9           8A46         FD            mov	al,-3[bp]
29297 87DC           30E4                       xor	ah,ah
29298 87DE           50                         push	ax
29299                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
29300 87DF           E8         ADE4            call	_ata_cmd_packet
29301 87E2           83C4                   14  add	sp,*$14
29302                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
29303 87E5           8846         FC            mov	-4[bp],al
29304                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29305 87E8           84C0                       test	al,al
29306 87EA           74           1B            je  	.616
29307                       000087EC            .617:
29308                                           ! 4282         ;
29309                                           !BCC_EOS
29310                                           ! 4283         AX = ((AX & 0x00ff) | ((0x02) << 8));
29311                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29312 87EC           8A46         16            mov	al,$16[bp]
29313                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
29314 87EF           30E4                       xor	ah,ah
29315 87F1           0D                   0200  or	ax,#$200
29316                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29317 87F4           8946         16            mov	$16[bp],ax
29318                                           !BCC_EOS
29319                                           ! 4284         AX = ((AX & 0xff00) | (0));
29320                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29321 87F7           8B46         16            mov	ax,$16[bp]
29322 87FA           30C0                       xor	al,al
29323                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29324 87FC           0C                     00  or	al,*0
29325                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29326 87FE           8946         16            mov	$16[bp],ax
29327                                           !BCC_EOS
29328                                           ! 4285         goto int13_fail_noah;
29329 8801           83C4                   00  add	sp,#..FFDF-..FFE1
29330 8804           E9         01A2            br 	.FFDF
29331                                           !BCC_EOS
29332                                           ! 4286         }
29333                                           ! 4287       goto int13_success;
29334                       00008807            .616:
29335 8807           83C4                   00  add	sp,#..FFE0-..FFE1
29336 880A           E9         01BE            br 	.FFE0
29337                                           !BCC_EOS
29338                                           ! 4288       break;
29339 880D           E9         018E            br 	.5FB
29340                                           !BCC_EOS
29341                                           ! 4289     case 0x08:
29342                                           ! 4290       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
29343                       00008810            .618:
29344                                           ! Debug: list * unsigned short = const $26E (used reg = )
29345 8810           B8                   026E  mov	ax,#$26E
29346 8813           50                         push	ax
29347                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29348 8814           FF76         FE            push	-2[bp]
29349                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29350 8817           E8         7DED            call	_read_word
29351 881A           83C4                   04  add	sp,*4
29352                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
29353 881D           8946         F8            mov	-8[bp],ax
29354                                           !BCC_EOS
29355                                           ! 4291       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
29356                                           ! Debug: list * unsigned short = const $26C (used reg = )
29357 8820           B8                   026C  mov	ax,#$26C
29358 8823           50                         push	ax
29359                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29360 8824           FF76         FE            push	-2[bp]
29361                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29362 8827           E8         7DDD            call	_read_word
29363 882A           83C4                   04  add	sp,*4
29364                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
29365                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
29366 882D           48                         dec	ax
29367 882E           8946         F6            mov	-$A[bp],ax
29368                                           !BCC_EOS
29369                                           ! 4292       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
29370                                           ! Debug: list * unsigned short = const $26A (used reg = )
29371 8831           B8                   026A  mov	ax,#$26A
29372 8834           50                         push	ax
29373                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29374 8835           FF76         FE            push	-2[bp]
29375                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29376 8838           E8         7DCC            call	_read_word
29377 883B           83C4                   04  add	sp,*4
29378                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
29379                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
29380 883E           48                         dec	ax
29381 883F           8946         FA            mov	-6[bp],ax
29382                                           !BCC_EOS
29383                                           ! 4293       AX = ((AX & 0xff00) | (0x00));
29384                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29385 8842           8B46         16            mov	ax,$16[bp]
29386 8845           30C0                       xor	al,al
29387                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29388 8847           0C                     00  or	al,*0
29389                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29390 8849           8946         16            mov	$16[bp],ax
29391                                           !BCC_EOS
29392                                           ! 4294       BX = ((BX & 0xff00) | (0x00));
29393                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29394 884C           8B46         10            mov	ax,$10[bp]
29395 884F           30C0                       xor	al,al
29396                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29397 8851           0C                     00  or	al,*0
29398                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29399 8853           8946         10            mov	$10[bp],ax
29400                                           !BCC_EOS
29401                                           ! 4295       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
29402                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
29403 8856           8A46         F6            mov	al,-$A[bp]
29404                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
29405 8859           30E4                       xor	ah,ah
29406 885B           88C4                       mov	ah,al
29407 885D           30C0                       xor	al,al
29408 885F           50                         push	ax
29409                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
29410 8860           8A46         14            mov	al,$14[bp]
29411                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29412 8863           30E4                       xor	ah,ah
29413 8865           0B46         CA            or	ax,0+..FFE1[bp]
29414 8868           44                         inc	sp
29415 8869           44                         inc	sp
29416                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
29417 886A           8946         14            mov	$14[bp],ax
29418                                           !BCC_EOS
29419                                           ! 4296       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
29420                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
29421 886D           8A46         F8            mov	al,-8[bp]
29422 8870           24                     3F  and	al,*$3F
29423 8872           50                         push	ax
29424                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
29425 8873           8B46         F6            mov	ax,-$A[bp]
29426 8876           D1E8                       shr	ax,*1
29427 8878           D1E8                       shr	ax,*1
29428                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
29429 887A           24                     C0  and	al,#$C0
29430                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29431 887C           0A46         CA            or	al,0+..FFE1[bp]
29432 887F           44                         inc	sp
29433 8880           44                         inc	sp
29434 8881           50                         push	ax
29435                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
29436 8882           8B46         14            mov	ax,$14[bp]
29437 8885           30C0                       xor	al,al
29438                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
29439 8887           0A46         CA            or	al,0+..FFE1[bp]
29440 888A           44                         inc	sp
29441 888B           44                         inc	sp
29442                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
29443 888C           8946         14            mov	$14[bp],ax
29444                                           !BCC_EOS
29445                                           ! 4297       DX = ((DX & 0x00ff) | ((vheads) << 8));
29446                                           ! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
29447 888F           8B46         FA            mov	ax,-6[bp]
29448 8892           88C4                       mov	ah,al
29449 8894           30C0                       xor	al,al
29450 8896           50                         push	ax
29451                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
29452 8897           8A46         12            mov	al,$12[bp]
29453                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29454 889A           30E4                       xor	ah,ah
29455 889C           0B46         CA            or	ax,0+..FFE1[bp]
29456 889F           44                         inc	sp
29457 88A0           44                         inc	sp
29458                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
29459 88A1           8946         12            mov	$12[bp],ax
29460                                           !BCC_EOS
29461                                           ! 4298       DX = ((DX & 0xff00) | (0x02));
29462                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
29463 88A4           8B46         12            mov	ax,$12[bp]
29464 88A7           30C0                       xor	al,al
29465                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
29466 88A9           0C                     02  or	al,*2
29467                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
29468 88AB           8946         12            mov	$12[bp],ax
29469                                           !BCC_EOS
29470                                           ! 4299       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
29471                                           ! Debug: list * unsigned char = const $25B (used reg = )
29472 88AE           B8                   025B  mov	ax,#$25B
29473 88B1           50                         push	ax
29474                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29475 88B2           FF76         FE            push	-2[bp]
29476                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29477 88B5           E8         7D3C            call	_read_byte
29478 88B8           83C4                   04  add	sp,*4
29479 88BB           EB           26            jmp .61B
29480                                           ! 4300         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
29481                       000088BD            .61C:
29482                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29483 88BD           8B46         10            mov	ax,$10[bp]
29484 88C0           30C0                       xor	al,al
29485                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
29486 88C2           0C                     02  or	al,*2
29487                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29488 88C4           8946         10            mov	$10[bp],ax
29489                                           !BCC_EOS
29490 88C7           EB           26            jmp .619
29491                                           !BCC_EOS
29492                                           ! 4301         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
29493                       000088C9            .61D:
29494                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29495 88C9           8B46         10            mov	ax,$10[bp]
29496 88CC           30C0                       xor	al,al
29497                                           ! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
29498 88CE           0C                     04  or	al,*4
29499                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29500 88D0           8946         10            mov	$10[bp],ax
29501                                           !BCC_EOS
29502 88D3           EB           1A            jmp .619
29503                                           !BCC_EOS
29504                                           ! 4302         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
29505                       000088D5            .61E:
29506                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29507 88D5           8B46         10            mov	ax,$10[bp]
29508 88D8           30C0                       xor	al,al
29509                                           ! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
29510 88DA           0C                     06  or	al,*6
29511                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29512 88DC           8946         10            mov	$10[bp],ax
29513                                           !BCC_EOS
29514 88DF           EB           0E            jmp .619
29515                                           !BCC_EOS
29516                                           ! 4303         }
29517                                           ! 4304 #asm
29518 88E1           EB           0C            jmp .619
29519                       000088E3            .61B:
29520 88E3           2C                     01  sub	al,*1
29521 88E5           74           D6            je 	.61C
29522 88E7           2C                     01  sub	al,*1
29523 88E9           74           DE            je 	.61D
29524 88EB           2C                     01  sub	al,*1
29525 88ED           74           E6            je 	.61E
29526                       000088EF            .619:
29527                                           !BCC_EOS
29528                                           !BCC_ASM
29529                       00000040            _int13_cdemu.BP	set	$40
29530                       0000000C            .int13_cdemu.BP	set	$C
29531                       0000004E            _int13_cdemu.CS	set	$4E
29532                       0000001A            .int13_cdemu.CS	set	$1A
29533                       00000022            _int13_cdemu.nbsectors	set	$22
29534                       FFFFFFEE            .int13_cdemu.nbsectors	set	-$12
29535                       00000048            _int13_cdemu.CX	set	$48
29536                       00000014            .int13_cdemu.CX	set	$14
29537                       00000012            _int13_cdemu.elba	set	$12
29538                       FFFFFFDE            .int13_cdemu.elba	set	-$22
29539                       0000000E            _int13_cdemu.segment	set	$E
29540                       FFFFFFDA            .int13_cdemu.segment	set	-$26
29541                       0000003C            _int13_cdemu.DI	set	$3C
29542                       00000008            .int13_cdemu.DI	set	8
29543                       00000050            _int13_cdemu.FLAGS	set	$50
29544                       0000001C            .int13_cdemu.FLAGS	set	$1C
29545                       0000002A            _int13_cdemu.vcylinders	set	$2A
29546                       FFFFFFF6            .int13_cdemu.vcylinders	set	-$A
29547                       00000026            _int13_cdemu.sector	set	$26
29548                       FFFFFFF2            .int13_cdemu.sector	set	-$E
29549                       00000038            _int13_cdemu.DS	set	$38
29550                       00000004            .int13_cdemu.DS	set	4
29551                       00000028            _int13_cdemu.head	set	$28
29552                       FFFFFFF4            .int13_cdemu.head	set	-$C
29553                       00000024            _int13_cdemu.cylinder	set	$24
29554                       FFFFFFF0            .int13_cdemu.cylinder	set	-$10
29555                       00000046            _int13_cdemu.DX	set	$46
29556                       00000012            .int13_cdemu.DX	set	$12
29557                       00000031            _int13_cdemu.device	set	$31
29558                       FFFFFFFD            .int13_cdemu.device	set	-3
29559                       0000003A            _int13_cdemu.ES	set	$3A
29560                       00000006            .int13_cdemu.ES	set	6
29561                       0000002C            _int13_cdemu.vspt	set	$2C
29562                       FFFFFFF8            .int13_cdemu.vspt	set	-8
29563                       0000001E            _int13_cdemu.vlba	set	$1E
29564                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
29565                       00000032            _int13_cdemu.ebda_seg	set	$32
29566                       FFFFFFFE            .int13_cdemu.ebda_seg	set	-2
29567                       0000003E            _int13_cdemu.SI	set	$3E
29568                       0000000A            .int13_cdemu.SI	set	$A
29569                       0000004C            _int13_cdemu.IP	set	$4C
29570                       00000018            .int13_cdemu.IP	set	$18
29571                       00000030            _int13_cdemu.status	set	$30
29572                       FFFFFFFC            .int13_cdemu.status	set	-4
29573                       00000000            _int13_cdemu.atacmd	set	0
29574                       FFFFFFCC            .int13_cdemu.atacmd	set	-$34
29575                       0000004A            _int13_cdemu.AX	set	$4A
29576                       00000016            .int13_cdemu.AX	set	$16
29577                       0000001A            _int13_cdemu.ilba	set	$1A
29578                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
29579                       00000010            _int13_cdemu.before	set	$10
29580                       FFFFFFDC            .int13_cdemu.before	set	-$24
29581                       0000000C            _int13_cdemu.offset	set	$C
29582                       FFFFFFD8            .int13_cdemu.offset	set	-$28
29583                       00000016            _int13_cdemu.slba	set	$16
29584                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
29585                       00000042            _int13_cdemu.SP	set	$42
29586                       0000000E            .int13_cdemu.SP	set	$E
29587                       0000002E            _int13_cdemu.vheads	set	$2E
29588                       FFFFFFFA            .int13_cdemu.vheads	set	-6
29589                       00000044            _int13_cdemu.BX	set	$44
29590                       00000010            .int13_cdemu.BX	set	$10
29591 88EF           55                               push bp
29592 88F0           89E5                             mov bp, sp
29593 88F2           B8                   EFDE        mov ax, #diskette_param_table2
29594 88F5           8946         3E                  mov _int13_cdemu.DI+2[bp], ax
29595 88F8           8C4E         3C                  mov _int13_cdemu.ES+2[bp], cs
29596 88FB           5D                               pop bp
29597                                           ! 4311 endasm
29598                                           !BCC_ENDASM
29599                                           !BCC_EOS
29600                                           ! 4312       goto int13_success;
29601 88FC           83C4                   00  add	sp,#..FFE0-..FFE1
29602 88FF           E9         00C9            br 	.FFE0
29603                                           !BCC_EOS
29604                                           ! 4313       break;
29605 8902           E9         0099            br 	.5FB
29606                                           !BCC_EOS
29607                                           ! 4314     case 0x15:
29608                                           ! 4315       AX = ((AX & 0x00ff) | ((0x03) << 8));
29609                       00008905            .61F:
29610                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29611 8905           8A46         16            mov	al,$16[bp]
29612                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
29613 8908           30E4                       xor	ah,ah
29614 890A           0D                   0300  or	ax,#$300
29615                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29616 890D           8946         16            mov	$16[bp],ax
29617                                           !BCC_EOS
29618                                           ! 4316       goto int13_success_noah;
29619 8910           83C4                   00  add	sp,#..FFDD-..FFE1
29620 8913           E9         00BF            br 	.FFDD
29621                                           !BCC_EOS
29622                                           ! 4317       break;
29623 8916           E9         0085            br 	.5FB
29624                                           !BCC_EOS
29625                                           ! 4318     case 0x0a:
29626                                           ! 4319     case 0x0b:
29627                       00008919            .620:
29628                                           ! 4320     case 0x18:
29629                       00008919            .621:
29630                                           ! 4321     case 0x41:
29631                       00008919            .622:
29632                                           ! 4322     case 0x42:
29633                       00008919            .623:
29634                                           ! 4323     case 0x43:
29635                       00008919            .624:
29636                                           ! 4324     case 0x44:
29637                       00008919            .625:
29638                                           ! 4325     case 0x45:
29639                       00008919            .626:
29640                                           ! 4326     case 0x46:
29641                       00008919            .627:
29642                                           ! 4327     case 0x47:
29643                       00008919            .628:
29644                                           ! 4328     case 0x48:
29645                       00008919            .629:
29646                                           ! 4329     case 0x49:
29647                       00008919            .62A:
29648                                           ! 4330     case 0x4e:
29649                       00008919            .62B:
29650                                           ! 4331     case 0x50:
29651                       00008919            .62C:
29652                                           ! 4332     default:
29653                       00008919            .62D:
29654                                           ! 4333       ;
29655                       00008919            .62E:
29656                                           !BCC_EOS
29657                                           ! 4334       goto int13_fail;
29658 8919           83C4                   00  add	sp,#..FFE2-..FFE1
29659 891C           E9         007F            jmp .FFE2
29660                                           !BCC_EOS
29661                                           ! 4335       break;
29662 891F           EB           7D            jmp .5FB
29663                                           !BCC_EOS
29664                                           ! 4336     }
29665                                           ! 4337 int13_fail:
29666 8921           EB           7B            jmp .5FB
29667                       00008923            .5FD:
29668 8923           2D                   0000  sub	ax,*0
29669 8926           7C           F1            jl 	.62E
29670 8928           3D                   0018  cmp	ax,*$18
29671 892B           77           3B            ja  	.62F
29672 892D           D1E0                       shl	ax,*1
29673 892F           89C3                       mov	bx,ax
29674 8931           2E                         seg	cs
29675 8932           FFA7       8936            br	.630[bx]
29676                       00008936            .630:
29677 8936                      8477            .word	.5FE
29678 8938                      8494            .word	.608
29679 893A                      84E5            .word	.60C
29680 893C                      8480            .word	.606
29681 893E                      84E5            .word	.60D
29682 8940                      8480            .word	.607
29683 8942                      8919            .word	.62E
29684 8944                      8919            .word	.62E
29685 8946                      8810            .word	.618
29686 8948                      8477            .word	.5FF
29687 894A                      8919            .word	.620
29688 894C                      8919            .word	.621
29689 894E                      8477            .word	.600
29690 8950                      8477            .word	.601
29691 8952                      8919            .word	.62E
29692 8954                      8919            .word	.62E
29693 8956                      8477            .word	.602
29694 8958                      8477            .word	.603
29695 895A                      8919            .word	.62E
29696 895C                      8919            .word	.62E
29697 895E                      8477            .word	.604
29698 8960                      8905            .word	.61F
29699 8962                      8477            .word	.605
29700 8964                      8919            .word	.62E
29701 8966                      8919            .word	.622
29702                       00008968            .62F:
29703 8968           2D                   0041  sub	ax,*$41
29704 896B           72           AC            jb 	.62E
29705 896D           3D                   000F  cmp	ax,*$F
29706 8970           77           29            ja  	.631
29707 8972           D1E0                       shl	ax,*1
29708 8974           89C3                       mov	bx,ax
29709 8976           2E                         seg	cs
29710 8977           FFA7       897B            br	.632[bx]
29711                       0000897B            .632:
29712 897B                      8919            .word	.623
29713 897D                      8919            .word	.624
29714 897F                      8919            .word	.625
29715 8981                      8919            .word	.626
29716 8983                      8919            .word	.627
29717 8985                      8919            .word	.628
29718 8987                      8919            .word	.629
29719 8989                      8919            .word	.62A
29720 898B                      8919            .word	.62B
29721 898D                      8919            .word	.62E
29722 898F                      8919            .word	.62E
29723 8991                      8919            .word	.62E
29724 8993                      8919            .word	.62E
29725 8995                      8919            .word	.62C
29726 8997                      8919            .word	.62E
29727 8999                      8919            .word	.62D
29728                       0000899B            .631:
29729 899B           E9         FF7B            br 	.62E
29730                       0000899E            .5FB:
29731                       FFFFFFCA            ..FFE1	=	-$36
29732                       0000899E            .FFE2:
29733                       FFFFFFCA            ..FFE2	=	-$36
29734                                           ! 4338     AX = ((AX & 0x00ff) | ((0x01) << 8));
29735                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29736 899E           8A46         16            mov	al,$16[bp]
29737                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
29738 89A1           30E4                       xor	ah,ah
29739 89A3           0D                   0100  or	ax,#$100
29740                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29741 89A6           8946         16            mov	$16[bp],ax
29742                                           !BCC_EOS
29743                                           ! 4339 int13_fail_noah:
29744                       000089A9            .FFDF:
29745                       FFFFFFCA            ..FFDF	=	-$36
29746                                           ! 4340     write_byte(0x0040, 0x0074, ( AX >> 8 ));
29747                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29748 89A9           8B46         16            mov	ax,$16[bp]
29749 89AC           88E0                       mov	al,ah
29750 89AE           30E4                       xor	ah,ah
29751                                           ! Debug: list unsigned int = ax+0 (used reg = )
29752 89B0           50                         push	ax
29753                                           ! Debug: list int = const $74 (used reg = )
29754 89B1           B8                   0074  mov	ax,*$74
29755 89B4           50                         push	ax
29756                                           ! Debug: list int = const $40 (used reg = )
29757 89B5           B8                   0040  mov	ax,*$40
29758 89B8           50                         push	ax
29759                                           ! Debug: func () void = write_byte+0 (used reg = )
29760 89B9           E8         7C5E            call	_write_byte
29761 89BC           83C4                   06  add	sp,*6
29762                                           !BCC_EOS
29763                                           ! 4341 int13_fail_nostatus:
29764                       000089BF            .FFDE:
29765                       FFFFFFCA            ..FFDE	=	-$36
29766                                           ! 4342     FLAGS |= 0x0001;
29767                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
29768 89BF           8B46         1C            mov	ax,$1C[bp]
29769 89C2           0C                     01  or	al,*1
29770 89C4           8946         1C            mov	$1C[bp],ax
29771                                           !BCC_EOS
29772                                           ! 4343     return;
29773 89C7           89EC                       mov	sp,bp
29774 89C9           5D                         pop	bp
29775 89CA           C3                         ret
29776                                           !BCC_EOS
29777                                           ! 4344 int13_success:
29778                       000089CB            .FFE0:
29779                       FFFFFFCA            ..FFE0	=	-$36
29780                                           ! 4345     AX = ((A
29781                                           ! 4345 X & 0x00ff) | ((0x00) << 8));
29782                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29783 89CB           8A46         16            mov	al,$16[bp]
29784                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
29785 89CE           0C                     00  or	al,*0
29786                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
29787 89D0           30E4                       xor	ah,ah
29788 89D2           8946         16            mov	$16[bp],ax
29789                                           !BCC_EOS
29790                                           ! 4346 int13_success_noah:
29791                       000089D5            .FFDD:
29792                       FFFFFFCA            ..FFDD	=	-$36
29793                                           ! 4347     write_byte(0x0040, 0x0074, 0x00);
29794                                           ! Debug: list int = const 0 (used reg = )
29795 89D5           31C0                       xor	ax,ax
29796 89D7           50                         push	ax
29797                                           ! Debug: list int = const $74 (used reg = )
29798 89D8           B8                   0074  mov	ax,*$74
29799 89DB           50                         push	ax
29800                                           ! Debug: list int = const $40 (used reg = )
29801 89DC           B8                   0040  mov	ax,*$40
29802 89DF           50                         push	ax
29803                                           ! Debug: func () void = write_byte+0 (used reg = )
29804 89E0           E8         7C37            call	_write_byte
29805 89E3           83C4                   06  add	sp,*6
29806                                           !BCC_EOS
29807                                           ! 4348     FLAGS &= 0xfffe;
29808                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
29809 89E6           8B46         1C            mov	ax,$1C[bp]
29810 89E9           24                     FE  and	al,#$FE
29811 89EB           8946         1C            mov	$1C[bp],ax
29812                                           !BCC_EOS
29813                                           ! 4349     return;
29814 89EE           89EC                       mov	sp,bp
29815 89F0           5D                         pop	bp
29816 89F1           C3                         ret
29817                                           !BCC_EOS
29818                                           ! 4350 }
29819                                           ! 4351 void floppy_reset_controller()
29820                                           ! Register BX used in function int13_cdemu
29821                                           ! 4352 {
29822                                           export	_floppy_reset_controller
29823                       000089F2            _floppy_reset_controller:
29824                                           ! 4353   Bit8u val8;
29825                                           !BCC_EOS
29826                                           ! 4354   val8 = inb(0x03f2);
29827 89F2           55                         push	bp
29828 89F3           89E5                       mov	bp,sp
29829 89F5           4C                         dec	sp
29830 89F6           4C                         dec	sp
29831                                           ! Debug: list int = const $3F2 (used reg = )
29832 89F7           B8                   03F2  mov	ax,#$3F2
29833 89FA           50                         push	ax
29834                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29835 89FB           E8         7B40            call	_inb
29836 89FE           44                         inc	sp
29837 89FF           44                         inc	sp
29838                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
29839 8A00           8846         FF            mov	-1[bp],al
29840                                           !BCC_EOS
29841                                           ! 4355   outb(0x03f2, val8 & ~0x04);
29842                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
29843 8A03           8A46         FF            mov	al,-1[bp]
29844 8A06           24                     FB  and	al,#$FB
29845                                           ! Debug: list unsigned char = al+0 (used reg = )
29846 8A08           30E4                       xor	ah,ah
29847 8A0A           50                         push	ax
29848                                           ! Debug: list int = const $3F2 (used reg = )
29849 8A0B           B8                   03F2  mov	ax,#$3F2
29850 8A0E           50                         push	ax
29851                                           ! Debug: func () void = outb+0 (used reg = )
29852 8A0F           E8         7B42            call	_outb
29853 8A12           83C4                   04  add	sp,*4
29854                                           !BCC_EOS
29855                                           ! 4356   outb(0x03f2, val8 | 0x04);
29856                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
29857 8A15           8A46         FF            mov	al,-1[bp]
29858 8A18           0C                     04  or	al,*4
29859                                           ! Debug: list unsigned char = al+0 (used reg = )
29860 8A1A           30E4                       xor	ah,ah
29861 8A1C           50                         push	ax
29862                                           ! Debug: list int = const $3F2 (used reg = )
29863 8A1D           B8                   03F2  mov	ax,#$3F2
29864 8A20           50                         push	ax
29865                                           ! Debug: func () void = outb+0 (used reg = )
29866 8A21           E8         7B30            call	_outb
29867 8A24           83C4                   04  add	sp,*4
29868                                           !BCC_EOS
29869                                           ! 4357   do {
29870                       00008A27            .635:
29871                                           ! 4358     val8 = inb(0x3f4);
29872                                           ! Debug: list int = const $3F4 (used reg = )
29873 8A27           B8                   03F4  mov	ax,#$3F4
29874 8A2A           50                         push	ax
29875                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29876 8A2B           E8         7B10            call	_inb
29877 8A2E           44                         inc	sp
29878 8A2F           44                         inc	sp
29879                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
29880 8A30           8846         FF            mov	-1[bp],al
29881                                           !BCC_EOS
29882                                           ! 4359   } while ( (val8 & 0xc0) != 0x80 );
29883                       00008A33            .634:
29884                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
29885 8A33           8A46         FF            mov	al,-1[bp]
29886 8A36           24                     C0  and	al,#$C0
29887                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
29888 8A38           3C                     80  cmp	al,#$80
29889 8A3A           75           EB            jne	.635
29890                       00008A3C            .636:
29891                                           !BCC_EOS
29892                                           ! 4360 }
29893                       00008A3C            .633:
29894 8A3C           89EC                       mov	sp,bp
29895 8A3E           5D                         pop	bp
29896 8A3F           C3                         ret
29897                                           ! 4361 void floppy_prepare_controller(drive)
29898                                           ! 4362   Bit16u drive;
29899                                           export	_floppy_prepare_controller
29900                       00008A40            _floppy_prepare_controller:
29901                                           !BCC_EOS
29902                                           ! 4363 {
29903                                           ! 4364   Bit8u val8, dor, prev_reset;
29904                                           !BCC_EOS
29905                                           ! 4365   val8 = read_byte(0x0040, 0x003e);
29906 8A40           55                         push	bp
29907 8A41           89E5                       mov	bp,sp
29908 8A43           83C4                   FC  add	sp,*-4
29909                                           ! Debug: list int = const $3E (used reg = )
29910 8A46           B8                   003E  mov	ax,*$3E
29911 8A49           50                         push	ax
29912                                           ! Debug: list int = const $40 (used reg = )
29913 8A4A           B8                   0040  mov	ax,*$40
29914 8A4D           50                         push	ax
29915                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29916 8A4E           E8         7BA3            call	_read_byte
29917 8A51           83C4                   04  add	sp,*4
29918                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
29919 8A54           8846         FF            mov	-1[bp],al
29920                                           !BCC_EOS
29921                                           ! 4366   val8 &= 0x7f;
29922                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
29923 8A57           8A46         FF            mov	al,-1[bp]
29924 8A5A           24                     7F  and	al,*$7F
29925 8A5C           8846         FF            mov	-1[bp],al
29926                                           !BCC_EOS
29927                                           ! 4367   write_byte(0x0040, 0x003e, val8);
29928                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
29929 8A5F           8A46         FF            mov	al,-1[bp]
29930 8A62           30E4                       xor	ah,ah
29931 8A64           50                         push	ax
29932                                           ! Debug: list int = const $3E (used reg = )
29933 8A65           B8                   003E  mov	ax,*$3E
29934 8A68           50                         push	ax
29935                                           ! Debug: list int = const $40 (used reg = )
29936 8A69           B8                   0040  mov	ax,*$40
29937 8A6C           50                         push	ax
29938                                           ! Debug: func () void = write_byte+0 (used reg = )
29939 8A6D           E8         7BAA            call	_write_byte
29940 8A70           83C4                   06  add	sp,*6
29941                                           !BCC_EOS
29942                                           ! 4368   prev_reset = inb(0x03f2) & 0x04;
29943                                           ! Debug: list int = const $3F2 (used reg = )
29944 8A73           B8                   03F2  mov	ax,#$3F2
29945 8A76           50                         push	ax
29946                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29947 8A77           E8         7AC4            call	_inb
29948 8A7A           44                         inc	sp
29949 8A7B           44                         inc	sp
29950                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
29951 8A7C           24                     04  and	al,*4
29952                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
29953 8A7E           8846         FD            mov	-3[bp],al
29954                                           !BCC_EOS
29955                                           ! 4369   if (drive)
29956 8A81           8B46         04            mov	ax,4[bp]
29957 8A84           85C0                       test	ax,ax
29958 8A86           74           07            je  	.637
29959                       00008A88            .638:
29960                                           ! 4370     dor = 0x20;
29961                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
29962 8A88           B0                     20  mov	al,*$20
29963 8A8A           8846         FE            mov	-2[bp],al
29964                                           !BCC_EOS
29965                                           ! 4371   else
29966                                           ! 4372     dor = 0x10;
29967 8A8D           EB           05            jmp .639
29968                       00008A8F            .637:
29969                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
29970 8A8F           B0                     10  mov	al,*$10
29971 8A91           8846         FE            mov	-2[bp],al
29972                                           !BCC_EOS
29973                                           ! 4373   dor |= 0x0c;
29974                       00008A94            .639:
29975                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
29976 8A94           8A46         FE            mov	al,-2[bp]
29977 8A97           0C                     0C  or	al,*$C
29978 8A99           8846         FE            mov	-2[bp],al
29979                                           !BCC_EOS
29980                                           ! 4374   dor |= drive;
29981                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
29982 8A9C           8B46         04            mov	ax,4[bp]
29983 8A9F           0A46         FE            or	al,-2[bp]
29984 8AA2           8846         FE            mov	-2[bp],al
29985                                           !BCC_EOS
29986                                           ! 4375   outb(0x03f2, dor);
29987                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
29988 8AA5           8A46         FE            mov	al,-2[bp]
29989 8AA8           30E4                       xor	ah,ah
29990 8AAA           50                         push	ax
29991                                           ! Debug: list int = const $3F2 (used reg = )
29992 8AAB           B8                   03F2  mov	ax,#$3F2
29993 8AAE           50                         push	ax
29994                                           ! Debug: func () void = outb+0 (used reg = )
29995 8AAF           E8         7AA2            call	_outb
29996 8AB2           83C4                   04  add	sp,*4
29997                                           !BCC_EOS
29998                                           ! 4376   write_byte(0x40,0x40, 37);
29999                                           ! Debug: list int = const $25 (used reg = )
30000 8AB5           B8                   0025  mov	ax,*$25
30001 8AB8           50                         push	ax
30002                                           ! Debug: list int = const $40 (used reg = )
30003 8AB9           B8                   0040  mov	ax,*$40
30004 8ABC           50                         push	ax
30005                                           ! Debug: list int = const $40 (used reg = )
30006 8ABD           B8                   0040  mov	ax,*$40
30007 8AC0           50                         push	ax
30008                                           ! Debug: func () void = write_byte+0 (used reg = )
30009 8AC1           E8         7B56            call	_write_byte
30010 8AC4           83C4                   06  add	sp,*6
30011                                           !BCC_EOS
30012                                           ! 4377   do {
30013                       00008AC7            .63C:
30014                                           ! 4378     val8 = inb(0x3f4);
30015                                           ! Debug: list int = const $3F4 (used reg = )
30016 8AC7           B8                   03F4  mov	ax,#$3F4
30017 8ACA           50                         push	ax
30018                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30019 8ACB           E8         7A70            call	_inb
30020 8ACE           44                         inc	sp
30021 8ACF           44                         inc	sp
30022                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30023 8AD0           8846         FF            mov	-1[bp],al
30024                                           !BCC_EOS
30025                                           ! 4379   } while ( (val8 & 0xc0) != 0x80 );
30026                       00008AD3            .63B:
30027                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
30028 8AD3           8A46         FF            mov	al,-1[bp]
30029 8AD6           24                     C0  and	al,#$C0
30030                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30031 8AD8           3C                     80  cmp	al,#$80
30032 8ADA           75           EB            jne	.63C
30033                       00008ADC            .63D:
30034                                           !BCC_EOS
30035                                           ! 4380   if (prev_reset == 0) {
30036                       00008ADC            .63A:
30037                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
30038 8ADC           8A46         FD            mov	al,-3[bp]
30039 8ADF           84C0                       test	al,al
30040 8AE1           75           38            jne 	.63E
30041                       00008AE3            .63F:
30042                                           ! 4381 #asm
30043                                           !BCC_EOS
30044                                           !BCC_ASM
30045                       00000002            _floppy_prepare_controller.dor	set	2
30046                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30047                       00000001            _floppy_prepare_controller.prev_reset	set	1
30048                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30049                       00000003            _floppy_prepare_controller.val8	set	3
30050                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30051                       00000008            _floppy_prepare_controller.drive	set	8
30052                       00000004            .floppy_prepare_controller.drive	set	4
30053 8AE3           FB                             sti
30054                                           ! 4383 endasm
30055                                           !BCC_ENDASM
30056                                           !BCC_EOS
30057                                           ! 4384     do {
30058                       00008AE4            .642:
30059                                           ! 4385       val8 = read_byte(0x0040, 0x003e);
30060                                           ! Debug: list int = const $3E (used reg = )
30061 8AE4           B8                   003E  mov	ax,*$3E
30062 8AE7           50                         push	ax
30063                                           ! Debug: list int = const $40 (used reg = )
30064 8AE8           B8                   0040  mov	ax,*$40
30065 8AEB           50                         push	ax
30066                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30067 8AEC           E8         7B05            call	_read_byte
30068 8AEF           83C4                   04  add	sp,*4
30069                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30070 8AF2           8846         FF            mov	-1[bp],al
30071                                           !BCC_EOS
30072                                           ! 4386     } while ( (val8 & 0x80) == 0 );
30073                       00008AF5            .641:
30074                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
30075 8AF5           8A46         FF            mov	al,-1[bp]
30076 8AF8           24                     80  and	al,#$80
30077                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
30078 8AFA           84C0                       test	al,al
30079 8AFC           74           E6            je 	.642
30080                       00008AFE            .643:
30081                                           !BCC_EOS
30082                                           ! 4387     val8 &= 0x7f;
30083                       00008AFE            .640:
30084                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30085 8AFE           8A46         FF            mov	al,-1[bp]
30086 8B01           24                     7F  and	al,*$7F
30087 8B03           8846         FF            mov	-1[bp],al
30088                                           !BCC_EOS
30089                                           ! 4388 #asm
30090                                           !BCC_EOS
30091                                           !BCC_ASM
30092                       00000002            _floppy_prepare_controller.dor	set	2
30093                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30094                       00000001            _floppy_prepare_controller.prev_reset	set	1
30095                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30096                       00000003            _floppy_prepare_controller.val8	set	3
30097                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30098                       00000008            _floppy_prepare_controller.drive	set	8
30099                       00000004            .floppy_prepare_controller.drive	set	4
30100 8B06           FA                             cli
30101                                           ! 4390 endasm
30102                                           !BCC_ENDASM
30103                                           !BCC_EOS
30104                                           ! 4391     write_byte(0x0040, 0x003e, val8);
30105                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30106 8B07           8A46         FF            mov	al,-1[bp]
30107 8B0A           30E4                       xor	ah,ah
30108 8B0C           50                         push	ax
30109                                           ! Debug: list int = const $3E (used reg = )
30110 8B0D           B8                   003E  mov	ax,*$3E
30111 8B10           50                         push	ax
30112                                           ! Debug: list int = const $40 (used reg = )
30113 8B11           B8                   0040  mov	ax,*$40
30114 8B14           50                         push	ax
30115                                           ! Debug: func () void = write_byte+0 (used reg = )
30116 8B15           E8         7B02            call	_write_byte
30117 8B18           83C4                   06  add	sp,*6
30118                                           !BCC_EOS
30119                                           ! 4392   }
30120                                           ! 4393 }
30121                       00008B1B            .63E:
30122 8B1B           89EC                       mov	sp,bp
30123 8B1D           5D                         pop	bp
30124 8B1E           C3                         ret
30125                                           ! 4394   bx_bool
30126                                           ! 4395 floppy_media_known(drive)
30127                                           ! 4396   Bit16u drive;
30128                                           export	_floppy_media_known
30129                       00008B1F            _floppy_media_known:
30130                                           !BCC_EOS
30131                                           ! 4397 {
30132                                           ! 4398   Bit8u val8;
30133                                           !BCC_EOS
30134                                           ! 4399   Bit16u media_state_offset;
30135                                           !BCC_EOS
30136                                           ! 4400   val8 = read_byte(0x0040, 0x003e);
30137 8B1F           55                         push	bp
30138 8B20           89E5                       mov	bp,sp
30139 8B22           83C4                   FC  add	sp,*-4
30140                                           ! Debug: list int = const $3E (used reg = )
30141 8B25           B8                   003E  mov	ax,*$3E
30142 8B28           50                         push	ax
30143                                           ! Debug: list int = const $40 (used reg = )
30144 8B29           B8                   0040  mov	ax,*$40
30145 8B2C           50                         push	ax
30146                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30147 8B2D           E8         7AC4            call	_read_byte
30148 8B30           83C4                   04  add	sp,*4
30149                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30150 8B33           8846         FF            mov	-1[bp],al
30151                                           !BCC_EOS
30152                                           ! 4401   if (drive)
30153 8B36           8B46         04            mov	ax,4[bp]
30154 8B39           85C0                       test	ax,ax
30155 8B3B           74           0A            je  	.644
30156                       00008B3D            .645:
30157                                           ! 4402     val8 >>= 1;
30158                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30159 8B3D           8A46         FF            mov	al,-1[bp]
30160 8B40           30E4                       xor	ah,ah
30161 8B42           D1E8                       shr	ax,*1
30162 8B44           8846         FF            mov	-1[bp],al
30163                                           !BCC_EOS
30164                                           ! 4403   val8 &= 0x01;
30165                       00008B47            .644:
30166                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30167 8B47           8A46         FF            mov	al,-1[bp]
30168 8B4A           24                     01  and	al,*1
30169 8B4C           8846         FF            mov	-1[bp],al
30170                                           !BCC_EOS
30171                                           ! 4404   if (val8 == 0)
30172                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30173 8B4F           8A46         FF            mov	al,-1[bp]
30174 8B52           84C0                       test	al,al
30175 8B54           75           06            jne 	.646
30176                       00008B56            .647:
30177                                           ! 4405     return(0);
30178 8B56           31C0                       xor	ax,ax
30179 8B58           89EC                       mov	sp,bp
30180 8B5A           5D                         pop	bp
30181 8B5B           C3                         ret
30182                                           !BCC_EOS
30183                                           ! 4406   media_state_offset = 0x0090;
30184                       00008B5C            .646:
30185                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
30186 8B5C           B8                   0090  mov	ax,#$90
30187 8B5F           8946         FC            mov	-4[bp],ax
30188                                           !BCC_EOS
30189                                           ! 4407   if (drive)
30190 8B62           8B46         04            mov	ax,4[bp]
30191 8B65           85C0                       test	ax,ax
30192 8B67           74           07            je  	.648
30193                       00008B69            .649:
30194                                           ! 4408     media_state_offset += 1;
30195                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
30196 8B69           8B46         FC            mov	ax,-4[bp]
30197 8B6C           40                         inc	ax
30198 8B6D           8946         FC            mov	-4[bp],ax
30199                                           !BCC_EOS
30200                                           ! 4409   val8 = read_byte(0x0040, media_state_offset);
30201                       00008B70            .648:
30202                                           ! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
30203 8B70           FF76         FC            push	-4[bp]
30204                                           ! Debug: list int = const $40 (used reg = )
30205 8B73           B8                   0040  mov	ax,*$40
30206 8B76           50                         push	ax
30207                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30208 8B77           E8         7A7A            call	_read_byte
30209 8B7A           83C4                   04  add	sp,*4
30210                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30211 8B7D           8846         FF            mov	-1[bp],al
30212                                           !BCC_EOS
30213                                           ! 4410   val8 = (val8 >> 4) & 0x01;
30214                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
30215 8B80           8A46         FF            mov	al,-1[bp]
30216 8B83           30E4                       xor	ah,ah
30217 8B85           B1                     04  mov	cl,*4
30218 8B87           D3E8                       shr	ax,cl
30219                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30220 8B89           24                     01  and	al,*1
30221                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30222 8B8B           8846         FF            mov	-1[bp],al
30223                                           !BCC_EOS
30224                                           ! 4411   if (val8 == 0)
30225                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30226 8B8E           8A46         FF            mov	al,-1[bp]
30227 8B91           84C0                       test	al,al
30228 8B93           75           06            jne 	.64A
30229                       00008B95            .64B:
30230                                           ! 4412     return(0);
30231 8B95           31C0                       xor	ax,ax
30232 8B97           89EC                       mov	sp,bp
30233 8B99           5D                         pop	bp
30234 8B9A           C3                         ret
30235                                           !BCC_EOS
30236                                           ! 4413   return(1);
30237                       00008B9B            .64A:
30238 8B9B           B8                   0001  mov	ax,*1
30239 8B9E           89EC                       mov	sp,bp
30240 8BA0           5D                         pop	bp
30241 8BA1           C3                         ret
30242                                           !BCC_EOS
30243                                           ! 4414 }
30244                                           ! 4415   bx_bool
30245                                           ! 4416 floppy_media_sense(drive)
30246                                           ! 4417   Bit16u drive;
30247                                           export	_floppy_media_sense
30248                       00008BA2            _floppy_media_sense:
30249                                           !BCC_EOS
30250                                           ! 4418 {
30251                                           ! 4419   bx_bool retval;
30252                                           !BCC_EOS
30253                                           ! 4420   Bit16u media_state_offset;
30254                                           !BCC_EOS
30255                                           ! 4421   Bit8u drive_type, config_data, media_state;
30256                                           !BCC_EOS
30257                                           ! 4422   if (floppy_drive_recal(drive) == 0) {
30258 8BA2           55                         push	bp
30259 8BA3           89E5                       mov	bp,sp
30260 8BA5           83C4                   F8  add	sp,*-8
30261                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
30262 8BA8           FF76         04            push	4[bp]
30263                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
30264 8BAB           E8         0152            call	_floppy_drive_recal
30265 8BAE           44                         inc	sp
30266 8BAF           44                         inc	sp
30267                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30268 8BB0           85C0                       test	ax,ax
30269 8BB2           75           06            jne 	.64C
30270                       00008BB4            .64D:
30271                                           ! 4423     return(0);
30272 8BB4           31C0                       xor	ax,ax
30273 8BB6           89EC                       mov	sp,bp
30274 8BB8           5D                         pop	bp
30275 8BB9           C3                         ret
30276                                           !BCC_EOS
30277                                           ! 4424     }
30278                                           ! 4425   drive_type = inb_cmos(0x10);
30279                       00008BBA            .64C:
30280                                           ! Debug: list int = const $10 (used reg = )
30281 8BBA           B8                   0010  mov	ax,*$10
30282 8BBD           50                         push	ax
30283                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30284 8BBE           E8         79C2            call	_inb_cmos
30285 8BC1           44                         inc	sp
30286 8BC2           44                         inc	sp
30287                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
30288 8BC3           8846         FB            mov	-5[bp],al
30289                                           !BCC_EOS
30290                                           ! 4426   if (drive == 0)
30291                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
30292 8BC6           8B46         04            mov	ax,4[bp]
30293 8BC9           85C0                       test	ax,ax
30294 8BCB           75           0E            jne 	.64E
30295                       00008BCD            .64F:
30296                                           ! 4427     drive_type >>= 4;
30297                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
30298 8BCD           8A46         FB            mov	al,-5[bp]
30299 8BD0           30E4                       xor	ah,ah
30300 8BD2           B1                     04  mov	cl,*4
30301 8BD4           D3E8                       shr	ax,cl
30302 8BD6           8846         FB            mov	-5[bp],al
30303                                           !BCC_EOS
30304                                           ! 4428   else
30305                                           ! 4429     drive_type &= 0x0f;
30306 8BD9           EB           08            jmp .650
30307                       00008BDB            .64E:
30308                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
30309 8BDB           8A46         FB            mov	al,-5[bp]
30310 8BDE           24                     0F  and	al,*$F
30311 8BE0           8846         FB            mov	-5[bp],al
30312                                           !BCC_EOS
30313                                           ! 4430   if ( drive_type == 1 ) {
30314                       00008BE3            .650:
30315                                           ! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
30316 8BE3           8A46         FB            mov	al,-5[bp]
30317 8BE6           3C                     01  cmp	al,*1
30318 8BE8           75           13            jne 	.651
30319                       00008BEA            .652:
30320                                           ! 4431     config_data = 0x00;
30321                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30322 8BEA           30C0                       xor	al,al
30323 8BEC           8846         FA            mov	-6[bp],al
30324                                           !BCC_EOS
30325                                           ! 4432     media_state = 0x25;
30326                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
30327 8BEF           B0                     25  mov	al,*$25
30328 8BF1           8846         F9            mov	-7[bp],al
30329                                           !BCC_EOS
30330                                           ! 4433     retval = 1;
30331                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30332 8BF4           B8                   0001  mov	ax,*1
30333 8BF7           8946         FE            mov	-2[bp],ax
30334                                           !BCC_EOS
30335                                           ! 4434     }
30336                                           ! 4435   else if ( drive_type == 2 ) {
30337 8BFA           E9         00C0            br 	.653
30338                       00008BFD            .651:
30339                                           ! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
30340 8BFD           8A46         FB            mov	al,-5[bp]
30341 8C00           3C                     02  cmp	al,*2
30342 8C02           75           13            jne 	.654
30343                       00008C04            .655:
30344                                           ! 4436     config_data = 0x00;
30345                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30346 8C04           30C0                       xor	al,al
30347 8C06           8846         FA            mov	-6[bp],al
30348                                           !BCC_EOS
30349                                           ! 4437     media_state = 0x25;
30350                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
30351 8C09           B0                     25  mov	al,*$25
30352 8C0B           8846         F9            mov	-7[bp],al
30353                                           !BCC_EOS
30354                                           ! 4438     retval = 1;
30355                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30356 8C0E           B8                   0001  mov	ax,*1
30357 8C11           8946         FE            mov	-2[bp],ax
30358                                           !BCC_EOS
30359                                           ! 4439     }
30360                                           ! 4440   else if ( drive_type == 3 ) {
30361 8C14           E9         00A6            br 	.656
30362                       00008C17            .654:
30363                                           ! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
30364 8C17           8A46         FB            mov	al,-5[bp]
30365 8C1A           3C                     03  cmp	al,*3
30366 8C1C           75           13            jne 	.657
30367                       00008C1E            .658:
30368                                           ! 4441     config_data = 0x00;
30369                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30370 8C1E           30C0                       xor	al,al
30371 8C20           8846         FA            mov	-6[bp],al
30372                                           !BCC_EOS
30373                                           ! 4442     media_state = 0x17;
30374                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
30375 8C23           B0                     17  mov	al,*$17
30376 8C25           8846         F9            mov	-7[bp],al
30377                                           !BCC_EOS
30378                                           ! 4443     retval = 1;
30379                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30380 8C28           B8                   0001  mov	ax,*1
30381 8C2B           8946         FE            mov	-2[bp],ax
30382                                           !BCC_EOS
30383                                           ! 4444     }
30384                                           ! 4445   else if ( drive_type == 4 ) {
30385 8C2E           E9         008C            br 	.659
30386                       00008C31            .657:
30387                                           ! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
30388 8C31           8A46         FB            mov	al,-5[bp]
30389 8C34           3C                     04  cmp	al,*4
30390 8C36           75           12            jne 	.65A
30391                       00008C38            .65B:
30392                                           ! 4446     config_data = 0x00;
30393                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30394 8C38           30C0                       xor	al,al
30395 8C3A           8846         FA            mov	-6[bp],al
30396                                           !BCC_EOS
30397                                           ! 4447     media_state = 0x17;
30398                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
30399 8C3D           B0                     17  mov	al,*$17
30400 8C3F           8846         F9            mov	-7[bp],al
30401                                           !BCC_EOS
30402                                           ! 4448     re
30403                                           ! 4448 tval = 1;
30404                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30405 8C42           B8                   0001  mov	ax,*1
30406 8C45           8946         FE            mov	-2[bp],ax
30407                                           !BCC_EOS
30408                                           ! 4449     }
30409                                           ! 4450   else if ( drive_type == 5 ) {
30410 8C48           EB           73            jmp .65C
30411                       00008C4A            .65A:
30412                                           ! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
30413 8C4A           8A46         FB            mov	al,-5[bp]
30414 8C4D           3C                     05  cmp	al,*5
30415 8C4F           75           12            jne 	.65D
30416                       00008C51            .65E:
30417                                           ! 4451     config_data = 0xCC;
30418                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
30419 8C51           B0                     CC  mov	al,#$CC
30420 8C53           8846         FA            mov	-6[bp],al
30421                                           !BCC_EOS
30422                                           ! 4452     media_state = 0xD7;
30423                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
30424 8C56           B0                     D7  mov	al,#$D7
30425 8C58           8846         F9            mov	-7[bp],al
30426                                           !BCC_EOS
30427                                           ! 4453     retval = 1;
30428                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30429 8C5B           B8                   0001  mov	ax,*1
30430 8C5E           8946         FE            mov	-2[bp],ax
30431                                           !BCC_EOS
30432                                           ! 4454     }
30433                                           ! 4455   else if ( drive_type == 6 ) {
30434 8C61           EB           5A            jmp .65F
30435                       00008C63            .65D:
30436                                           ! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
30437 8C63           8A46         FB            mov	al,-5[bp]
30438 8C66           3C                     06  cmp	al,*6
30439 8C68           75           12            jne 	.660
30440                       00008C6A            .661:
30441                                           ! 4456     config_data = 0x00;
30442                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30443 8C6A           30C0                       xor	al,al
30444 8C6C           8846         FA            mov	-6[bp],al
30445                                           !BCC_EOS
30446                                           ! 4457     media_state = 0x27;
30447                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30448 8C6F           B0                     27  mov	al,*$27
30449 8C71           8846         F9            mov	-7[bp],al
30450                                           !BCC_EOS
30451                                           ! 4458     retval = 1;
30452                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30453 8C74           B8                   0001  mov	ax,*1
30454 8C77           8946         FE            mov	-2[bp],ax
30455                                           !BCC_EOS
30456                                           ! 4459     }
30457                                           ! 4460   else if ( drive_type == 7 ) {
30458 8C7A           EB           41            jmp .662
30459                       00008C7C            .660:
30460                                           ! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
30461 8C7C           8A46         FB            mov	al,-5[bp]
30462 8C7F           3C                     07  cmp	al,*7
30463 8C81           75           12            jne 	.663
30464                       00008C83            .664:
30465                                           ! 4461     config_data = 0x00;
30466                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30467 8C83           30C0                       xor	al,al
30468 8C85           8846         FA            mov	-6[bp],al
30469                                           !BCC_EOS
30470                                           ! 4462     media_state = 0x27;
30471                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30472 8C88           B0                     27  mov	al,*$27
30473 8C8A           8846         F9            mov	-7[bp],al
30474                                           !BCC_EOS
30475                                           ! 4463     retval = 1;
30476                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30477 8C8D           B8                   0001  mov	ax,*1
30478 8C90           8946         FE            mov	-2[bp],ax
30479                                           !BCC_EOS
30480                                           ! 4464     }
30481                                           ! 4465   else if ( drive_type == 8 ) {
30482 8C93           EB           28            jmp .665
30483                       00008C95            .663:
30484                                           ! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
30485 8C95           8A46         FB            mov	al,-5[bp]
30486 8C98           3C                     08  cmp	al,*8
30487 8C9A           75           12            jne 	.666
30488                       00008C9C            .667:
30489                                           ! 4466     config_data = 0x00;
30490                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30491 8C9C           30C0                       xor	al,al
30492 8C9E           8846         FA            mov	-6[bp],al
30493                                           !BCC_EOS
30494                                           ! 4467     media_state = 0x27;
30495                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30496 8CA1           B0                     27  mov	al,*$27
30497 8CA3           8846         F9            mov	-7[bp],al
30498                                           !BCC_EOS
30499                                           ! 4468     retval = 1;
30500                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30501 8CA6           B8                   0001  mov	ax,*1
30502 8CA9           8946         FE            mov	-2[bp],ax
30503                                           !BCC_EOS
30504                                           ! 4469     }
30505                                           ! 4470   else {
30506 8CAC           EB           0F            jmp .668
30507                       00008CAE            .666:
30508                                           ! 4471     config_data = 0x00;
30509                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30510 8CAE           30C0                       xor	al,al
30511 8CB0           8846         FA            mov	-6[bp],al
30512                                           !BCC_EOS
30513                                           ! 4472     media_state = 0x00;
30514                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
30515 8CB3           30C0                       xor	al,al
30516 8CB5           8846         F9            mov	-7[bp],al
30517                                           !BCC_EOS
30518                                           ! 4473     retval = 0;
30519                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
30520 8CB8           31C0                       xor	ax,ax
30521 8CBA           8946         FE            mov	-2[bp],ax
30522                                           !BCC_EOS
30523                                           ! 4474     }
30524                                           ! 4475   if (drive == 0)
30525                       00008CBD            .668:
30526                       00008CBD            .665:
30527                       00008CBD            .662:
30528                       00008CBD            .65F:
30529                       00008CBD            .65C:
30530                       00008CBD            .659:
30531                       00008CBD            .656:
30532                       00008CBD            .653:
30533                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
30534 8CBD           8B46         04            mov	ax,4[bp]
30535 8CC0           85C0                       test	ax,ax
30536 8CC2           75           08            jne 	.669
30537                       00008CC4            .66A:
30538                                           ! 4476     media_state_offset = 0x90;
30539                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
30540 8CC4           B8                   0090  mov	ax,#$90
30541 8CC7           8946         FC            mov	-4[bp],ax
30542                                           !BCC_EOS
30543                                           ! 4477   else
30544                                           ! 4478     media_state_offset = 0x91;
30545 8CCA           EB           06            jmp .66B
30546                       00008CCC            .669:
30547                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
30548 8CCC           B8                   0091  mov	ax,#$91
30549 8CCF           8946         FC            mov	-4[bp],ax
30550                                           !BCC_EOS
30551                                           ! 4479   write_byte(0x0040, 0x008B, config_data);
30552                       00008CD2            .66B:
30553                                           ! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
30554 8CD2           8A46         FA            mov	al,-6[bp]
30555 8CD5           30E4                       xor	ah,ah
30556 8CD7           50                         push	ax
30557                                           ! Debug: list int = const $8B (used reg = )
30558 8CD8           B8                   008B  mov	ax,#$8B
30559 8CDB           50                         push	ax
30560                                           ! Debug: list int = const $40 (used reg = )
30561 8CDC           B8                   0040  mov	ax,*$40
30562 8CDF           50                         push	ax
30563                                           ! Debug: func () void = write_byte+0 (used reg = )
30564 8CE0           E8         7937            call	_write_byte
30565 8CE3           83C4                   06  add	sp,*6
30566                                           !BCC_EOS
30567                                           ! 4480   write_byte(0x0040, media_state_offset, media_state);
30568                                           ! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
30569 8CE6           8A46         F9            mov	al,-7[bp]
30570 8CE9           30E4                       xor	ah,ah
30571 8CEB           50                         push	ax
30572                                           ! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
30573 8CEC           FF76         FC            push	-4[bp]
30574                                           ! Debug: list int = const $40 (used reg = )
30575 8CEF           B8                   0040  mov	ax,*$40
30576 8CF2           50                         push	ax
30577                                           ! Debug: func () void = write_byte+0 (used reg = )
30578 8CF3           E8         7924            call	_write_byte
30579 8CF6           83C4                   06  add	sp,*6
30580                                           !BCC_EOS
30581                                           ! 4481   return(retval);
30582 8CF9           8B46         FE            mov	ax,-2[bp]
30583 8CFC           89EC                       mov	sp,bp
30584 8CFE           5D                         pop	bp
30585 8CFF           C3                         ret
30586                                           !BCC_EOS
30587                                           ! 4482 }
30588                                           ! 4483   bx_bool
30589                                           ! 4484 floppy_drive_recal(drive)
30590                                           ! 4485   Bit16u drive;
30591                                           export	_floppy_drive_recal
30592                       00008D00            _floppy_drive_recal:
30593                                           !BCC_EOS
30594                                           ! 4486 {
30595                                           ! 4487   Bit8u val8;
30596                                           !BCC_EOS
30597                                           ! 4488   Bit16u curr_cyl_offset;
30598                                           !BCC_EOS
30599                                           ! 4489   floppy_prepare_controller(drive);
30600 8D00           55                         push	bp
30601 8D01           89E5                       mov	bp,sp
30602 8D03           83C4                   FC  add	sp,*-4
30603                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
30604 8D06           FF76         04            push	4[bp]
30605                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
30606 8D09           E8         FD34            call	_floppy_prepare_controller
30607 8D0C           44                         inc	sp
30608 8D0D           44                         inc	sp
30609                                           !BCC_EOS
30610                                           ! 4490   outb(0x03f5, 0x07);
30611                                           ! Debug: list int = const 7 (used reg = )
30612 8D0E           B8                   0007  mov	ax,*7
30613 8D11           50                         push	ax
30614                                           ! Debug: list int = const $3F5 (used reg = )
30615 8D12           B8                   03F5  mov	ax,#$3F5
30616 8D15           50                         push	ax
30617                                           ! Debug: func () void = outb+0 (used reg = )
30618 8D16           E8         783B            call	_outb
30619 8D19           83C4                   04  add	sp,*4
30620                                           !BCC_EOS
30621                                           ! 4491   outb(0x03f5, drive);
30622                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
30623 8D1C           FF76         04            push	4[bp]
30624                                           ! Debug: list int = const $3F5 (used reg = )
30625 8D1F           B8                   03F5  mov	ax,#$3F5
30626 8D22           50                         push	ax
30627                                           ! Debug: func () void = outb+0 (used reg = )
30628 8D23           E8         782E            call	_outb
30629 8D26           83C4                   04  add	sp,*4
30630                                           !BCC_EOS
30631                                           ! 4492 #asm
30632                                           !BCC_EOS
30633                                           !BCC_ASM
30634                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
30635                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
30636                       00000003            _floppy_drive_recal.val8	set	3
30637                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
30638                       00000008            _floppy_drive_recal.drive	set	8
30639                       00000004            .floppy_drive_recal.drive	set	4
30640 8D29           FB                           sti
30641                                           ! 4494 endasm
30642                                           !BCC_ENDASM
30643                                           !BCC_EOS
30644                                           ! 4495   do {
30645                       00008D2A            .66E:
30646                                           ! 4496     val8 = (read_byte(0x0040, 0x003e) & 0x80);
30647                                           ! Debug: list int = const $3E (used reg = )
30648 8D2A           B8                   003E  mov	ax,*$3E
30649 8D2D           50                         push	ax
30650                                           ! Debug: list int = const $40 (used reg = )
30651 8D2E           B8                   0040  mov	ax,*$40
30652 8D31           50                         push	ax
30653                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30654 8D32           E8         78BF            call	_read_byte
30655 8D35           83C4                   04  add	sp,*4
30656                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
30657 8D38           24                     80  and	al,#$80
30658                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30659 8D3A           8846         FF            mov	-1[bp],al
30660                                           !BCC_EOS
30661                                           ! 4497   } while ( val8 == 0 );
30662                       00008D3D            .66D:
30663                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30664 8D3D           8A46         FF            mov	al,-1[bp]
30665 8D40           84C0                       test	al,al
30666 8D42           74           E6            je 	.66E
30667                       00008D44            .66F:
30668                                           !BCC_EOS
30669                                           ! 4498   val8 = 0;
30670                       00008D44            .66C:
30671                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30672 8D44           30C0                       xor	al,al
30673 8D46           8846         FF            mov	-1[bp],al
30674                                           !BCC_EOS
30675                                           ! 4499 #asm
30676                                           !BCC_EOS
30677                                           !BCC_ASM
30678                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
30679                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
30680                       00000003            _floppy_drive_recal.val8	set	3
30681                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
30682                       00000008            _floppy_drive_recal.drive	set	8
30683                       00000004            .floppy_drive_recal.drive	set	4
30684 8D49           FA                           cli
30685                                           ! 4501 endasm
30686                                           !BCC_ENDASM
30687                                           !BCC_EOS
30688                                           ! 4502   val8 = read_byte(0x0040, 0x003e);
30689                                           ! Debug: list int = const $3E (used reg = )
30690 8D4A           B8                   003E  mov	ax,*$3E
30691 8D4D           50                         push	ax
30692                                           ! Debug: list int = const $40 (used reg = )
30693 8D4E           B8                   0040  mov	ax,*$40
30694 8D51           50                         push	ax
30695                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30696 8D52           E8         789F            call	_read_byte
30697 8D55           83C4                   04  add	sp,*4
30698                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30699 8D58           8846         FF            mov	-1[bp],al
30700                                           !BCC_EOS
30701                                           ! 4503   val8 &= 0x7f;
30702                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30703 8D5B           8A46         FF            mov	al,-1[bp]
30704 8D5E           24                     7F  and	al,*$7F
30705 8D60           8846         FF            mov	-1[bp],al
30706                                           !BCC_EOS
30707                                           ! 4504   if (drive) {
30708 8D63           8B46         04            mov	ax,4[bp]
30709 8D66           85C0                       test	ax,ax
30710 8D68           74           10            je  	.670
30711                       00008D6A            .671:
30712                                           ! 4505     val8 |= 0x02;
30713                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
30714 8D6A           8A46         FF            mov	al,-1[bp]
30715 8D6D           0C                     02  or	al,*2
30716 8D6F           8846         FF            mov	-1[bp],al
30717                                           !BCC_EOS
30718                                           ! 4506     curr_cyl_offset = 0x0095;
30719                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
30720 8D72           B8                   0095  mov	ax,#$95
30721 8D75           8946         FC            mov	-4[bp],ax
30722                                           !BCC_EOS
30723                                           ! 4507   } else {
30724 8D78           EB           0E            jmp .672
30725                       00008D7A            .670:
30726                                           ! 4508     val8 |= 0x01;
30727                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30728 8D7A           8A46         FF            mov	al,-1[bp]
30729 8D7D           0C                     01  or	al,*1
30730 8D7F           8846         FF            mov	-1[bp],al
30731                                           !BCC_EOS
30732                                           ! 4509     curr_cyl_offset = 0x0094;
30733                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
30734 8D82           B8                   0094  mov	ax,#$94
30735 8D85           8946         FC            mov	-4[bp],ax
30736                                           !BCC_EOS
30737                                           ! 4510   }
30738                                           ! 4511   write_byte(0x0040, 0x003e, val8);
30739                       00008D88            .672:
30740                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30741 8D88           8A46         FF            mov	al,-1[bp]
30742 8D8B           30E4                       xor	ah,ah
30743 8D8D           50                         push	ax
30744                                           ! Debug: list int = const $3E (used reg = )
30745 8D8E           B8                   003E  mov	ax,*$3E
30746 8D91           50                         push	ax
30747                                           ! Debug: list int = const $40 (used reg = )
30748 8D92           B8                   0040  mov	ax,*$40
30749 8D95           50                         push	ax
30750                                           ! Debug: func () void = write_byte+0 (used reg = )
30751 8D96           E8         7881            call	_write_byte
30752 8D99           83C4                   06  add	sp,*6
30753                                           !BCC_EOS
30754                                           ! 4512   write_byte(0x0040, curr_cyl_offset, 0);
30755                                           ! Debug: list int = const 0 (used reg = )
30756 8D9C           31C0                       xor	ax,ax
30757 8D9E           50                         push	ax
30758                                           ! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
30759 8D9F           FF76         FC            push	-4[bp]
30760                                           ! Debug: list int = const $40 (used reg = )
30761 8DA2           B8                   0040  mov	ax,*$40
30762 8DA5           50                         push	ax
30763                                           ! Debug: func () void = write_byte+0 (used reg = )
30764 8DA6           E8         7871            call	_write_byte
30765 8DA9           83C4                   06  add	sp,*6
30766                                           !BCC_EOS
30767                                           ! 4513   return(1);
30768 8DAC           B8                   0001  mov	ax,*1
30769 8DAF           89EC                       mov	sp,bp
30770 8DB1           5D                         pop	bp
30771 8DB2           C3                         ret
30772                                           !BCC_EOS
30773                                           ! 4514 }
30774                                           ! 4515   bx_bool
30775                                           ! 4516 floppy_drive_exists(drive)
30776                                           ! 4517   Bit16u drive;
30777                                           export	_floppy_drive_exists
30778                       00008DB3            _floppy_drive_exists:
30779                                           !BCC_EOS
30780                                           ! 4518 {
30781                                           ! 4519   Bit8u drive_type;
30782                                           !BCC_EOS
30783                                           ! 4520   drive_type = inb_cmos(0x10);
30784 8DB3           55                         push	bp
30785 8DB4           89E5                       mov	bp,sp
30786 8DB6           4C                         dec	sp
30787 8DB7           4C                         dec	sp
30788                                           ! Debug: list int = const $10 (used reg = )
30789 8DB8           B8                   0010  mov	ax,*$10
30790 8DBB           50                         push	ax
30791                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30792 8DBC           E8         77C4            call	_inb_cmos
30793 8DBF           44                         inc	sp
30794 8DC0           44                         inc	sp
30795                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
30796 8DC1           8846         FF            mov	-1[bp],al
30797                                           !BCC_EOS
30798                                           ! 4521   if (drive == 0)
30799                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
30800 8DC4           8B46         04            mov	ax,4[bp]
30801 8DC7           85C0                       test	ax,ax
30802 8DC9           75           0E            jne 	.673
30803                       00008DCB            .674:
30804                                           ! 4522     drive_type >>= 4;
30805                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
30806 8DCB           8A46         FF            mov	al,-1[bp]
30807 8DCE           30E4                       xor	ah,ah
30808 8DD0           B1                     04  mov	cl,*4
30809 8DD2           D3E8                       shr	ax,cl
30810 8DD4           8846         FF            mov	-1[bp],al
30811                                           !BCC_EOS
30812                                           ! 4523   else
30813                                           ! 4524     drive_type &= 0x0f;
30814 8DD7           EB           08            jmp .675
30815                       00008DD9            .673:
30816                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
30817 8DD9           8A46         FF            mov	al,-1[bp]
30818 8DDC           24                     0F  and	al,*$F
30819 8DDE           8846         FF            mov	-1[bp],al
30820                                           !BCC_EOS
30821                                           ! 4525   if ( drive_type == 0 )
30822                       00008DE1            .675:
30823                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
30824 8DE1           8A46         FF            mov	al,-1[bp]
30825 8DE4           84C0                       test	al,al
30826 8DE6           75           08            jne 	.676
30827                       00008DE8            .677:
30828                                           ! 4526     return(0);
30829 8DE8           31C0                       xor	ax,ax
30830 8DEA           89EC                       mov	sp,bp
30831 8DEC           5D                         pop	bp
30832 8DED           C3                         ret
30833                                           !BCC_EOS
30834                                           ! 4527   else
30835                                           ! 4528     return(1);
30836 8DEE           EB           07            jmp .678
30837                       00008DF0            .676:
30838 8DF0           B8                   0001  mov	ax,*1
30839 8DF3           89EC                       mov	sp,bp
30840 8DF5           5D                         pop	bp
30841 8DF6           C3                         ret
30842                                           !BCC_EOS
30843                                           ! 4529 }
30844                       00008DF7            .678:
30845 8DF7           89EC                       mov	sp,bp
30846 8DF9           5D                         pop	bp
30847 8DFA           C3                         ret
30848                                           ! 4530   void
30849                                           ! 4531 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
30850                                           ! 4532   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
30851                                           export	_int13_diskette_function
30852                       00008DFB            _int13_diskette_function:
30853                                           !BCC_EOS
30854                                           ! 4533 {
30855                                           ! 4534   Bit8u drive, num_sectors, track, sector, head, status;
30856                                           !BCC_EOS
30857                                           ! 4535   Bit16u base_address, base_count, base_es;
30858                                           !BCC_EOS
30859                                           ! 4536   Bit8u page, mode_register, val8, dor;
30860                                           !BCC_EOS
30861                                           ! 4537   Bit8u return_status[7];
30862                                           !BCC_EOS
30863                                           ! 4538   Bit8u drive_type, num_floppies, ah;
30864                                           !BCC_EOS
30865                                           ! 4539   Bit16u es, last_addr;
30866                                           !BCC_EOS
30867                                           ! 4540   ;
30868 8DFB           55                         push	bp
30869 8DFC           89E5                       mov	bp,sp
30870 8DFE           83C4                   E2  add	sp,*-$1E
30871                                           !BCC_EOS
30872                                           ! 4541   ah = ( AX >> 8 );
30873                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
30874 8E01           8B46         16            mov	ax,$16[bp]
30875 8E04           88E0                       mov	al,ah
30876 8E06           30E4                       xor	ah,ah
30877                                           ! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
30878 8E08           8846         E6            mov	-$1A[bp],al
30879                                           !BCC_EOS
30880                                           ! 4542   switch ( ah ) {
30881 8E0B           8A46         E6            mov	al,-$1A[bp]
30882 8E0E           E9         109F            br 	.67B
30883                                           ! 4543     case 0x00:
30884                                           ! 4544 ;
30885                       00008E11            .67C:
30886                                           !BCC_EOS
30887                                           ! 4545       drive = ( ELDX & 0x00ff );
30888                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
30889 8E11           8A46         0E            mov	al,$E[bp]
30890                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
30891 8E14           8846         FF            mov	-1[bp],al
30892                                           !BCC_EOS
30893                                           ! 4546       if (drive > 1) {
30894                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
30895 8E17           8A46         FF            mov	al,-1[bp]
30896 8E1A           3C                     01  cmp	al,*1
30897 8E1C           76           20            jbe 	.67D
30898                       00008E1E            .67E:
30899                                           ! 4547         AX = ((AX & 0x00
30900                                           ! 4547 ff) | ((1) << 8));
30901                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30902 8E1E           8A46         16            mov	al,$16[bp]
30903                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
30904 8E21           30E4                       xor	ah,ah
30905 8E23           0D                   0100  or	ax,#$100
30906                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30907 8E26           8946         16            mov	$16[bp],ax
30908                                           !BCC_EOS
30909                                           ! 4548         set_diskette_ret_status(1);
30910                                           ! Debug: list int = const 1 (used reg = )
30911 8E29           B8                   0001  mov	ax,*1
30912 8E2C           50                         push	ax
30913                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30914 8E2D           E8         10C3            call	_set_diskette_ret_status
30915 8E30           44                         inc	sp
30916 8E31           44                         inc	sp
30917                                           !BCC_EOS
30918                                           ! 4549         FLAGS |= 0x0001;
30919                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30920 8E32           8B46         1C            mov	ax,$1C[bp]
30921 8E35           0C                     01  or	al,*1
30922 8E37           8946         1C            mov	$1C[bp],ax
30923                                           !BCC_EOS
30924                                           ! 4550         return;
30925 8E3A           89EC                       mov	sp,bp
30926 8E3C           5D                         pop	bp
30927 8E3D           C3                         ret
30928                                           !BCC_EOS
30929                                           ! 4551       }
30930                                           ! 4552       drive_type = inb_cmos(0x10);
30931                       00008E3E            .67D:
30932                                           ! Debug: list int = const $10 (used reg = )
30933 8E3E           B8                   0010  mov	ax,*$10
30934 8E41           50                         push	ax
30935                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30936 8E42           E8         773E            call	_inb_cmos
30937 8E45           44                         inc	sp
30938 8E46           44                         inc	sp
30939                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30940 8E47           8846         E8            mov	-$18[bp],al
30941                                           !BCC_EOS
30942                                           ! 4553       if (drive == 0)
30943                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
30944 8E4A           8A46         FF            mov	al,-1[bp]
30945 8E4D           84C0                       test	al,al
30946 8E4F           75           0E            jne 	.67F
30947                       00008E51            .680:
30948                                           ! 4554         drive_type >>= 4;
30949                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30950 8E51           8A46         E8            mov	al,-$18[bp]
30951 8E54           30E4                       xor	ah,ah
30952 8E56           B1                     04  mov	cl,*4
30953 8E58           D3E8                       shr	ax,cl
30954 8E5A           8846         E8            mov	-$18[bp],al
30955                                           !BCC_EOS
30956                                           ! 4555       else
30957                                           ! 4556         drive_type &= 0x0f;
30958 8E5D           EB           08            jmp .681
30959                       00008E5F            .67F:
30960                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
30961 8E5F           8A46         E8            mov	al,-$18[bp]
30962 8E62           24                     0F  and	al,*$F
30963 8E64           8846         E8            mov	-$18[bp],al
30964                                           !BCC_EOS
30965                                           ! 4557       if (drive_type == 0) {
30966                       00008E67            .681:
30967                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30968 8E67           8A46         E8            mov	al,-$18[bp]
30969 8E6A           84C0                       test	al,al
30970 8E6C           75           20            jne 	.682
30971                       00008E6E            .683:
30972                                           ! 4558         AX = ((AX & 0x00ff) | ((0x80) << 8));
30973                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30974 8E6E           8A46         16            mov	al,$16[bp]
30975                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
30976 8E71           30E4                       xor	ah,ah
30977 8E73           0D                   8000  or	ax,#-$8000
30978                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30979 8E76           8946         16            mov	$16[bp],ax
30980                                           !BCC_EOS
30981                                           ! 4559         set_diskette_ret_status(0x80);
30982                                           ! Debug: list int = const $80 (used reg = )
30983 8E79           B8                   0080  mov	ax,#$80
30984 8E7C           50                         push	ax
30985                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30986 8E7D           E8         1073            call	_set_diskette_ret_status
30987 8E80           44                         inc	sp
30988 8E81           44                         inc	sp
30989                                           !BCC_EOS
30990                                           ! 4560         FLAGS |= 0x0001;
30991                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30992 8E82           8B46         1C            mov	ax,$1C[bp]
30993 8E85           0C                     01  or	al,*1
30994 8E87           8946         1C            mov	$1C[bp],ax
30995                                           !BCC_EOS
30996                                           ! 4561         return;
30997 8E8A           89EC                       mov	sp,bp
30998 8E8C           5D                         pop	bp
30999 8E8D           C3                         ret
31000                                           !BCC_EOS
31001                                           ! 4562       }
31002                                           ! 4563       AX = ((AX & 0x00ff) | ((0) << 8));
31003                       00008E8E            .682:
31004                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31005 8E8E           8A46         16            mov	al,$16[bp]
31006                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
31007 8E91           0C                     00  or	al,*0
31008                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
31009 8E93           30E4                       xor	ah,ah
31010 8E95           8946         16            mov	$16[bp],ax
31011                                           !BCC_EOS
31012                                           ! 4564       set_diskette_ret_status(0);
31013                                           ! Debug: list int = const 0 (used reg = )
31014 8E98           31C0                       xor	ax,ax
31015 8E9A           50                         push	ax
31016                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31017 8E9B           E8         1055            call	_set_diskette_ret_status
31018 8E9E           44                         inc	sp
31019 8E9F           44                         inc	sp
31020                                           !BCC_EOS
31021                                           ! 4565       FLAGS &= 0xfffe;
31022                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31023 8EA0           8B46         1C            mov	ax,$1C[bp]
31024 8EA3           24                     FE  and	al,#$FE
31025 8EA5           8946         1C            mov	$1C[bp],ax
31026                                           !BCC_EOS
31027                                           ! 4566       set_diskette_current_cyl(drive, 0);
31028                                           ! Debug: list int = const 0 (used reg = )
31029 8EA8           31C0                       xor	ax,ax
31030 8EAA           50                         push	ax
31031                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
31032 8EAB           8A46         FF            mov	al,-1[bp]
31033 8EAE           30E4                       xor	ah,ah
31034 8EB0           50                         push	ax
31035                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
31036 8EB1           E8         1057            call	_set_diskette_current_cyl
31037 8EB4           83C4                   04  add	sp,*4
31038                                           !BCC_EOS
31039                                           ! 4567       return;
31040 8EB7           89EC                       mov	sp,bp
31041 8EB9           5D                         pop	bp
31042 8EBA           C3                         ret
31043                                           !BCC_EOS
31044                                           ! 4568     case 0x01:
31045                                           ! 4569       FLAGS &= 0xfffe;
31046                       00008EBB            .684:
31047                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31048 8EBB           8B46         1C            mov	ax,$1C[bp]
31049 8EBE           24                     FE  and	al,#$FE
31050 8EC0           8946         1C            mov	$1C[bp],ax
31051                                           !BCC_EOS
31052                                           ! 4570       val8 = read_byte(0x0000, 0x0441);
31053                                           ! Debug: list int = const $441 (used reg = )
31054 8EC3           B8                   0441  mov	ax,#$441
31055 8EC6           50                         push	ax
31056                                           ! Debug: list int = const 0 (used reg = )
31057 8EC7           31C0                       xor	ax,ax
31058 8EC9           50                         push	ax
31059                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31060 8ECA           E8         7727            call	_read_byte
31061 8ECD           83C4                   04  add	sp,*4
31062                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31063 8ED0           8846         F1            mov	-$F[bp],al
31064                                           !BCC_EOS
31065                                           ! 4571       AX = ((AX & 0x00ff) | ((val8) << 8));
31066                                           ! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
31067 8ED3           8A46         F1            mov	al,-$F[bp]
31068 8ED6           30E4                       xor	ah,ah
31069 8ED8           88C4                       mov	ah,al
31070 8EDA           30C0                       xor	al,al
31071 8EDC           50                         push	ax
31072                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
31073 8EDD           8A46         16            mov	al,$16[bp]
31074                                           ! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
31075 8EE0           30E4                       xor	ah,ah
31076 8EE2           0B46         E0            or	ax,0+..FFDC[bp]
31077 8EE5           44                         inc	sp
31078 8EE6           44                         inc	sp
31079                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31080 8EE7           8946         16            mov	$16[bp],ax
31081                                           !BCC_EOS
31082                                           ! 4572       if (val8) {
31083 8EEA           8A46         F1            mov	al,-$F[bp]
31084 8EED           84C0                       test	al,al
31085 8EEF           74           08            je  	.685
31086                       00008EF1            .686:
31087                                           ! 4573         FLAGS |= 0x0001;
31088                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31089 8EF1           8B46         1C            mov	ax,$1C[bp]
31090 8EF4           0C                     01  or	al,*1
31091 8EF6           8946         1C            mov	$1C[bp],ax
31092                                           !BCC_EOS
31093                                           ! 4574       }
31094                                           ! 4575       return;
31095                       00008EF9            .685:
31096 8EF9           89EC                       mov	sp,bp
31097 8EFB           5D                         pop	bp
31098 8EFC           C3                         ret
31099                                           !BCC_EOS
31100                                           ! 4576     case 0x02:
31101                                           ! 4577     case 0x03:
31102                       00008EFD            .687:
31103                                           ! 4578     case 0x04:
31104                       00008EFD            .688:
31105                                           ! 4579       num_sectors = ( AX & 0x00ff );
31106                       00008EFD            .689:
31107                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31108 8EFD           8A46         16            mov	al,$16[bp]
31109                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31110 8F00           8846         FE            mov	-2[bp],al
31111                                           !BCC_EOS
31112                                           ! 4580       track = ( CX >> 8 );
31113                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
31114 8F03           8B46         14            mov	ax,$14[bp]
31115 8F06           88E0                       mov	al,ah
31116 8F08           30E4                       xor	ah,ah
31117                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
31118 8F0A           8846         FD            mov	-3[bp],al
31119                                           !BCC_EOS
31120                                           ! 4581       sector = ( CX & 0x00ff );
31121                                           ! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
31122 8F0D           8A46         14            mov	al,$14[bp]
31123                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
31124 8F10           8846         FC            mov	-4[bp],al
31125                                           !BCC_EOS
31126                                           ! 4582       head = ( DX >> 8 );
31127                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
31128 8F13           8B46         12            mov	ax,$12[bp]
31129 8F16           88E0                       mov	al,ah
31130 8F18           30E4                       xor	ah,ah
31131                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
31132 8F1A           8846         FB            mov	-5[bp],al
31133                                           !BCC_EOS
31134                                           ! 4583       drive = ( ELDX & 0x00ff );
31135                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31136 8F1D           8A46         0E            mov	al,$E[bp]
31137                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31138 8F20           8846         FF            mov	-1[bp],al
31139                                           !BCC_EOS
31140                                           ! 4584       if ((drive > 1) || (head > 1) || (sector == 0) ||
31141                                           ! 4585           (num_sectors == 0) || (num_sectors > 72)) {
31142                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
31143 8F23           8A46         FF            mov	al,-1[bp]
31144 8F26           3C                     01  cmp	al,*1
31145 8F28           77           1C            ja  	.68B
31146                       00008F2A            .68F:
31147                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
31148 8F2A           8A46         FB            mov	al,-5[bp]
31149 8F2D           3C                     01  cmp	al,*1
31150 8F2F           77           15            ja  	.68B
31151                       00008F31            .68E:
31152                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
31153 8F31           8A46         FC            mov	al,-4[bp]
31154 8F34           84C0                       test	al,al
31155 8F36           74           0E            je  	.68B
31156                       00008F38            .68D:
31157                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31158 8F38           8A46         FE            mov	al,-2[bp]
31159 8F3B           84C0                       test	al,al
31160 8F3D           74           07            je  	.68B
31161                       00008F3F            .68C:
31162                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
31163 8F3F           8A46         FE            mov	al,-2[bp]
31164 8F42           3C                     48  cmp	al,*$48
31165 8F44           76           2A            jbe 	.68A
31166                       00008F46            .68B:
31167                                           ! 4586         ;
31168                                           !BCC_EOS
31169                                           ! 4587         AX = ((AX & 0x00ff) | ((1) << 8));
31170                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31171 8F46           8A46         16            mov	al,$16[bp]
31172                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31173 8F49           30E4                       xor	ah,ah
31174 8F4B           0D                   0100  or	ax,#$100
31175                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31176 8F4E           8946         16            mov	$16[bp],ax
31177                                           !BCC_EOS
31178                                           ! 4588         set_diskette_ret_status(1);
31179                                           ! Debug: list int = const 1 (used reg = )
31180 8F51           B8                   0001  mov	ax,*1
31181 8F54           50                         push	ax
31182                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31183 8F55           E8         0F9B            call	_set_diskette_ret_status
31184 8F58           44                         inc	sp
31185 8F59           44                         inc	sp
31186                                           !BCC_EOS
31187                                           ! 4589         AX = ((AX & 0xff00) | (0));
31188                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31189 8F5A           8B46         16            mov	ax,$16[bp]
31190 8F5D           30C0                       xor	al,al
31191                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31192 8F5F           0C                     00  or	al,*0
31193                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31194 8F61           8946         16            mov	$16[bp],ax
31195                                           !BCC_EOS
31196                                           ! 4590         FLAGS |= 0x0001;
31197                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31198 8F64           8B46         1C            mov	ax,$1C[bp]
31199 8F67           0C                     01  or	al,*1
31200 8F69           8946         1C            mov	$1C[bp],ax
31201                                           !BCC_EOS
31202                                           ! 4591         return;
31203 8F6C           89EC                       mov	sp,bp
31204 8F6E           5D                         pop	bp
31205 8F6F           C3                         ret
31206                                           !BCC_EOS
31207                                           ! 4592       }
31208                                           ! 4593       if (floppy_drive_exists(drive) == 0) {
31209                       00008F70            .68A:
31210                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31211 8F70           8A46         FF            mov	al,-1[bp]
31212 8F73           30E4                       xor	ah,ah
31213 8F75           50                         push	ax
31214                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
31215 8F76           E8         FE3A            call	_floppy_drive_exists
31216 8F79           44                         inc	sp
31217 8F7A           44                         inc	sp
31218                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31219 8F7B           85C0                       test	ax,ax
31220 8F7D           75           2A            jne 	.690
31221                       00008F7F            .691:
31222                                           ! 4594         AX = ((AX & 0x00ff) | ((0x80) << 8));
31223                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31224 8F7F           8A46         16            mov	al,$16[bp]
31225                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31226 8F82           30E4                       xor	ah,ah
31227 8F84           0D                   8000  or	ax,#-$8000
31228                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31229 8F87           8946         16            mov	$16[bp],ax
31230                                           !BCC_EOS
31231                                           ! 4595         set_diskette_ret_status(0x80);
31232                                           ! Debug: list int = const $80 (used reg = )
31233 8F8A           B8                   0080  mov	ax,#$80
31234 8F8D           50                         push	ax
31235                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31236 8F8E           E8         0F62            call	_set_diskette_ret_status
31237 8F91           44                         inc	sp
31238 8F92           44                         inc	sp
31239                                           !BCC_EOS
31240                                           ! 4596         AX = ((AX & 0xff00) | (0));
31241                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31242 8F93           8B46         16            mov	ax,$16[bp]
31243 8F96           30C0                       xor	al,al
31244                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31245 8F98           0C                     00  or	al,*0
31246                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31247 8F9A           8946         16            mov	$16[bp],ax
31248                                           !BCC_EOS
31249                                           ! 4597         FLAGS |= 0x0001;
31250                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31251 8F9D           8B46         1C            mov	ax,$1C[bp]
31252 8FA0           0C                     01  or	al,*1
31253 8FA2           8946         1C            mov	$1C[bp],ax
31254                                           !BCC_EOS
31255                                           ! 4598         return;
31256 8FA5           89EC                       mov	sp,bp
31257 8FA7           5D                         pop	bp
31258 8FA8           C3                         ret
31259                                           !BCC_EOS
31260                                           ! 4599       }
31261                                           ! 4600       if (floppy_media_known(drive) == 0) {
31262                       00008FA9            .690:
31263                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31264 8FA9           8A46         FF            mov	al,-1[bp]
31265 8FAC           30E4                       xor	ah,ah
31266 8FAE           50                         push	ax
31267                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
31268 8FAF           E8         FB6D            call	_floppy_media_known
31269 8FB2           44                         inc	sp
31270 8FB3           44                         inc	sp
31271                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31272 8FB4           85C0                       test	ax,ax
31273 8FB6           75           39            jne 	.692
31274                       00008FB8            .693:
31275                                           ! 4601         if (floppy_media_sense(drive) == 0) {
31276                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31277 8FB8           8A46         FF            mov	al,-1[bp]
31278 8FBB           30E4                       xor	ah,ah
31279 8FBD           50                         push	ax
31280                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
31281 8FBE           E8         FBE1            call	_floppy_media_sense
31282 8FC1           44                         inc	sp
31283 8FC2           44                         inc	sp
31284                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31285 8FC3           85C0                       test	ax,ax
31286 8FC5           75           2A            jne 	.694
31287                       00008FC7            .695:
31288                                           ! 4602           AX = ((AX & 0x00ff) | ((0x0C) << 8));
31289                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31290 8FC7           8A46         16            mov	al,$16[bp]
31291                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
31292 8FCA           30E4                       xor	ah,ah
31293 8FCC           0D                   0C00  or	ax,#$C00
31294                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31295 8FCF           8946         16            mov	$16[bp],ax
31296                                           !BCC_EOS
31297                                           ! 4603           set_diskette_ret_status(0x0C);
31298                                           ! Debug: list int = const $C (used reg = )
31299 8FD2           B8                   000C  mov	ax,*$C
31300 8FD5           50                         push	ax
31301                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31302 8FD6           E8         0F1A            call	_set_diskette_ret_status
31303 8FD9           44                         inc	sp
31304 8FDA           44                         inc	sp
31305                                           !BCC_EOS
31306                                           ! 4604           AX = ((AX & 0xff00) | (0));
31307                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31308 8FDB           8B46         16            mov	ax,$16[bp]
31309 8FDE           30C0                       xor	al,al
31310                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31311 8FE0           0C                     00  or	al,*0
31312                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31313 8FE2           8946         16            mov	$16[bp],ax
31314                                           !BCC_EOS
31315                                           ! 4605           FLAGS |= 0x0001;
31316                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31317 8FE5           8B46         1C            mov	ax,$1C[bp]
31318 8FE8           0C                     01  or	al,*1
31319 8FEA           8946         1C            mov	$1C[bp],ax
31320                                           !BCC_EOS
31321                                           ! 4606           return;
31322 8FED           89EC                       mov	sp,bp
31323 8FEF           5D                         pop	bp
31324 8FF0           C3                         ret
31325                                           !BCC_EOS
31326                                           ! 4607         }
31327                                           ! 4608       }
31328                       00008FF1            .694:
31329                                           ! 4609       if (ah == 0x02) {
31330                       00008FF1            .692:
31331                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
31332 8FF1           8A46         E6            mov	al,-$1A[bp]
31333 8FF4           3C                     02  cmp	al,*2
31334 8FF6         0F85         03B4            bne 	.696
31335                       00008FFA            .697:
31336                                           ! 4610         page = (ES >> 12);
31337                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
31338 8FFA           8B46         06            mov	ax,6[bp]
31339 8FFD           88E0                       mov	al,ah
31340 8FFF           30E4                       xor	ah,ah
31341 9001           B1                     04  mov	cl,*4
31342 9003           D3E8                       shr	ax,cl
31343                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
31344 9005           8846         F3            mov	-$D[bp],al
31345                                           !BCC_EOS
31346                                           ! 4611         base_es = (ES << 4);
31347                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
31348 9008           8B46         06            mov	ax,6[bp]
31349 900B           B1                     04  mov	cl,*4
31350 900D           D3E0                       shl	ax,cl
31351                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
31352 900F           8946         F4            mov	-$C[bp],ax
31353                                           !BCC_EOS
31354                                           ! 4612         base_address = base_es + BX;
31355                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
31356 9012           8B46         F4            mov	ax,-$C[bp]
31357 9015           0346         10            add	ax,$10[bp]
31358                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
31359 9018           8946         F8            mov	-8[bp],ax
31360                                           !BCC_EOS
31361                                           ! 4613         if ( base_address < base_es ) {
31362                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
31363 901B           8B46         F8            mov	ax,-8[bp]
31364 901E           3B46         F4            cmp	ax,-$C[bp]
31365 9021           73           07            jae 	.698
31366                       00009023            .699:
31367                                           ! 4614           page++;
31368                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
31369 9023           8A46         F3            mov	al,-$D[bp]
31370 9026           40                         inc	ax
31371 9027           8846         F3            mov	-$D[bp],al
31372                                           !BCC_EOS
31373                                           ! 4615         }
31374                                           ! 4616         base_count = (num_sectors * 512) - 1;
31375                       0000902A            .698:
31376                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
31377 902A           8A46         FE            mov	al,-2[bp]
31378 902D           30E4                       xor	ah,ah
31379 902F           B9                   0200  mov	cx,#$200
31380 9032           F7E9                       imul	cx
31381                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
31382                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
31383 9034           48                         dec	ax
31384 9035           8946         F6            mov	-$A[bp],ax
31385                                           !BCC_EOS
31386                                           ! 4617         last_addr = base_address + base_count;
31387                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
31388 9038           8B46         F8            mov	ax,-8[bp]
31389 903B           0346         F6            add	ax,-$A[bp]
31390                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
31391 903E           8946         E2            mov	-$1E[bp],ax
31392                                           !BCC_EOS
31393                                           ! 4618         if (last_addr < base_address) {
31394                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
31395 9041           8B46         E2            mov	ax,-$1E[bp]
31396 9044           3B46         F8            cmp	ax,-8[bp]
31397 9047           73           2A            jae 	.69A
31398                       00009049            .69B:
31399                                           ! 4619           AX = ((AX &
31400                                           ! 4619  0x00ff) | ((0x09) << 8));
31401                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31402 9049           8A46         16            mov	al,$16[bp]
31403                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
31404 904C           30E4                       xor	ah,ah
31405 904E           0D                   0900  or	ax,#$900
31406                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31407 9051           8946         16            mov	$16[bp],ax
31408                                           !BCC_EOS
31409                                           ! 4620           set_diskette_ret_status(0x09);
31410                                           ! Debug: list int = const 9 (used reg = )
31411 9054           B8                   0009  mov	ax,*9
31412 9057           50                         push	ax
31413                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31414 9058           E8         0E98            call	_set_diskette_ret_status
31415 905B           44                         inc	sp
31416 905C           44                         inc	sp
31417                                           !BCC_EOS
31418                                           ! 4621           AX = ((AX & 0xff00) | (0));
31419                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31420 905D           8B46         16            mov	ax,$16[bp]
31421 9060           30C0                       xor	al,al
31422                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31423 9062           0C                     00  or	al,*0
31424                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31425 9064           8946         16            mov	$16[bp],ax
31426                                           !BCC_EOS
31427                                           ! 4622           FLAGS |= 0x0001;
31428                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31429 9067           8B46         1C            mov	ax,$1C[bp]
31430 906A           0C                     01  or	al,*1
31431 906C           8946         1C            mov	$1C[bp],ax
31432                                           !BCC_EOS
31433                                           ! 4623           return;
31434 906F           89EC                       mov	sp,bp
31435 9071           5D                         pop	bp
31436 9072           C3                         ret
31437                                           !BCC_EOS
31438                                           ! 4624         }
31439                                           ! 4625         ;
31440                       00009073            .69A:
31441                                           !BCC_EOS
31442                                           ! 4626         outb(0x000a, 0x06);
31443                                           ! Debug: list int = const 6 (used reg = )
31444 9073           B8                   0006  mov	ax,*6
31445 9076           50                         push	ax
31446                                           ! Debug: list int = const $A (used reg = )
31447 9077           B8                   000A  mov	ax,*$A
31448 907A           50                         push	ax
31449                                           ! Debug: func () void = outb+0 (used reg = )
31450 907B           E8         74D6            call	_outb
31451 907E           83C4                   04  add	sp,*4
31452                                           !BCC_EOS
31453                                           ! 4627   ;
31454                                           !BCC_EOS
31455                                           ! 4628         outb(0x000c, 0x00);
31456                                           ! Debug: list int = const 0 (used reg = )
31457 9081           31C0                       xor	ax,ax
31458 9083           50                         push	ax
31459                                           ! Debug: list int = const $C (used reg = )
31460 9084           B8                   000C  mov	ax,*$C
31461 9087           50                         push	ax
31462                                           ! Debug: func () void = outb+0 (used reg = )
31463 9088           E8         74C9            call	_outb
31464 908B           83C4                   04  add	sp,*4
31465                                           !BCC_EOS
31466                                           ! 4629         outb(0x0004, base_address);
31467                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
31468 908E           FF76         F8            push	-8[bp]
31469                                           ! Debug: list int = const 4 (used reg = )
31470 9091           B8                   0004  mov	ax,*4
31471 9094           50                         push	ax
31472                                           ! Debug: func () void = outb+0 (used reg = )
31473 9095           E8         74BC            call	_outb
31474 9098           83C4                   04  add	sp,*4
31475                                           !BCC_EOS
31476                                           ! 4630         outb(0x0004, base_address>>8);
31477                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
31478 909B           8B46         F8            mov	ax,-8[bp]
31479 909E           88E0                       mov	al,ah
31480 90A0           30E4                       xor	ah,ah
31481                                           ! Debug: list unsigned int = ax+0 (used reg = )
31482 90A2           50                         push	ax
31483                                           ! Debug: list int = const 4 (used reg = )
31484 90A3           B8                   0004  mov	ax,*4
31485 90A6           50                         push	ax
31486                                           ! Debug: func () void = outb+0 (used reg = )
31487 90A7           E8         74AA            call	_outb
31488 90AA           83C4                   04  add	sp,*4
31489                                           !BCC_EOS
31490                                           ! 4631   ;
31491                                           !BCC_EOS
31492                                           ! 4632         outb(0x000c, 0x00);
31493                                           ! Debug: list int = const 0 (used reg = )
31494 90AD           31C0                       xor	ax,ax
31495 90AF           50                         push	ax
31496                                           ! Debug: list int = const $C (used reg = )
31497 90B0           B8                   000C  mov	ax,*$C
31498 90B3           50                         push	ax
31499                                           ! Debug: func () void = outb+0 (used reg = )
31500 90B4           E8         749D            call	_outb
31501 90B7           83C4                   04  add	sp,*4
31502                                           !BCC_EOS
31503                                           ! 4633         outb(0x0005, base_count);
31504                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
31505 90BA           FF76         F6            push	-$A[bp]
31506                                           ! Debug: list int = const 5 (used reg = )
31507 90BD           B8                   0005  mov	ax,*5
31508 90C0           50                         push	ax
31509                                           ! Debug: func () void = outb+0 (used reg = )
31510 90C1           E8         7490            call	_outb
31511 90C4           83C4                   04  add	sp,*4
31512                                           !BCC_EOS
31513                                           ! 4634         outb(0x0005, base_count>>8);
31514                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
31515 90C7           8B46         F6            mov	ax,-$A[bp]
31516 90CA           88E0                       mov	al,ah
31517 90CC           30E4                       xor	ah,ah
31518                                           ! Debug: list unsigned int = ax+0 (used reg = )
31519 90CE           50                         push	ax
31520                                           ! Debug: list int = const 5 (used reg = )
31521 90CF           B8                   0005  mov	ax,*5
31522 90D2           50                         push	ax
31523                                           ! Debug: func () void = outb+0 (used reg = )
31524 90D3           E8         747E            call	_outb
31525 90D6           83C4                   04  add	sp,*4
31526                                           !BCC_EOS
31527                                           ! 4635         mode_register = 0x46;
31528                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
31529 90D9           B0                     46  mov	al,*$46
31530 90DB           8846         F2            mov	-$E[bp],al
31531                                           !BCC_EOS
31532                                           ! 4636   ;
31533                                           !BCC_EOS
31534                                           ! 4637         outb(0x000b, mode_register);
31535                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
31536 90DE           8A46         F2            mov	al,-$E[bp]
31537 90E1           30E4                       xor	ah,ah
31538 90E3           50                         push	ax
31539                                           ! Debug: list int = const $B (used reg = )
31540 90E4           B8                   000B  mov	ax,*$B
31541 90E7           50                         push	ax
31542                                           ! Debug: func () void = outb+0 (used reg = )
31543 90E8           E8         7469            call	_outb
31544 90EB           83C4                   04  add	sp,*4
31545                                           !BCC_EOS
31546                                           ! 4638   ;
31547                                           !BCC_EOS
31548                                           ! 4639         outb(0x0081, page);
31549                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
31550 90EE           8A46         F3            mov	al,-$D[bp]
31551 90F1           30E4                       xor	ah,ah
31552 90F3           50                         push	ax
31553                                           ! Debug: list int = const $81 (used reg = )
31554 90F4           B8                   0081  mov	ax,#$81
31555 90F7           50                         push	ax
31556                                           ! Debug: func () void = outb+0 (used reg = )
31557 90F8           E8         7459            call	_outb
31558 90FB           83C4                   04  add	sp,*4
31559                                           !BCC_EOS
31560                                           ! 4640   ;
31561                                           !BCC_EOS
31562                                           ! 4641         outb(0x000a, 0x02);
31563                                           ! Debug: list int = const 2 (used reg = )
31564 90FE           B8                   0002  mov	ax,*2
31565 9101           50                         push	ax
31566                                           ! Debug: list int = const $A (used reg = )
31567 9102           B8                   000A  mov	ax,*$A
31568 9105           50                         push	ax
31569                                           ! Debug: func () void = outb+0 (used reg = )
31570 9106           E8         744B            call	_outb
31571 9109           83C4                   04  add	sp,*4
31572                                           !BCC_EOS
31573                                           ! 4642         ;
31574                                           !BCC_EOS
31575                                           ! 4643         outb(0x000a, 0x02);
31576                                           ! Debug: list int = const 2 (used reg = )
31577 910C           B8                   0002  mov	ax,*2
31578 910F           50                         push	ax
31579                                           ! Debug: list int = const $A (used reg = )
31580 9110           B8                   000A  mov	ax,*$A
31581 9113           50                         push	ax
31582                                           ! Debug: func () void = outb+0 (used reg = )
31583 9114           E8         743D            call	_outb
31584 9117           83C4                   04  add	sp,*4
31585                                           !BCC_EOS
31586                                           ! 4644         floppy_prepare_controller(drive);
31587                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31588 911A           8A46         FF            mov	al,-1[bp]
31589 911D           30E4                       xor	ah,ah
31590 911F           50                         push	ax
31591                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
31592 9120           E8         F91D            call	_floppy_prepare_controller
31593 9123           44                         inc	sp
31594 9124           44                         inc	sp
31595                                           !BCC_EOS
31596                                           ! 4645         outb(0x03f5, 0xe6);
31597                                           ! Debug: list int = const $E6 (used reg = )
31598 9125           B8                   00E6  mov	ax,#$E6
31599 9128           50                         push	ax
31600                                           ! Debug: list int = const $3F5 (used reg = )
31601 9129           B8                   03F5  mov	ax,#$3F5
31602 912C           50                         push	ax
31603                                           ! Debug: func () void = outb+0 (used reg = )
31604 912D           E8         7424            call	_outb
31605 9130           83C4                   04  add	sp,*4
31606                                           !BCC_EOS
31607                                           ! 4646         outb(0x03f5, (head << 2) | drive);
31608                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
31609 9133           8A46         FB            mov	al,-5[bp]
31610 9136           30E4                       xor	ah,ah
31611 9138           D1E0                       shl	ax,*1
31612 913A           D1E0                       shl	ax,*1
31613                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
31614 913C           0A46         FF            or	al,-1[bp]
31615                                           ! Debug: list unsigned int = ax+0 (used reg = )
31616 913F           50                         push	ax
31617                                           ! Debug: list int = const $3F5 (used reg = )
31618 9140           B8                   03F5  mov	ax,#$3F5
31619 9143           50                         push	ax
31620                                           ! Debug: func () void = outb+0 (used reg = )
31621 9144           E8         740D            call	_outb
31622 9147           83C4                   04  add	sp,*4
31623                                           !BCC_EOS
31624                                           ! 4647         outb(0x03f5, track);
31625                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
31626 914A           8A46         FD            mov	al,-3[bp]
31627 914D           30E4                       xor	ah,ah
31628 914F           50                         push	ax
31629                                           ! Debug: list int = const $3F5 (used reg = )
31630 9150           B8                   03F5  mov	ax,#$3F5
31631 9153           50                         push	ax
31632                                           ! Debug: func () void = outb+0 (used reg = )
31633 9154           E8         73FD            call	_outb
31634 9157           83C4                   04  add	sp,*4
31635                                           !BCC_EOS
31636                                           ! 4648         outb(0x03f5, head);
31637                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
31638 915A           8A46         FB            mov	al,-5[bp]
31639 915D           30E4                       xor	ah,ah
31640 915F           50                         push	ax
31641                                           ! Debug: list int = const $3F5 (used reg = )
31642 9160           B8                   03F5  mov	ax,#$3F5
31643 9163           50                         push	ax
31644                                           ! Debug: func () void = outb+0 (used reg = )
31645 9164           E8         73ED            call	_outb
31646 9167           83C4                   04  add	sp,*4
31647                                           !BCC_EOS
31648                                           ! 4649         outb(0x03f5, sector);
31649                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
31650 916A           8A46         FC            mov	al,-4[bp]
31651 916D           30E4                       xor	ah,ah
31652 916F           50                         push	ax
31653                                           ! Debug: list int = const $3F5 (used reg = )
31654 9170           B8                   03F5  mov	ax,#$3F5
31655 9173           50                         push	ax
31656                                           ! Debug: func () void = outb+0 (used reg = )
31657 9174           E8         73DD            call	_outb
31658 9177           83C4                   04  add	sp,*4
31659                                           !BCC_EOS
31660                                           ! 4650         outb(0x03f5, 2);
31661                                           ! Debug: list int = const 2 (used reg = )
31662 917A           B8                   0002  mov	ax,*2
31663 917D           50                         push	ax
31664                                           ! Debug: list int = const $3F5 (used reg = )
31665 917E           B8                   03F5  mov	ax,#$3F5
31666 9181           50                         push	ax
31667                                           ! Debug: func () void = outb+0 (used reg = )
31668 9182           E8         73CF            call	_outb
31669 9185           83C4                   04  add	sp,*4
31670                                           !BCC_EOS
31671                                           ! 4651         outb(0x03f5, sector + num_sectors - 1);
31672                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
31673 9188           8A46         FC            mov	al,-4[bp]
31674 918B           30E4                       xor	ah,ah
31675 918D           0246         FE            add	al,-2[bp]
31676 9190           80D4                   00  adc	ah,*0
31677                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
31678                                           ! Debug: list unsigned int = ax-1 (used reg = )
31679 9193           48                         dec	ax
31680 9194           50                         push	ax
31681                                           ! Debug: list int = const $3F5 (used reg = )
31682 9195           B8                   03F5  mov	ax,#$3F5
31683 9198           50                         push	ax
31684                                           ! Debug: func () void = outb+0 (used reg = )
31685 9199           E8         73B8            call	_outb
31686 919C           83C4                   04  add	sp,*4
31687                                           !BCC_EOS
31688                                           ! 4652         outb(0x03f5, 0);
31689                                           ! Debug: list int = const 0 (used reg = )
31690 919F           31C0                       xor	ax,ax
31691 91A1           50                         push	ax
31692                                           ! Debug: list int = const $3F5 (used reg = )
31693 91A2           B8                   03F5  mov	ax,#$3F5
31694 91A5           50                         push	ax
31695                                           ! Debug: func () void = outb+0 (used reg = )
31696 91A6           E8         73AB            call	_outb
31697 91A9           83C4                   04  add	sp,*4
31698                                           !BCC_EOS
31699                                           ! 4653         outb(0x03f5, 0xff);
31700                                           ! Debug: list int = const $FF (used reg = )
31701 91AC           B8                   00FF  mov	ax,#$FF
31702 91AF           50                         push	ax
31703                                           ! Debug: list int = const $3F5 (used reg = )
31704 91B0           B8                   03F5  mov	ax,#$3F5
31705 91B3           50                         push	ax
31706                                           ! Debug: func () void = outb+0 (used reg = )
31707 91B4           E8         739D            call	_outb
31708 91B7           83C4                   04  add	sp,*4
31709                                           !BCC_EOS
31710                                           ! 4654 #asm
31711                                           !BCC_EOS
31712                                           !BCC_ASM
31713                       0000002A            _int13_diskette_function.BP	set	$2A
31714                       0000000C            .int13_diskette_function.BP	set	$C
31715                       00000038            _int13_diskette_function.CS	set	$38
31716                       0000001A            .int13_diskette_function.CS	set	$1A
31717                       00000032            _int13_diskette_function.CX	set	$32
31718                       00000014            .int13_diskette_function.CX	set	$14
31719                       00000016            _int13_diskette_function.base_address	set	$16
31720                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
31721                       00000026            _int13_diskette_function.DI	set	$26
31722                       00000008            .int13_diskette_function.DI	set	8
31723                       0000003A            _int13_diskette_function.FLAGS	set	$3A
31724                       0000001C            .int13_diskette_function.FLAGS	set	$1C
31725                       00000014            _int13_diskette_function.base_count	set	$14
31726                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
31727                       0000001A            _int13_diskette_function.sector	set	$1A
31728                       FFFFFFFC            .int13_diskette_function.sector	set	-4
31729                       00000022            _int13_diskette_function.DS	set	$22
31730                       00000004            .int13_diskette_function.DS	set	4
31731                       00000019            _int13_diskette_function.head	set	$19
31732                       FFFFFFFB            .int13_diskette_function.head	set	-5
31733                       0000002C            _int13_diskette_function.ELDX	set	$2C
31734                       0000000E            .int13_diskette_function.ELDX	set	$E
31735                       0000000E            _int13_diskette_function.dor	set	$E
31736                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
31737                       00000030            _int13_diskette_function.DX	set	$30
31738                       00000012            .int13_diskette_function.DX	set	$12
31739                       00000007            _int13_diskette_function.return_status	set	7
31740                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
31741                       00000002            _int13_diskette_function.es	set	2
31742                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
31743                       00000010            _int13_diskette_function.mode_register	set	$10
31744                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
31745                       00000024            _int13_diskette_function.ES	set	$24
31746                       00000006            .int13_diskette_function.ES	set	6
31747                       00000012            _int13_diskette_function.base_es	set	$12
31748                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
31749                       0000001B            _int13_diskette_function.track	set	$1B
31750                       FFFFFFFD            .int13_diskette_function.track	set	-3
31751                       00000028            _int13_diskette_function.SI	set	$28
31752                       0000000A            .int13_diskette_function.SI	set	$A
31753                       00000006            _int13_diskette_function.drive_type	set	6
31754                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
31755                       0000001C            _int13_diskette_function.num_sectors	set	$1C
31756                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
31757                       00000036            _int13_diskette_function.IP	set	$36
31758                       00000018            .int13_diskette_function.IP	set	$18
31759                       00000018            _int13_diskette_function.status	set	$18
31760                       FFFFFFFA            .int13_diskette_function.status	set	-6
31761                       00000034            _int13_diskette_function.AX	set	$34
31762                       00000016            .int13_diskette_function.AX	set	$16
31763                       0000000F            _int13_diskette_function.val8	set	$F
31764                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
31765                       00000000            _int13_diskette_function.last_addr	set	0
31766                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
31767                       00000011            _int13_diskette_function.page	set	$11
31768                       FFFFFFF3            .int13_diskette_function.page	set	-$D
31769                       00000004            _int13_diskette_function.ah	set	4
31770                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
31771                       0000001D            _int13_diskette_function.drive	set	$1D
31772                       FFFFFFFF            .int13_diskette_function.drive	set	-1
31773                       00000005            _int13_diskette_function.num_floppies	set	5
31774                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
31775                       0000002E            _int13_diskette_function.BX	set	$2E
31776                       00000010            .int13_diskette_function.BX	set	$10
31777 91BA           FB                                 sti
31778                                           ! 4656 endasm
31779                                           !BCC_ENDASM
31780                                           !BCC_EOS
31781                                           ! 4657         do {
31782                       000091BB            .69E:
31783                                           ! 4658           val8 = read_byte(0x0040, 0x0040);
31784                                           ! Debug: list int = const $40 (used reg = )
31785 91BB           B8                   0040  mov	ax,*$40
31786 91BE           50                         push	ax
31787                                           ! Debug: list int = const $40 (used reg = )
31788 91BF           B8                   0040  mov	ax,*$40
31789 91C2           50                         push	ax
31790                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31791 91C3           E8         742E            call	_read_byte
31792 91C6           83C4                   04  add	sp,*4
31793                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31794 91C9           8846         F1            mov	-$F[bp],al
31795                                           !BCC_EOS
31796                                           ! 4659           if (val8 == 0) {
31797                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31798 91CC           8A46         F1            mov	al,-$F[bp]
31799 91CF           84C0                       test	al,al
31800 91D1           75           2D            jne 	.69F
31801                       000091D3            .6A0:
31802                                           ! 4660             floppy_reset_controller();
31803                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
31804 91D3           E8         F81C            call	_floppy_reset_controller
31805                                           !BCC_EOS
31806                                           ! 4661             AX = ((AX & 0x00ff) | ((0x80) << 8));
31807                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31808 91D6           8A46         16            mov	al,$16[bp]
31809                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31810 91D9           30E4                       xor	ah,ah
31811 91DB           0D                   8000  or	ax,#-$8000
31812                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31813 91DE           8946         16            mov	$16[bp],ax
31814                                           !BCC_EOS
31815                                           ! 4662             set_diskette_ret_status(0x80);
31816                                           ! Debug: list int = const $80 (used reg = )
31817 91E1           B8                   0080  mov	ax,#$80
31818 91E4           50                         push	ax
31819                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31820 91E5           E8         0D0B            call	_set_diskette_ret_status
31821 91E8           44                         inc	sp
31822 91E9           44                         inc	sp
31823                                           !BCC_EOS
31824                                           ! 4663             AX = ((AX & 0xff00) | (0));
31825                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31826 91EA           8B46         16            mov	ax,$16[bp]
31827 91ED           30C0                       xor	al,al
31828                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31829 91EF           0C                     00  or	al,*0
31830                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31831 91F1           8946         16            mov	$16[bp],ax
31832                                           !BCC_EOS
31833                                           ! 4664             FLAGS |= 0x0001;
31834                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31835 91F4           8B46         1C            mov	ax,$1C[bp]
31836 91F7           0C                     01  or	al,*1
31837 91F9           8946         1C            mov	$1C[bp],ax
31838                                           !BCC_EOS
31839                                           ! 4665             return;
31840 91FC           89EC                       mov	sp,bp
31841 91FE           5D                         pop	bp
31842 91FF           C3                         ret
31843                                           !BCC_EOS
31844                                           ! 4666           }
31845                                           ! 4667           val8 = (read_byte(0x0040, 0x003e) & 0x80);
31846                       00009200            .69F:
31847                                           ! Debug: list int = const $3E (used reg = )
31848 9200           B8                   003E  mov	ax,*$3E
31849 9203           50                         push	ax
31850                                           ! Debug: list int = const $40 (used reg = )
31851 9204           B8                   0040  mov	ax,*$40
31852 9207           50                         push	ax
31853                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31854 9208           E8         73E9            call	_read_byte
31855 920B           83C4                   04  add	sp,*4
31856                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
31857 920E           24                     80  and	al,#$80
31858                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31859 9210           8846         F1            mov	-$F[bp],al
31860                                           !BCC_EOS
31861                                           ! 4668         } while ( val8 == 0 );
31862                       00009213            .69D:
31863                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31864 9213           8A46         F1            mov	al,-$F[bp]
31865 9216           84C0                       test	al,al
31866 9218           74           A1            je 	.69E
31867                       0000921A            .6A1:
31868                                           !BCC_EOS
31869                                           ! 4669         val8 = 0;
31870                       0000921A            .69C:
31871                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31872 921A           30C0                       xor	al,al
31873 921C           8846         F1            mov	-$F[bp],al
31874                                           !BCC_EOS
31875                                           ! 4670 #asm
31876                                           !BCC_EOS
31877                                           !BCC_ASM
31878                       0000002A            _int13_diskette_function.BP	set	$2A
31879                       0000000C            .int13_diskette_function.BP	set	$C
31880                       00000038            _int13_diskette_function.CS	set	$38
31881                       0000001A            .int13_diskette_function.CS	set	$1A
31882                       00000032            _int13_diskette_function.CX	set	$32
31883                       00000014            .int13_diskette_function.CX	set	$14
31884                       00000016            _int13_diskette_function.base_address	set	$16
31885                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
31886                       00000026            _int13_diskette_function.DI	set	$26
31887                       00000008            .int13_diskette_function.DI	set	8
31888                       0000003A            _int13_diskette_function.FLAGS	set	$3A
31889                       0000001C            .int13_diskette_function.FLAGS	set	$1C
31890                       00000014            _int13_diskette_function.base_count	set	$14
31891                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
31892                       0000001A            _int13_diskette_function.sector	set	$1A
31893                       FFFFFFFC            .int13_diskette_function.sector	set	-4
31894                       00000022            _int13_diskette_function.DS	set	$22
31895                       00000004            .int13_diskette_function.DS	set	4
31896                       00000019            _int13_diskette_function.head	set	$19
31897                       FFFFFFFB            .int13_diskette_function.head	set	-5
31898                       0000002C            _int13_diskette_function.ELDX	set	$2C
31899                       0000000E            .int13_diskette_function.ELDX	set	$E
31900                       0000000E            _int13_diskette_function.dor	set	$E
31901                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
31902                       00000030            _int13_diskette_function.DX	set	$30
31903                       00000012            .int13_diskette_function.DX	set	$12
31904                       00000007            _int13_diskette_function.return_status	set	7
31905                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
31906                       00000002            _int13_diskette_function.es	set	2
31907                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
31908                       00000010            _int13_diskette_function.mode_register	set	$10
31909                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
31910                       00000024            _int13_diskette_function.ES	set	$24
31911                       00000006            .int13_diskette_function.ES	set	6
31912                       00000012            _int13_diskette_function.base_es	set	$12
31913                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
31914                       0000001B            _int13_diskette_function.track	set	$1B
31915                       FFFFFFFD            .int13_diskette_function.track	set	-3
31916                       00000028            _int13_diskette_function.SI	set	$28
31917                       0000000A            .int13_diskette_function.SI	set	$A
31918                       00000006            _int13_diskette_function.drive_type	set	6
31919                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
31920                       0000001C            _int13_diskette_function.num_sectors	set	$1C
31921                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
31922                       00000036            _int13_diskette_function.IP	set	$36
31923                       00000018            .int13_diskette_function.IP	set	$18
31924                       00000018            _int13_diskette_function.status	set	$18
31925                       FFFFFFFA            .int13_diskette_function.status	set	-6
31926                       00000034            _int13_diskette_function.AX	set	$34
31927                       00000016            .int13_diskette_function.AX	set	$16
31928                       0000000F            _int13_diskette_function.val8	set	$F
31929                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
31930                       00000000            _int13_diskette_function.last_addr	set	0
31931                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
31932                       00000011            _int13_diskette_function.page	set	$11
31933                       FFFFFFF3            .int13_diskette_function.page	set	-$D
31934                       00000004            _int13_diskette_function.ah	set	4
31935                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
31936                       0000001D            _int13_diskette_function.drive	set	$1D
31937                       FFFFFFFF            .int13_diskette_function.drive	set	-1
31938                       00000005            _int13_diskette_function.num_floppies	set	5
31939                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
31940                       0000002E            _int13_diskette_function.BX	set	$2E
31941                       00000010            .int13_diskette_function.BX	set	$10
31942 921F           FA                                 cli
31943                                           ! 4672 endasm
31944                                           !BCC_ENDASM
31945                                           !BCC_EOS
31946                                           ! 4673         val8 = read_byte(0x0040, 0x003e);
31947                                           ! Debug: list int = const $3E (used reg = )
31948 9220           B8                   003E  mov	ax,*$3E
31949 9223           50                         push	ax
31950                                           ! Debug: list int = const $40 (used reg = )
31951 9224           B8                   0040  mov	ax,*$40
31952 9227           50                         push	ax
31953                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31954 9228           E8         73C9            call	_read_byte
31955 922B           83C4                   04  add	sp,*4
31956                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31957 922E           8846         F1            mov	-$F[bp],al
31958                                           !BCC_EOS
31959                                           ! 4674         val8 &= 0x7f;
31960                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
31961 9231           8A46         F1            mov	al,-$F[bp]
31962 9234           24                     7F  and	al,*$7F
31963 9236           8846         F1            mov	-$F[bp],al
31964                                           !BCC_EOS
31965                                           ! 4675         write_byte(0x0040, 0x003e, val8);
31966                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
31967 9239           8A46         F1            mov	al,-$F[bp]
31968 923C           30E4                       xor	ah,ah
31969 923E           50                         push	ax
31970                                           ! Debug: list int = const $3E (used reg = )
31971 923F           B8                   003E  mov	ax,*$3E
31972 9242           50                         push	ax
31973                                           ! Debug: list int = const $40 (used reg = )
31974 9243           B8                   0040  mov	ax,*$40
31975 9246           50                         push	ax
31976                                           ! Debug: func () void = write_byte+0 (used reg = )
31977 9247           E8         73D0            call	_write_byte
31978 924A           83C4                   06  add	sp,*6
31979                                           !BCC_EOS
31980                                           ! 4676         val8 = inb(0x3f4);
31981                                           ! Debug: list int = const $3F4 (used reg = )
31982 924D           B8                   03F4  mov	ax,#$3F4
31983 9250           50                         push	ax
31984                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31985 9251           E8         72EA            call	_inb
31986 9254           44                         inc	sp
31987 9255           44                         inc	sp
31988                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31989 9256           8846         F1            mov	-$F[bp],al
31990                                           !BCC_EOS
31991                                           ! 4677         if ( (val8 & 0xc0) != 0xc0 )
31992                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
31993 9259           8A46         F1            mov	al,-$F[bp]
31994 925C           24                     C0  and	al,#$C0
31995                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
31996 925E           3C                     C0  cmp	al,#$C0
31997 9260           74           0E            je  	.6A2
31998                       00009262            .6A3:
31999                                           ! 4678           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32000                                           ! Debug: list * char = .6A4+0 (used reg = )
32001 9262           BB                   D0F6  mov	bx,#.6A4
32002 9265           53                         push	bx
32003                                           ! Debug: list int = const 7 (used reg = )
32004 9266           B8                   0007  mov	ax,*7
32005 9269           50                         push	ax
32006                                           ! Debug: func () void = bios_printf+0 (used reg = )
32007 926A           E8         77AE            call	_bios_printf
32008 926D           83C4                   04  add	sp,*4
32009                                           !BCC_EOS
32010                                           ! 4679         return_status[0] = inb(0x3f5);
32011                       00009270            .6A2:
32012                                           ! Debug: list int = const $3F5 (used reg = )
32013 9270           B8                   03F5  mov	ax,#$3F5
32014 9273           50                         push	ax
32015                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32016 9274           E8         72C7            call	_inb
32017 9277           44                         inc	sp
32018 9278           44                         inc	sp
32019                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32020 9279           8846         E9            mov	-$17[bp],al
32021                                           !BCC_EOS
32022                                           ! 4680         return_status[1] = inb(0x3f5);
32023                                           ! Debug: list int = const $3F5 (used reg = )
32024 927C           B8                   03F5  mov	ax,#$3F5
32025 927F           50                         push	ax
32026                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32027 9280           E8         72BB            call	_inb
32028 9283           44                         inc	sp
32029 9284           44                         inc	sp
32030                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32031 9285           8846         EA            mov	-$16[bp],al
32032                                           !BCC_EOS
32033                                           ! 4681         return_status[2] = inb(0x3f5);
32034                                           ! Debug: list int = const $3F5 (used reg = )
32035 9288           B8                   03F5  mov	ax,#$3F5
32036 928B           50                         push	ax
32037                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32038 928C           E8         72AF            call	_inb
32039 928F           44                         inc	sp
32040 9290           44                         inc	sp
32041                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32042 9291           8846         EB            mov	-$15[bp],al
32043                                           !BCC_EOS
32044                                           ! 4682         return_status[3] = inb(0x3f5);
32045                                           ! Debug: list int = const $3F5 (used reg = )
32046 9294           B8                   03F5  mov	ax,#$3F5
32047 9297           50                         push	ax
32048                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32049 9298           E8         72A3            call	_inb
32050 929B           44                         inc	sp
32051 929C           44                         inc	sp
32052                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32053 929D           8846         EC            mov	-$14[bp],al
32054                                           !BCC_EOS
32055                                           ! 4683         return_status[4] = inb(0x3f5);
32056                                           ! Debug: list int = const $3F5 (used reg = )
32057 92A0           B8                   03F5  mov	ax,#$3F5
32058 92A3           50                         push	ax
32059                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32060 92A4           E8         7297            call	_inb
32061 92A7           44                         inc	sp
32062 92A8           44                         inc	sp
32063                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32064 92A9           8846         ED            mov	-$13[bp],al
32065                                           !BCC_EOS
32066                                           ! 4684         return_status[5] = inb(0x3f5);
32067                                           ! Debug: list int = const $3F5 (used reg = )
32068 92AC           B8                   03F5  mov	ax,#$3F5
32069 92AF           50                         push	ax
32070                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32071 92B0           E8         728B            call	_inb
32072 92B3           44                         inc	sp
32073 92B4           44                         inc	sp
32074                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
32075 92B5           8846         EE            mov	-$12[bp],al
32076                                           !BCC_EOS
32077                                           ! 4685         return_status[6] = inb(0x3f5);
32078                                           ! Debug: list int = const $3F5 (used reg = )
32079 92B8           B8                   03F5  mov	ax,#$3F5
32080 92BB           50                         push	ax
32081                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32082 92BC           E8         727F            call	_inb
32083 92BF           44                         inc	sp
32084 92C0           44                         inc	sp
32085                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
32086 92C1           8846         EF            mov	-$11[bp],al
32087                                           !BCC_EOS
32088                                           ! 4686         write_byte(0x0040, 0x0042, return_status[0]);
32089                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
32090 92C4           8A46         E9            mov	al,-$17[bp]
32091 92C7           30E4                       xor	ah,ah
32092 92C9           50                         push	ax
32093                                           ! Debug: list int = const $42 (used reg = )
32094 92CA           B8                   0042  mov	ax,*$42
32095 92CD           50                         push	ax
32096                                           ! Debug: list int = const $40 (used reg = )
32097 92CE           B8                   0040  mov	ax,*$40
32098 92D1           50                         push	ax
32099                                           ! Debug: func () void = write_byte+0 (used reg = )
32100 92D2           E8         7345            call	_write_byte
32101 92D5           83C4                   06  add	sp,*6
32102                                           !BCC_EOS
32103                                           ! 4687         write_byte(0x0040, 0x0043, return_status[1]);
32104                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
32105 92D8           8A46         EA            mov	al,-$16[bp]
32106 92DB           30E4                       xor	ah,ah
32107 92DD           50                         push	ax
32108                                           ! Debug: list int = const $43 (used reg = )
32109 92DE           B8                   0043  mov	ax,*$43
32110 92E1           50                         push	ax
32111                                           ! Debug: list int = const $40 (used reg = )
32112 92E2           B8                   0040  mov	ax,*$40
32113 92E5           50                         push	ax
32114                                           ! Debug: func () void = write_byte+0 (used reg = )
32115 92E6           E8         7331            call	_write_byte
32116 92E9           83C4                   06  add	sp,*6
32117                                           !BCC_EOS
32118                                           ! 4688         write_byte(0x0040, 0x0044, return_status
32119                                           ! 4688 [2]);
32120                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
32121 92EC           8A46         EB            mov	al,-$15[bp]
32122 92EF           30E4                       xor	ah,ah
32123 92F1           50                         push	ax
32124                                           ! Debug: list int = const $44 (used reg = )
32125 92F2           B8                   0044  mov	ax,*$44
32126 92F5           50                         push	ax
32127                                           ! Debug: list int = const $40 (used reg = )
32128 92F6           B8                   0040  mov	ax,*$40
32129 92F9           50                         push	ax
32130                                           ! Debug: func () void = write_byte+0 (used reg = )
32131 92FA           E8         731D            call	_write_byte
32132 92FD           83C4                   06  add	sp,*6
32133                                           !BCC_EOS
32134                                           ! 4689         write_byte(0x0040, 0x0045, return_status[3]);
32135                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
32136 9300           8A46         EC            mov	al,-$14[bp]
32137 9303           30E4                       xor	ah,ah
32138 9305           50                         push	ax
32139                                           ! Debug: list int = const $45 (used reg = )
32140 9306           B8                   0045  mov	ax,*$45
32141 9309           50                         push	ax
32142                                           ! Debug: list int = const $40 (used reg = )
32143 930A           B8                   0040  mov	ax,*$40
32144 930D           50                         push	ax
32145                                           ! Debug: func () void = write_byte+0 (used reg = )
32146 930E           E8         7309            call	_write_byte
32147 9311           83C4                   06  add	sp,*6
32148                                           !BCC_EOS
32149                                           ! 4690         write_byte(0x0040, 0x0046, return_status[4]);
32150                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
32151 9314           8A46         ED            mov	al,-$13[bp]
32152 9317           30E4                       xor	ah,ah
32153 9319           50                         push	ax
32154                                           ! Debug: list int = const $46 (used reg = )
32155 931A           B8                   0046  mov	ax,*$46
32156 931D           50                         push	ax
32157                                           ! Debug: list int = const $40 (used reg = )
32158 931E           B8                   0040  mov	ax,*$40
32159 9321           50                         push	ax
32160                                           ! Debug: func () void = write_byte+0 (used reg = )
32161 9322           E8         72F5            call	_write_byte
32162 9325           83C4                   06  add	sp,*6
32163                                           !BCC_EOS
32164                                           ! 4691         write_byte(0x0040, 0x0047, return_status[5]);
32165                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
32166 9328           8A46         EE            mov	al,-$12[bp]
32167 932B           30E4                       xor	ah,ah
32168 932D           50                         push	ax
32169                                           ! Debug: list int = const $47 (used reg = )
32170 932E           B8                   0047  mov	ax,*$47
32171 9331           50                         push	ax
32172                                           ! Debug: list int = const $40 (used reg = )
32173 9332           B8                   0040  mov	ax,*$40
32174 9335           50                         push	ax
32175                                           ! Debug: func () void = write_byte+0 (used reg = )
32176 9336           E8         72E1            call	_write_byte
32177 9339           83C4                   06  add	sp,*6
32178                                           !BCC_EOS
32179                                           ! 4692         write_byte(0x0040, 0x0048, return_status[6]);
32180                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
32181 933C           8A46         EF            mov	al,-$11[bp]
32182 933F           30E4                       xor	ah,ah
32183 9341           50                         push	ax
32184                                           ! Debug: list int = const $48 (used reg = )
32185 9342           B8                   0048  mov	ax,*$48
32186 9345           50                         push	ax
32187                                           ! Debug: list int = const $40 (used reg = )
32188 9346           B8                   0040  mov	ax,*$40
32189 9349           50                         push	ax
32190                                           ! Debug: func () void = write_byte+0 (used reg = )
32191 934A           E8         72CD            call	_write_byte
32192 934D           83C4                   06  add	sp,*6
32193                                           !BCC_EOS
32194                                           ! 4693         if ( (return_status[0] & 0xc0) != 0 ) {
32195                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
32196 9350           8A46         E9            mov	al,-$17[bp]
32197 9353           24                     C0  and	al,#$C0
32198                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32199 9355           84C0                       test	al,al
32200 9357           74           2A            je  	.6A5
32201                       00009359            .6A6:
32202                                           ! 4694           AX = ((AX & 0x00ff) | ((0x20) << 8));
32203                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32204 9359           8A46         16            mov	al,$16[bp]
32205                                           ! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
32206 935C           30E4                       xor	ah,ah
32207 935E           0D                   2000  or	ax,#$2000
32208                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32209 9361           8946         16            mov	$16[bp],ax
32210                                           !BCC_EOS
32211                                           ! 4695           set_diskette_ret_status(0x20);
32212                                           ! Debug: list int = const $20 (used reg = )
32213 9364           B8                   0020  mov	ax,*$20
32214 9367           50                         push	ax
32215                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32216 9368           E8         0B88            call	_set_diskette_ret_status
32217 936B           44                         inc	sp
32218 936C           44                         inc	sp
32219                                           !BCC_EOS
32220                                           ! 4696           AX = ((AX & 0xff00) | (0));
32221                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32222 936D           8B46         16            mov	ax,$16[bp]
32223 9370           30C0                       xor	al,al
32224                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32225 9372           0C                     00  or	al,*0
32226                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32227 9374           8946         16            mov	$16[bp],ax
32228                                           !BCC_EOS
32229                                           ! 4697           FLAGS |= 0x0001;
32230                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32231 9377           8B46         1C            mov	ax,$1C[bp]
32232 937A           0C                     01  or	al,*1
32233 937C           8946         1C            mov	$1C[bp],ax
32234                                           !BCC_EOS
32235                                           ! 4698           return;
32236 937F           89EC                       mov	sp,bp
32237 9381           5D                         pop	bp
32238 9382           C3                         ret
32239                                           !BCC_EOS
32240                                           ! 4699         }
32241                                           ! 4700         set_diskette_current_cyl(drive, track);
32242                       00009383            .6A5:
32243                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32244 9383           8A46         FD            mov	al,-3[bp]
32245 9386           30E4                       xor	ah,ah
32246 9388           50                         push	ax
32247                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
32248 9389           8A46         FF            mov	al,-1[bp]
32249 938C           30E4                       xor	ah,ah
32250 938E           50                         push	ax
32251                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
32252 938F           E8         0B79            call	_set_diskette_current_cyl
32253 9392           83C4                   04  add	sp,*4
32254                                           !BCC_EOS
32255                                           ! 4701         AX = ((AX & 0x00ff) | ((0x00) << 8));
32256                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32257 9395           8A46         16            mov	al,$16[bp]
32258                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32259 9398           0C                     00  or	al,*0
32260                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
32261 939A           30E4                       xor	ah,ah
32262 939C           8946         16            mov	$16[bp],ax
32263                                           !BCC_EOS
32264                                           ! 4702         FLAGS &= 0xfffe;
32265                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32266 939F           8B46         1C            mov	ax,$1C[bp]
32267 93A2           24                     FE  and	al,#$FE
32268 93A4           8946         1C            mov	$1C[bp],ax
32269                                           !BCC_EOS
32270                                           ! 4703         return;
32271 93A7           89EC                       mov	sp,bp
32272 93A9           5D                         pop	bp
32273 93AA           C3                         ret
32274                                           !BCC_EOS
32275                                           ! 4704       } else if (ah == 0x03) {
32276 93AB           E9         03D7            br 	.6A7
32277                       000093AE            .696:
32278                                           ! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
32279 93AE           8A46         E6            mov	al,-$1A[bp]
32280 93B1           3C                     03  cmp	al,*3
32281 93B3         0F85         03A6            bne 	.6A8
32282                       000093B7            .6A9:
32283                                           ! 4705         page = (ES >> 12);
32284                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
32285 93B7           8B46         06            mov	ax,6[bp]
32286 93BA           88E0                       mov	al,ah
32287 93BC           30E4                       xor	ah,ah
32288 93BE           B1                     04  mov	cl,*4
32289 93C0           D3E8                       shr	ax,cl
32290                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
32291 93C2           8846         F3            mov	-$D[bp],al
32292                                           !BCC_EOS
32293                                           ! 4706         base_es = (ES << 4);
32294                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
32295 93C5           8B46         06            mov	ax,6[bp]
32296 93C8           B1                     04  mov	cl,*4
32297 93CA           D3E0                       shl	ax,cl
32298                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
32299 93CC           8946         F4            mov	-$C[bp],ax
32300                                           !BCC_EOS
32301                                           ! 4707         base_address = base_es + BX;
32302                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
32303 93CF           8B46         F4            mov	ax,-$C[bp]
32304 93D2           0346         10            add	ax,$10[bp]
32305                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
32306 93D5           8946         F8            mov	-8[bp],ax
32307                                           !BCC_EOS
32308                                           ! 4708         if ( base_address < base_es ) {
32309                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
32310 93D8           8B46         F8            mov	ax,-8[bp]
32311 93DB           3B46         F4            cmp	ax,-$C[bp]
32312 93DE           73           07            jae 	.6AA
32313                       000093E0            .6AB:
32314                                           ! 4709           page++;
32315                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
32316 93E0           8A46         F3            mov	al,-$D[bp]
32317 93E3           40                         inc	ax
32318 93E4           8846         F3            mov	-$D[bp],al
32319                                           !BCC_EOS
32320                                           ! 4710         }
32321                                           ! 4711         base_count = (num_sectors * 512) - 1;
32322                       000093E7            .6AA:
32323                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
32324 93E7           8A46         FE            mov	al,-2[bp]
32325 93EA           30E4                       xor	ah,ah
32326 93EC           B9                   0200  mov	cx,#$200
32327 93EF           F7E9                       imul	cx
32328                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32329                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
32330 93F1           48                         dec	ax
32331 93F2           8946         F6            mov	-$A[bp],ax
32332                                           !BCC_EOS
32333                                           ! 4712         last_addr = base_address + base_count;
32334                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
32335 93F5           8B46         F8            mov	ax,-8[bp]
32336 93F8           0346         F6            add	ax,-$A[bp]
32337                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
32338 93FB           8946         E2            mov	-$1E[bp],ax
32339                                           !BCC_EOS
32340                                           ! 4713         if (last_addr < base_address) {
32341                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
32342 93FE           8B46         E2            mov	ax,-$1E[bp]
32343 9401           3B46         F8            cmp	ax,-8[bp]
32344 9404           73           2A            jae 	.6AC
32345                       00009406            .6AD:
32346                                           ! 4714           AX = ((AX & 0x00ff) | ((0x09) << 8));
32347                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32348 9406           8A46         16            mov	al,$16[bp]
32349                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
32350 9409           30E4                       xor	ah,ah
32351 940B           0D                   0900  or	ax,#$900
32352                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32353 940E           8946         16            mov	$16[bp],ax
32354                                           !BCC_EOS
32355                                           ! 4715           set_diskette_ret_status(0x09);
32356                                           ! Debug: list int = const 9 (used reg = )
32357 9411           B8                   0009  mov	ax,*9
32358 9414           50                         push	ax
32359                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32360 9415           E8         0ADB            call	_set_diskette_ret_status
32361 9418           44                         inc	sp
32362 9419           44                         inc	sp
32363                                           !BCC_EOS
32364                                           ! 4716           AX = ((AX & 0xff00) | (0));
32365                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32366 941A           8B46         16            mov	ax,$16[bp]
32367 941D           30C0                       xor	al,al
32368                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32369 941F           0C                     00  or	al,*0
32370                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32371 9421           8946         16            mov	$16[bp],ax
32372                                           !BCC_EOS
32373                                           ! 4717           FLAGS |= 0x0001;
32374                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32375 9424           8B46         1C            mov	ax,$1C[bp]
32376 9427           0C                     01  or	al,*1
32377 9429           8946         1C            mov	$1C[bp],ax
32378                                           !BCC_EOS
32379                                           ! 4718           return;
32380 942C           89EC                       mov	sp,bp
32381 942E           5D                         pop	bp
32382 942F           C3                         ret
32383                                           !BCC_EOS
32384                                           ! 4719         }
32385                                           ! 4720         ;
32386                       00009430            .6AC:
32387                                           !BCC_EOS
32388                                           ! 4721         outb(0x000a, 0x06);
32389                                           ! Debug: list int = const 6 (used reg = )
32390 9430           B8                   0006  mov	ax,*6
32391 9433           50                         push	ax
32392                                           ! Debug: list int = const $A (used reg = )
32393 9434           B8                   000A  mov	ax,*$A
32394 9437           50                         push	ax
32395                                           ! Debug: func () void = outb+0 (used reg = )
32396 9438           E8         7119            call	_outb
32397 943B           83C4                   04  add	sp,*4
32398                                           !BCC_EOS
32399                                           ! 4722         outb(0x000c, 0x00);
32400                                           ! Debug: list int = const 0 (used reg = )
32401 943E           31C0                       xor	ax,ax
32402 9440           50                         push	ax
32403                                           ! Debug: list int = const $C (used reg = )
32404 9441           B8                   000C  mov	ax,*$C
32405 9444           50                         push	ax
32406                                           ! Debug: func () void = outb+0 (used reg = )
32407 9445           E8         710C            call	_outb
32408 9448           83C4                   04  add	sp,*4
32409                                           !BCC_EOS
32410                                           ! 4723         outb(0x0004, base_address);
32411                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
32412 944B           FF76         F8            push	-8[bp]
32413                                           ! Debug: list int = const 4 (used reg = )
32414 944E           B8                   0004  mov	ax,*4
32415 9451           50                         push	ax
32416                                           ! Debug: func () void = outb+0 (used reg = )
32417 9452           E8         70FF            call	_outb
32418 9455           83C4                   04  add	sp,*4
32419                                           !BCC_EOS
32420                                           ! 4724         outb(0x0004, base_address>>8);
32421                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
32422 9458           8B46         F8            mov	ax,-8[bp]
32423 945B           88E0                       mov	al,ah
32424 945D           30E4                       xor	ah,ah
32425                                           ! Debug: list unsigned int = ax+0 (used reg = )
32426 945F           50                         push	ax
32427                                           ! Debug: list int = const 4 (used reg = )
32428 9460           B8                   0004  mov	ax,*4
32429 9463           50                         push	ax
32430                                           ! Debug: func () void = outb+0 (used reg = )
32431 9464           E8         70ED            call	_outb
32432 9467           83C4                   04  add	sp,*4
32433                                           !BCC_EOS
32434                                           ! 4725         outb(0x000c, 0x00);
32435                                           ! Debug: list int = const 0 (used reg = )
32436 946A           31C0                       xor	ax,ax
32437 946C           50                         push	ax
32438                                           ! Debug: list int = const $C (used reg = )
32439 946D           B8                   000C  mov	ax,*$C
32440 9470           50                         push	ax
32441                                           ! Debug: func () void = outb+0 (used reg = )
32442 9471           E8         70E0            call	_outb
32443 9474           83C4                   04  add	sp,*4
32444                                           !BCC_EOS
32445                                           ! 4726         outb(0x0005, base_count);
32446                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
32447 9477           FF76         F6            push	-$A[bp]
32448                                           ! Debug: list int = const 5 (used reg = )
32449 947A           B8                   0005  mov	ax,*5
32450 947D           50                         push	ax
32451                                           ! Debug: func () void = outb+0 (used reg = )
32452 947E           E8         70D3            call	_outb
32453 9481           83C4                   04  add	sp,*4
32454                                           !BCC_EOS
32455                                           ! 4727         outb(0x0005, base_count>>8);
32456                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
32457 9484           8B46         F6            mov	ax,-$A[bp]
32458 9487           88E0                       mov	al,ah
32459 9489           30E4                       xor	ah,ah
32460                                           ! Debug: list unsigned int = ax+0 (used reg = )
32461 948B           50                         push	ax
32462                                           ! Debug: list int = const 5 (used reg = )
32463 948C           B8                   0005  mov	ax,*5
32464 948F           50                         push	ax
32465                                           ! Debug: func () void = outb+0 (used reg = )
32466 9490           E8         70C1            call	_outb
32467 9493           83C4                   04  add	sp,*4
32468                                           !BCC_EOS
32469                                           ! 4728         mode_register = 0x4a;
32470                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
32471 9496           B0                     4A  mov	al,*$4A
32472 9498           8846         F2            mov	-$E[bp],al
32473                                           !BCC_EOS
32474                                           ! 4729         outb(0x000b, mode_register);
32475                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
32476 949B           8A46         F2            mov	al,-$E[bp]
32477 949E           30E4                       xor	ah,ah
32478 94A0           50                         push	ax
32479                                           ! Debug: list int = const $B (used reg = )
32480 94A1           B8                   000B  mov	ax,*$B
32481 94A4           50                         push	ax
32482                                           ! Debug: func () void = outb+0 (used reg = )
32483 94A5           E8         70AC            call	_outb
32484 94A8           83C4                   04  add	sp,*4
32485                                           !BCC_EOS
32486                                           ! 4730         outb(0x0081, page);
32487                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
32488 94AB           8A46         F3            mov	al,-$D[bp]
32489 94AE           30E4                       xor	ah,ah
32490 94B0           50                         push	ax
32491                                           ! Debug: list int = const $81 (used reg = )
32492 94B1           B8                   0081  mov	ax,#$81
32493 94B4           50                         push	ax
32494                                           ! Debug: func () void = outb+0 (used reg = )
32495 94B5           E8         709C            call	_outb
32496 94B8           83C4                   04  add	sp,*4
32497                                           !BCC_EOS
32498                                           ! 4731         ;
32499                                           !BCC_EOS
32500                                           ! 4732         outb(0x000a, 0x02);
32501                                           ! Debug: list int = const 2 (used reg = )
32502 94BB           B8                   0002  mov	ax,*2
32503 94BE           50                         push	ax
32504                                           ! Debug: list int = const $A (used reg = )
32505 94BF           B8                   000A  mov	ax,*$A
32506 94C2           50                         push	ax
32507                                           ! Debug: func () void = outb+0 (used reg = )
32508 94C3           E8         708E            call	_outb
32509 94C6           83C4                   04  add	sp,*4
32510                                           !BCC_EOS
32511                                           ! 4733         floppy_prepare_controller(drive);
32512                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32513 94C9           8A46         FF            mov	al,-1[bp]
32514 94CC           30E4                       xor	ah,ah
32515 94CE           50                         push	ax
32516                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
32517 94CF           E8         F56E            call	_floppy_prepare_controller
32518 94D2           44                         inc	sp
32519 94D3           44                         inc	sp
32520                                           !BCC_EOS
32521                                           ! 4734         outb(0x03f5, 0xc5);
32522                                           ! Debug: list int = const $C5 (used reg = )
32523 94D4           B8                   00C5  mov	ax,#$C5
32524 94D7           50                         push	ax
32525                                           ! Debug: list int = const $3F5 (used reg = )
32526 94D8           B8                   03F5  mov	ax,#$3F5
32527 94DB           50                         push	ax
32528                                           ! Debug: func () void = outb+0 (used reg = )
32529 94DC           E8         7075            call	_outb
32530 94DF           83C4                   04  add	sp,*4
32531                                           !BCC_EOS
32532                                           ! 4735         outb(0x03f5, (head << 2) | drive);
32533                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
32534 94E2           8A46         FB            mov	al,-5[bp]
32535 94E5           30E4                       xor	ah,ah
32536 94E7           D1E0                       shl	ax,*1
32537 94E9           D1E0                       shl	ax,*1
32538                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
32539 94EB           0A46         FF            or	al,-1[bp]
32540                                           ! Debug: list unsigned int = ax+0 (used reg = )
32541 94EE           50                         push	ax
32542                                           ! Debug: list int = const $3F5 (used reg = )
32543 94EF           B8                   03F5  mov	ax,#$3F5
32544 94F2           50                         push	ax
32545                                           ! Debug: func () void = outb+0 (used reg = )
32546 94F3           E8         705E            call	_outb
32547 94F6           83C4                   04  add	sp,*4
32548                                           !BCC_EOS
32549                                           ! 4736         outb(0x03f5, track);
32550                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32551 94F9           8A46         FD            mov	al,-3[bp]
32552 94FC           30E4                       xor	ah,ah
32553 94FE           50                         push	ax
32554                                           ! Debug: list int = const $3F5 (used reg = )
32555 94FF           B8                   03F5  mov	ax,#$3F5
32556 9502           50                         push	ax
32557                                           ! Debug: func () void = outb+0 (used reg = )
32558 9503           E8         704E            call	_outb
32559 9506           83C4                   04  add	sp,*4
32560                                           !BCC_EOS
32561                                           ! 4737         outb(0x03f5, head);
32562                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
32563 9509           8A46         FB            mov	al,-5[bp]
32564 950C           30E4                       xor	ah,ah
32565 950E           50                         push	ax
32566                                           ! Debug: list int = const $3F5 (used reg = )
32567 950F           B8                   03F5  mov	ax,#$3F5
32568 9512           50                         push	ax
32569                                           ! Debug: func () void = outb+0 (used reg = )
32570 9513           E8         703E            call	_outb
32571 9516           83C4                   04  add	sp,*4
32572                                           !BCC_EOS
32573                                           ! 4738         outb(0x03f5, sector);
32574                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
32575 9519           8A46         FC            mov	al,-4[bp]
32576 951C           30E4                       xor	ah,ah
32577 951E           50                         push	ax
32578                                           ! Debug: list int = const $3F5 (used reg = )
32579 951F           B8                   03F5  mov	ax,#$3F5
32580 9522           50                         push	ax
32581                                           ! Debug: func () void = outb+0 (used reg = )
32582 9523           E8         702E            call	_outb
32583 9526           83C4                   04  add	sp,*4
32584                                           !BCC_EOS
32585                                           ! 4739         outb(0x03f5, 2);
32586                                           ! Debug: list int = const 2 (used reg = )
32587 9529           B8                   0002  mov	ax,*2
32588 952C           50                         push	ax
32589                                           ! Debug: list int = const $3F5 (used reg = )
32590 952D           B8                   03F5  mov	ax,#$3F5
32591 9530           50                         push	ax
32592                                           ! Debug: func () void = outb+0 (used reg = )
32593 9531           E8         7020            call	_outb
32594 9534           83C4                   04  add	sp,*4
32595                                           !BCC_EOS
32596                                           ! 4740         outb(0x03f5, sector + num_sectors - 1);
32597                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
32598 9537           8A46         FC            mov	al,-4[bp]
32599 953A           30E4                       xor	ah,ah
32600 953C           0246         FE            add	al,-2[bp]
32601 953F           80D4                   00  adc	ah,*0
32602                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32603                                           ! Debug: list unsigned int = ax-1 (used reg = )
32604 9542           48                         dec	ax
32605 9543           50                         push	ax
32606                                           ! Debug: list int = const $3F5 (used reg = )
32607 9544           B8                   03F5  mov	ax,#$3F5
32608 9547           50                         push	ax
32609                                           ! Debug: func () void = outb+0 (used reg = )
32610 9548           E8         7009            call	_outb
32611 954B           83C4                   04  add	sp,*4
32612                                           !BCC_EOS
32613                                           ! 4741         outb(0x03f5, 0);
32614                                           ! Debug: list int = const 0 (used reg = )
32615 954E           31C0                       xor	ax,ax
32616 9550           50                         push	ax
32617                                           ! Debug: list int = const $3F5 (used reg = )
32618 9551           B8                   03F5  mov	ax,#$3F5
32619 9554           50                         push	ax
32620                                           ! Debug: func () void = outb+0 (used reg = )
32621 9555           E8         6FFC            call	_outb
32622 9558           83C4                   04  add	sp,*4
32623                                           !BCC_EOS
32624                                           ! 4742         outb(0x03f5, 0xff);
32625                                           ! Debug: list int = const $FF (used reg = )
32626 955B           B8                   00FF  mov	ax,#$FF
32627 955E           50                         push	ax
32628                                           ! Debug: list int = const $3F5 (used reg = )
32629 955F           B8                   03F5  mov	ax,#$3F5
32630 9562           50                         push	ax
32631                                           ! Debug: func () void = outb+0 (used reg = )
32632 9563           E8         6FEE            call	_outb
32633 9566           83C4                   04  add	sp,*4
32634                                           !BCC_EOS
32635                                           ! 4743 #asm
32636                                           !BCC_EOS
32637                                           !BCC_ASM
32638                       0000002A            _int13_diskette_function.BP	set	$2A
32639                       0000000C            .int13_diskette_function.BP	set	$C
32640                       00000038            _int13_diskette_function.CS	set	$38
32641                       0000001A            .int13_diskette_function.CS	set	$1A
32642                       00000032            _int13_diskette_function.CX	set	$32
32643                       00000014            .int13_diskette_function.CX	set	$14
32644                       00000016            _int13_diskette_function.base_address	set	$16
32645                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32646                       00000026            _int13_diskette_function.DI	set	$26
32647                       00000008            .int13_diskette_function.DI	set	8
32648                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32649                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32650                       00000014            _int13_diskette_function.base_count	set	$14
32651                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32652                       0000001A            _int13_diskette_function.sector	set	$1A
32653                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32654                       00000022            _int13_diskette_function.DS	set	$22
32655                       00000004            .int13_diskette_function.DS	set	4
32656                       00000019            _int13_diskette_function.head	set	$19
32657                       FFFFFFFB            .int13_diskette_function.head	set	-5
32658                       0000002C            _int13_diskette_function.ELDX	set	$2C
32659                       0000000E            .int13_diskette_function.ELDX	set	$E
32660                       0000000E            _int13_diskette_function.dor	set	$E
32661                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32662                       00000030            _int13_diskette_function.DX	set	$30
32663                       00000012            .int13_diskette_function.DX	set	$12
32664                       00000007            _int13_diskette_function.return_status	set	7
32665                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32666                       00000002            _int13_diskette_function.es	set	2
32667                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32668                       00000010            _int13_diskette_function.mode_register	set	$10
32669                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32670                       00000024            _int13_diskette_function.ES	set	$24
32671                       00000006            .int13_diskette_function.ES	set	6
32672                       00000012            _int13_diskette_function.base_es	set	$12
32673                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32674                       0000001B            _int13_diskette_function.track	set	$1B
32675                       FFFFFFFD            .int13_diskette_function.track	set	-3
32676                       00000028            _int13_diskette_function.SI	set	$28
32677                       0000000A            .int13_diskette_function.SI	set	$A
32678                       00000006            _int13_diskette_function.drive_type	set	6
32679                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32680                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32681                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32682                       00000036            _int13_diskette_function.IP	set	$36
32683                       00000018            .int13_diskette_function.IP	set	$18
32684                       00000018            _int13_diskette_function.status	set	$18
32685                       FFFFFFFA            .int13_diskette_function.status	set	-6
32686                       00000034            _int13_diskette_function.AX	set	$34
32687                       00000016            .int13_diskette_function.AX	set	$16
32688                       0000000F            _int13_diskette_function.val8	set	$F
32689                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32690                       00000000            _int13_diskette_function.last_addr	set	0
32691                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32692                       00000011            _int13_diskette_function.page	set	$11
32693                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32694                       00000004            _int13_diskette_function.ah	set	4
32695                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32696                       0000001D            _int13_diskette_function.drive	set	$1D
32697                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32698                       00000005            _int13_diskette_function.num_floppies	set	5
32699                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32700                       0000002E            _int13_diskette_function.BX	set	$2E
32701                       00000010            .int13_diskette_function.BX	set	$10
32702 9569           FB                                 sti
32703                                           ! 4745 endasm
32704                                           !BCC_ENDASM
32705                                           !BCC_EOS
32706                                           ! 4746         do {
32707                       0000956A            .6B0:
32708                                           ! 4747           val8 = read_byte(0x0040, 0x0040);
32709                                           ! Debug: list int = const $40 (used reg = )
32710 956A           B8                   0040  mov	ax,*$40
32711 956D           50                         push	ax
32712                                           ! Debug: list int = const $40 (used reg = )
32713 956E           B8                   0040  mov	ax,*$40
32714 9571           50                         push	ax
32715                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32716 9572           E8         707F            call	_read_byte
32717 9575           83C4                   04  add	sp,*4
32718                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32719 9578           8846         F1            mov	-$F[bp],al
32720                                           !BCC_EOS
32721                                           ! 4748           if (val8 == 0) {
32722                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32723 957B           8A46         F1            mov	al,-$F[bp]
32724 957E           84C0                       test	al,al
32725 9580           75           2D            jne 	.6B1
32726                       00009582            .6B2:
32727                                           ! 4749             floppy_reset_controller();
32728                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
32729 9582           E8         F46D            call	_floppy_reset_controller
32730                                           !BCC_EOS
32731                                           ! 4750             AX = ((AX & 0x00ff) | ((0x80) << 8));
32732                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32733 9585           8A46         16            mov	al,$16[bp]
32734                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32735 9588           30E4                       xor	ah,ah
32736 958A           0D                   8000  or	ax,#-$8000
32737                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32738 958D           8946         16            mov	$16[bp],ax
32739                                           !BCC_EOS
32740                                           ! 4751             set_diskette_ret_status(0x80);
32741                                           ! Debug: list int = const $80 (used reg = )
32742 9590           B8                   0080  mov	ax,#$80
32743 9593           50                         push	ax
32744                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32745 9594           E8         095C            call	_set_diskette_ret_status
32746 9597           44                         inc	sp
32747 9598           44                         inc	sp
32748                                           !BCC_EOS
32749                                           ! 4752             AX
32750                                           ! 4752  = ((AX & 0xff00) | (0));
32751                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32752 9599           8B46         16            mov	ax,$16[bp]
32753 959C           30C0                       xor	al,al
32754                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32755 959E           0C                     00  or	al,*0
32756                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32757 95A0           8946         16            mov	$16[bp],ax
32758                                           !BCC_EOS
32759                                           ! 4753             FLAGS |= 0x0001;
32760                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32761 95A3           8B46         1C            mov	ax,$1C[bp]
32762 95A6           0C                     01  or	al,*1
32763 95A8           8946         1C            mov	$1C[bp],ax
32764                                           !BCC_EOS
32765                                           ! 4754             return;
32766 95AB           89EC                       mov	sp,bp
32767 95AD           5D                         pop	bp
32768 95AE           C3                         ret
32769                                           !BCC_EOS
32770                                           ! 4755           }
32771                                           ! 4756           val8 = (read_byte(0x0040, 0x003e) & 0x80);
32772                       000095AF            .6B1:
32773                                           ! Debug: list int = const $3E (used reg = )
32774 95AF           B8                   003E  mov	ax,*$3E
32775 95B2           50                         push	ax
32776                                           ! Debug: list int = const $40 (used reg = )
32777 95B3           B8                   0040  mov	ax,*$40
32778 95B6           50                         push	ax
32779                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32780 95B7           E8         703A            call	_read_byte
32781 95BA           83C4                   04  add	sp,*4
32782                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32783 95BD           24                     80  and	al,#$80
32784                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32785 95BF           8846         F1            mov	-$F[bp],al
32786                                           !BCC_EOS
32787                                           ! 4757         } while ( val8 == 0 );
32788                       000095C2            .6AF:
32789                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32790 95C2           8A46         F1            mov	al,-$F[bp]
32791 95C5           84C0                       test	al,al
32792 95C7           74           A1            je 	.6B0
32793                       000095C9            .6B3:
32794                                           !BCC_EOS
32795                                           ! 4758         val8 = 0;
32796                       000095C9            .6AE:
32797                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32798 95C9           30C0                       xor	al,al
32799 95CB           8846         F1            mov	-$F[bp],al
32800                                           !BCC_EOS
32801                                           ! 4759 #asm
32802                                           !BCC_EOS
32803                                           !BCC_ASM
32804                       0000002A            _int13_diskette_function.BP	set	$2A
32805                       0000000C            .int13_diskette_function.BP	set	$C
32806                       00000038            _int13_diskette_function.CS	set	$38
32807                       0000001A            .int13_diskette_function.CS	set	$1A
32808                       00000032            _int13_diskette_function.CX	set	$32
32809                       00000014            .int13_diskette_function.CX	set	$14
32810                       00000016            _int13_diskette_function.base_address	set	$16
32811                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32812                       00000026            _int13_diskette_function.DI	set	$26
32813                       00000008            .int13_diskette_function.DI	set	8
32814                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32815                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32816                       00000014            _int13_diskette_function.base_count	set	$14
32817                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32818                       0000001A            _int13_diskette_function.sector	set	$1A
32819                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32820                       00000022            _int13_diskette_function.DS	set	$22
32821                       00000004            .int13_diskette_function.DS	set	4
32822                       00000019            _int13_diskette_function.head	set	$19
32823                       FFFFFFFB            .int13_diskette_function.head	set	-5
32824                       0000002C            _int13_diskette_function.ELDX	set	$2C
32825                       0000000E            .int13_diskette_function.ELDX	set	$E
32826                       0000000E            _int13_diskette_function.dor	set	$E
32827                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32828                       00000030            _int13_diskette_function.DX	set	$30
32829                       00000012            .int13_diskette_function.DX	set	$12
32830                       00000007            _int13_diskette_function.return_status	set	7
32831                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32832                       00000002            _int13_diskette_function.es	set	2
32833                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32834                       00000010            _int13_diskette_function.mode_register	set	$10
32835                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32836                       00000024            _int13_diskette_function.ES	set	$24
32837                       00000006            .int13_diskette_function.ES	set	6
32838                       00000012            _int13_diskette_function.base_es	set	$12
32839                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32840                       0000001B            _int13_diskette_function.track	set	$1B
32841                       FFFFFFFD            .int13_diskette_function.track	set	-3
32842                       00000028            _int13_diskette_function.SI	set	$28
32843                       0000000A            .int13_diskette_function.SI	set	$A
32844                       00000006            _int13_diskette_function.drive_type	set	6
32845                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32846                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32847                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32848                       00000036            _int13_diskette_function.IP	set	$36
32849                       00000018            .int13_diskette_function.IP	set	$18
32850                       00000018            _int13_diskette_function.status	set	$18
32851                       FFFFFFFA            .int13_diskette_function.status	set	-6
32852                       00000034            _int13_diskette_function.AX	set	$34
32853                       00000016            .int13_diskette_function.AX	set	$16
32854                       0000000F            _int13_diskette_function.val8	set	$F
32855                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32856                       00000000            _int13_diskette_function.last_addr	set	0
32857                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32858                       00000011            _int13_diskette_function.page	set	$11
32859                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32860                       00000004            _int13_diskette_function.ah	set	4
32861                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32862                       0000001D            _int13_diskette_function.drive	set	$1D
32863                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32864                       00000005            _int13_diskette_function.num_floppies	set	5
32865                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32866                       0000002E            _int13_diskette_function.BX	set	$2E
32867                       00000010            .int13_diskette_function.BX	set	$10
32868 95CE           FA                                 cli
32869                                           ! 4761 endasm
32870                                           !BCC_ENDASM
32871                                           !BCC_EOS
32872                                           ! 4762         val8 = read_byte(0x0040, 0x003e);
32873                                           ! Debug: list int = const $3E (used reg = )
32874 95CF           B8                   003E  mov	ax,*$3E
32875 95D2           50                         push	ax
32876                                           ! Debug: list int = const $40 (used reg = )
32877 95D3           B8                   0040  mov	ax,*$40
32878 95D6           50                         push	ax
32879                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32880 95D7           E8         701A            call	_read_byte
32881 95DA           83C4                   04  add	sp,*4
32882                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32883 95DD           8846         F1            mov	-$F[bp],al
32884                                           !BCC_EOS
32885                                           ! 4763         val8 &= 0x7f;
32886                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
32887 95E0           8A46         F1            mov	al,-$F[bp]
32888 95E3           24                     7F  and	al,*$7F
32889 95E5           8846         F1            mov	-$F[bp],al
32890                                           !BCC_EOS
32891                                           ! 4764         write_byte(0x0040, 0x003e, val8);
32892                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
32893 95E8           8A46         F1            mov	al,-$F[bp]
32894 95EB           30E4                       xor	ah,ah
32895 95ED           50                         push	ax
32896                                           ! Debug: list int = const $3E (used reg = )
32897 95EE           B8                   003E  mov	ax,*$3E
32898 95F1           50                         push	ax
32899                                           ! Debug: list int = const $40 (used reg = )
32900 95F2           B8                   0040  mov	ax,*$40
32901 95F5           50                         push	ax
32902                                           ! Debug: func () void = write_byte+0 (used reg = )
32903 95F6           E8         7021            call	_write_byte
32904 95F9           83C4                   06  add	sp,*6
32905                                           !BCC_EOS
32906                                           ! 4765         val8 = inb(0x3f4);
32907                                           ! Debug: list int = const $3F4 (used reg = )
32908 95FC           B8                   03F4  mov	ax,#$3F4
32909 95FF           50                         push	ax
32910                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32911 9600           E8         6F3B            call	_inb
32912 9603           44                         inc	sp
32913 9604           44                         inc	sp
32914                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32915 9605           8846         F1            mov	-$F[bp],al
32916                                           !BCC_EOS
32917                                           ! 4766         if ( (val8 & 0xc0) != 0xc0 )
32918                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
32919 9608           8A46         F1            mov	al,-$F[bp]
32920 960B           24                     C0  and	al,#$C0
32921                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
32922 960D           3C                     C0  cmp	al,#$C0
32923 960F           74           0E            je  	.6B4
32924                       00009611            .6B5:
32925                                           ! 4767           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32926                                           ! Debug: list * char = .6B6+0 (used reg = )
32927 9611           BB                   D0D6  mov	bx,#.6B6
32928 9614           53                         push	bx
32929                                           ! Debug: list int = const 7 (used reg = )
32930 9615           B8                   0007  mov	ax,*7
32931 9618           50                         push	ax
32932                                           ! Debug: func () void = bios_printf+0 (used reg = )
32933 9619           E8         73FF            call	_bios_printf
32934 961C           83C4                   04  add	sp,*4
32935                                           !BCC_EOS
32936                                           ! 4768         return_status[0] = inb(0x3f5);
32937                       0000961F            .6B4:
32938                                           ! Debug: list int = const $3F5 (used reg = )
32939 961F           B8                   03F5  mov	ax,#$3F5
32940 9622           50                         push	ax
32941                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32942 9623           E8         6F18            call	_inb
32943 9626           44                         inc	sp
32944 9627           44                         inc	sp
32945                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32946 9628           8846         E9            mov	-$17[bp],al
32947                                           !BCC_EOS
32948                                           ! 4769         return_status[1] = inb(0x3f5);
32949                                           ! Debug: list int = const $3F5 (used reg = )
32950 962B           B8                   03F5  mov	ax,#$3F5
32951 962E           50                         push	ax
32952                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32953 962F           E8         6F0C            call	_inb
32954 9632           44                         inc	sp
32955 9633           44                         inc	sp
32956                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32957 9634           8846         EA            mov	-$16[bp],al
32958                                           !BCC_EOS
32959                                           ! 4770         return_status[2] = inb(0x3f5);
32960                                           ! Debug: list int = const $3F5 (used reg = )
32961 9637           B8                   03F5  mov	ax,#$3F5
32962 963A           50                         push	ax
32963                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32964 963B           E8         6F00            call	_inb
32965 963E           44                         inc	sp
32966 963F           44                         inc	sp
32967                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32968 9640           8846         EB            mov	-$15[bp],al
32969                                           !BCC_EOS
32970                                           ! 4771         return_status[3] = inb(0x3f5);
32971                                           ! Debug: list int = const $3F5 (used reg = )
32972 9643           B8                   03F5  mov	ax,#$3F5
32973 9646           50                         push	ax
32974                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32975 9647           E8         6EF4            call	_inb
32976 964A           44                         inc	sp
32977 964B           44                         inc	sp
32978                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32979 964C           8846         EC            mov	-$14[bp],al
32980                                           !BCC_EOS
32981                                           ! 4772         return_status[4] = inb(0x3f5);
32982                                           ! Debug: list int = const $3F5 (used reg = )
32983 964F           B8                   03F5  mov	ax,#$3F5
32984 9652           50                         push	ax
32985                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32986 9653           E8         6EE8            call	_inb
32987 9656           44                         inc	sp
32988 9657           44                         inc	sp
32989                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32990 9658           8846         ED            mov	-$13[bp],al
32991                                           !BCC_EOS
32992                                           ! 4773         return_status[5] = inb(0x3f5);
32993                                           ! Debug: list int = const $3F5 (used reg = )
32994 965B           B8                   03F5  mov	ax,#$3F5
32995 965E           50                         push	ax
32996                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32997 965F           E8         6EDC            call	_inb
32998 9662           44                         inc	sp
32999 9663           44                         inc	sp
33000                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
33001 9664           8846         EE            mov	-$12[bp],al
33002                                           !BCC_EOS
33003                                           ! 4774         return_status[6] = inb(0x3f5);
33004                                           ! Debug: list int = const $3F5 (used reg = )
33005 9667           B8                   03F5  mov	ax,#$3F5
33006 966A           50                         push	ax
33007                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33008 966B           E8         6ED0            call	_inb
33009 966E           44                         inc	sp
33010 966F           44                         inc	sp
33011                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
33012 9670           8846         EF            mov	-$11[bp],al
33013                                           !BCC_EOS
33014                                           ! 4775         write_byte(0x0040, 0x0042, return_status[0]);
33015                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
33016 9673           8A46         E9            mov	al,-$17[bp]
33017 9676           30E4                       xor	ah,ah
33018 9678           50                         push	ax
33019                                           ! Debug: list int = const $42 (used reg = )
33020 9679           B8                   0042  mov	ax,*$42
33021 967C           50                         push	ax
33022                                           ! Debug: list int = const $40 (used reg = )
33023 967D           B8                   0040  mov	ax,*$40
33024 9680           50                         push	ax
33025                                           ! Debug: func () void = write_byte+0 (used reg = )
33026 9681           E8         6F96            call	_write_byte
33027 9684           83C4                   06  add	sp,*6
33028                                           !BCC_EOS
33029                                           ! 4776         write_byte(0x0040, 0x0043, return_status[1]);
33030                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
33031 9687           8A46         EA            mov	al,-$16[bp]
33032 968A           30E4                       xor	ah,ah
33033 968C           50                         push	ax
33034                                           ! Debug: list int = const $43 (used reg = )
33035 968D           B8                   0043  mov	ax,*$43
33036 9690           50                         push	ax
33037                                           ! Debug: list int = const $40 (used reg = )
33038 9691           B8                   0040  mov	ax,*$40
33039 9694           50                         push	ax
33040                                           ! Debug: func () void = write_byte+0 (used reg = )
33041 9695           E8         6F82            call	_write_byte
33042 9698           83C4                   06  add	sp,*6
33043                                           !BCC_EOS
33044                                           ! 4777         write_byte(0x0040, 0x0044, return_status[2]);
33045                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
33046 969B           8A46         EB            mov	al,-$15[bp]
33047 969E           30E4                       xor	ah,ah
33048 96A0           50                         push	ax
33049                                           ! Debug: list int = const $44 (used reg = )
33050 96A1           B8                   0044  mov	ax,*$44
33051 96A4           50                         push	ax
33052                                           ! Debug: list int = const $40 (used reg = )
33053 96A5           B8                   0040  mov	ax,*$40
33054 96A8           50                         push	ax
33055                                           ! Debug: func () void = write_byte+0 (used reg = )
33056 96A9           E8         6F6E            call	_write_byte
33057 96AC           83C4                   06  add	sp,*6
33058                                           !BCC_EOS
33059                                           ! 4778         write_byte(0x0040, 0x0045, return_status[3]);
33060                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
33061 96AF           8A46         EC            mov	al,-$14[bp]
33062 96B2           30E4                       xor	ah,ah
33063 96B4           50                         push	ax
33064                                           ! Debug: list int = const $45 (used reg = )
33065 96B5           B8                   0045  mov	ax,*$45
33066 96B8           50                         push	ax
33067                                           ! Debug: list int = const $40 (used reg = )
33068 96B9           B8                   0040  mov	ax,*$40
33069 96BC           50                         push	ax
33070                                           ! Debug: func () void = write_byte+0 (used reg = )
33071 96BD           E8         6F5A            call	_write_byte
33072 96C0           83C4                   06  add	sp,*6
33073                                           !BCC_EOS
33074                                           ! 4779         write_byte(0x0040, 0x0046, return_status[4]);
33075                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
33076 96C3           8A46         ED            mov	al,-$13[bp]
33077 96C6           30E4                       xor	ah,ah
33078 96C8           50                         push	ax
33079                                           ! Debug: list int = const $46 (used reg = )
33080 96C9           B8                   0046  mov	ax,*$46
33081 96CC           50                         push	ax
33082                                           ! Debug: list int = const $40 (used reg = )
33083 96CD           B8                   0040  mov	ax,*$40
33084 96D0           50                         push	ax
33085                                           ! Debug: func () void = write_byte+0 (used reg = )
33086 96D1           E8         6F46            call	_write_byte
33087 96D4           83C4                   06  add	sp,*6
33088                                           !BCC_EOS
33089                                           ! 4780         write_byte(0x0040, 0x0047, return_status[5]);
33090                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
33091 96D7           8A46         EE            mov	al,-$12[bp]
33092 96DA           30E4                       xor	ah,ah
33093 96DC           50                         push	ax
33094                                           ! Debug: list int = const $47 (used reg = )
33095 96DD           B8                   0047  mov	ax,*$47
33096 96E0           50                         push	ax
33097                                           ! Debug: list int = const $40 (used reg = )
33098 96E1           B8                   0040  mov	ax,*$40
33099 96E4           50                         push	ax
33100                                           ! Debug: func () void = write_byte+0 (used reg = )
33101 96E5           E8         6F32            call	_write_byte
33102 96E8           83C4                   06  add	sp,*6
33103                                           !BCC_EOS
33104                                           ! 4781         write_byte(0x0040, 0x0048, return_status[6]);
33105                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
33106 96EB           8A46         EF            mov	al,-$11[bp]
33107 96EE           30E4                       xor	ah,ah
33108 96F0           50                         push	ax
33109                                           ! Debug: list int = const $48 (used reg = )
33110 96F1           B8                   0048  mov	ax,*$48
33111 96F4           50                         push	ax
33112                                           ! Debug: list int = const $40 (used reg = )
33113 96F5           B8                   0040  mov	ax,*$40
33114 96F8           50                         push	ax
33115                                           ! Debug: func () void = write_byte+0 (used reg = )
33116 96F9           E8         6F1E            call	_write_byte
33117 96FC           83C4                   06  add	sp,*6
33118                                           !BCC_EOS
33119                                           ! 4782         if ( (return_status[0] & 0xc0) != 0 ) {
33120                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
33121 96FF           8A46         E9            mov	al,-$17[bp]
33122 9702           24                     C0  and	al,#$C0
33123                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33124 9704           84C0                       test	al,al
33125 9706           74           2B            je  	.6B7
33126                       00009708            .6B8:
33127                                           ! 4783           if ( (return_status[1] & 0x02) != 0 ) {
33128                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
33129 9708           8A46         EA            mov	al,-$16[bp]
33130 970B           24                     02  and	al,*2
33131                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33132 970D           84C0                       test	al,al
33133 970F           74           14            je  	.6B9
33134                       00009711            .6BA:
33135                                           ! 4784             AX = 0x0300;
33136                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
33137 9711           B8                   0300  mov	ax,#$300
33138 9714           8946         16            mov	$16[bp],ax
33139                                           !BCC_EOS
33140                                           ! 4785             FLAGS |= 0x0001;
33141                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33142 9717           8B46         1C            mov	ax,$1C[bp]
33143 971A           0C                     01  or	al,*1
33144 971C           8946         1C            mov	$1C[bp],ax
33145                                           !BCC_EOS
33146                                           ! 4786             return;
33147 971F           89EC                       mov	sp,bp
33148 9721           5D                         pop	bp
33149 9722           C3                         ret
33150                                           !BCC_EOS
33151                                           ! 4787           } else {
33152 9723           EB           0E            jmp .6BB
33153                       00009725            .6B9:
33154                                           ! 4788             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
33155                                           ! Debug: list * char = .6BC+0 (used reg = )
33156 9725           BB                   D0B1  mov	bx,#.6BC
33157 9728           53                         push	bx
33158                                           ! Debug: list int = const 7 (used reg = )
33159 9729           B8                   0007  mov	ax,*7
33160 972C           50                         push	ax
33161                                           ! Debug: func () void = bios_printf+0 (used reg = )
33162 972D           E8         72EB            call	_bios_printf
33163 9730           83C4                   04  add	sp,*4
33164                                           !BCC_EOS
33165                                           ! 4789           }
33166                                           ! 4790         }
33167                       00009733            .6BB:
33168                                           ! 4791         set_diskette_current_cyl(drive, track);
33169                       00009733            .6B7:
33170                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33171 9733           8A46         FD            mov	al,-3[bp]
33172 9736           30E4                       xor	ah,ah
33173 9738           50                         push	ax
33174                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33175 9739           8A46         FF            mov	al,-1[bp]
33176 973C           30E4                       xor	ah,ah
33177 973E           50                         push	ax
33178                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33179 973F           E8         07C9            call	_set_diskette_current_cyl
33180 9742           83C4                   04  add	sp,*4
33181                                           !BCC_EOS
33182                                           ! 4792         AX = ((AX & 0x00ff) | ((0x00) << 8));
33183                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33184 9745           8A46         16            mov	al,$16[bp]
33185                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33186 9748           0C                     00  or	al,*0
33187                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33188 974A           30E4                       xor	ah,ah
33189 974C           8946         16            mov	$16[bp],ax
33190                                           !BCC_EOS
33191                                           ! 4793         FLAGS &= 0xfffe;
33192                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33193 974F           8B46         1C            mov	ax,$1C[bp]
33194 9752           24                     FE  and	al,#$FE
33195 9754           8946         1C            mov	$1C[bp],ax
33196                                           !BCC_EOS
33197                                           ! 4794         return;
33198 9757           89EC                       mov	sp,bp
33199 9759           5D                         pop	bp
33200 975A           C3                         ret
33201                                           !BCC_EOS
33202                                           ! 4795       } else {
33203 975B           EB           28            jmp .6BD
33204                       0000975D            .6A8:
33205                                           ! 4796         set_diskette_current_cyl(drive, track);
33206                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33207 975D           8A46         FD            mov	al,-3[bp]
33208 9760           30E4                       xor	ah,ah
33209 9762           50                         push	ax
33210                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33211 9763           8A46         FF            mov	al,-1[bp]
33212 9766           30E4                       xor	ah,ah
33213 9768           50                         push	ax
33214                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33215 9769           E8         079F            call	_set_diskette_current_cyl
33216 976C           83C4                   04  add	sp,*4
33217                                           !BCC_EOS
33218                                           ! 4797         FLAGS &= 0xfffe;
33219                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33220 976F           8B46         1C            mov	ax,$1C[bp]
33221 9772           24                     FE  and	al,#$FE
33222 9774           8946         1C            mov	$1C[bp],ax
33223                                           !BCC_EOS
33224                                           ! 4798         AX = ((AX & 0x00ff) | ((0x00) << 8));
33225                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33226 9777           8A46         16            mov	al,$16[bp]
33227                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33228 977A           0C                     00  or	al,*0
33229                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33230 977C           30E4                       xor	ah,ah
33231 977E           8946         16            mov	$16[bp],ax
33232                                           !BCC_EOS
33233                                           ! 4799         return;
33234 9781           89EC                       mov	sp,bp
33235 9783           5D                         pop	bp
33236 9784           C3                         ret
33237                                           !BCC_EOS
33238                                           ! 4800       }
33239                                           ! 4801       break;
33240                       00009785            .6BD:
33241                       00009785            .6A7:
33242 9785           E9         0767            br 	.679
33243                                           !BCC_EOS
33244                                           ! 4802     case 0x05:
33245                                           ! 4803 ;
33246                       00009788            .6BE:
33247                                           !BCC_EOS
33248                                           ! 4804       num_sectors = ( AX & 0x00ff );
33249                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33250 9788           8A46         16            mov	al,$16[bp]
33251                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33252 978B           8846         FE            mov	-2[bp],al
33253                                           !BCC_EOS
33254                                           ! 4805       track = ( CX >> 8 );
33255                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
33256 978E           8B46         14            mov	ax,$14[bp]
33257 9791           88E0                       mov	al,ah
33258 9793           30E4                       xor	ah,ah
33259                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
33260 9795           8846         FD            mov	-3[bp],al
33261                                           !BCC_EOS
33262                                           ! 4806       head = ( DX >> 8 );
33263                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
33264 9798           8B46         12            mov	ax,$12[bp]
33265 979B           88E0                       mov	al,ah
33266 979D           30E4                       xor	ah,ah
33267                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
33268 979F           8846         FB            mov	-5[bp],al
33269                                           !BCC_EOS
33270                                           ! 4807       drive = ( ELDX & 0x00ff );
33271                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
33272 97A2           8A46         0E            mov	al,$E[bp]
33273                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
33274 97A5           8846         FF            mov	-1[bp],al
33275                                           !BCC_EOS
33276                                           ! 4808       if ((drive > 1) || (head > 1) || (track > 79) ||
33277                                           ! 4809           (num_sectors == 0) || (num_sectors > 18)) {
33278                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
33279 97A8           8A46         FF            mov	al,-1[bp]
33280 97AB           3C                     01  cmp	al,*1
33281 97AD           77           1C            ja  	.6C0
33282                       000097AF            .6C4:
33283                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
33284 97AF           8A46         FB            mov	al,-5[bp]
33285 97B2           3C                     01  cmp	al,*1
33286 97B4           77           15            ja  	.6C0
33287                       000097B6            .6C3:
33288                                           ! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
33289 97B6           8A46         FD            mov	al,-3[bp]
33290 97B9           3C                     4F  cmp	al,*$4F
33291 97BB           77           0E            ja  	.6C0
33292                       000097BD            .6C2:
33293                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33294 97BD           8A46         FE            mov	al,-2[bp]
33295 97C0           84C0                       test	al,al
33296 97C2           74           07            je  	.6C0
33297                       000097C4            .6C1:
33298                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
33299 97C4           8A46         FE            mov	al,-2[bp]
33300 97C7           3C                     12  cmp	al,*$12
33301 97C9           76           1C            jbe 	.6BF
33302                       000097CB            .6C0:
33303                                           ! 4810         AX = ((AX & 0x00ff) | ((1) << 8));
33304                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33305 97CB           8A46         16            mov	al,$16[bp]
33306                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33307 97CE           30E4                       xor	ah,ah
33308 97D0           0D                   0100  or	ax,#$100
33309                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33310 97D3           8946         16            mov	$16[bp],ax
33311                                           !BCC_EOS
33312                                           ! 4811         set_diskette_ret_status(1);
33313                                           ! Debug: list int = const 1 (used reg = )
33314 97D6           B8                   0001  mov	ax,*1
33315 97D9           50                         push	ax
33316                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33317 97DA           E8         0716            call	_set_diskette_ret_status
33318 97DD           44                         inc	sp
33319 97DE           44                         inc	sp
33320                                           !BCC_EOS
33321                                           ! 4812         FLAGS |
33322                                           ! 4812 = 0x0001;
33323                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33324 97DF           8B46         1C            mov	ax,$1C[bp]
33325 97E2           0C                     01  or	al,*1
33326 97E4           8946         1C            mov	$1C[bp],ax
33327                                           !BCC_EOS
33328                                           ! 4813       }
33329                                           ! 4814       if (floppy_drive_exists(drive) == 0) {
33330                       000097E7            .6BF:
33331                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33332 97E7           8A46         FF            mov	al,-1[bp]
33333 97EA           30E4                       xor	ah,ah
33334 97EC           50                         push	ax
33335                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
33336 97ED           E8         F5C3            call	_floppy_drive_exists
33337 97F0           44                         inc	sp
33338 97F1           44                         inc	sp
33339                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33340 97F2           85C0                       test	ax,ax
33341 97F4           75           20            jne 	.6C5
33342                       000097F6            .6C6:
33343                                           ! 4815         AX = ((AX & 0x00ff) | ((0x80) << 8));
33344                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33345 97F6           8A46         16            mov	al,$16[bp]
33346                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33347 97F9           30E4                       xor	ah,ah
33348 97FB           0D                   8000  or	ax,#-$8000
33349                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33350 97FE           8946         16            mov	$16[bp],ax
33351                                           !BCC_EOS
33352                                           ! 4816         set_diskette_ret_status(0x80);
33353                                           ! Debug: list int = const $80 (used reg = )
33354 9801           B8                   0080  mov	ax,#$80
33355 9804           50                         push	ax
33356                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33357 9805           E8         06EB            call	_set_diskette_ret_status
33358 9808           44                         inc	sp
33359 9809           44                         inc	sp
33360                                           !BCC_EOS
33361                                           ! 4817         FLAGS |= 0x0001;
33362                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33363 980A           8B46         1C            mov	ax,$1C[bp]
33364 980D           0C                     01  or	al,*1
33365 980F           8946         1C            mov	$1C[bp],ax
33366                                           !BCC_EOS
33367                                           ! 4818         return;
33368 9812           89EC                       mov	sp,bp
33369 9814           5D                         pop	bp
33370 9815           C3                         ret
33371                                           !BCC_EOS
33372                                           ! 4819       }
33373                                           ! 4820       if (floppy_media_known(drive) == 0) {
33374                       00009816            .6C5:
33375                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33376 9816           8A46         FF            mov	al,-1[bp]
33377 9819           30E4                       xor	ah,ah
33378 981B           50                         push	ax
33379                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
33380 981C           E8         F300            call	_floppy_media_known
33381 981F           44                         inc	sp
33382 9820           44                         inc	sp
33383                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33384 9821           85C0                       test	ax,ax
33385 9823           75           39            jne 	.6C7
33386                       00009825            .6C8:
33387                                           ! 4821         if (floppy_media_sense(drive) == 0) {
33388                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33389 9825           8A46         FF            mov	al,-1[bp]
33390 9828           30E4                       xor	ah,ah
33391 982A           50                         push	ax
33392                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
33393 982B           E8         F374            call	_floppy_media_sense
33394 982E           44                         inc	sp
33395 982F           44                         inc	sp
33396                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33397 9830           85C0                       test	ax,ax
33398 9832           75           2A            jne 	.6C9
33399                       00009834            .6CA:
33400                                           ! 4822           AX = ((AX & 0x00ff) | ((0x0C) << 8));
33401                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33402 9834           8A46         16            mov	al,$16[bp]
33403                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
33404 9837           30E4                       xor	ah,ah
33405 9839           0D                   0C00  or	ax,#$C00
33406                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33407 983C           8946         16            mov	$16[bp],ax
33408                                           !BCC_EOS
33409                                           ! 4823           set_diskette_ret_status(0x0C);
33410                                           ! Debug: list int = const $C (used reg = )
33411 983F           B8                   000C  mov	ax,*$C
33412 9842           50                         push	ax
33413                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33414 9843           E8         06AD            call	_set_diskette_ret_status
33415 9846           44                         inc	sp
33416 9847           44                         inc	sp
33417                                           !BCC_EOS
33418                                           ! 4824           AX = ((AX & 0xff00) | (0));
33419                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33420 9848           8B46         16            mov	ax,$16[bp]
33421 984B           30C0                       xor	al,al
33422                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33423 984D           0C                     00  or	al,*0
33424                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33425 984F           8946         16            mov	$16[bp],ax
33426                                           !BCC_EOS
33427                                           ! 4825           FLAGS |= 0x0001;
33428                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33429 9852           8B46         1C            mov	ax,$1C[bp]
33430 9855           0C                     01  or	al,*1
33431 9857           8946         1C            mov	$1C[bp],ax
33432                                           !BCC_EOS
33433                                           ! 4826           return;
33434 985A           89EC                       mov	sp,bp
33435 985C           5D                         pop	bp
33436 985D           C3                         ret
33437                                           !BCC_EOS
33438                                           ! 4827         }
33439                                           ! 4828       }
33440                       0000985E            .6C9:
33441                                           ! 4829       page = (ES >> 12);
33442                       0000985E            .6C7:
33443                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
33444 985E           8B46         06            mov	ax,6[bp]
33445 9861           88E0                       mov	al,ah
33446 9863           30E4                       xor	ah,ah
33447 9865           B1                     04  mov	cl,*4
33448 9867           D3E8                       shr	ax,cl
33449                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
33450 9869           8846         F3            mov	-$D[bp],al
33451                                           !BCC_EOS
33452                                           ! 4830       base_es = (ES << 4);
33453                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
33454 986C           8B46         06            mov	ax,6[bp]
33455 986F           B1                     04  mov	cl,*4
33456 9871           D3E0                       shl	ax,cl
33457                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
33458 9873           8946         F4            mov	-$C[bp],ax
33459                                           !BCC_EOS
33460                                           ! 4831       base_address = base_es + BX;
33461                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
33462 9876           8B46         F4            mov	ax,-$C[bp]
33463 9879           0346         10            add	ax,$10[bp]
33464                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
33465 987C           8946         F8            mov	-8[bp],ax
33466                                           !BCC_EOS
33467                                           ! 4832       if ( base_address < base_es ) {
33468                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
33469 987F           8B46         F8            mov	ax,-8[bp]
33470 9882           3B46         F4            cmp	ax,-$C[bp]
33471 9885           73           07            jae 	.6CB
33472                       00009887            .6CC:
33473                                           ! 4833         page++;
33474                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
33475 9887           8A46         F3            mov	al,-$D[bp]
33476 988A           40                         inc	ax
33477 988B           8846         F3            mov	-$D[bp],al
33478                                           !BCC_EOS
33479                                           ! 4834       }
33480                                           ! 4835       base_count = (num_sectors * 4) - 1;
33481                       0000988E            .6CB:
33482                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
33483 988E           8A46         FE            mov	al,-2[bp]
33484 9891           30E4                       xor	ah,ah
33485 9893           D1E0                       shl	ax,*1
33486 9895           D1E0                       shl	ax,*1
33487                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33488                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
33489 9897           48                         dec	ax
33490 9898           8946         F6            mov	-$A[bp],ax
33491                                           !BCC_EOS
33492                                           ! 4836       last_addr = base_address + base_count;
33493                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
33494 989B           8B46         F8            mov	ax,-8[bp]
33495 989E           0346         F6            add	ax,-$A[bp]
33496                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
33497 98A1           8946         E2            mov	-$1E[bp],ax
33498                                           !BCC_EOS
33499                                           ! 4837       if (last_addr < base_address) {
33500                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
33501 98A4           8B46         E2            mov	ax,-$1E[bp]
33502 98A7           3B46         F8            cmp	ax,-8[bp]
33503 98AA           73           2A            jae 	.6CD
33504                       000098AC            .6CE:
33505                                           ! 4838         AX = ((AX & 0x00ff) | ((0x09) << 8));
33506                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33507 98AC           8A46         16            mov	al,$16[bp]
33508                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
33509 98AF           30E4                       xor	ah,ah
33510 98B1           0D                   0900  or	ax,#$900
33511                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33512 98B4           8946         16            mov	$16[bp],ax
33513                                           !BCC_EOS
33514                                           ! 4839         set_diskette_ret_status(0x09);
33515                                           ! Debug: list int = const 9 (used reg = )
33516 98B7           B8                   0009  mov	ax,*9
33517 98BA           50                         push	ax
33518                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33519 98BB           E8         0635            call	_set_diskette_ret_status
33520 98BE           44                         inc	sp
33521 98BF           44                         inc	sp
33522                                           !BCC_EOS
33523                                           ! 4840         AX = ((AX & 0xff00) | (0));
33524                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33525 98C0           8B46         16            mov	ax,$16[bp]
33526 98C3           30C0                       xor	al,al
33527                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33528 98C5           0C                     00  or	al,*0
33529                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33530 98C7           8946         16            mov	$16[bp],ax
33531                                           !BCC_EOS
33532                                           ! 4841         FLAGS |= 0x0001;
33533                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33534 98CA           8B46         1C            mov	ax,$1C[bp]
33535 98CD           0C                     01  or	al,*1
33536 98CF           8946         1C            mov	$1C[bp],ax
33537                                           !BCC_EOS
33538                                           ! 4842         return;
33539 98D2           89EC                       mov	sp,bp
33540 98D4           5D                         pop	bp
33541 98D5           C3                         ret
33542                                           !BCC_EOS
33543                                           ! 4843       }
33544                                           ! 4844       outb(0x000a, 0x06);
33545                       000098D6            .6CD:
33546                                           ! Debug: list int = const 6 (used reg = )
33547 98D6           B8                   0006  mov	ax,*6
33548 98D9           50                         push	ax
33549                                           ! Debug: list int = const $A (used reg = )
33550 98DA           B8                   000A  mov	ax,*$A
33551 98DD           50                         push	ax
33552                                           ! Debug: func () void = outb+0 (used reg = )
33553 98DE           E8         6C73            call	_outb
33554 98E1           83C4                   04  add	sp,*4
33555                                           !BCC_EOS
33556                                           ! 4845       outb(0x000c, 0x00);
33557                                           ! Debug: list int = const 0 (used reg = )
33558 98E4           31C0                       xor	ax,ax
33559 98E6           50                         push	ax
33560                                           ! Debug: list int = const $C (used reg = )
33561 98E7           B8                   000C  mov	ax,*$C
33562 98EA           50                         push	ax
33563                                           ! Debug: func () void = outb+0 (used reg = )
33564 98EB           E8         6C66            call	_outb
33565 98EE           83C4                   04  add	sp,*4
33566                                           !BCC_EOS
33567                                           ! 4846       outb(0x0004, base_address);
33568                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
33569 98F1           FF76         F8            push	-8[bp]
33570                                           ! Debug: list int = const 4 (used reg = )
33571 98F4           B8                   0004  mov	ax,*4
33572 98F7           50                         push	ax
33573                                           ! Debug: func () void = outb+0 (used reg = )
33574 98F8           E8         6C59            call	_outb
33575 98FB           83C4                   04  add	sp,*4
33576                                           !BCC_EOS
33577                                           ! 4847       outb(0x0004, base_address>>8);
33578                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
33579 98FE           8B46         F8            mov	ax,-8[bp]
33580 9901           88E0                       mov	al,ah
33581 9903           30E4                       xor	ah,ah
33582                                           ! Debug: list unsigned int = ax+0 (used reg = )
33583 9905           50                         push	ax
33584                                           ! Debug: list int = const 4 (used reg = )
33585 9906           B8                   0004  mov	ax,*4
33586 9909           50                         push	ax
33587                                           ! Debug: func () void = outb+0 (used reg = )
33588 990A           E8         6C47            call	_outb
33589 990D           83C4                   04  add	sp,*4
33590                                           !BCC_EOS
33591                                           ! 4848       outb(0x000c, 0x00);
33592                                           ! Debug: list int = const 0 (used reg = )
33593 9910           31C0                       xor	ax,ax
33594 9912           50                         push	ax
33595                                           ! Debug: list int = const $C (used reg = )
33596 9913           B8                   000C  mov	ax,*$C
33597 9916           50                         push	ax
33598                                           ! Debug: func () void = outb+0 (used reg = )
33599 9917           E8         6C3A            call	_outb
33600 991A           83C4                   04  add	sp,*4
33601                                           !BCC_EOS
33602                                           ! 4849       outb(0x0005, base_count);
33603                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
33604 991D           FF76         F6            push	-$A[bp]
33605                                           ! Debug: list int = const 5 (used reg = )
33606 9920           B8                   0005  mov	ax,*5
33607 9923           50                         push	ax
33608                                           ! Debug: func () void = outb+0 (used reg = )
33609 9924           E8         6C2D            call	_outb
33610 9927           83C4                   04  add	sp,*4
33611                                           !BCC_EOS
33612                                           ! 4850       outb(0x0005, base_count>>8);
33613                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
33614 992A           8B46         F6            mov	ax,-$A[bp]
33615 992D           88E0                       mov	al,ah
33616 992F           30E4                       xor	ah,ah
33617                                           ! Debug: list unsigned int = ax+0 (used reg = )
33618 9931           50                         push	ax
33619                                           ! Debug: list int = const 5 (used reg = )
33620 9932           B8                   0005  mov	ax,*5
33621 9935           50                         push	ax
33622                                           ! Debug: func () void = outb+0 (used reg = )
33623 9936           E8         6C1B            call	_outb
33624 9939           83C4                   04  add	sp,*4
33625                                           !BCC_EOS
33626                                           ! 4851       mode_register = 0x4a;
33627                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
33628 993C           B0                     4A  mov	al,*$4A
33629 993E           8846         F2            mov	-$E[bp],al
33630                                           !BCC_EOS
33631                                           ! 4852       outb(0x000b, mode_register);
33632                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
33633 9941           8A46         F2            mov	al,-$E[bp]
33634 9944           30E4                       xor	ah,ah
33635 9946           50                         push	ax
33636                                           ! Debug: list int = const $B (used reg = )
33637 9947           B8                   000B  mov	ax,*$B
33638 994A           50                         push	ax
33639                                           ! Debug: func () void = outb+0 (used reg = )
33640 994B           E8         6C06            call	_outb
33641 994E           83C4                   04  add	sp,*4
33642                                           !BCC_EOS
33643                                           ! 4853       outb(0x0081, page);
33644                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
33645 9951           8A46         F3            mov	al,-$D[bp]
33646 9954           30E4                       xor	ah,ah
33647 9956           50                         push	ax
33648                                           ! Debug: list int = const $81 (used reg = )
33649 9957           B8                   0081  mov	ax,#$81
33650 995A           50                         push	ax
33651                                           ! Debug: func () void = outb+0 (used reg = )
33652 995B           E8         6BF6            call	_outb
33653 995E           83C4                   04  add	sp,*4
33654                                           !BCC_EOS
33655                                           ! 4854       outb(0x000a, 0x02);
33656                                           ! Debug: list int = const 2 (used reg = )
33657 9961           B8                   0002  mov	ax,*2
33658 9964           50                         push	ax
33659                                           ! Debug: list int = const $A (used reg = )
33660 9965           B8                   000A  mov	ax,*$A
33661 9968           50                         push	ax
33662                                           ! Debug: func () void = outb+0 (used reg = )
33663 9969           E8         6BE8            call	_outb
33664 996C           83C4                   04  add	sp,*4
33665                                           !BCC_EOS
33666                                           ! 4855       floppy_prepare_controller(drive);
33667                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33668 996F           8A46         FF            mov	al,-1[bp]
33669 9972           30E4                       xor	ah,ah
33670 9974           50                         push	ax
33671                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
33672 9975           E8         F0C8            call	_floppy_prepare_controller
33673 9978           44                         inc	sp
33674 9979           44                         inc	sp
33675                                           !BCC_EOS
33676                                           ! 4856       outb(0x03f5, 0x4d);
33677                                           ! Debug: list int = const $4D (used reg = )
33678 997A           B8                   004D  mov	ax,*$4D
33679 997D           50                         push	ax
33680                                           ! Debug: list int = const $3F5 (used reg = )
33681 997E           B8                   03F5  mov	ax,#$3F5
33682 9981           50                         push	ax
33683                                           ! Debug: func () void = outb+0 (used reg = )
33684 9982           E8         6BCF            call	_outb
33685 9985           83C4                   04  add	sp,*4
33686                                           !BCC_EOS
33687                                           ! 4857       outb(0x03f5, (head << 2) | drive);
33688                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
33689 9988           8A46         FB            mov	al,-5[bp]
33690 998B           30E4                       xor	ah,ah
33691 998D           D1E0                       shl	ax,*1
33692 998F           D1E0                       shl	ax,*1
33693                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
33694 9991           0A46         FF            or	al,-1[bp]
33695                                           ! Debug: list unsigned int = ax+0 (used reg = )
33696 9994           50                         push	ax
33697                                           ! Debug: list int = const $3F5 (used reg = )
33698 9995           B8                   03F5  mov	ax,#$3F5
33699 9998           50                         push	ax
33700                                           ! Debug: func () void = outb+0 (used reg = )
33701 9999           E8         6BB8            call	_outb
33702 999C           83C4                   04  add	sp,*4
33703                                           !BCC_EOS
33704                                           ! 4858       outb(0x03f5, 2);
33705                                           ! Debug: list int = const 2 (used reg = )
33706 999F           B8                   0002  mov	ax,*2
33707 99A2           50                         push	ax
33708                                           ! Debug: list int = const $3F5 (used reg = )
33709 99A3           B8                   03F5  mov	ax,#$3F5
33710 99A6           50                         push	ax
33711                                           ! Debug: func () void = outb+0 (used reg = )
33712 99A7           E8         6BAA            call	_outb
33713 99AA           83C4                   04  add	sp,*4
33714                                           !BCC_EOS
33715                                           ! 4859       outb(0x03f5, num_sectors);
33716                                           ! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
33717 99AD           8A46         FE            mov	al,-2[bp]
33718 99B0           30E4                       xor	ah,ah
33719 99B2           50                         push	ax
33720                                           ! Debug: list int = const $3F5 (used reg = )
33721 99B3           B8                   03F5  mov	ax,#$3F5
33722 99B6           50                         push	ax
33723                                           ! Debug: func () void = outb+0 (used reg = )
33724 99B7           E8         6B9A            call	_outb
33725 99BA           83C4                   04  add	sp,*4
33726                                           !BCC_EOS
33727                                           ! 4860       outb(0x03f5, 0);
33728                                           ! Debug: list int = const 0 (used reg = )
33729 99BD           31C0                       xor	ax,ax
33730 99BF           50                         push	ax
33731                                           ! Debug: list int = const $3F5 (used reg = )
33732 99C0           B8                   03F5  mov	ax,#$3F5
33733 99C3           50                         push	ax
33734                                           ! Debug: func () void = outb+0 (used reg = )
33735 99C4           E8         6B8D            call	_outb
33736 99C7           83C4                   04  add	sp,*4
33737                                           !BCC_EOS
33738                                           ! 4861       outb(0x03f5, 0xf6);
33739                                           ! Debug: list int = const $F6 (used reg = )
33740 99CA           B8                   00F6  mov	ax,#$F6
33741 99CD           50                         push	ax
33742                                           ! Debug: list int = const $3F5 (used reg = )
33743 99CE           B8                   03F5  mov	ax,#$3F5
33744 99D1           50                         push	ax
33745                                           ! Debug: func () void = outb+0 (used reg = )
33746 99D2           E8         6B7F            call	_outb
33747 99D5           83C4                   04  add	sp,*4
33748                                           !BCC_EOS
33749                                           ! 4862 #asm
33750                                           !BCC_EOS
33751                                           !BCC_ASM
33752                       0000002A            _int13_diskette_function.BP	set	$2A
33753                       0000000C            .int13_diskette_function.BP	set	$C
33754                       00000038            _int13_diskette_function.CS	set	$38
33755                       0000001A            .int13_diskette_function.CS	set	$1A
33756                       00000032            _int13_diskette_function.CX	set	$32
33757                       00000014            .int13_diskette_function.CX	set	$14
33758                       00000016            _int13_diskette_function.base_address	set	$16
33759                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33760                       00000026            _int13_diskette_function.DI	set	$26
33761                       00000008            .int13_diskette_function.DI	set	8
33762                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33763                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33764                       00000014            _int13_diskette_function.base_count	set	$14
33765                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33766                       0000001A            _int13_diskette_function.sector	set	$1A
33767                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33768                       00000022            _int13_diskette_function.DS	set	$22
33769                       00000004            .int13_diskette_function.DS	set	4
33770                       00000019            _int13_diskette_function.head	set	$19
33771                       FFFFFFFB            .int13_diskette_function.head	set	-5
33772                       0000002C            _int13_diskette_function.ELDX	set	$2C
33773                       0000000E            .int13_diskette_function.ELDX	set	$E
33774                       0000000E            _int13_diskette_function.dor	set	$E
33775                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33776                       00000030            _int13_diskette_function.DX	set	$30
33777                       00000012            .int13_diskette_function.DX	set	$12
33778                       00000007            _int13_diskette_function.return_status	set	7
33779                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33780                       00000002            _int13_diskette_function.es	set	2
33781                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33782                       00000010            _int13_diskette_function.mode_register	set	$10
33783                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33784                       00000024            _int13_diskette_function.ES	set	$24
33785                       00000006            .int13_diskette_function.ES	set	6
33786                       00000012            _int13_diskette_function.base_es	set	$12
33787                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33788                       0000001B            _int13_diskette_function.track	set	$1B
33789                       FFFFFFFD            .int13_diskette_function.track	set	-3
33790                       00000028            _int13_diskette_function.SI	set	$28
33791                       0000000A            .int13_diskette_function.SI	set	$A
33792                       00000006            _int13_diskette_function.drive_type	set	6
33793                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33794                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33795                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33796                       00000036            _int13_diskette_function.IP	set	$36
33797                       00000018            .int13_diskette_function.IP	set	$18
33798                       00000018            _int13_diskette_function.status	set	$18
33799                       FFFFFFFA            .int13_diskette_function.status	set	-6
33800                       00000034            _int13_diskette_function.AX	set	$34
33801                       00000016            .int13_diskette_function.AX	set	$16
33802                       0000000F            _int13_diskette_function.val8	set	$F
33803                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33804                       00000000            _int13_diskette_function.last_addr	set	0
33805                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33806                       00000011            _int13_diskette_function.page	set	$11
33807                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33808                       00000004            _int13_diskette_function.ah	set	4
33809                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33810                       0000001D            _int13_diskette_function.drive	set	$1D
33811                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33812                       00000005            _int13_diskette_function.num_floppies	set	5
33813                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33814                       0000002E            _int13_diskette_function.BX	set	$2E
33815                       00000010            .int13_diskette_function.BX	set	$10
33816 99D8           FB                               sti
33817                                           ! 4864 endasm
33818                                           !BCC_ENDASM
33819                                           !BCC_EOS
33820                                           ! 4865       do {
33821                       000099D9            .6D1:
33822                                           ! 4866         val8 = read_byte(0x0040, 0x0040);
33823                                           ! Debug: list int = const $40 (used reg = )
33824 99D9           B8                   0040  mov	ax,*$40
33825 99DC           50                         push	ax
33826                                           ! Debug: list int = const $40 (used reg = )
33827 99DD           B8                   0040  mov	ax,*$40
33828 99E0           50                         push	ax
33829                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33830 99E1           E8         6C10            call	_read_byte
33831 99E4           83C4                   04  add	sp,*4
33832                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33833 99E7           8846         F1            mov	-$F[bp],al
33834                                           !BCC_EOS
33835                                           ! 4867         if (val8 == 0) {
33836                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33837 99EA           8A46         F1            mov	al,-$F[bp]
33838 99ED           84C0                       test	al,al
33839 99EF           75           23            jne 	.6D2
33840                       000099F1            .6D3:
33841                                           ! 4868           floppy_reset_controller();
33842                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
33843 99F1           E8         EFFE            call	_floppy_reset_controller
33844                                           !BCC_EOS
33845                                           ! 4869           AX = ((AX & 0x00ff) | ((0x80) << 8));
33846                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33847 99F4           8A46         16            mov	al,$16[bp]
33848                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33849 99F7           30E4                       xor	ah,ah
33850 99F9           0D                   8000  or	ax,#-$8000
33851                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33852 99FC           8946         16            mov	$16[bp],ax
33853                                           !BCC_EOS
33854                                           ! 4870           set_diskette_ret_status(0x80);
33855                                           ! Debug: list int = const $80 (used reg = )
33856 99FF           B8                   0080  mov	ax,#$80
33857 9A02           50                         push	ax
33858                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33859 9A03           E8         04ED            call	_set_diskette_ret_status
33860 9A06           44                         inc	sp
33861 9A07           44                         inc	sp
33862                                           !BCC_EOS
33863                                           ! 4871           FLAGS |= 0x0001;
33864                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33865 9A08           8B46         1C            mov	ax,$1C[bp]
33866 9A0B           0C                     01  or	al,*1
33867 9A0D           8946         1C            mov	$1C[bp],ax
33868                                           !BCC_EOS
33869                                           ! 4872           return;
33870 9A10           89EC                       mov	sp,bp
33871 9A12           5D                         pop	bp
33872 9A13           C3                         ret
33873                                           !BCC_EOS
33874                                           ! 4873         }
33875                                           ! 4874         val8 = (read_byte(0x0040, 0x003e) & 0x80);
33876                       00009A14            .6D2:
33877                                           ! Debug: list int = const $3E (used reg = )
33878 9A14           B8                   003E  mov	ax,*$3E
33879 9A17           50                         push	ax
33880                                           ! Debug: list int = const $40 (used reg = )
33881 9A18           B8                   0040  mov	ax,*$40
33882 9A1B           50                         push	ax
33883                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33884 9A1C           E8         6BD5            call	_read_byte
33885 9A1F           83C4                   04  add	sp,*4
33886                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
33887 9A22           24                     80  and	al,#$80
33888                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33889 9A24           8846         F1            mov	-$F[bp],al
33890                                           !BCC_EOS
33891                                           ! 4875       } while ( val8 == 0 );
33892                       00009A27            .6D0:
33893                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33894 9A27           8A46         F1            mov	al,-$F[bp]
33895 9A2A           84C0                       test	al,al
33896 9A2C           74           AB            je 	.6D1
33897                       00009A2E            .6D4:
33898                                           !BCC_EOS
33899                                           ! 4876       val8 = 0;
33900                       00009A2E            .6CF:
33901                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33902 9A2E           30C0                       xor	al,al
33903 9A30           8846         F1            mov	-$F[bp],al
33904                                           !BCC_EOS
33905                                           ! 4877 #asm
33906                                           !BCC_EOS
33907                                           !BCC_ASM
33908                       0000002A            _int13_diskette_function.BP	set	$2A
33909                       0000000C            .int13_diskette_function.BP	set	$C
33910                       00000038            _int13_diskette_function.CS	set	$38
33911                       0000001A            .int13_diskette_function.CS	set	$1A
33912                       00000032            _int13_diskette_function.CX	set	$32
33913                       00000014            .int13_diskette_function.CX	set	$14
33914                       00000016            _int13_diskette_function.base_address	set	$16
33915                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33916                       00000026            _int13_diskette_function.DI	set	$26
33917                       00000008            .int13_diskette_function.DI	set	8
33918                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33919                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33920                       00000014            _int13_diskette_function.base_count	set	$14
33921                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33922                       0000001A            _int13_diskette_function.sector	set	$1A
33923                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33924                       00000022            _int13_diskette_function.DS	set	$22
33925                       00000004            .int13_diskette_function.DS	set	4
33926                       00000019            _int13_diskette_function.head	set	$19
33927                       FFFFFFFB            .int13_diskette_function.head	set	-5
33928                       0000002C            _int13_diskette_function.ELDX	set	$2C
33929                       0000000E            .int13_diskette_function.ELDX	set	$E
33930                       0000000E            _int13_diskette_function.dor	set	$E
33931                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33932                       00000030            _int13_diskette_function.DX	set	$30
33933                       00000012            .int13_diskette_function.DX	set	$12
33934                       00000007            _int13_diskette_function.return_status	set	7
33935                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33936                       00000002            _int13_diskette_function.es	set	2
33937                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33938                       00000010            _int13_diskette_function.mode_register	set	$10
33939                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33940                       00000024            _int13_diskette_function.ES	set	$24
33941                       00000006            .int13_diskette_function.ES	set	6
33942                       00000012            _int13_diskette_function.base_es	set	$12
33943                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33944                       0000001B            _int13_diskette_function.track	set	$1B
33945                       FFFFFFFD            .int13_diskette_function.track	set	-3
33946                       00000028            _int13_diskette_function.SI	set	$28
33947                       0000000A            .int13_diskette_function.SI	set	$A
33948                       00000006            _int13_diskette_function.drive_type	set	6
33949                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33950                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33951                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33952                       00000036            _int13_diskette_function.IP	set	$36
33953                       00000018            .int13_diskette_function.IP	set	$18
33954                       00000018            _int13_diskette_function.status	set	$18
33955                       FFFFFFFA            .int13_diskette_function.status	set	-6
33956                       00000034            _int13_diskette_function.AX	set	$34
33957                       00000016            .int13_diskette_function.AX	set	$16
33958                       0000000F            _int13_diskette_function.val8	set	$F
33959                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33960                       00000000            _int13_diskette_function.last_addr	set	0
33961                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33962                       00000011            _int13_diskette_function.page	set	$11
33963                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33964                       00000004            _int13_diskette_function.ah	set	4
33965                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33966                       0000001D            _int13_diskette_function.drive	set	$1D
33967                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33968                       00000005            _int13_diskette_function.num_floppies	set	5
33969                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33970                       0000002E            _int13_diskette_function.BX	set	$2E
33971                       00000010            .int13_diskette_function.BX	set	$10
33972 9A33           FA                               cli
33973                                           ! 4879 endasm
33974                                           !BCC_ENDASM
33975                                           !BCC_EOS
33976                                           ! 4880       val8 = read_byte(0x0040, 0x003e);
33977                                           ! Debug: list int = const $3E (used reg = )
33978 9A34           B8                   003E  mov	ax,*$3E
33979 9A37           50                         push	ax
33980                                           ! Debug: list int = const $40 (used reg = )
33981 9A38           B8                   0040  mov	ax,*$40
33982 9A3B           50                         push	ax
33983                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33984 9A3C           E8         6BB5            call	_read_byte
33985 9A3F           83C4                   04  add	sp,*4
33986                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33987 9A42           8846         F1            mov	-$F[bp],al
33988                                           !BCC_EOS
33989                                           ! 4881       val8 &= 0x7f;
33990                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
33991 9A45           8A46         F1            mov	al,-$F[bp]
33992 9A48           24                     7F  and	al,*$7F
33993 9A4A           8846         F1            mov	-$F[bp],al
33994                                           !BCC_EOS
33995                                           ! 4882       write_byte(0x0040, 0x003e, val8);
33996                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
33997 9A4D           8A46         F1            mov	al,-$F[bp]
33998 9A50           30E4                       xor	ah,ah
33999 9A52           50                         push	ax
34000                                           ! Debug: list int = const $3E (used reg = )
34001 9A53           B8                   003E  mov	ax,*$3E
34002 9A56           50                         push	ax
34003                                           ! Debug: list int = const $40 (used reg = )
34004 9A57           B8                   0040  mov	ax,*$40
34005 9A5A           50                         push	ax
34006                                           ! Debug: func () void = write_byte+0 (used reg = )
34007 9A5B           E8         6BBC            call	_write_byte
34008 9A5E           83C4                   06  add	sp,*6
34009                                           !BCC_EOS
34010                                           ! 4883       val8 = inb(0x3f4);
34011                                           ! Debug: list int = const $3F4 (used reg = )
34012 9A61           B8                   03F4  mov	ax,#$3F4
34013 9A64           50                         push	ax
34014                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34015 9A65           E8         6AD6            call	_inb
34016 9A68           44                         inc	sp
34017 9A69           44                         inc	sp
34018                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34019 9A6A           8846         F1            mov	-$F[bp],al
34020                                           !BCC_EOS
34021                                           ! 4884       if ( (val8 & 0xc0) != 0xc0 )
34022                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
34023 9A6D           8A46         F1            mov	al,-$F[bp]
34024 9A70           24                     C0  and	al,#$C0
34025                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
34026 9A72           3C                     C0  cmp	al,#$C0
34027 9A74           74           0E            je  	.6D5
34028                       00009A76            .6D6:
34029                                           ! 4885         bios_printf((2 
34030                                           ! 4885 | 4 | 1), "int13_diskette: ctrl not ready\n");
34031                                           ! Debug: list * char = .6D7+0 (used reg = )
34032 9A76           BB                   D091  mov	bx,#.6D7
34033 9A79           53                         push	bx
34034                                           ! Debug: list int = const 7 (used reg = )
34035 9A7A           B8                   0007  mov	ax,*7
34036 9A7D           50                         push	ax
34037                                           ! Debug: func () void = bios_printf+0 (used reg = )
34038 9A7E           E8         6F9A            call	_bios_printf
34039 9A81           83C4                   04  add	sp,*4
34040                                           !BCC_EOS
34041                                           ! 4886       return_status[0] = inb(0x3f5);
34042                       00009A84            .6D5:
34043                                           ! Debug: list int = const $3F5 (used reg = )
34044 9A84           B8                   03F5  mov	ax,#$3F5
34045 9A87           50                         push	ax
34046                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34047 9A88           E8         6AB3            call	_inb
34048 9A8B           44                         inc	sp
34049 9A8C           44                         inc	sp
34050                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
34051 9A8D           8846         E9            mov	-$17[bp],al
34052                                           !BCC_EOS
34053                                           ! 4887       return_status[1] = inb(0x3f5);
34054                                           ! Debug: list int = const $3F5 (used reg = )
34055 9A90           B8                   03F5  mov	ax,#$3F5
34056 9A93           50                         push	ax
34057                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34058 9A94           E8         6AA7            call	_inb
34059 9A97           44                         inc	sp
34060 9A98           44                         inc	sp
34061                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
34062 9A99           8846         EA            mov	-$16[bp],al
34063                                           !BCC_EOS
34064                                           ! 4888       return_status[2] = inb(0x3f5);
34065                                           ! Debug: list int = const $3F5 (used reg = )
34066 9A9C           B8                   03F5  mov	ax,#$3F5
34067 9A9F           50                         push	ax
34068                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34069 9AA0           E8         6A9B            call	_inb
34070 9AA3           44                         inc	sp
34071 9AA4           44                         inc	sp
34072                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
34073 9AA5           8846         EB            mov	-$15[bp],al
34074                                           !BCC_EOS
34075                                           ! 4889       return_status[3] = inb(0x3f5);
34076                                           ! Debug: list int = const $3F5 (used reg = )
34077 9AA8           B8                   03F5  mov	ax,#$3F5
34078 9AAB           50                         push	ax
34079                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34080 9AAC           E8         6A8F            call	_inb
34081 9AAF           44                         inc	sp
34082 9AB0           44                         inc	sp
34083                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
34084 9AB1           8846         EC            mov	-$14[bp],al
34085                                           !BCC_EOS
34086                                           ! 4890       return_status[4] = inb(0x3f5);
34087                                           ! Debug: list int = const $3F5 (used reg = )
34088 9AB4           B8                   03F5  mov	ax,#$3F5
34089 9AB7           50                         push	ax
34090                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34091 9AB8           E8         6A83            call	_inb
34092 9ABB           44                         inc	sp
34093 9ABC           44                         inc	sp
34094                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
34095 9ABD           8846         ED            mov	-$13[bp],al
34096                                           !BCC_EOS
34097                                           ! 4891       return_status[5] = inb(0x3f5);
34098                                           ! Debug: list int = const $3F5 (used reg = )
34099 9AC0           B8                   03F5  mov	ax,#$3F5
34100 9AC3           50                         push	ax
34101                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34102 9AC4           E8         6A77            call	_inb
34103 9AC7           44                         inc	sp
34104 9AC8           44                         inc	sp
34105                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
34106 9AC9           8846         EE            mov	-$12[bp],al
34107                                           !BCC_EOS
34108                                           ! 4892       return_status[6] = inb(0x3f5);
34109                                           ! Debug: list int = const $3F5 (used reg = )
34110 9ACC           B8                   03F5  mov	ax,#$3F5
34111 9ACF           50                         push	ax
34112                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34113 9AD0           E8         6A6B            call	_inb
34114 9AD3           44                         inc	sp
34115 9AD4           44                         inc	sp
34116                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
34117 9AD5           8846         EF            mov	-$11[bp],al
34118                                           !BCC_EOS
34119                                           ! 4893       write_byte(0x0040, 0x0042, return_status[0]);
34120                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
34121 9AD8           8A46         E9            mov	al,-$17[bp]
34122 9ADB           30E4                       xor	ah,ah
34123 9ADD           50                         push	ax
34124                                           ! Debug: list int = const $42 (used reg = )
34125 9ADE           B8                   0042  mov	ax,*$42
34126 9AE1           50                         push	ax
34127                                           ! Debug: list int = const $40 (used reg = )
34128 9AE2           B8                   0040  mov	ax,*$40
34129 9AE5           50                         push	ax
34130                                           ! Debug: func () void = write_byte+0 (used reg = )
34131 9AE6           E8         6B31            call	_write_byte
34132 9AE9           83C4                   06  add	sp,*6
34133                                           !BCC_EOS
34134                                           ! 4894       write_byte(0x0040, 0x0043, return_status[1]);
34135                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
34136 9AEC           8A46         EA            mov	al,-$16[bp]
34137 9AEF           30E4                       xor	ah,ah
34138 9AF1           50                         push	ax
34139                                           ! Debug: list int = const $43 (used reg = )
34140 9AF2           B8                   0043  mov	ax,*$43
34141 9AF5           50                         push	ax
34142                                           ! Debug: list int = const $40 (used reg = )
34143 9AF6           B8                   0040  mov	ax,*$40
34144 9AF9           50                         push	ax
34145                                           ! Debug: func () void = write_byte+0 (used reg = )
34146 9AFA           E8         6B1D            call	_write_byte
34147 9AFD           83C4                   06  add	sp,*6
34148                                           !BCC_EOS
34149                                           ! 4895       write_byte(0x0040, 0x0044, return_status[2]);
34150                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
34151 9B00           8A46         EB            mov	al,-$15[bp]
34152 9B03           30E4                       xor	ah,ah
34153 9B05           50                         push	ax
34154                                           ! Debug: list int = const $44 (used reg = )
34155 9B06           B8                   0044  mov	ax,*$44
34156 9B09           50                         push	ax
34157                                           ! Debug: list int = const $40 (used reg = )
34158 9B0A           B8                   0040  mov	ax,*$40
34159 9B0D           50                         push	ax
34160                                           ! Debug: func () void = write_byte+0 (used reg = )
34161 9B0E           E8         6B09            call	_write_byte
34162 9B11           83C4                   06  add	sp,*6
34163                                           !BCC_EOS
34164                                           ! 4896       write_byte(0x0040, 0x0045, return_status[3]);
34165                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
34166 9B14           8A46         EC            mov	al,-$14[bp]
34167 9B17           30E4                       xor	ah,ah
34168 9B19           50                         push	ax
34169                                           ! Debug: list int = const $45 (used reg = )
34170 9B1A           B8                   0045  mov	ax,*$45
34171 9B1D           50                         push	ax
34172                                           ! Debug: list int = const $40 (used reg = )
34173 9B1E           B8                   0040  mov	ax,*$40
34174 9B21           50                         push	ax
34175                                           ! Debug: func () void = write_byte+0 (used reg = )
34176 9B22           E8         6AF5            call	_write_byte
34177 9B25           83C4                   06  add	sp,*6
34178                                           !BCC_EOS
34179                                           ! 4897       write_byte(0x0040, 0x0046, return_status[4]);
34180                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
34181 9B28           8A46         ED            mov	al,-$13[bp]
34182 9B2B           30E4                       xor	ah,ah
34183 9B2D           50                         push	ax
34184                                           ! Debug: list int = const $46 (used reg = )
34185 9B2E           B8                   0046  mov	ax,*$46
34186 9B31           50                         push	ax
34187                                           ! Debug: list int = const $40 (used reg = )
34188 9B32           B8                   0040  mov	ax,*$40
34189 9B35           50                         push	ax
34190                                           ! Debug: func () void = write_byte+0 (used reg = )
34191 9B36           E8         6AE1            call	_write_byte
34192 9B39           83C4                   06  add	sp,*6
34193                                           !BCC_EOS
34194                                           ! 4898       write_byte(0x0040, 0x0047, return_status[5]);
34195                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
34196 9B3C           8A46         EE            mov	al,-$12[bp]
34197 9B3F           30E4                       xor	ah,ah
34198 9B41           50                         push	ax
34199                                           ! Debug: list int = const $47 (used reg = )
34200 9B42           B8                   0047  mov	ax,*$47
34201 9B45           50                         push	ax
34202                                           ! Debug: list int = const $40 (used reg = )
34203 9B46           B8                   0040  mov	ax,*$40
34204 9B49           50                         push	ax
34205                                           ! Debug: func () void = write_byte+0 (used reg = )
34206 9B4A           E8         6ACD            call	_write_byte
34207 9B4D           83C4                   06  add	sp,*6
34208                                           !BCC_EOS
34209                                           ! 4899       write_byte(0x0040, 0x0048, return_status[6]);
34210                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
34211 9B50           8A46         EF            mov	al,-$11[bp]
34212 9B53           30E4                       xor	ah,ah
34213 9B55           50                         push	ax
34214                                           ! Debug: list int = const $48 (used reg = )
34215 9B56           B8                   0048  mov	ax,*$48
34216 9B59           50                         push	ax
34217                                           ! Debug: list int = const $40 (used reg = )
34218 9B5A           B8                   0040  mov	ax,*$40
34219 9B5D           50                         push	ax
34220                                           ! Debug: func () void = write_byte+0 (used reg = )
34221 9B5E           E8         6AB9            call	_write_byte
34222 9B61           83C4                   06  add	sp,*6
34223                                           !BCC_EOS
34224                                           ! 4900       if ( (return_status[0] & 0xc0) != 0 ) {
34225                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
34226 9B64           8A46         E9            mov	al,-$17[bp]
34227 9B67           24                     C0  and	al,#$C0
34228                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34229 9B69           84C0                       test	al,al
34230 9B6B           74           2B            je  	.6D8
34231                       00009B6D            .6D9:
34232                                           ! 4901         if ( (return_status[1] & 0x02) != 0 ) {
34233                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
34234 9B6D           8A46         EA            mov	al,-$16[bp]
34235 9B70           24                     02  and	al,*2
34236                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34237 9B72           84C0                       test	al,al
34238 9B74           74           14            je  	.6DA
34239                       00009B76            .6DB:
34240                                           ! 4902           AX = 0x0300;
34241                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
34242 9B76           B8                   0300  mov	ax,#$300
34243 9B79           8946         16            mov	$16[bp],ax
34244                                           !BCC_EOS
34245                                           ! 4903           FLAGS |= 0x0001;
34246                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34247 9B7C           8B46         1C            mov	ax,$1C[bp]
34248 9B7F           0C                     01  or	al,*1
34249 9B81           8946         1C            mov	$1C[bp],ax
34250                                           !BCC_EOS
34251                                           ! 4904           return;
34252 9B84           89EC                       mov	sp,bp
34253 9B86           5D                         pop	bp
34254 9B87           C3                         ret
34255                                           !BCC_EOS
34256                                           ! 4905         } else {
34257 9B88           EB           0E            jmp .6DC
34258                       00009B8A            .6DA:
34259                                           ! 4906           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
34260                                           ! Debug: list * char = .6DD+0 (used reg = )
34261 9B8A           BB                   D06B  mov	bx,#.6DD
34262 9B8D           53                         push	bx
34263                                           ! Debug: list int = const 7 (used reg = )
34264 9B8E           B8                   0007  mov	ax,*7
34265 9B91           50                         push	ax
34266                                           ! Debug: func () void = bios_printf+0 (used reg = )
34267 9B92           E8         6E86            call	_bios_printf
34268 9B95           83C4                   04  add	sp,*4
34269                                           !BCC_EOS
34270                                           ! 4907         }
34271                                           ! 4908       }
34272                       00009B98            .6DC:
34273                                           ! 4909       AX = ((AX & 0x00ff) | ((0) << 8));
34274                       00009B98            .6D8:
34275                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34276 9B98           8A46         16            mov	al,$16[bp]
34277                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34278 9B9B           0C                     00  or	al,*0
34279                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34280 9B9D           30E4                       xor	ah,ah
34281 9B9F           8946         16            mov	$16[bp],ax
34282                                           !BCC_EOS
34283                                           ! 4910       set_diskette_ret_status(0);
34284                                           ! Debug: list int = const 0 (used reg = )
34285 9BA2           31C0                       xor	ax,ax
34286 9BA4           50                         push	ax
34287                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34288 9BA5           E8         034B            call	_set_diskette_ret_status
34289 9BA8           44                         inc	sp
34290 9BA9           44                         inc	sp
34291                                           !BCC_EOS
34292                                           ! 4911       set_diskette_current_cyl(drive, 0);
34293                                           ! Debug: list int = const 0 (used reg = )
34294 9BAA           31C0                       xor	ax,ax
34295 9BAC           50                         push	ax
34296                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34297 9BAD           8A46         FF            mov	al,-1[bp]
34298 9BB0           30E4                       xor	ah,ah
34299 9BB2           50                         push	ax
34300                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34301 9BB3           E8         0355            call	_set_diskette_current_cyl
34302 9BB6           83C4                   04  add	sp,*4
34303                                           !BCC_EOS
34304                                           ! 4912       FLAGS &= 0xfffe;
34305                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34306 9BB9           8B46         1C            mov	ax,$1C[bp]
34307 9BBC           24                     FE  and	al,#$FE
34308 9BBE           8946         1C            mov	$1C[bp],ax
34309                                           !BCC_EOS
34310                                           ! 4913       return;
34311 9BC1           89EC                       mov	sp,bp
34312 9BC3           5D                         pop	bp
34313 9BC4           C3                         ret
34314                                           !BCC_EOS
34315                                           ! 4914     case 0x08:
34316                                           ! 4915 ;
34317                       00009BC5            .6DE:
34318                                           !BCC_EOS
34319                                           ! 4916       drive = ( ELDX & 0x00ff );
34320                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34321 9BC5           8A46         0E            mov	al,$E[bp]
34322                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34323 9BC8           8846         FF            mov	-1[bp],al
34324                                           !BCC_EOS
34325                                           ! 4917       if (drive > 1) {
34326                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34327 9BCB           8A46         FF            mov	al,-1[bp]
34328 9BCE           3C                     01  cmp	al,*1
34329 9BD0           76           35            jbe 	.6DF
34330                       00009BD2            .6E0:
34331                                           ! 4918         AX = 0;
34332                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
34333 9BD2           31C0                       xor	ax,ax
34334 9BD4           8946         16            mov	$16[bp],ax
34335                                           !BCC_EOS
34336                                           ! 4919         BX = 0;
34337                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
34338 9BD7           31C0                       xor	ax,ax
34339 9BD9           8946         10            mov	$10[bp],ax
34340                                           !BCC_EOS
34341                                           ! 4920         CX = 0;
34342                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
34343 9BDC           31C0                       xor	ax,ax
34344 9BDE           8946         14            mov	$14[bp],ax
34345                                           !BCC_EOS
34346                                           ! 4921         DX = 0;
34347                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
34348 9BE1           31C0                       xor	ax,ax
34349 9BE3           8946         12            mov	$12[bp],ax
34350                                           !BCC_EOS
34351                                           ! 4922         ES = 0;
34352                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
34353 9BE6           31C0                       xor	ax,ax
34354 9BE8           8946         06            mov	6[bp],ax
34355                                           !BCC_EOS
34356                                           ! 4923         DI = 0;
34357                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
34358 9BEB           31C0                       xor	ax,ax
34359 9BED           8946         08            mov	8[bp],ax
34360                                           !BCC_EOS
34361                                           ! 4924         DX = ((DX & 0xff00) | (num_floppies));
34362                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
34363 9BF0           8B46         12            mov	ax,$12[bp]
34364 9BF3           30C0                       xor	al,al
34365                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
34366 9BF5           0A46         E7            or	al,-$19[bp]
34367                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34368 9BF8           8946         12            mov	$12[bp],ax
34369                                           !BCC_EOS
34370                                           ! 4925         FLAGS |= 0x0001;
34371                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34372 9BFB           8B46         1C            mov	ax,$1C[bp]
34373 9BFE           0C                     01  or	al,*1
34374 9C00           8946         1C            mov	$1C[bp],ax
34375                                           !BCC_EOS
34376                                           ! 4926         return;
34377 9C03           89EC                       mov	sp,bp
34378 9C05           5D                         pop	bp
34379 9C06           C3                         ret
34380                                           !BCC_EOS
34381                                           ! 4927         }
34382                                           ! 4928       drive_type = inb_cmos(0x10);
34383                       00009C07            .6DF:
34384                                           ! Debug: list int = const $10 (used reg = )
34385 9C07           B8                   0010  mov	ax,*$10
34386 9C0A           50                         push	ax
34387                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34388 9C0B           E8         6975            call	_inb_cmos
34389 9C0E           44                         inc	sp
34390 9C0F           44                         inc	sp
34391                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34392 9C10           8846         E8            mov	-$18[bp],al
34393                                           !BCC_EOS
34394                                           ! 4929       num_floppies = 0;
34395                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
34396 9C13           30C0                       xor	al,al
34397 9C15           8846         E7            mov	-$19[bp],al
34398                                           !BCC_EOS
34399                                           ! 4930       if (drive_type & 0xf0)
34400                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34401 9C18           8A46         E8            mov	al,-$18[bp]
34402 9C1B           24                     F0  and	al,#$F0
34403 9C1D           84C0                       test	al,al
34404 9C1F           74           07            je  	.6E1
34405                       00009C21            .6E2:
34406                                           ! 4931         num_floppies++;
34407                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
34408 9C21           8A46         E7            mov	al,-$19[bp]
34409 9C24           40                         inc	ax
34410 9C25           8846         E7            mov	-$19[bp],al
34411                                           !BCC_EOS
34412                                           ! 4932       if (drive_type & 0x0f)
34413                       00009C28            .6E1:
34414                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34415 9C28           8A46         E8            mov	al,-$18[bp]
34416 9C2B           24                     0F  and	al,*$F
34417 9C2D           84C0                       test	al,al
34418 9C2F           74           07            je  	.6E3
34419                       00009C31            .6E4:
34420                                           ! 4933         num_floppies++;
34421                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
34422 9C31           8A46         E7            mov	al,-$19[bp]
34423 9C34           40                         inc	ax
34424 9C35           8846         E7            mov	-$19[bp],al
34425                                           !BCC_EOS
34426                                           ! 4934       if (drive == 0)
34427                       00009C38            .6E3:
34428                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
34429 9C38           8A46         FF            mov	al,-1[bp]
34430 9C3B           84C0                       test	al,al
34431 9C3D           75           0E            jne 	.6E5
34432                       00009C3F            .6E6:
34433                                           ! 4935         drive_type >>= 4;
34434                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34435 9C3F           8A46         E8            mov	al,-$18[bp]
34436 9C42           30E4                       xor	ah,ah
34437 9C44           B1                     04  mov	cl,*4
34438 9C46           D3E8                       shr	ax,cl
34439 9C48           8846         E8            mov	-$18[bp],al
34440                                           !BCC_EOS
34441                                           ! 4936       else
34442                                           ! 4937         drive_type &= 0x0f;
34443 9C4B           EB           08            jmp .6E7
34444                       00009C4D            .6E5:
34445                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34446 9C4D           8A46         E8            mov	al,-$18[bp]
34447 9C50           24                     0F  and	al,*$F
34448 9C52           8846         E8            mov	-$18[bp],al
34449                                           !BCC_EOS
34450                                           ! 4938       BX = ((BX & 0x00ff) | ((0) << 8));
34451                       00009C55            .6E7:
34452                                           ! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
34453 9C55           8A46         10            mov	al,$10[bp]
34454                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34455 9C58           0C                     00  or	al,*0
34456                                           ! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
34457 9C5A           30E4                       xor	ah,ah
34458 9C5C           8946         10            mov	$10[bp],ax
34459                                           !BCC_EOS
34460                                           ! 4939       BX = ((BX & 0xff00) | (drive_type));
34461                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
34462 9C5F           8B46         10            mov	ax,$10[bp]
34463 9C62           30C0                       xor	al,al
34464                                           ! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
34465 9C64           0A46         E8            or	al,-$18[bp]
34466                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
34467 9C67           8946         10            mov	$10[bp],ax
34468                                           !BCC_EOS
34469                                           ! 4940       AX = ((AX & 0x00ff) | ((0) << 8));
34470                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34471 9C6A           8A46         16            mov	al,$16[bp]
34472                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34473 9C6D           0C                     00  or	al,*0
34474                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34475 9C6F           30E4                       xor	ah,ah
34476 9C71           8946         16            mov	$16[bp],ax
34477                                           !BCC_EOS
34478                                           ! 4941       AX = ((AX & 0xff00) | (0));
34479                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34480 9C74           8B46         16            mov	ax,$16[bp]
34481 9C77           30C0                       xor	al,al
34482                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34483 9C79           0C                     00  or	al,*0
34484                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34485 9C7B           8946         16            mov	$16[bp],ax
34486                                           !BCC_EOS
34487                                           ! 4942       DX = ((DX & 0xff00) | (num_floppies));
34488                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
34489 9C7E           8B46         12            mov	ax,$12[bp]
34490 9C81           30C0                       xor	al,al
34491                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
34492 9C83           0A46         E7            or	al,-$19[bp]
34493                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34494 9C86           8946         12            mov	$12[bp],ax
34495                                           !BCC_EOS
34496                                           ! 4943       switch (drive_type) {
34497 9C89           8A46         E8            mov	al,-$18[bp]
34498 9C8C           E9         00BC            br 	.6EA
34499                                           ! 4944         case 0:
34500                                           ! 4945           CX = 0;
34501                       00009C8F            .6EB:
34502                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
34503 9C8F           31C0                       xor	ax,ax
34504 9C91           8946         14            mov	$14[bp],ax
34505                                           !BCC_EOS
34506                                           ! 4946           DX = ((DX & 0x00ff) | ((0) << 8));
34507                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34508 9C94           8A46         12            mov	al,$12[bp]
34509                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34510 9C97           0C                     00  or	al,*0
34511                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34512 9C99           30E4                       xor	ah,ah
34513 9C9B           8946         12            mov	$12[bp],ax
34514                                           !BCC_EOS
34515                                           ! 4947           break;
34516 9C9E           E9         00D1            br 	.6E8
34517                                           !BCC_EOS
34518                                           ! 4948         case 1:
34519                                           ! 4949           CX = 0x2709;
34520                       00009CA1            .6EC:
34521                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
34522 9CA1           B8                   2709  mov	ax,#$2709
34523 9CA4           8946         14            mov	$14[bp],ax
34524                                           !BCC_EOS
34525                                           ! 4950           DX = ((DX & 0x00ff) | ((1) << 8));
34526                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34527 9CA7           8A46         12            mov	al,$12[bp]
34528                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34529 9CAA           30E4                       xor	ah,ah
34530 9CAC           0D                   0100  or	ax,#$100
34531                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34532 9CAF           8946         12            mov	$12[bp],ax
34533                                           !BCC_EOS
34534                                           ! 4951           break;
34535 9CB2           E9         00BD            br 	.6E8
34536                                           !BCC_EOS
34537                                           ! 4952  
34538                                           ! 4952        case 2:
34539                                           ! 4953           CX = 0x4f0f;
34540                       00009CB5            .6ED:
34541                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
34542 9CB5           B8                   4F0F  mov	ax,#$4F0F
34543 9CB8           8946         14            mov	$14[bp],ax
34544                                           !BCC_EOS
34545                                           ! 4954           DX = ((DX & 0x00ff) | ((1) << 8));
34546                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34547 9CBB           8A46         12            mov	al,$12[bp]
34548                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34549 9CBE           30E4                       xor	ah,ah
34550 9CC0           0D                   0100  or	ax,#$100
34551                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34552 9CC3           8946         12            mov	$12[bp],ax
34553                                           !BCC_EOS
34554                                           ! 4955           break;
34555 9CC6           E9         00A9            br 	.6E8
34556                                           !BCC_EOS
34557                                           ! 4956         case 3:
34558                                           ! 4957           CX = 0x4f09;
34559                       00009CC9            .6EE:
34560                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
34561 9CC9           B8                   4F09  mov	ax,#$4F09
34562 9CCC           8946         14            mov	$14[bp],ax
34563                                           !BCC_EOS
34564                                           ! 4958           DX = ((DX & 0x00ff) | ((1) << 8));
34565                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34566 9CCF           8A46         12            mov	al,$12[bp]
34567                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34568 9CD2           30E4                       xor	ah,ah
34569 9CD4           0D                   0100  or	ax,#$100
34570                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34571 9CD7           8946         12            mov	$12[bp],ax
34572                                           !BCC_EOS
34573                                           ! 4959           break;
34574 9CDA           E9         0095            br 	.6E8
34575                                           !BCC_EOS
34576                                           ! 4960         case 4:
34577                                           ! 4961           CX = 0x4f12;
34578                       00009CDD            .6EF:
34579                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
34580 9CDD           B8                   4F12  mov	ax,#$4F12
34581 9CE0           8946         14            mov	$14[bp],ax
34582                                           !BCC_EOS
34583                                           ! 4962           DX = ((DX & 0x00ff) | ((1) << 8));
34584                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34585 9CE3           8A46         12            mov	al,$12[bp]
34586                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34587 9CE6           30E4                       xor	ah,ah
34588 9CE8           0D                   0100  or	ax,#$100
34589                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34590 9CEB           8946         12            mov	$12[bp],ax
34591                                           !BCC_EOS
34592                                           ! 4963           break;
34593 9CEE           E9         0081            br 	.6E8
34594                                           !BCC_EOS
34595                                           ! 4964         case 5:
34596                                           ! 4965           CX = 0x4f24;
34597                       00009CF1            .6F0:
34598                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
34599 9CF1           B8                   4F24  mov	ax,#$4F24
34600 9CF4           8946         14            mov	$14[bp],ax
34601                                           !BCC_EOS
34602                                           ! 4966           DX = ((DX & 0x00ff) | ((1) << 8));
34603                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34604 9CF7           8A46         12            mov	al,$12[bp]
34605                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34606 9CFA           30E4                       xor	ah,ah
34607 9CFC           0D                   0100  or	ax,#$100
34608                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34609 9CFF           8946         12            mov	$12[bp],ax
34610                                           !BCC_EOS
34611                                           ! 4967           break;
34612 9D02           EB           6E            jmp .6E8
34613                                           !BCC_EOS
34614                                           ! 4968         case 6:
34615                                           ! 4969           CX = 0x2708;
34616                       00009D04            .6F1:
34617                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
34618 9D04           B8                   2708  mov	ax,#$2708
34619 9D07           8946         14            mov	$14[bp],ax
34620                                           !BCC_EOS
34621                                           ! 4970           DX = ((DX & 0x00ff) | ((0) << 8));
34622                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34623 9D0A           8A46         12            mov	al,$12[bp]
34624                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34625 9D0D           0C                     00  or	al,*0
34626                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34627 9D0F           30E4                       xor	ah,ah
34628 9D11           8946         12            mov	$12[bp],ax
34629                                           !BCC_EOS
34630                                           ! 4971           break;
34631 9D14           EB           5C            jmp .6E8
34632                                           !BCC_EOS
34633                                           ! 4972         case 7:
34634                                           ! 4973           CX = 0x2709;
34635                       00009D16            .6F2:
34636                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
34637 9D16           B8                   2709  mov	ax,#$2709
34638 9D19           8946         14            mov	$14[bp],ax
34639                                           !BCC_EOS
34640                                           ! 4974           DX = ((DX & 0x00ff) | ((0) << 8));
34641                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34642 9D1C           8A46         12            mov	al,$12[bp]
34643                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34644 9D1F           0C                     00  or	al,*0
34645                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34646 9D21           30E4                       xor	ah,ah
34647 9D23           8946         12            mov	$12[bp],ax
34648                                           !BCC_EOS
34649                                           ! 4975           break;
34650 9D26           EB           4A            jmp .6E8
34651                                           !BCC_EOS
34652                                           ! 4976         case 8:
34653                                           ! 4977           CX = 0x2708;
34654                       00009D28            .6F3:
34655                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
34656 9D28           B8                   2708  mov	ax,#$2708
34657 9D2B           8946         14            mov	$14[bp],ax
34658                                           !BCC_EOS
34659                                           ! 4978           DX = ((DX & 0x00ff) | ((1) << 8));
34660                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34661 9D2E           8A46         12            mov	al,$12[bp]
34662                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34663 9D31           30E4                       xor	ah,ah
34664 9D33           0D                   0100  or	ax,#$100
34665                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34666 9D36           8946         12            mov	$12[bp],ax
34667                                           !BCC_EOS
34668                                           ! 4979           break;
34669 9D39           EB           37            jmp .6E8
34670                                           !BCC_EOS
34671                                           ! 4980         default:
34672                                           ! 4981           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
34673                       00009D3B            .6F4:
34674                                           ! Debug: list * char = .6F5+0 (used reg = )
34675 9D3B           BB                   D04B  mov	bx,#.6F5
34676 9D3E           53                         push	bx
34677                                           ! Debug: list int = const 7 (used reg = )
34678 9D3F           B8                   0007  mov	ax,*7
34679 9D42           50                         push	ax
34680                                           ! Debug: func () void = bios_printf+0 (used reg = )
34681 9D43           E8         6CD5            call	_bios_printf
34682 9D46           83C4                   04  add	sp,*4
34683                                           !BCC_EOS
34684                                           ! 4982         }
34685                                           ! 4983 #asm
34686 9D49           EB           27            jmp .6E8
34687                       00009D4B            .6EA:
34688 9D4B           2C                     00  sub	al,*0
34689 9D4D           72           EC            jb 	.6F4
34690 9D4F           3C                     08  cmp	al,*8
34691 9D51           77           1D            ja  	.6F6
34692 9D53           30E4                       xor	ah,ah
34693 9D55           D1E0                       shl	ax,*1
34694 9D57           89C3                       mov	bx,ax
34695 9D59           2E                         seg	cs
34696 9D5A           FFA7       9D5E            br	.6F7[bx]
34697                       00009D5E            .6F7:
34698 9D5E                      9C8F            .word	.6EB
34699 9D60                      9CA1            .word	.6EC
34700 9D62                      9CB5            .word	.6ED
34701 9D64                      9CC9            .word	.6EE
34702 9D66                      9CDD            .word	.6EF
34703 9D68                      9CF1            .word	.6F0
34704 9D6A                      9D04            .word	.6F1
34705 9D6C                      9D16            .word	.6F2
34706 9D6E                      9D28            .word	.6F3
34707                       00009D70            .6F6:
34708 9D70           EB           C9            jmp	.6F4
34709                       00009D72            .6E8:
34710                                           !BCC_EOS
34711                                           !BCC_ASM
34712                       0000002A            _int13_diskette_function.BP	set	$2A
34713                       0000000C            .int13_diskette_function.BP	set	$C
34714                       00000038            _int13_diskette_function.CS	set	$38
34715                       0000001A            .int13_diskette_function.CS	set	$1A
34716                       00000032            _int13_diskette_function.CX	set	$32
34717                       00000014            .int13_diskette_function.CX	set	$14
34718                       00000016            _int13_diskette_function.base_address	set	$16
34719                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34720                       00000026            _int13_diskette_function.DI	set	$26
34721                       00000008            .int13_diskette_function.DI	set	8
34722                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34723                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34724                       00000014            _int13_diskette_function.base_count	set	$14
34725                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34726                       0000001A            _int13_diskette_function.sector	set	$1A
34727                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34728                       00000022            _int13_diskette_function.DS	set	$22
34729                       00000004            .int13_diskette_function.DS	set	4
34730                       00000019            _int13_diskette_function.head	set	$19
34731                       FFFFFFFB            .int13_diskette_function.head	set	-5
34732                       0000002C            _int13_diskette_function.ELDX	set	$2C
34733                       0000000E            .int13_diskette_function.ELDX	set	$E
34734                       0000000E            _int13_diskette_function.dor	set	$E
34735                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34736                       00000030            _int13_diskette_function.DX	set	$30
34737                       00000012            .int13_diskette_function.DX	set	$12
34738                       00000007            _int13_diskette_function.return_status	set	7
34739                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34740                       00000002            _int13_diskette_function.es	set	2
34741                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34742                       00000010            _int13_diskette_function.mode_register	set	$10
34743                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34744                       00000024            _int13_diskette_function.ES	set	$24
34745                       00000006            .int13_diskette_function.ES	set	6
34746                       00000012            _int13_diskette_function.base_es	set	$12
34747                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34748                       0000001B            _int13_diskette_function.track	set	$1B
34749                       FFFFFFFD            .int13_diskette_function.track	set	-3
34750                       00000028            _int13_diskette_function.SI	set	$28
34751                       0000000A            .int13_diskette_function.SI	set	$A
34752                       00000006            _int13_diskette_function.drive_type	set	6
34753                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34754                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34755                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34756                       00000036            _int13_diskette_function.IP	set	$36
34757                       00000018            .int13_diskette_function.IP	set	$18
34758                       00000018            _int13_diskette_function.status	set	$18
34759                       FFFFFFFA            .int13_diskette_function.status	set	-6
34760                       00000034            _int13_diskette_function.AX	set	$34
34761                       00000016            .int13_diskette_function.AX	set	$16
34762                       0000000F            _int13_diskette_function.val8	set	$F
34763                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34764                       00000000            _int13_diskette_function.last_addr	set	0
34765                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34766                       00000011            _int13_diskette_function.page	set	$11
34767                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34768                       00000004            _int13_diskette_function.ah	set	4
34769                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34770                       0000001D            _int13_diskette_function.drive	set	$1D
34771                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34772                       00000005            _int13_diskette_function.num_floppies	set	5
34773                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34774                       0000002E            _int13_diskette_function.BX	set	$2E
34775                       00000010            .int13_diskette_function.BX	set	$10
34776 9D72           55                               push bp
34777 9D73           89E5                             mov bp, sp
34778 9D75           B8                   EFDE        mov ax, #diskette_param_table2
34779 9D78           8946         28                  mov _int13_diskette_function.DI+2[bp], ax
34780 9D7B           8C4E         26                  mov _int13_diskette_function.ES+2[bp], cs
34781 9D7E           5D                               pop bp
34782                                           ! 4990 endasm
34783                                           !BCC_ENDASM
34784                                           !BCC_EOS
34785                                           ! 4991       FLAGS &= 0xfffe;
34786                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34787 9D7F           8B46         1C            mov	ax,$1C[bp]
34788 9D82           24                     FE  and	al,#$FE
34789 9D84           8946         1C            mov	$1C[bp],ax
34790                                           !BCC_EOS
34791                                           ! 4992       return;
34792 9D87           89EC                       mov	sp,bp
34793 9D89           5D                         pop	bp
34794 9D8A           C3                         ret
34795                                           !BCC_EOS
34796                                           ! 4993     case 0x15:
34797                                           ! 4994 ;
34798                       00009D8B            .6F8:
34799                                           !BCC_EOS
34800                                           ! 4995       drive = ( ELDX & 0x00ff );
34801                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34802 9D8B           8A46         0E            mov	al,$E[bp]
34803                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34804 9D8E           8846         FF            mov	-1[bp],al
34805                                           !BCC_EOS
34806                                           ! 4996       if (drive > 1) {
34807                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34808 9D91           8A46         FF            mov	al,-1[bp]
34809 9D94           3C                     01  cmp	al,*1
34810 9D96           76           16            jbe 	.6F9
34811                       00009D98            .6FA:
34812                                           ! 4997         AX = ((AX & 0x00ff) | ((0) << 8));
34813                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34814 9D98           8A46         16            mov	al,$16[bp]
34815                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34816 9D9B           0C                     00  or	al,*0
34817                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34818 9D9D           30E4                       xor	ah,ah
34819 9D9F           8946         16            mov	$16[bp],ax
34820                                           !BCC_EOS
34821                                           ! 4998         FLAGS |= 0x0001;
34822                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34823 9DA2           8B46         1C            mov	ax,$1C[bp]
34824 9DA5           0C                     01  or	al,*1
34825 9DA7           8946         1C            mov	$1C[bp],ax
34826                                           !BCC_EOS
34827                                           ! 4999         return;
34828 9DAA           89EC                       mov	sp,bp
34829 9DAC           5D                         pop	bp
34830 9DAD           C3                         ret
34831                                           !BCC_EOS
34832                                           ! 5000         }
34833                                           ! 5001       drive_type = inb_cmos(0x10);
34834                       00009DAE            .6F9:
34835                                           ! Debug: list int = const $10 (used reg = )
34836 9DAE           B8                   0010  mov	ax,*$10
34837 9DB1           50                         push	ax
34838                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34839 9DB2           E8         67CE            call	_inb_cmos
34840 9DB5           44                         inc	sp
34841 9DB6           44                         inc	sp
34842                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34843 9DB7           8846         E8            mov	-$18[bp],al
34844                                           !BCC_EOS
34845                                           ! 5002       if (drive == 0)
34846                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
34847 9DBA           8A46         FF            mov	al,-1[bp]
34848 9DBD           84C0                       test	al,al
34849 9DBF           75           0E            jne 	.6FB
34850                       00009DC1            .6FC:
34851                                           ! 5003         drive_type >>= 4;
34852                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34853 9DC1           8A46         E8            mov	al,-$18[bp]
34854 9DC4           30E4                       xor	ah,ah
34855 9DC6           B1                     04  mov	cl,*4
34856 9DC8           D3E8                       shr	ax,cl
34857 9DCA           8846         E8            mov	-$18[bp],al
34858                                           !BCC_EOS
34859                                           ! 5004       else
34860                                           ! 5005         drive_type &= 0x0f;
34861 9DCD           EB           08            jmp .6FD
34862                       00009DCF            .6FB:
34863                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34864 9DCF           8A46         E8            mov	al,-$18[bp]
34865 9DD2           24                     0F  and	al,*$F
34866 9DD4           8846         E8            mov	-$18[bp],al
34867                                           !BCC_EOS
34868                                           ! 5006       FLAGS &= 0xfffe;
34869                       00009DD7            .6FD:
34870                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34871 9DD7           8B46         1C            mov	ax,$1C[bp]
34872 9DDA           24                     FE  and	al,#$FE
34873 9DDC           8946         1C            mov	$1C[bp],ax
34874                                           !BCC_EOS
34875                                           ! 5007       if (drive_type==0) {
34876                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34877 9DDF           8A46         E8            mov	al,-$18[bp]
34878 9DE2           84C0                       test	al,al
34879 9DE4           75           0C            jne 	.6FE
34880                       00009DE6            .6FF:
34881                                           ! 5008         AX = ((AX & 0x00ff) | ((0) << 8));
34882                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34883 9DE6           8A46         16            mov	al,$16[bp]
34884                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34885 9DE9           0C                     00  or	al,*0
34886                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34887 9DEB           30E4                       xor	ah,ah
34888 9DED           8946         16            mov	$16[bp],ax
34889                                           !BCC_EOS
34890                                           ! 5009         }
34891                                           ! 5010       else {
34892 9DF0           EB           0B            jmp .700
34893                       00009DF2            .6FE:
34894                                           ! 5011         AX = ((AX & 0x00ff) | ((1) << 8));
34895                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34896 9DF2           8A46         16            mov	al,$16[bp]
34897                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34898 9DF5           30E4                       xor	ah,ah
34899 9DF7           0D                   0100  or	ax,#$100
34900                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34901 9DFA           8946         16            mov	$16[bp],ax
34902                                           !BCC_EOS
34903                                           ! 5012         }
34904                                           ! 5013       return;
34905                       00009DFD            .700:
34906 9DFD           89EC                       mov	sp,bp
34907 9DFF           5D                         pop	bp
34908 9E00           C3                         ret
34909                                           !BCC_EOS
34910                                           ! 5014     case 0x16:
34911                                           ! 5015 ;
34912                       00009E01            .701:
34913                                           !BCC_EOS
34914                                           ! 5016       drive = ( ELDX & 0x00ff );
34915                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34916 9E01           8A46         0E            mov	al,$E[bp]
34917                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34918 9E04           8846         FF            mov	-1[bp],al
34919                                           !BCC_EOS
34920                                           ! 5017       if (drive > 1) {
34921                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34922 9E07           8A46         FF            mov	al,-1[bp]
34923 9E0A           3C                     01  cmp	al,*1
34924 9E0C           76           20            jbe 	.702
34925                       00009E0E            .703:
34926                                           ! 5018         AX = ((AX & 0x00ff) | ((0x01) << 8));
34927                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34928 9E0E           8A46         16            mov	al,$16[bp]
34929                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34930 9E11           30E4                       xor	ah,ah
34931 9E13           0D                   0100  or	ax,#$100
34932                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34933 9E16           8946         16            mov	$16[bp],ax
34934                                           !BCC_EOS
34935                                           ! 5019         set_diskette_ret_status(0x01);
34936                                           ! Debug: list int = const 1 (used reg = )
34937 9E19           B8                   0001  mov	ax,*1
34938 9E1C           50                         push	ax
34939                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34940 9E1D           E8         00D3            call	_set_diskette_ret_status
34941 9E20           44                         inc	sp
34942 9E21           44                         inc	sp
34943                                           !BCC_EOS
34944                                           ! 5020         FLAGS |= 0x0001;
34945                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34946 9E22           8B46         1C            mov	ax,$1C[bp]
34947 9E25           0C                     01  or	al,*1
34948 9E27           8946         1C            mov	$1C[bp],ax
34949                                           !BCC_EOS
34950                                           ! 5021         return;
34951 9E2A           89EC                       mov	sp,bp
34952 9E2C           5D                         pop	bp
34953 9E2D           C3                         ret
34954                                           !BCC_EOS
34955                                           ! 5022         }
34956                                           ! 5023       AX = ((AX & 0x00ff) | ((0x06) << 8));
34957                       00009E2E            .702:
34958                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34959 9E2E           8A46         16            mov	al,$16[bp]
34960                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
34961 9E31           30E4                       xor	ah,ah
34962 9E33           0D                   0600  or	ax,#$600
34963                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34964 9E36           8946         16            mov	$16[bp],ax
34965                                           !BCC_EOS
34966                                           ! 5024       set_diskette_ret_status(0x06);
34967                                           ! Debug: list int = const 6 (used reg = )
34968 9E39           B8                   0006  mov	ax,*6
34969 9E3C           50                         push	ax
34970                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34971 9E3D           E8         00B3            call	_set_diskette_ret_status
34972 9E40           44                         inc	sp
34973 9E41           44                         inc	sp
34974                                           !BCC_EOS
34975                                           ! 5025       FLAGS |= 0x0001;
34976                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34977 9E42           8B46         1C            mov	ax,$1C[bp]
34978 9E45           0C                     01  or	al,*1
34979 9E47           8946         1C            mov	$1C[bp],ax
34980                                           !BCC_EOS
34981                                           ! 5026       return;
34982 9E4A           89EC                       mov	sp,bp
34983 9E4C           5D                         pop	bp
34984 9E4D           C3                         ret
34985                                           !BCC_EOS
34986                                           ! 5027     case 0x17:
34987                                           ! 5028 ;
34988                       00009E4E            .704:
34989                                           !BCC_EOS
34990                                           ! 5029       AX = ((AX & 0x00ff) | ((0x01) << 8));
34991                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34992 9E4E           8A46         16            mov	al,$16[bp]
34993                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34994 9E51           30E4                       xor	ah,ah
34995 9E53           0D                   0100  or	ax,#$100
34996                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34997 9E56           8946         16            mov	$16[bp],ax
34998                                           !BCC_EOS
34999                                           ! 5030       set_diskette_ret_status(1);
35000                                           ! Debug: list int = const 1 (used reg = )
35001 9E59           B8                   0001  mov	ax,*1
35002 9E5C           50                         push	ax
35003                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35004 9E5D           E8         0093            call	_set_diskette_ret_status
35005 9E60           44                         inc	sp
35006 9E61           44                         inc	sp
35007                                           !BCC_EOS
35008                                           ! 5031       FLAGS |= 0x0001;
35009                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35010 9E62           8B46         1C            mov	ax,$1C[bp]
35011 9E65           0C                     01  or	al,*1
35012 9E67           8946         1C            mov	$1C[bp],ax
35013                                           !BCC_EOS
35014                                           ! 5032       return;
35015 9E6A           89EC                       mov	sp,bp
35016 9E6C           5D                         pop	bp
35017 9E6D           C3                         ret
35018                                           !BCC_EOS
35019                                           ! 5033     case 0x18:
35020                                           ! 5034 ;
35021                       00009E6E            .705:
35022                                           !BCC_EOS
35023                                           ! 5035       AX = ((AX & 0x00ff) | ((0x01) << 8));
35024                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35025 9E6E           8A46         16            mov	al,$16[bp]
35026                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35027 9E71           30E4                       xor	ah,ah
35028 9E73           0D                   0100  or	ax,#$100
35029                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35030 9E76           8946         16            mov	$16[bp],ax
35031                                           !BCC_EOS
35032                                           ! 5036       set_diskette_ret_s
35033                                           ! 5036 tatus(1);
35034                                           ! Debug: list int = const 1 (used reg = )
35035 9E79           B8                   0001  mov	ax,*1
35036 9E7C           50                         push	ax
35037                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35038 9E7D           E8         0073            call	_set_diskette_ret_status
35039 9E80           44                         inc	sp
35040 9E81           44                         inc	sp
35041                                           !BCC_EOS
35042                                           ! 5037       FLAGS |= 0x0001;
35043                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35044 9E82           8B46         1C            mov	ax,$1C[bp]
35045 9E85           0C                     01  or	al,*1
35046 9E87           8946         1C            mov	$1C[bp],ax
35047                                           !BCC_EOS
35048                                           ! 5038       return;
35049 9E8A           89EC                       mov	sp,bp
35050 9E8C           5D                         pop	bp
35051 9E8D           C3                         ret
35052                                           !BCC_EOS
35053                                           ! 5039     default:
35054                                           ! 5040         ;
35055                       00009E8E            .706:
35056                                           !BCC_EOS
35057                                           ! 5041         AX = ((AX & 0x00ff) | ((0x01) << 8));
35058                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35059 9E8E           8A46         16            mov	al,$16[bp]
35060                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35061 9E91           30E4                       xor	ah,ah
35062 9E93           0D                   0100  or	ax,#$100
35063                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35064 9E96           8946         16            mov	$16[bp],ax
35065                                           !BCC_EOS
35066                                           ! 5042         set_diskette_ret_status(1);
35067                                           ! Debug: list int = const 1 (used reg = )
35068 9E99           B8                   0001  mov	ax,*1
35069 9E9C           50                         push	ax
35070                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35071 9E9D           E8         0053            call	_set_diskette_ret_status
35072 9EA0           44                         inc	sp
35073 9EA1           44                         inc	sp
35074                                           !BCC_EOS
35075                                           ! 5043         FLAGS |= 0x0001;
35076                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35077 9EA2           8B46         1C            mov	ax,$1C[bp]
35078 9EA5           0C                     01  or	al,*1
35079 9EA7           8946         1C            mov	$1C[bp],ax
35080                                           !BCC_EOS
35081                                           ! 5044         return;
35082 9EAA           89EC                       mov	sp,bp
35083 9EAC           5D                         pop	bp
35084 9EAD           C3                         ret
35085                                           !BCC_EOS
35086                                           ! 5045     }
35087                                           ! 5046 }
35088 9EAE           EB           3F            jmp .679
35089                       00009EB0            .67B:
35090 9EB0           2C                     00  sub	al,*0
35091 9EB2           72           DA            jb 	.706
35092 9EB4           3C                     08  cmp	al,*8
35093 9EB6           77           1D            ja  	.707
35094 9EB8           30E4                       xor	ah,ah
35095 9EBA           D1E0                       shl	ax,*1
35096 9EBC           89C3                       mov	bx,ax
35097 9EBE           2E                         seg	cs
35098 9EBF           FFA7       9EC3            br	.708[bx]
35099                       00009EC3            .708:
35100 9EC3                      8E11            .word	.67C
35101 9EC5                      8EBB            .word	.684
35102 9EC7                      8EFD            .word	.687
35103 9EC9                      8EFD            .word	.688
35104 9ECB                      8EFD            .word	.689
35105 9ECD                      9788            .word	.6BE
35106 9ECF                      9E8E            .word	.706
35107 9ED1                      9E8E            .word	.706
35108 9ED3                      9BC5            .word	.6DE
35109                       00009ED5            .707:
35110 9ED5           2C                     15  sub	al,*$15
35111 9ED7         0F84         FEB0            beq 	.6F8
35112 9EDB           2C                     01  sub	al,*1
35113 9EDD         0F84         FF20            beq 	.701
35114 9EE1           2C                     01  sub	al,*1
35115 9EE3         0F84         FF67            beq 	.704
35116 9EE7           2C                     01  sub	al,*1
35117 9EE9         0F84         FF81            beq 	.705
35118 9EED           EB           9F            jmp	.706
35119                       00009EEF            .679:
35120                       FFFFFFE0            ..FFDC	=	-$20
35121 9EEF           89EC                       mov	sp,bp
35122 9EF1           5D                         pop	bp
35123 9EF2           C3                         ret
35124                                           ! 5047  void
35125                                           ! Register BX used in function int13_diskette_function
35126                                           ! 5048 set_diskette_ret_status(value)
35127                                           ! 5049   Bit8u value;
35128                                           export	_set_diskette_ret_status
35129                       00009EF3            _set_diskette_ret_status:
35130                                           !BCC_EOS
35131                                           ! 5050 {
35132                                           ! 5051   write_byte(0x0040, 0x0041, value);
35133 9EF3           55                         push	bp
35134 9EF4           89E5                       mov	bp,sp
35135                                           ! Debug: list unsigned char value = [S+2+2] (used reg = )
35136 9EF6           8A46         04            mov	al,4[bp]
35137 9EF9           30E4                       xor	ah,ah
35138 9EFB           50                         push	ax
35139                                           ! Debug: list int = const $41 (used reg = )
35140 9EFC           B8                   0041  mov	ax,*$41
35141 9EFF           50                         push	ax
35142                                           ! Debug: list int = const $40 (used reg = )
35143 9F00           B8                   0040  mov	ax,*$40
35144 9F03           50                         push	ax
35145                                           ! Debug: func () void = write_byte+0 (used reg = )
35146 9F04           E8         6713            call	_write_byte
35147 9F07           89EC                       mov	sp,bp
35148                                           !BCC_EOS
35149                                           ! 5052 }
35150 9F09           5D                         pop	bp
35151 9F0A           C3                         ret
35152                                           ! 5053   void
35153                                           ! 5054 set_diskette_current_cyl(drive, cyl)
35154                                           ! 5055   Bit8u drive;
35155                                           export	_set_diskette_current_cyl
35156                       00009F0B            _set_diskette_current_cyl:
35157                                           !BCC_EOS
35158                                           ! 5056   Bit8u cyl;
35159                                           !BCC_EOS
35160                                           ! 5057 {
35161                                           ! 5058   if (drive > 1)
35162 9F0B           55                         push	bp
35163 9F0C           89E5                       mov	bp,sp
35164                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
35165 9F0E           8A46         04            mov	al,4[bp]
35166 9F11           3C                     01  cmp	al,*1
35167 9F13           76           0D            jbe 	.709
35168                       00009F15            .70A:
35169                                           ! 5059     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
35170                                           ! Debug: list * char = .70B+0 (used reg = )
35171 9F15           BB                   D024  mov	bx,#.70B
35172 9F18           53                         push	bx
35173                                           ! Debug: list int = const 7 (used reg = )
35174 9F19           B8                   0007  mov	ax,*7
35175 9F1C           50                         push	ax
35176                                           ! Debug: func () void = bios_printf+0 (used reg = )
35177 9F1D           E8         6AFB            call	_bios_printf
35178 9F20           89EC                       mov	sp,bp
35179                                           !BCC_EOS
35180                                           ! 5060   write_byte(0x0040, 0x0094+drive, cyl);
35181                       00009F22            .709:
35182                                           ! Debug: list unsigned char cyl = [S+2+4] (used reg = )
35183 9F22           8A46         06            mov	al,6[bp]
35184 9F25           30E4                       xor	ah,ah
35185 9F27           50                         push	ax
35186                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
35187                                           ! Debug: expression subtree swapping
35188 9F28           8A46         04            mov	al,4[bp]
35189 9F2B           30E4                       xor	ah,ah
35190                                           ! Debug: list unsigned int = ax+$94 (used reg = )
35191 9F2D           05                   0094  add	ax,#$94
35192 9F30           50                         push	ax
35193                                           ! Debug: list int = const $40 (used reg = )
35194 9F31           B8                   0040  mov	ax,*$40
35195 9F34           50                         push	ax
35196                                           ! Debug: func () void = write_byte+0 (used reg = )
35197 9F35           E8         66E2            call	_write_byte
35198 9F38           89EC                       mov	sp,bp
35199                                           !BCC_EOS
35200                                           ! 5061 }
35201 9F3A           5D                         pop	bp
35202 9F3B           C3                         ret
35203                                           ! 5062   void
35204                                           ! Register BX used in function set_diskette_current_cyl
35205                                           ! 5063 determine_floppy_media(drive)
35206                                           ! 5064   Bit16u drive;
35207                                           export	_determine_floppy_media
35208                       00009F3C            _determine_floppy_media:
35209                                           !BCC_EOS
35210                                           ! 5065 {
35211                                           ! 5066 }
35212 9F3C           C3                         ret
35213                                           ! 5067   void
35214                                           ! 5068 int17_function(regs, ds, iret_addr)
35215                                           ! 5069   pusha_regs_t regs;
35216                                           export	_int17_function
35217                       00009F3D            _int17_function:
35218                                           !BCC_EOS
35219                                           ! 5070   Bit16u ds;
35220                                           !BCC_EOS
35221                                           ! 5071   iret_addr_t iret_addr;
35222                                           !BCC_EOS
35223                                           ! 5072 {
35224                                           ! 5073   Bit16u addr,timeout;
35225                                           !BCC_EOS
35226                                           ! 5074   Bit8u val8;
35227                                           !BCC_EOS
35228                                           ! 5075 #asm
35229 9F3D           55                         push	bp
35230 9F3E           89E5                       mov	bp,sp
35231 9F40           83C4                   FA  add	sp,*-6
35232                                           !BCC_EOS
35233                                           !BCC_ASM
35234                       0000001A            _int17_function.ds	set	$1A
35235                       00000014            .int17_function.ds	set	$14
35236                       00000002            _int17_function.timeout	set	2
35237                       FFFFFFFC            .int17_function.timeout	set	-4
35238                       00000001            _int17_function.val8	set	1
35239                       FFFFFFFB            .int17_function.val8	set	-5
35240                       0000001C            _int17_function.iret_addr	set	$1C
35241                       00000016            .int17_function.iret_addr	set	$16
35242                       00000004            _int17_function.addr	set	4
35243                       FFFFFFFE            .int17_function.addr	set	-2
35244                       0000000A            _int17_function.regs	set	$A
35245                       00000004            .int17_function.regs	set	4
35246 9F43           FB                           sti
35247                                           ! 5077 endasm
35248                                           !BCC_ENDASM
35249                                           !BCC_EOS
35250                                           ! 5078   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
35251                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
35252 9F44           8B46         0E            mov	ax,$E[bp]
35253 9F47           D1E0                       shl	ax,*1
35254                                           ! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
35255                                           ! Debug: list unsigned int = ax+8 (used reg = )
35256 9F49           05                   0008  add	ax,*8
35257 9F4C           50                         push	ax
35258                                           ! Debug: list int = const $40 (used reg = )
35259 9F4D           B8                   0040  mov	ax,*$40
35260 9F50           50                         push	ax
35261                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35262 9F51           E8         66B3            call	_read_word
35263 9F54           83C4                   04  add	sp,*4
35264                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
35265 9F57           8946         FE            mov	-2[bp],ax
35266                                           !BCC_EOS
35267                                           ! 5079   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
35268                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
35269 9F5A           8A46         13            mov	al,$13[bp]
35270 9F5D           3C                     03  cmp	al,*3
35271 9F5F         0F83         0106            bhis	.70C
35272                       00009F63            .70F:
35273                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
35274 9F63           8B46         0E            mov	ax,$E[bp]
35275 9F66           3D                   0003  cmp	ax,*3
35276 9F69         0F83         00FC            bhis	.70C
35277                       00009F6D            .70E:
35278                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
35279 9F6D           8B46         FE            mov	ax,-2[bp]
35280 9F70           85C0                       test	ax,ax
35281 9F72         0F84         00F3            beq 	.70C
35282                       00009F76            .70D:
35283                                           ! 5080     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
35284                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
35285                                           ! Debug: expression subtree swapping
35286 9F76           8B46         0E            mov	ax,$E[bp]
35287                                           ! Debug: list unsigned int = ax+$78 (used reg = )
35288 9F79           05                   0078  add	ax,*$78
35289 9F7C           50                         push	ax
35290                                           ! Debug: list int = const $40 (used reg = )
35291 9F7D           B8                   0040  mov	ax,*$40
35292 9F80           50                         push	ax
35293                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
35294 9F81           E8         6670            call	_read_byte
35295 9F84           83C4                   04  add	sp,*4
35296                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
35297 9F87           30E4                       xor	ah,ah
35298 9F89           88C4                       mov	ah,al
35299 9F8B           30C0                       xor	al,al
35300                                           ! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
35301 9F8D           8946         FC            mov	-4[bp],ax
35302                                           !BCC_EOS
35303                                           ! 5081     if (regs.u.r8.ah == 0) {
35304                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
35305 9F90           8A46         13            mov	al,$13[bp]
35306 9F93           84C0                       test	al,al
35307 9F95           75           66            jne 	.710
35308                       00009F97            .711:
35309                                           ! 5082       outb(addr, regs.u.r8.al);
35310                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
35311 9F97           8A46         12            mov	al,$12[bp]
35312 9F9A           30E4                       xor	ah,ah
35313 9F9C           50                         push	ax
35314                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
35315 9F9D           FF76         FE            push	-2[bp]
35316                                           ! Debug: func () void = outb+0 (used reg = )
35317 9FA0           E8         65B1            call	_outb
35318 9FA3           83C4                   04  add	sp,*4
35319                                           !BCC_EOS
35320                                           ! 5083       val8 = inb(addr+2);
35321                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
35322 9FA6           8B46         FE            mov	ax,-2[bp]
35323                                           ! Debug: list unsigned int = ax+2 (used reg = )
35324 9FA9           40                         inc	ax
35325 9FAA           40                         inc	ax
35326 9FAB           50                         push	ax
35327                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35328 9FAC           E8         658F            call	_inb
35329 9FAF           44                         inc	sp
35330 9FB0           44                         inc	sp
35331                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35332 9FB1           8846         FB            mov	-5[bp],al
35333                                           !BCC_EOS
35334                                           ! 5084       outb(addr+2, val8 | 0x01);
35335                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
35336 9FB4           8A46         FB            mov	al,-5[bp]
35337 9FB7           0C                     01  or	al,*1
35338                                           ! Debug: list unsigned char = al+0 (used reg = )
35339 9FB9           30E4                       xor	ah,ah
35340 9FBB           50                         push	ax
35341                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35342 9FBC           8B46         FE            mov	ax,-2[bp]
35343                                           ! Debug: list unsigned int = ax+2 (used reg = )
35344 9FBF           40                         inc	ax
35345 9FC0           40                         inc	ax
35346 9FC1           50                         push	ax
35347                                           ! Debug: func () void = outb+0 (used reg = )
35348 9FC2           E8         658F            call	_outb
35349 9FC5           83C4                   04  add	sp,*4
35350                                           !BCC_EOS
35351                                           ! 5085 #asm
35352                                           !BCC_EOS
35353                                           !BCC_ASM
35354                       0000001A            _int17_function.ds	set	$1A
35355                       00000014            .int17_function.ds	set	$14
35356                       00000002            _int17_function.timeout	set	2
35357                       FFFFFFFC            .int17_function.timeout	set	-4
35358                       00000001            _int17_function.val8	set	1
35359                       FFFFFFFB            .int17_function.val8	set	-5
35360                       0000001C            _int17_function.iret_addr	set	$1C
35361                       00000016            .int17_function.iret_addr	set	$16
35362                       00000004            _int17_function.addr	set	4
35363                       FFFFFFFE            .int17_function.addr	set	-2
35364                       0000000A            _int17_function.regs	set	$A
35365                       00000004            .int17_function.regs	set	4
35366 9FC8           90                               nop
35367                                           ! 5087 endasm
35368                                           !BCC_ENDASM
35369                                           !BCC_EOS
35370                                           ! 5088       outb(addr+2, val8 & ~0x01);
35371                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
35372 9FC9           8A46         FB            mov	al,-5[bp]
35373 9FCC           24                     FE  and	al,#$FE
35374                                           ! Debug: list unsigned char = al+0 (used reg = )
35375 9FCE           30E4                       xor	ah,ah
35376 9FD0           50                         push	ax
35377                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35378 9FD1           8B46         FE            mov	ax,-2[bp]
35379                                           ! Debug: list unsigned int = ax+2 (used reg = )
35380 9FD4           40                         inc	ax
35381 9FD5           40                         inc	ax
35382 9FD6           50                         push	ax
35383                                           ! Debug: func () void = outb+0 (used reg = )
35384 9FD7           E8         657A            call	_outb
35385 9FDA           83C4                   04  add	sp,*4
35386                                           !BCC_EOS
35387                                           ! 5089       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
35388 9FDD           EB           07            jmp .713
35389                       00009FDF            .714:
35390                                           ! 5090         timeout--;
35391                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
35392 9FDF           8B46         FC            mov	ax,-4[bp]
35393 9FE2           48                         dec	ax
35394 9FE3           8946         FC            mov	-4[bp],ax
35395                                           !BCC_EOS
35396                                           ! 5091       }
35397                                           ! 5092     }
35398                       00009FE6            .713:
35399                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
35400 9FE6           8B46         FE            mov	ax,-2[bp]
35401                                           ! Debug: list unsigned int = ax+1 (used reg = )
35402 9FE9           40                         inc	ax
35403 9FEA           50                         push	ax
35404                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35405 9FEB           E8         6550            call	_inb
35406 9FEE           44                         inc	sp
35407 9FEF           44                         inc	sp
35408                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
35409 9FF0           24                     40  and	al,*$40
35410                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
35411 9FF2           3C                     40  cmp	al,*$40
35412 9FF4           75           07            jne 	.715
35413                       00009FF6            .716:
35414 9FF6           8B46         FC            mov	ax,-4[bp]
35415 9FF9           85C0                       test	ax,ax
35416 9FFB           75           E2            jne	.714
35417                       00009FFD            .715:
35418                       00009FFD            .712:
35419                                           ! 5093     if (regs.u.r8.ah == 1) {
35420                       00009FFD            .710:
35421                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
35422 9FFD           8A46         13            mov	al,$13[bp]
35423 A000           3C                     01  cmp	al,*1
35424 A002           75           37            jne 	.717
35425                       0000A004            .718:
35426                                           ! 5094       val8 = inb(addr+2);
35427                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
35428 A004           8B46         FE            mov	ax,-2[bp]
35429                                           ! Debug: list unsigned int = ax+2 (used reg = )
35430 A007           40                         inc	ax
35431 A008           40                         inc	ax
35432 A009           50                         push	ax
35433                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35434 A00A           E8         6531            call	_inb
35435 A00D           44                         inc	sp
35436 A00E           44                         inc	sp
35437                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35438 A00F           8846         FB            mov	-5[bp],al
35439                                           !BCC_EOS
35440                                           ! 5095       outb(addr+2, val8 & ~0x04);
35441                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
35442 A012           8A46         FB            mov	al,-5[bp]
35443 A015           24                     FB  and	al,#$FB
35444                                           ! Debug: list unsigned char = al+0 (used reg = )
35445 A017           30E4                       xor	ah,ah
35446 A019           50                         push	ax
35447                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35448 A01A           8B46         FE            mov	ax,-2[bp]
35449                                           ! Debug: list unsigned int = ax+2 (used reg = )
35450 A01D           40                         inc	ax
35451 A01E           40                         inc	ax
35452 A01F           50                         push	ax
35453                                           ! Debug: func () void = outb+0 (used reg = )
35454 A020           E8         6531            call	_outb
35455 A023           83C4                   04  add	sp,*4
35456                                           !BCC_EOS
35457                                           ! 5096 #asm
35458                                           !BCC_EOS
35459                                           !BCC_ASM
35460                       0000001A            _int17_function.ds	set	$1A
35461                       00000014            .int17_function.ds	set	$14
35462                       00000002            _int17_function.timeout	set	2
35463                       FFFFFFFC            .int17_function.timeout	set	-4
35464                       00000001            _int17_function.val8	set	1
35465                       FFFFFFFB            .int17_function.val8	set	-5
35466                       0000001C            _int17_function.iret_addr	set	$1C
35467                       00000016            .int17_function.iret_addr	set	$16
35468                       00000004            _int17_function.addr	set	4
35469                       FFFFFFFE            .int17_function.addr	set	-2
35470                       0000000A            _int17_function.regs	set	$A
35471                       00000004            .int17_function.regs	set	4
35472 A026           90                               nop
35473                                           ! 5098 endasm
35474                                           !BCC_ENDASM
35475                                           !BCC_EOS
35476                                           ! 5099       outb(addr+2, val8 | 0x04);
35477                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
35478 A027           8A46         FB            mov	al,-5[bp]
35479 A02A           0C                     04  or	al,*4
35480                                           ! Debug: list unsigned char = al+0 (used reg = )
35481 A02C           30E4                       xor	ah,ah
35482 A02E           50                         push	ax
35483                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35484 A02F           8B46         FE            mov	ax,-2[bp]
35485                                           ! Debug: list unsigned int = ax+2 (used reg = )
35486 A032           40                         inc	ax
35487 A033           40                         inc	ax
35488 A034           50                         push	ax
35489                                           ! Debug: func () void = outb+0 (used reg = )
35490 A035           E8         651C            call	_outb
35491 A038           83C4                   04  add	sp,*4
35492                                           !BCC_EOS
35493                                           ! 5100     }
35494                                           ! 5101     val8 = inb(addr+1);
35495                       0000A03B            .717:
35496                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
35497 A03B           8B46         FE            mov	ax,-2[bp]
35498                                           ! Debug: list unsigned int = ax+1 (used reg = )
35499 A03E           40                         inc	ax
35500 A03F           50                         push	ax
35501                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35502 A040           E8         64FB            call	_inb
35503 A043           44                         inc	sp
35504 A044           44                         inc	sp
35505                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35506 A045           8846         FB            mov	-5[bp],al
35507                                           !BCC_EOS
35508                                           ! 5102     regs.u.r8.ah = (val8 ^ 0x48);
35509                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
35510 A048           8A46         FB            mov	al,-5[bp]
35511 A04B           34                     48  xor	al,*$48
35512                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
35513 A04D           8846         13            mov	$13[bp],al
35514                                           !BCC_EOS
35515                                           ! 5103     if (!timeout) regs.u.r8.ah |= 0x01;
35516 A050           8B46         FC            mov	ax,-4[bp]
35517 A053           85C0                       test	ax,ax
35518 A055           75           08            jne 	.719
35519                       0000A057            .71A:
35520                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
35521 A057           8A46         13            mov	al,$13[bp]
35522 A05A           0C                     01  or	al,*1
35523 A05C           8846         13            mov	$13[bp],al
35524                                           !BCC_EOS
35525                                           ! 5104     iret_addr.flags.u.r8.flagsl &= 0xfe;
35526                       0000A05F            .719:
35527                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
35528 A05F           8A46         1A            mov	al,$1A[bp]
35529 A062           24                     FE  and	al,#$FE
35530 A064           8846         1A            mov	$1A[bp],al
35531                                           !BCC_EOS
35532                                           ! 5105   } else {
35533 A067           EB           08            jmp .71B
35534                       0000A069            .70C:
35535                                           ! 5106     iret_addr.flags.u.r8.flagsl |= 0x01;
35536                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
35537 A069           8A46         1A            mov	al,$1A[bp]
35538 A06C           0C                     01  or	al,*1
35539 A06E           8846         1A            mov	$1A[bp],al
35540                                           !BCC_EOS
35541                                           ! 5107   }
35542                                           ! 5108 }
35543                       0000A071            .71B:
35544 A071           89EC                       mov	sp,bp
35545 A073           5D                         pop	bp
35546 A074           C3                         ret
35547                                           ! 5109 void
35548                                           ! 5110 int18_function(seq_nr)
35549                                           ! 5111 Bit16u seq_nr;
35550                                           export	_int18_function
35551                       0000A075            _int18_function:
35552                                           !BCC_EOS
35553                                           ! 5112 {
35554                                           ! 5113   Bit16u ebda_seg=read_word(0x0040,0x000E);
35555 A075           55                         push	bp
35556 A076           89E5                       mov	bp,sp
35557 A078           4C                         dec	sp
35558 A079           4C                         dec	sp
35559                                           ! Debug: list int = const $E (used reg = )
35560 A07A           B8                   000E  mov	ax,*$E
35561 A07D           50                         push	ax
35562                                           ! Debug: list int = const $40 (used reg = )
35563 A07E           B8                   0040  mov	ax,*$40
35564 A081           50                         push	ax
35565                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35566 A082           E8         6582            call	_read_word
35567 A085           83C4                   04  add	sp,*4
35568                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
35569 A088           8946         FE            mov	-2[bp],ax
35570                                           !BCC_EOS
35571                                           ! 5114   Bit16u bootdev;
35572                                           !BCC_EOS
35573                                           ! 5115   Bit8u bootdrv;
35574                                           !BCC_EOS
35575                                           ! 5116   Bit8u bootchk;
35576                                           !BCC_EOS
35577                                           ! 5117   Bit16u bootseg;
35578                                           !BCC_EOS
35579                                           ! 5118   Bit16u bootip;
35580                                           !BCC_EOS
35581                                           ! 5119   Bit16u status;
35582                                           !BCC_EOS
35583                                           ! 5120   Bit16u bootfirst;
35584                                           !BCC_EOS
35585                                           ! 5121   ipl_entry_t e;
35586                                           !BCC_EOS
35587                                           ! 5122   bootdev = inb_cmos(0x3d);
35588 A08B           83C4                   E4  add	sp,*-$1C
35589                                           ! Debug: list int = const $3D (used reg = )
35590 A08E           B8                   003D  mov	ax,*$3D
35591 A091           50                         push	ax
35592                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35593 A092           E8         64EE            call	_inb_cmos
35594 A095           44                         inc	sp
35595 A096           44                         inc	sp
35596                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35597 A097           30E4                       xor	ah,ah
35598 A099           8946         FC            mov	-4[bp],ax
35599                                           !BCC_EOS
35600                                           ! 5123   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
35601                                           ! Debug: list int = const $38 (used reg = )
35602 A09C           B8                   0038  mov	ax,*$38
35603 A09F           50                         push	ax
35604                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35605 A0A0           E8         64E0            call	_inb_cmos
35606 A0A3           44                         inc	sp
35607 A0A4           44                         inc	sp
35608                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
35609 A0A5           24                     F0  and	al,#$F0
35610                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
35611 A0A7           30E4                       xor	ah,ah
35612 A0A9           B1                     04  mov	cl,*4
35613 A0AB           D3E0                       shl	ax,cl
35614                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35615 A0AD           0B46         FC            or	ax,-4[bp]
35616 A0B0           8946         FC            mov	-4[bp],ax
35617                                           !BCC_EOS
35618                                           ! 5124   bootdev >>= 4 * seq_nr;
35619                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
35620                                           ! Debug: expression subtree swapping
35621 A0B3           8B46         04            mov	ax,4[bp]
35622 A0B6           D1E0                       shl	ax,*1
35623 A0B8           D1E0                       shl	ax,*1
35624                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35625 A0BA           89C3                       mov	bx,ax
35626 A0BC           8B46         FC            mov	ax,-4[bp]
35627 A0BF           89D9                       mov	cx,bx
35628 A0C1           D3E8                       shr	ax,cl
35629 A0C3           8946         FC            mov	-4[bp],ax
35630                                           !BCC_EOS
35631                                           ! 5125   bootdev &= 0xf;
35632                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
35633 A0C6           8A46         FC            mov	al,-4[bp]
35634 A0C9           24                     0F  and	al,*$F
35635 A0CB           30E4                       xor	ah,ah
35636 A0CD           8946         FC            mov	-4[bp],ax
35637                                           !BCC_EOS
35638                                           ! 5126   bootfirst = read_word(ebda_seg, 0x0384);
35639                                           ! Debug: list int = const $384 (used reg = )
35640 A0D0           B8                   0384  mov	ax,#$384
35641 A0D3           50                         push	ax
35642                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
35643 A0D4           FF76         FE            push	-2[bp]
35644                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35645 A0D7           E8         652D            call	_read_word
35646 A0DA           83C4                   04  add	sp,*4
35647                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
35648 A0DD           8946         F2            mov	-$E[bp],ax
35649                                           !BCC_EOS
35650                                           ! 5127   if (bootfirst != 0xFFFF) {
35651                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
35652 A0E0           8B46         F2            mov	ax,-$E[bp]
35653 A0E3           3D                   FFFF  cmp	ax,#$FFFF
35654 A0E6           74           2A            je  	.71C
35655                       0000A0E8            .71D:
35656                                           ! 5128     bootdev = bootfirst;
35657                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
35658 A0E8           8B46         F2            mov	ax,-$E[bp]
35659 A0EB           8946         FC            mov	-4[bp],ax
35660                                           !BCC_EOS
35661                                           ! 5129     write_word(ebda_seg, 0x0384, 0xFFFF);
35662                                           ! Debug: list unsigned int = const $FFFF (used reg = )
35663 A0EE           B8                   FFFF  mov	ax,#$FFFF
35664 A0F1           50                         push	ax
35665                                           ! Debug: list int = const $384 (used reg = )
35666 A0F2           B8                   0384  mov	ax,#$384
35667 A0F5           50                         push	ax
35668                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
35669 A0F6           FF76         FE            push	-2[bp]
35670                                           ! Debug: func () void = write_word+0 (used reg = )
35671 A0F9           E8         6536            call	_write_word
35672 A0FC           83C4                   06  add	sp,*6
35673                                           !BCC_EOS
35674                                           ! 5130     write_word(ebda_seg, 0x0382, 0xFFFF);
35675                                           ! Debug: list unsigned int = const $FFFF (used reg = )
35676 A0FF           B8                   FFFF  mov	ax,#$FFFF
35677 A102           50                         push	ax
35678                                           ! Debug: list int = const $382 (used reg = )
35679 A103           B8                   0382  mov	ax,#$382
35680 A106           50                         push	ax
35681                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
35682 A107           FF76         FE            push	-2[bp]
35683                                           ! Debug: func () void = write_word+0 (used reg = )
35684 A10A           E8         6525            call	_write_word
35685 A10D           83C4                   06  add	sp,*6
35686                                           !BCC_EOS
35687                                           ! 5131   }
35688                                           ! 5131  else if (bootdev == 0) {
35689 A110           EB           3C            jmp .71E
35690                       0000A112            .71C:
35691                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
35692 A112           8B46         FC            mov	ax,-4[bp]
35693 A115           85C0                       test	ax,ax
35694 A117           75           35            jne 	.71F
35695                       0000A119            .720:
35696                                           ! 5132     bios_printf(2, "\nNo bootable device.\n");
35697                                           ! Debug: list * char = .721+0 (used reg = )
35698 A119           BB                   D00E  mov	bx,#.721
35699 A11C           53                         push	bx
35700                                           ! Debug: list int = const 2 (used reg = )
35701 A11D           B8                   0002  mov	ax,*2
35702 A120           50                         push	ax
35703                                           ! Debug: func () void = bios_printf+0 (used reg = )
35704 A121           E8         68F7            call	_bios_printf
35705 A124           83C4                   04  add	sp,*4
35706                                           !BCC_EOS
35707                                           ! 5133     bios_printf(2, "Powering off in 30 seconds.\n");
35708                                           ! Debug: list * char = .722+0 (used reg = )
35709 A127           BB                   CFF1  mov	bx,#.722
35710 A12A           53                         push	bx
35711                                           ! Debug: list int = const 2 (used reg = )
35712 A12B           B8                   0002  mov	ax,*2
35713 A12E           50                         push	ax
35714                                           ! Debug: func () void = bios_printf+0 (used reg = )
35715 A12F           E8         68E9            call	_bios_printf
35716 A132           83C4                   04  add	sp,*4
35717                                           !BCC_EOS
35718                                           ! 5134 #asm
35719                                           !BCC_EOS
35720                                           !BCC_ASM
35721                       00000014            _int18_function.bootip	set	$14
35722                       FFFFFFF6            .int18_function.bootip	set	-$A
35723                       00000022            _int18_function.seq_nr	set	$22
35724                       00000004            .int18_function.seq_nr	set	4
35725                       00000018            _int18_function.bootchk	set	$18
35726                       FFFFFFFA            .int18_function.bootchk	set	-6
35727                       00000016            _int18_function.bootseg	set	$16
35728                       FFFFFFF8            .int18_function.bootseg	set	-8
35729                       0000001C            _int18_function.ebda_seg	set	$1C
35730                       FFFFFFFE            .int18_function.ebda_seg	set	-2
35731                       00000012            _int18_function.status	set	$12
35732                       FFFFFFF4            .int18_function.status	set	-$C
35733                       00000010            _int18_function.bootfirst	set	$10
35734                       FFFFFFF2            .int18_function.bootfirst	set	-$E
35735                       00000019            _int18_function.bootdrv	set	$19
35736                       FFFFFFFB            .int18_function.bootdrv	set	-5
35737                       0000001A            _int18_function.bootdev	set	$1A
35738                       FFFFFFFC            .int18_function.bootdev	set	-4
35739                       00000000            _int18_function.e	set	0
35740                       FFFFFFE2            .int18_function.e	set	-$1E
35741 A135           FB                             sti
35742 A136           B9                   01C9      mov cx, #0x01c9
35743 A139           BA                   C380      mov dx, #0xc380
35744 A13C           B4                     86      mov ah, #0x86 ;; INT 15/86: wait CX:DX usec.
35745 A13E           CD                     15      int #0x15
35746                                           ! 5140 endasm
35747                                           !BCC_ENDASM
35748                                           !BCC_EOS
35749                                           ! 5141     bios_printf(1, "");
35750                                           ! Debug: list * char = .723+0 (used reg = )
35751 A140           BB                   CFF0  mov	bx,#.723
35752 A143           53                         push	bx
35753                                           ! Debug: list int = const 1 (used reg = )
35754 A144           B8                   0001  mov	ax,*1
35755 A147           50                         push	ax
35756                                           ! Debug: func () void = bios_printf+0 (used reg = )
35757 A148           E8         68D0            call	_bios_printf
35758 A14B           83C4                   04  add	sp,*4
35759                                           !BCC_EOS
35760                                           ! 5142   }
35761                                           ! 5143   bootdev -= 1;
35762                       0000A14E            .71F:
35763                       0000A14E            .71E:
35764                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
35765 A14E           8B46         FC            mov	ax,-4[bp]
35766 A151           48                         dec	ax
35767 A152           8946         FC            mov	-4[bp],ax
35768                                           !BCC_EOS
35769                                           ! 5144   if (get_boot_vector(bootdev, &e) == 0) {
35770                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
35771 A155           8D5E         E2            lea	bx,-$1E[bp]
35772 A158           53                         push	bx
35773                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
35774 A159           FF76         FC            push	-4[bp]
35775                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
35776 A15C           E8         73A4            call	_get_boot_vector
35777 A15F           83C4                   04  add	sp,*4
35778                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
35779 A162           84C0                       test	al,al
35780 A164           75           04            jne 	.724
35781                       0000A166            .725:
35782                                           ! 5145     ;
35783                                           !BCC_EOS
35784                                           ! 5146     return;
35785 A166           89EC                       mov	sp,bp
35786 A168           5D                         pop	bp
35787 A169           C3                         ret
35788                                           !BCC_EOS
35789                                           ! 5147   }
35790                                           ! 5148   print_boot_device(e.type, e.description);
35791                       0000A16A            .724:
35792                                           ! Debug: list unsigned long e = [S+$20-$18] (used reg = )
35793 A16A           FF76         EC            push	-$14[bp]
35794 A16D           FF76         EA            push	-$16[bp]
35795                                           ! Debug: list unsigned short e = [S+$24-$20] (used reg = )
35796 A170           FF76         E2            push	-$1E[bp]
35797                                           ! Debug: func () void = print_boot_device+0 (used reg = )
35798 A173           E8         75E6            call	_print_boot_device
35799 A176           83C4                   06  add	sp,*6
35800                                           !BCC_EOS
35801                                           ! 5149   switch(e.type) {
35802 A179           8B46         E2            mov	ax,-$1E[bp]
35803 A17C           E9         012A            br 	.728
35804                                           ! 5150   case 0x01:
35805                                           ! 5151   case 0x02:
35806                       0000A17F            .729:
35807                                           ! 5152     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
35808                       0000A17F            .72A:
35809                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
35810 A17F           8B46         E2            mov	ax,-$1E[bp]
35811 A182           3D                   0002  cmp	ax,*2
35812 A185           75           04            jne 	.72B
35813                       0000A187            .72C:
35814 A187           B0                     80  mov	al,#$80
35815 A189           EB           02            jmp .72D
35816                       0000A18B            .72B:
35817 A18B           30C0                       xor	al,al
35818                       0000A18D            .72D:
35819                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
35820 A18D           8846         FB            mov	-5[bp],al
35821                                           !BCC_EOS
35822                                           ! 5153     bootseg = 0x07c0;
35823                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
35824 A190           B8                   07C0  mov	ax,#$7C0
35825 A193           8946         F8            mov	-8[bp],ax
35826                                           !BCC_EOS
35827                                           ! 5154     status = 0;
35828                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
35829 A196           31C0                       xor	ax,ax
35830 A198           8946         F4            mov	-$C[bp],ax
35831                                           !BCC_EOS
35832                                           ! 5155 #asm
35833                                           !BCC_EOS
35834                                           !BCC_ASM
35835                       00000014            _int18_function.bootip	set	$14
35836                       FFFFFFF6            .int18_function.bootip	set	-$A
35837                       00000022            _int18_function.seq_nr	set	$22
35838                       00000004            .int18_function.seq_nr	set	4
35839                       00000018            _int18_function.bootchk	set	$18
35840                       FFFFFFFA            .int18_function.bootchk	set	-6
35841                       00000016            _int18_function.bootseg	set	$16
35842                       FFFFFFF8            .int18_function.bootseg	set	-8
35843                       0000001C            _int18_function.ebda_seg	set	$1C
35844                       FFFFFFFE            .int18_function.ebda_seg	set	-2
35845                       00000012            _int18_function.status	set	$12
35846                       FFFFFFF4            .int18_function.status	set	-$C
35847                       00000010            _int18_function.bootfirst	set	$10
35848                       FFFFFFF2            .int18_function.bootfirst	set	-$E
35849                       00000019            _int18_function.bootdrv	set	$19
35850                       FFFFFFFB            .int18_function.bootdrv	set	-5
35851                       0000001A            _int18_function.bootdev	set	$1A
35852                       FFFFFFFC            .int18_function.bootdev	set	-4
35853                       00000000            _int18_function.e	set	0
35854                       FFFFFFE2            .int18_function.e	set	-$1E
35855 A19B           55                             push bp
35856 A19C           89E5                           mov bp, sp
35857 A19E           50                             push ax
35858 A19F           53                             push bx
35859 A1A0           51                             push cx
35860 A1A1           52                             push dx
35861 A1A2           8A56         1B                mov dl, _int18_function.bootdrv + 2[bp]
35862 A1A5           8B46         18                mov ax, _int18_function.bootseg + 2[bp]
35863 A1A8           8EC0                           mov es, ax ;; segment
35864 A1AA           31DB                           xor bx, bx ;; offset
35865 A1AC           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
35866 A1AE           B0                     01      mov al, #0x01 ;; read 1 sector
35867 A1B0           B5                     00      mov ch, #0x00 ;; track 0
35868 A1B2           B1                     01      mov cl, #0x01 ;; sector 1
35869 A1B4           B6                     00      mov dh, #0x00 ;; head 0
35870 A1B6           CD                     13      int #0x13 ;; read sector
35871 A1B8           73           06                jnc int19_load_done
35872 A1BA           B8                   0001      mov ax, #0x0001
35873 A1BD           8946         14                mov _int18_function.status + 2[bp], ax
35874                       0000A1C0            int19_load_done:
35875 A1C0           5A                             pop dx
35876 A1C1           59                             pop cx
35877 A1C2           5B                             pop bx
35878 A1C3           58                             pop ax
35879 A1C4           5D                             pop bp
35880                                           ! 5181 endasm
35881                                           !BCC_ENDASM
35882                                           !BCC_EOS
35883                                           ! 5182     if (status != 0) {
35884                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
35885 A1C5           8B46         F4            mov	ax,-$C[bp]
35886 A1C8           85C0                       test	ax,ax
35887 A1CA           74           11            je  	.72E
35888                       0000A1CC            .72F:
35889                                           ! 5183       print_boot_failure(e.type, 1);
35890                                           ! Debug: list int = const 1 (used reg = )
35891 A1CC           B8                   0001  mov	ax,*1
35892 A1CF           50                         push	ax
35893                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
35894 A1D0           FF76         E2            push	-$1E[bp]
35895                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
35896 A1D3           E8         764F            call	_print_boot_failure
35897 A1D6           83C4                   04  add	sp,*4
35898                                           !BCC_EOS
35899                                           ! 5184       return;
35900 A1D9           89EC                       mov	sp,bp
35901 A1DB           5D                         pop	bp
35902 A1DC           C3                         ret
35903                                           !BCC_EOS
35904                                           ! 5185     }
35905                                           ! 5186     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
35906                       0000A1DD            .72E:
35907                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
35908 A1DD           8B46         E2            mov	ax,-$1E[bp]
35909 A1E0           3D                   0001  cmp	ax,*1
35910 A1E3           75           0F            jne 	.731
35911                       0000A1E5            .732:
35912                                           ! Debug: list int = const $38 (used reg = )
35913 A1E5           B8                   0038  mov	ax,*$38
35914 A1E8           50                         push	ax
35915                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35916 A1E9           E8         6397            call	_inb_cmos
35917 A1EC           44                         inc	sp
35918 A1ED           44                         inc	sp
35919                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
35920 A1EE           24                     01  and	al,*1
35921 A1F0           84C0                       test	al,al
35922 A1F2           75           22            jne 	.730
35923                       0000A1F4            .731:
35924                                           ! 5187       if (read_word(bootseg,0x1fe) != 0xaa55) {
35925                                           ! Debug: list int = const $1FE (used reg = )
35926 A1F4           B8                   01FE  mov	ax,#$1FE
35927 A1F7           50                         push	ax
35928                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
35929 A1F8           FF76         F8            push	-8[bp]
35930                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35931 A1FB           E8         6409            call	_read_word
35932 A1FE           83C4                   04  add	sp,*4
35933                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
35934 A201           3D                   AA55  cmp	ax,#$AA55
35935 A204           74           10            je  	.733
35936                       0000A206            .734:
35937                                           ! 5188         print_boot_failure(e.type, 0);
35938                                           ! Debug: list int = const 0 (used reg = )
35939 A206           31C0                       xor	ax,ax
35940 A208           50                         push	ax
35941                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
35942 A209           FF76         E2            push	-$1E[bp]
35943                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
35944 A20C           E8         7616            call	_print_boot_failure
35945 A20F           83C4                   04  add	sp,*4
35946                                           !BCC_EOS
35947                                           ! 5189         return;
35948 A212           89EC                       mov	sp,bp
35949 A214           5D                         pop	bp
35950 A215           C3                         ret
35951                                           !BCC_EOS
35952                                           ! 5190       }
35953                                           ! 5191     }
35954                       0000A216            .733:
35955                                           ! 5192     bootip = (bootseg & 0x0fff) << 4;
35956                       0000A216            .730:
35957                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
35958 A216           8B46         F8            mov	ax,-8[bp]
35959 A219           25                   0FFF  and	ax,#$FFF
35960                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
35961 A21C           B1                     04  mov	cl,*4
35962 A21E           D3E0                       shl	ax,cl
35963                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
35964 A220           8946         F6            mov	-$A[bp],ax
35965                                           !BCC_EOS
35966                                           ! 5193     bootseg &= 0xf000;
35967                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
35968 A223           8B46         F8            mov	ax,-8[bp]
35969 A226           25                   F000  and	ax,#$F000
35970 A229           8946         F8            mov	-8[bp],ax
35971                                           !BCC_EOS
35972                                           ! 5194   break;
35973 A22C           E9         0096            br 	.726
35974                                           !BCC_EOS
35975                                           ! 5195   case 0x03:
35976                                           ! 5196     status = cdrom_boot();
35977                       0000A22F            .735:
35978                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
35979 A22F           E8         9CB9            call	_cdrom_boot
35980                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
35981 A232           8946         F4            mov	-$C[bp],ax
35982                                           !BCC_EOS
35983                                           ! 5197     if ( (status & 0x00ff) !=0 ) {
35984                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
35985 A235           8A46         F4            mov	al,-$C[bp]
35986                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35987 A238           84C0                       test	al,al
35988 A23A           74           19            je  	.736
35989                       0000A23C            .737:
35990                                           ! 5198       print_cdromboot_failure(status);
35991                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
35992 A23C           FF76         F4            push	-$C[bp]
35993                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
35994 A23F           E8         765B            call	_print_cdromboot_failure
35995 A242           44                         inc	sp
35996 A243           44                         inc	sp
35997                                           !BCC_EOS
35998                                           ! 5199       print_boot_failure(e.type, 1);
35999                                           ! Debug: list int = const 1 (used reg = )
36000 A244           B8                   0001  mov	ax,*1
36001 A247           50                         push	ax
36002                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36003 A248           FF76         E2            push	-$1E[bp]
36004                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36005 A24B           E8         75D7            call	_print_boot_failure
36006 A24E           83C4                   04  add	sp,*4
36007                                           !BCC_EOS
36008                                           ! 5200       return;
36009 A251           89EC                       mov	sp,bp
36010 A253           5D                         pop	bp
36011 A254           C3                         ret
36012                                           !BCC_EOS
36013                                           ! 5201     }
36014                                           ! 5202     bootdrv = (Bit8u)(status>>8);
36015                       0000A255            .736:
36016                                           ! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
36017 A255           8B46         F4            mov	ax,-$C[bp]
36018 A258           88E0                       mov	al,ah
36019 A25A           30E4                       xor	ah,ah
36020                                           ! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
36021                                           ! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36022 A25C           8846         FB            mov	-5[bp],al
36023                                           !BCC_EOS
36024                                           ! 5203     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
36025                                           ! Debug: list * unsigned short = const $266 (used reg = )
36026 A25F           B8                   0266  mov	ax,#$266
36027 A262           50                         push	ax
36028                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
36029 A263           FF76         FE            push	-2[bp]
36030                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36031 A266           E8         639E            call	_read_word
36032 A269           83C4                   04  add	sp,*4
36033                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36034 A26C           8946         F8            mov	-8[bp],ax
36035                                           !BCC_EOS
36036                                           ! 5204     bootip = (bootseg & 0x0fff) << 4;
36037                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
36038 A26F           8B46         F8            mov	ax,-8[bp]
36039 A272           25                   0FFF  and	ax,#$FFF
36040                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
36041 A275           B1                     04  mov	cl,*4
36042 A277           D3E0                       shl	ax,cl
36043                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36044 A279           8946         F6            mov	-$A[bp],ax
36045                                           !BCC_EOS
36046                                           ! 5205     bootseg &= 0xf000;
36047                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
36048 A27C           8B46         F8            mov	ax,-8[bp]
36049 A27F           25                   F000  and	ax,#$F000
36050 A282           8946         F8            mov	-8[bp],ax
36051                                           !BCC_EOS
36052                                           ! 5206     break;
36053 A285           EB           3E            jmp .726
36054                                           !BCC_EOS
36055                                           ! 5207   case 0x80:
36056                                           ! 5208     bootseg = e.vector >> 16;
36057                       0000A287            .738:
36058                                           ! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
36059 A287           8B46         E6            mov	ax,-$1A[bp]
36060 A28A           8B5E         E8            mov	bx,-$18[bp]
36061 A28D           93                         xchg	bx,ax
36062 A28E           31DB                       xor	bx,bx
36063                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36064 A290           8946         F8            mov	-8[bp],ax
36065                                           !BCC_EOS
36066                                           ! 5209     bootip = e.vector & 0xffff;
36067                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
36068                                           ! Debug: expression subtree swapping
36069 A293           B8                   FFFF  mov	ax,#$FFFF
36070 A296           31DB                       xor	bx,bx
36071 A298           8D7E         E6            lea	di,-$1A[bp]
36072 A29B           E8         5E1D            call	landul
36073                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36074 A29E           8946         F6            mov	-$A[bp],ax
36075                                           !BCC_EOS
36076                                           ! 5210     break;
36077 A2A1           EB           22            jmp .726
36078                                           !BCC_EOS
36079                                           ! 5211   default: return;
36080                       0000A2A3            .739:
36081 A2A3           89EC                       mov	sp,bp
36082 A2A5           5D                         pop	bp
36083 A2A6           C3                         ret
36084                                           !BCC_EOS
36085                                           ! 5212   }
36086                                           ! 5213   ;
36087 A2A7           EB           1C            jmp .726
36088                       0000A2A9            .728:
36089 A2A9           2D                   0001  sub	ax,*1
36090 A2AC         0F84         FECF            beq 	.729
36091 A2B0           2D                   0001  sub	ax,*1
36092 A2B3         0F84         FEC8            beq 	.72A
36093 A2B7           2D                   0001  sub	ax,*1
36094 A2BA         0F84         FF71            beq 	.735
36095 A2BE           2D                   007D  sub	ax,*$7D
36096 A2C1           74           C4            je 	.738
36097 A2C3           EB           DE            jmp	.739
36098                       0000A2C5            .726:
36099                       FFFFFFE0            ..FFDB	=	-$20
36100                                           !BCC_EOS
36101                                           ! 5214 #asm
36102                                           !BCC_EOS
36103                                           !BCC_ASM
36104                       00000014            _int18_function.bootip	set	$14
36105                       FFFFFFF6            .int18_function.bootip	set	-$A
36106                       00000022            _int18_function.seq_nr	set	$22
36107                       00000004            .int18_function.seq_nr	set	4
36108                       00000018            _int18_function.bootchk	set	$18
36109                       FFFFFFFA            .int18_function.bootchk	set	-6
36110                       00000016            _int18_function.bootseg	set	$16
36111                       FFFFFFF8            .int18_function.bootseg	set	-8
36112                       0000001C            _int18_function.ebda_seg	set	$1C
36113                       FFFFFFFE            .int18_function.ebda_seg	set	-2
36114                       00000012            _int18_function.status	set	$12
36115                       FFFFFFF4            .int18_function.status	set	-$C
36116                       00000010            _int18_function.bootfirst	set	$10
36117                       FFFFFFF2            .int18_function.bootfirst	set	-$E
36118                       00000019            _int18_function.bootdrv	set	$19
36119                       FFFFFFFB            .int18_function.bootdrv	set	-5
36120                       0000001A            _int18_function.bootdev	set	$1A
36121                       FFFFFFFC            .int18_function.bootdev	set	-4
36122                       00000000            _int18_function.e	set	0
36123                       FFFFFFE2            .int18_function.e	set	-$1E
36124 A2C5           89E5                           mov bp, sp
36125 A2C7           0E                             push cs
36126 A2C8           68                   A819      push #int18_handler
36127                                               ;; Build an iret stack frame that will take us to the boot vector.
36128                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
36129 A2CB           9C                             pushf
36130 A2CC           8B46         16                mov ax, _int18_function.bootseg + 0[bp]
36131 A2CF           50                             push ax
36132 A2D0           8B46         14                mov ax, _int18_function.bootip + 0[bp]
36133 A2D3           50                             push ax
36134                                               ;; Set the magic number in ax and the boot drive in dl.
36135 A2D4           B8                   AA55      mov ax, #0xaa55
36136 A2D7           8A56         19                mov dl, _int18_function.bootdrv + 0[bp]
36137                                               ;; Zero some of the other registers.
36138 A2DA           31DB                           xor bx, bx
36139 A2DC           8EDB                           mov ds, bx
36140 A2DE           8EC3                           mov es, bx
36141 A2E0           89DD                           mov bp, bx
36142                                               ;; Go!
36143 A2E2           CF                             iret
36144                                           ! 5235 endasm
36145                                           !BCC_ENDASM
36146                                           !BCC_EOS
36147                                           ! 5236 }
36148 A2E3           89EC                       mov	sp,bp
36149 A2E5           5D                         pop	bp
36150 A2E6           C3                         ret
36151                                           ! 5237   void
36152                                           ! Register BX used in function int18_function
36153                                           ! 5238 int1a_function(regs, ds, iret_addr)
36154                                           ! 5239   pusha_regs_t regs;
36155                                           export	_int1a_function
36156                       0000A2E7            _int1a_function:
36157                                           !BCC_EOS
36158                                           ! 5240   Bit16u ds;
36159                                           !BCC_EOS
36160                                           ! 5241   iret_addr_t iret_addr;
36161                                           !BCC_EOS
36162                                           ! 5242 {
36163                                           ! 5243   Bit8u val8;
36164                                           !BCC_EOS
36165                                           ! 5244   ;
36166 A2E7           55                         push	bp
36167 A2E8           89E5                       mov	bp,sp
36168 A2EA           4C                         dec	sp
36169 A2EB           4C                         dec	sp
36170                                           !BCC_EOS
36171                                           ! 5245 #asm
36172                                           !BCC_EOS
36173                                           !BCC_ASM
36174                       00000016            _int1a_function.ds	set	$16
36175                       00000014            .int1a_function.ds	set	$14
36176                       00000001            _int1a_function.val8	set	1
36177                       FFFFFFFF            .int1a_function.val8	set	-1
36178                       00000018            _int1a_function.iret_addr	set	$18
36179                       00000016            .int1a_function.iret_addr	set	$16
36180                       00000006            _int1a_function.regs	set	6
36181                       00000004            .int1a_function.regs	set	4
36182 A2EC           FB                           sti
36183                                           ! 5247 endasm
36184                                           !BCC_ENDASM
36185                                           !BCC_EOS
36186                                           ! 5248   switch (regs.u.r8.ah) {
36187 A2ED           8A46         13            mov	al,$13[bp]
36188 A2F0           E9         0309            br 	.73C
36189                                           ! 5249     case 0:
36190                                           ! 5250 #asm
36191                       0000A2F3            .73D:
36192                                           !BCC_EOS
36193                                           !BCC_ASM
36194                       00000016            _int1a_function.ds	set	$16
36195                       00000014            .int1a_function.ds	set	$14
36196                       00000001            _int1a_function.val8	set	1
36197                       FFFFFFFF            .int1a_function.val8	set	-1
36198                       00000018            _int1a_function.iret_addr	set	$18
36199                       00000016            .int1a_function.iret_addr	set	$16
36200                       00000006            _int1a_function.regs	set	6
36201                       00000004            .int1a_function.regs	set	4
36202 A2F3           FA                               cli
36203                                           ! 5252 endasm
36204                                           !BCC_ENDASM
36205                                           !BCC_EOS
36206                                           ! 5253       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
36207                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
36208 A2F4           A1         046E            mov	ax,[$46E]
36209 A2F7           8946         10            mov	$10[bp],ax
36210                                           !BCC_EOS
36211                                           ! 5254       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
36212                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
36213 A2FA           A1         046C            mov	ax,[$46C]
36214 A2FD           8946         0E            mov	$E[bp],ax
36215                                           !BCC_EOS
36216                                           ! 5255       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
36217                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
36218 A300           A0         0470            mov	al,[$470]
36219 A303           8846         12            mov	$12[bp],al
36220                                           !BCC_EOS
36221                                           ! 5256       ((bios_data_t *) 0)->midnight_flag = 0;
36222                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
36223 A306           30C0                       xor	al,al
36224 A308           A2         0470            mov	[$470],al
36225                                           !BCC_EOS
36226                                           ! 5257 #asm
36227                                           !BCC_EOS
36228                                           !BCC_ASM
36229                       00000016            _int1a_function.ds	set	$16
36230                       00000014            .int1a_function.ds	set	$14
36231                       00000001            _int1a_function.val8	set	1
36232                       FFFFFFFF            .int1a_function.val8	set	-1
36233                       00000018            _int1a_function.iret_addr	set	$18
36234                       00000016            .int1a_function.iret_addr	set	$16
36235                       00000006            _int1a_function.regs	set	6
36236                       00000004            .int1a_function.regs	set	4
36237 A30B           FB                               sti
36238                                           ! 5259 endasm
36239                                           !BCC_ENDASM
36240                                           !BCC_EOS
36241                                           ! 5260       iret_addr.flags.u.r8.flagsl &= 0xfe;
36242                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36243 A30C           8A46         1A            mov	al,$1A[bp]
36244 A30F           24                     FE  and	al,#$FE
36245 A311           8846         1A            mov	$1A[bp],al
36246                                           !BCC_EOS
36247                                           ! 5261       break;
36248 A314           E9         030E            br 	.73A
36249                                           !BCC_EOS
36250                                           ! 5262     case 1:
36251                                           ! 5263 #asm
36252                       0000A317            .73E:
36253                                           !BCC_EOS
36254                                           !BCC_ASM
36255                       00000016            _int1a_function.ds	set	$16
36256                       00000014            .int1a_function.ds	set	$14
36257                       00000001            _int1a_function.val8	set	1
36258                       FFFFFFFF            .int1a_function.val8	set	-1
36259                       00000018            _int1a_function.iret_addr	set	$18
36260                       00000016            .int1a_function.iret_addr	set	$16
36261                       00000006            _int1a_function.regs	set	6
36262                       00000004            .int1a_function.regs	set	4
36263 A317           FA                               cli
36264                                           ! 5265 endasm
36265                                           !BCC_ENDASM
36266                                           !BCC_EOS
36267                                           ! 5266       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
36268                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
36269 A318           8B46         10            mov	ax,$10[bp]
36270 A31B           A3         046E            mov	[$46E],ax
36271                                           !BCC_EOS
36272                                           ! 5267       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
36273                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
36274 A31E           8B46         0E            mov	ax,$E[bp]
36275 A321           A3         046C            mov	[$46C],ax
36276                                           !BCC_EOS
36277                                           ! 5268       ((bios_data_t *) 0)->midnight_flag = 0;
36278                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
36279 A324           30C0                       xor	al,al
36280 A326           A2         0470            mov	[$470],al
36281                                           !BCC_EOS
36282                                           ! 5269 #asm
36283                                           !BCC_EOS
36284                                           !BCC_ASM
36285                       00000016            _int1a_function.ds	set	$16
36286                       00000014            .int1a_function.ds	set	$14
36287                       00000001            _int1a_function.val8	set	1
36288                       FFFFFFFF            .int1a_function.val8	set	-1
36289                       00000018            _int1a_function.iret_addr	set	$18
36290                       00000016            .int1a_function.iret_addr	set	$16
36291                       00000006            _int1a_function.regs	set	6
36292                       00000004            .int1a_function.regs	set	4
36293 A329           FB                               sti
36294                                           ! 5271 endasm
36295                                           !BCC_ENDASM
36296                                           !BCC_EOS
36297                                           ! 5272       regs.u.r8.ah = 0;
36298                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36299 A32A           30C0                       xor	al,al
36300 A32C           8846         13            mov	$13[bp],al
36301                                           !BCC_EOS
36302                                           ! 5273       iret_addr.flags.u.r8.flagsl &= 0xfe;
36303                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36304 A32F           8A46         1A            mov	al,$1A[bp]
36305 A332           24                     FE  and	al,#$FE
36306 A334           8846         1A            mov	$1A[bp],al
36307                                           !BCC_EOS
36308                                           ! 5274       break;
36309 A337           E9         02EB            br 	.73A
36310                                           !BCC_EOS
36311                                           ! 5275     case 2:
36312                                           ! 5276       if (rtc_updating()) {
36313                       0000A33A            .73F:
36314                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36315 A33A           E8         6283            call	_rtc_updating
36316 A33D           85C0                       test	ax,ax
36317 A33F           74           0B            je  	.740
36318                       0000A341            .741:
36319                                           ! 5277         iret_addr.flags.u.r8.flagsl |= 0x01;
36320                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36321 A341           8A46         1A            mov	al,$1A[bp]
36322 A344           0C                     01  or	al,*1
36323 A346           8846         1A            mov	$1A[bp],al
36324                                           !BCC_EOS
36325                                           ! 5278         break;
36326 A349           E9         02D9            br 	.73A
36327                                           !BCC_EOS
36328                                           ! 5279         }
36329                                           ! 5280       regs.u.r8.dh = inb_cmos(0x00);
36330                       0000A34C            .740:
36331                                           ! Debug: list int = const 0 (used reg = )
36332 A34C           31C0                       xor	ax,ax
36333 A34E           50                         push	ax
36334                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36335 A34F           E8         6231            call	_inb_cmos
36336 A352           44                         inc	sp
36337 A353           44                         inc	sp
36338                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
36339 A354           8846         0F            mov	$F[bp],al
36340                                           !BCC_EOS
36341                                           ! 5281       regs.u.r8.cl = inb_cmos(0x02);
36342                                           ! Debug: list int = const 2 (used reg = )
36343 A357           B8                   0002  mov	ax,*2
36344 A35A           50                         push	ax
36345                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36346 A35B           E8         6225            call	_inb_cmos
36347 A35E           44                         inc	sp
36348 A35F           44                         inc	sp
36349                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
36350 A360           8846         10            mov	$10[bp],al
36351                                           !BCC_EOS
36352                                           ! 5282       regs.u.r8.ch = inb_cmos(0x04);
36353                                           ! Debug: list int = const 4 (used reg = )
36354 A363           B8                   0004  mov	ax,*4
36355 A366           50                         push	ax
36356                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36357 A367           E8         6219            call	_inb_cmos
36358 A36A           44                         inc	sp
36359 A36B           44                         inc	sp
36360                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
36361 A36C           8846         11            mov	$11[bp],al
36362                                           !BCC_EOS
36363                                           ! 5283       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
36364                                           ! Debug: list int = const $B (used reg = )
36365 A36F           B8                   000B  mov	ax,*$B
36366 A372           50                         push	ax
36367                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36368 A373           E8         620D            call	_inb_cmos
36369 A376           44                         inc	sp
36370 A377           44                         inc	sp
36371                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
36372 A378           24                     01  and	al,*1
36373                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
36374 A37A           8846         0E            mov	$E[bp],al
36375                                           !BCC_EOS
36376                                           ! 5284       regs.u.r8.ah = 0;
36377                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36378 A37D           30C0                       xor	al,al
36379 A37F           8846         13            mov	$13[bp],al
36380                                           !BCC_EOS
36381                                           ! 5285       regs.u.r8.al = regs.u.r8.ch;
36382                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
36383 A382           8A46         11            mov	al,$11[bp]
36384 A385           8846         12            mov	$12[bp],al
36385                                           !BCC_EOS
36386                                           ! 5286       iret_addr.flags.u.r8.flagsl &= 0xfe;
36387                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36388 A388           8A46         1A            mov	al,$1A[bp]
36389 A38B           24                     FE  and	al,#$FE
36390 A38D           8846         1A            mov	$1A[bp],al
36391                                           !BCC_EOS
36392                                           ! 5287       break;
36393 A390           E9         0292            br 	.73A
36394                                           !BCC_EOS
36395                                           ! 5288     case 3:
36396                                           ! 5289       if (rtc_updating()) {
36397                       0000A393            .742:
36398                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36399 A393           E8         622A            call	_rtc_updating
36400 A396           85C0                       test	ax,ax
36401 A398           74           03            je  	.743
36402                       0000A39A            .744:
36403                                           ! 5290         init_rtc();
36404                                           ! Debug: func () void = init_rtc+0 (used reg = )
36405 A39A           E8         61F2            call	_init_rtc
36406                                           !BCC_EOS
36407                                           ! 5291         }
36408                                           ! 5292       outb_cmos(0x00, regs.u.r8.dh);
36409                       0000A39D            .743:
36410                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36411 A39D           8A46         0F            mov	al,$F[bp]
36412 A3A0           30E4                       xor	ah,ah
36413 A3A2           50                         push	ax
36414                                           ! Debug: list int = const 0 (used reg = )
36415 A3A3           31C0                       xor	ax,ax
36416 A3A5           50                         push	ax
36417                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36418 A3A6           E8         61CB            call	_outb_cmos
36419 A3A9           83C4                   04  add	sp,*4
36420                                           !BCC_EOS
36421                                           ! 5293       outb_cmos(0x02, regs.u.r8.cl);
36422                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36423 A3AC           8A46         10            mov	al,$10[bp]
36424 A3AF           30E4                       xor	ah,ah
36425 A3B1           50                         push	ax
36426                                           ! Debug: list int = const 2 (used reg = )
36427 A3B2           B8                   0002  mov	ax,*2
36428 A3B5           50                         push	ax
36429                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36430 A3B6           E8         61BB            call	_outb_cmos
36431 A3B9           83C4                   04  add	sp,*4
36432                                           !BCC_EOS
36433                                           ! 5294       outb_cmos(0x04, regs.u.r8.ch);
36434                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36435 A3BC           8A46         11            mov	al,$11[bp]
36436 A3BF           30E4                       xor	ah,ah
36437 A3C1           50                         push	ax
36438                                           ! Debug: list int = const 4 (used reg = )
36439 A3C2           B8                   0004  mov	ax,*4
36440 A3C5           50                         push	ax
36441                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36442 A3C6           E8         61AB            call	_outb_cmos
36443 A3C9           83C4                   04  add	sp,*4
36444                                           !BCC_EOS
36445                                           ! 5295       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
36446                                           ! Debug: expression subtree swapping
36447                                           ! Debug: list int = const $B (used reg = )
36448 A3CC           B8                   000B  mov	ax,*$B
36449 A3CF           50                         push	ax
36450                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36451 A3D0           E8         61B0            call	_inb_cmos
36452 A3D3           44                         inc	sp
36453 A3D4           44                         inc	sp
36454                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
36455 A3D5           24                     60  and	al,*$60
36456                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
36457 A3D7           0C                     02  or	al,*2
36458 A3D9           50                         push	ax
36459                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
36460 A3DA           8A46         0E            mov	al,$E[bp]
36461 A3DD           24                     01  and	al,*1
36462                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
36463 A3DF           0A46         FC            or	al,0+..FFDA[bp]
36464 A3E2           44                         inc	sp
36465 A3E3           44                         inc	sp
36466                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36467 A3E4           8846         FF            mov	-1[bp],al
36468                                           !BCC_EOS
36469                                           ! 5296       outb_cmos(0x0b, val8);
36470                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
36471 A3E7           8A46         FF            mov	al,-1[bp]
36472 A3EA           30E4                       xor	ah,ah
36473 A3EC           50                         push	ax
36474                                           ! Debug: list int = const $B (used reg = )
36475 A3ED           B8                   000B  mov	ax,*$B
36476 A3F0           50                         push	ax
36477                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36478 A3F1           E8         6180            call	_outb_cmos
36479 A3F4           83C4                   04  add	sp,*4
36480                                           !BCC_EOS
36481                                           ! 5297       regs.u.r8.ah = 0;
36482                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36483 A3F7           30C0                       xor	al,al
36484 A3F9           8846         13            mov	$13[bp],al
36485                                           !BCC_EOS
36486                                           ! 5298       regs.u.r8.al = val8;
36487                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36488 A3FC           8A46         FF            mov	al,-1[bp]
36489 A3FF           8846         12            mov	$12[bp],al
36490                                           !BCC_EOS
36491                                           ! 5299       iret_addr.flags.u.r8.flagsl &= 0xfe;
36492                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36493 A402           8A46         1A            mov	al,$1A[bp]
36494 A405           24                     FE  and	al,#$FE
36495 A407           8846         1A            mov	$1A[bp],al
36496                                           !BCC_EOS
36497                                           ! 5300       break;
36498 A40A           E9         0218            br 	.73A
36499                                           !BCC_EOS
36500                                           ! 5301     case 4:
36501                                           ! 5302       regs.u.r8.ah = 0;
36502                       0000A40D            .745:
36503                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36504 A40D           30C0                       xor	al,al
36505 A40F           8846         13            mov	$13[bp],al
36506                                           !BCC_EOS
36507                                           ! 5303       if (rtc
36508                                           ! 5303 _updating()) {
36509                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36510 A412           E8         61AB            call	_rtc_updating
36511 A415           85C0                       test	ax,ax
36512 A417           74           0B            je  	.746
36513                       0000A419            .747:
36514                                           ! 5304         iret_addr.flags.u.r8.flagsl |= 0x01;
36515                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36516 A419           8A46         1A            mov	al,$1A[bp]
36517 A41C           0C                     01  or	al,*1
36518 A41E           8846         1A            mov	$1A[bp],al
36519                                           !BCC_EOS
36520                                           ! 5305         break;
36521 A421           E9         0201            br 	.73A
36522                                           !BCC_EOS
36523                                           ! 5306         }
36524                                           ! 5307       regs.u.r8.cl = inb_cmos(0x09);
36525                       0000A424            .746:
36526                                           ! Debug: list int = const 9 (used reg = )
36527 A424           B8                   0009  mov	ax,*9
36528 A427           50                         push	ax
36529                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36530 A428           E8         6158            call	_inb_cmos
36531 A42B           44                         inc	sp
36532 A42C           44                         inc	sp
36533                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
36534 A42D           8846         10            mov	$10[bp],al
36535                                           !BCC_EOS
36536                                           ! 5308       regs.u.r8.dh = inb_cmos(0x08);
36537                                           ! Debug: list int = const 8 (used reg = )
36538 A430           B8                   0008  mov	ax,*8
36539 A433           50                         push	ax
36540                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36541 A434           E8         614C            call	_inb_cmos
36542 A437           44                         inc	sp
36543 A438           44                         inc	sp
36544                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
36545 A439           8846         0F            mov	$F[bp],al
36546                                           !BCC_EOS
36547                                           ! 5309       regs.u.r8.dl = inb_cmos(0x07);
36548                                           ! Debug: list int = const 7 (used reg = )
36549 A43C           B8                   0007  mov	ax,*7
36550 A43F           50                         push	ax
36551                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36552 A440           E8         6140            call	_inb_cmos
36553 A443           44                         inc	sp
36554 A444           44                         inc	sp
36555                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
36556 A445           8846         0E            mov	$E[bp],al
36557                                           !BCC_EOS
36558                                           ! 5310       regs.u.r8.ch = inb_cmos(0x32);
36559                                           ! Debug: list int = const $32 (used reg = )
36560 A448           B8                   0032  mov	ax,*$32
36561 A44B           50                         push	ax
36562                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36563 A44C           E8         6134            call	_inb_cmos
36564 A44F           44                         inc	sp
36565 A450           44                         inc	sp
36566                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
36567 A451           8846         11            mov	$11[bp],al
36568                                           !BCC_EOS
36569                                           ! 5311       regs.u.r8.al = regs.u.r8.ch;
36570                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
36571 A454           8A46         11            mov	al,$11[bp]
36572 A457           8846         12            mov	$12[bp],al
36573                                           !BCC_EOS
36574                                           ! 5312       iret_addr.flags.u.r8.flagsl &= 0xfe;
36575                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36576 A45A           8A46         1A            mov	al,$1A[bp]
36577 A45D           24                     FE  and	al,#$FE
36578 A45F           8846         1A            mov	$1A[bp],al
36579                                           !BCC_EOS
36580                                           ! 5313       break;
36581 A462           E9         01C0            br 	.73A
36582                                           !BCC_EOS
36583                                           ! 5314     case 5:
36584                                           ! 5315       if (rtc_updating()) {
36585                       0000A465            .748:
36586                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36587 A465           E8         6158            call	_rtc_updating
36588 A468           85C0                       test	ax,ax
36589 A46A           74           0E            je  	.749
36590                       0000A46C            .74A:
36591                                           ! 5316         init_rtc();
36592                                           ! Debug: func () void = init_rtc+0 (used reg = )
36593 A46C           E8         6120            call	_init_rtc
36594                                           !BCC_EOS
36595                                           ! 5317         iret_addr.flags.u.r8.flagsl |= 0x01;
36596                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36597 A46F           8A46         1A            mov	al,$1A[bp]
36598 A472           0C                     01  or	al,*1
36599 A474           8846         1A            mov	$1A[bp],al
36600                                           !BCC_EOS
36601                                           ! 5318         break;
36602 A477           E9         01AB            br 	.73A
36603                                           !BCC_EOS
36604                                           ! 5319         }
36605                                           ! 5320       outb_cmos(0x09, regs.u.r8.cl);
36606                       0000A47A            .749:
36607                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36608 A47A           8A46         10            mov	al,$10[bp]
36609 A47D           30E4                       xor	ah,ah
36610 A47F           50                         push	ax
36611                                           ! Debug: list int = const 9 (used reg = )
36612 A480           B8                   0009  mov	ax,*9
36613 A483           50                         push	ax
36614                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36615 A484           E8         60ED            call	_outb_cmos
36616 A487           83C4                   04  add	sp,*4
36617                                           !BCC_EOS
36618                                           ! 5321       outb_cmos(0x08, regs.u.r8.dh);
36619                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36620 A48A           8A46         0F            mov	al,$F[bp]
36621 A48D           30E4                       xor	ah,ah
36622 A48F           50                         push	ax
36623                                           ! Debug: list int = const 8 (used reg = )
36624 A490           B8                   0008  mov	ax,*8
36625 A493           50                         push	ax
36626                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36627 A494           E8         60DD            call	_outb_cmos
36628 A497           83C4                   04  add	sp,*4
36629                                           !BCC_EOS
36630                                           ! 5322       outb_cmos(0x07, regs.u.r8.dl);
36631                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
36632 A49A           8A46         0E            mov	al,$E[bp]
36633 A49D           30E4                       xor	ah,ah
36634 A49F           50                         push	ax
36635                                           ! Debug: list int = const 7 (used reg = )
36636 A4A0           B8                   0007  mov	ax,*7
36637 A4A3           50                         push	ax
36638                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36639 A4A4           E8         60CD            call	_outb_cmos
36640 A4A7           83C4                   04  add	sp,*4
36641                                           !BCC_EOS
36642                                           ! 5323       outb_cmos(0x32, regs.u.r8.ch);
36643                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36644 A4AA           8A46         11            mov	al,$11[bp]
36645 A4AD           30E4                       xor	ah,ah
36646 A4AF           50                         push	ax
36647                                           ! Debug: list int = const $32 (used reg = )
36648 A4B0           B8                   0032  mov	ax,*$32
36649 A4B3           50                         push	ax
36650                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36651 A4B4           E8         60BD            call	_outb_cmos
36652 A4B7           83C4                   04  add	sp,*4
36653                                           !BCC_EOS
36654                                           ! 5324       val8 = inb_cmos(0x0b) & 0x7f;
36655                                           ! Debug: list int = const $B (used reg = )
36656 A4BA           B8                   000B  mov	ax,*$B
36657 A4BD           50                         push	ax
36658                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36659 A4BE           E8         60C2            call	_inb_cmos
36660 A4C1           44                         inc	sp
36661 A4C2           44                         inc	sp
36662                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
36663 A4C3           24                     7F  and	al,*$7F
36664                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36665 A4C5           8846         FF            mov	-1[bp],al
36666                                           !BCC_EOS
36667                                           ! 5325       outb_cmos(0x0b, val8);
36668                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
36669 A4C8           8A46         FF            mov	al,-1[bp]
36670 A4CB           30E4                       xor	ah,ah
36671 A4CD           50                         push	ax
36672                                           ! Debug: list int = const $B (used reg = )
36673 A4CE           B8                   000B  mov	ax,*$B
36674 A4D1           50                         push	ax
36675                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36676 A4D2           E8         609F            call	_outb_cmos
36677 A4D5           83C4                   04  add	sp,*4
36678                                           !BCC_EOS
36679                                           ! 5326       regs.u.r8.ah = 0;
36680                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36681 A4D8           30C0                       xor	al,al
36682 A4DA           8846         13            mov	$13[bp],al
36683                                           !BCC_EOS
36684                                           ! 5327       regs.u.r8.al = val8;
36685                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36686 A4DD           8A46         FF            mov	al,-1[bp]
36687 A4E0           8846         12            mov	$12[bp],al
36688                                           !BCC_EOS
36689                                           ! 5328       iret_addr.flags.u.r8.flagsl &= 0xfe;
36690                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36691 A4E3           8A46         1A            mov	al,$1A[bp]
36692 A4E6           24                     FE  and	al,#$FE
36693 A4E8           8846         1A            mov	$1A[bp],al
36694                                           !BCC_EOS
36695                                           ! 5329       break;
36696 A4EB           E9         0137            br 	.73A
36697                                           !BCC_EOS
36698                                           ! 5330     case 6:
36699                                           ! 5331       val8 = inb_cmos(0x0b);
36700                       0000A4EE            .74B:
36701                                           ! Debug: list int = const $B (used reg = )
36702 A4EE           B8                   000B  mov	ax,*$B
36703 A4F1           50                         push	ax
36704                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36705 A4F2           E8         608E            call	_inb_cmos
36706 A4F5           44                         inc	sp
36707 A4F6           44                         inc	sp
36708                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36709 A4F7           8846         FF            mov	-1[bp],al
36710                                           !BCC_EOS
36711                                           ! 5332       regs.u.r16.ax = 0;
36712                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
36713 A4FA           31C0                       xor	ax,ax
36714 A4FC           8946         12            mov	$12[bp],ax
36715                                           !BCC_EOS
36716                                           ! 5333       if (val8 & 0x20) {
36717                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
36718 A4FF           8A46         FF            mov	al,-1[bp]
36719 A502           24                     20  and	al,*$20
36720 A504           84C0                       test	al,al
36721 A506           74           0B            je  	.74C
36722                       0000A508            .74D:
36723                                           ! 5334         iret_addr.flags.u.r8.flagsl |= 0x01;
36724                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36725 A508           8A46         1A            mov	al,$1A[bp]
36726 A50B           0C                     01  or	al,*1
36727 A50D           8846         1A            mov	$1A[bp],al
36728                                           !BCC_EOS
36729                                           ! 5335         break;
36730 A510           E9         0112            br 	.73A
36731                                           !BCC_EOS
36732                                           ! 5336         }
36733                                           ! 5337       if (rtc_updating()) {
36734                       0000A513            .74C:
36735                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36736 A513           E8         60AA            call	_rtc_updating
36737 A516           85C0                       test	ax,ax
36738 A518           74           03            je  	.74E
36739                       0000A51A            .74F:
36740                                           ! 5338         init_rtc();
36741                                           ! Debug: func () void = init_rtc+0 (used reg = )
36742 A51A           E8         6072            call	_init_rtc
36743                                           !BCC_EOS
36744                                           ! 5339         }
36745                                           ! 5340       outb_cmos(0x01, regs.u.r8.dh);
36746                       0000A51D            .74E:
36747                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36748 A51D           8A46         0F            mov	al,$F[bp]
36749 A520           30E4                       xor	ah,ah
36750 A522           50                         push	ax
36751                                           ! Debug: list int = const 1 (used reg = )
36752 A523           B8                   0001  mov	ax,*1
36753 A526           50                         push	ax
36754                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36755 A527           E8         604A            call	_outb_cmos
36756 A52A           83C4                   04  add	sp,*4
36757                                           !BCC_EOS
36758                                           ! 5341       outb_cmos(0x03, regs.u.r8.cl);
36759                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36760 A52D           8A46         10            mov	al,$10[bp]
36761 A530           30E4                       xor	ah,ah
36762 A532           50                         push	ax
36763                                           ! Debug: list int = const 3 (used reg = )
36764 A533           B8                   0003  mov	ax,*3
36765 A536           50                         push	ax
36766                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36767 A537           E8         603A            call	_outb_cmos
36768 A53A           83C4                   04  add	sp,*4
36769                                           !BCC_EOS
36770                                           ! 5342       outb_cmos(0x05, regs.u.r8.ch);
36771                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36772 A53D           8A46         11            mov	al,$11[bp]
36773 A540           30E4                       xor	ah,ah
36774 A542           50                         push	ax
36775                                           ! Debug: list int = const 5 (used reg = )
36776 A543           B8                   0005  mov	ax,*5
36777 A546           50                         push	ax
36778                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36779 A547           E8         602A            call	_outb_cmos
36780 A54A           83C4                   04  add	sp,*4
36781                                           !BCC_EOS
36782                                           ! 5343       outb(0xa1, inb(0xa1) & 0xfe);
36783                                           ! Debug: list int = const $A1 (used reg = )
36784 A54D           B8                   00A1  mov	ax,#$A1
36785 A550           50                         push	ax
36786                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36787 A551           E8         5FEA            call	_inb
36788 A554           44                         inc	sp
36789 A555           44                         inc	sp
36790                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
36791 A556           24                     FE  and	al,#$FE
36792                                           ! Debug: list unsigned char = al+0 (used reg = )
36793 A558           30E4                       xor	ah,ah
36794 A55A           50                         push	ax
36795                                           ! Debug: list int = const $A1 (used reg = )
36796 A55B           B8                   00A1  mov	ax,#$A1
36797 A55E           50                         push	ax
36798                                           ! Debug: func () void = outb+0 (used reg = )
36799 A55F           E8         5FF2            call	_outb
36800 A562           83C4                   04  add	sp,*4
36801                                           !BCC_EOS
36802                                           ! 5344       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
36803                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
36804 A565           8A46         FF            mov	al,-1[bp]
36805 A568           24                     7F  and	al,*$7F
36806                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
36807 A56A           0C                     20  or	al,*$20
36808                                           ! Debug: list unsigned char = al+0 (used reg = )
36809 A56C           30E4                       xor	ah,ah
36810 A56E           50                         push	ax
36811                                           ! Debug: list int = const $B (used reg = )
36812 A56F           B8                   000B  mov	ax,*$B
36813 A572           50                         push	ax
36814                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36815 A573           E8         5FFE            call	_outb_cmos
36816 A576           83C4                   04  add	sp,*4
36817                                           !BCC_EOS
36818                                           ! 5345       iret_addr.flags.u.r8.flagsl &= 0xfe;
36819                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36820 A579           8A46         1A            mov	al,$1A[bp]
36821 A57C           24                     FE  and	al,#$FE
36822 A57E           8846         1A            mov	$1A[bp],al
36823                                           !BCC_EOS
36824                                           ! 5346       break;
36825 A581           E9         00A1            br 	.73A
36826                                           !BCC_EOS
36827                                           ! 5347     case 7:
36828                                           ! 5348       val8 = inb_cmos(0x0b);
36829                       0000A584            .750:
36830                                           ! Debug: list int = const $B (used reg = )
36831 A584           B8                   000B  mov	ax,*$B
36832 A587           50                         push	ax
36833                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36834 A588           E8         5FF8            call	_inb_cmos
36835 A58B           44                         inc	sp
36836 A58C           44                         inc	sp
36837                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36838 A58D           8846         FF            mov	-1[bp],al
36839                                           !BCC_EOS
36840                                           ! 5349       outb_cmos(0x0b, val8 & 0x57);
36841                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
36842 A590           8A46         FF            mov	al,-1[bp]
36843 A593           24                     57  and	al,*$57
36844                                           ! Debug: list unsigned char = al+0 (used reg = )
36845 A595           30E4                       xor	ah,ah
36846 A597           50                         push	ax
36847                                           ! Debug: list int = const $B (used reg = )
36848 A598           B8                   000B  mov	ax,*$B
36849 A59B           50                         push	ax
36850                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36851 A59C           E8         5FD5            call	_outb_cmos
36852 A59F           83C4                   04  add	sp,*4
36853                                           !BCC_EOS
36854                                           ! 5350       regs.u.r8.ah = 0;
36855                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36856 A5A2           30C0                       xor	al,al
36857 A5A4           8846         13            mov	$13[bp],al
36858                                           !BCC_EOS
36859                                           ! 5351       regs.u.r8.al = val8;
36860                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36861 A5A7           8A46         FF            mov	al,-1[bp]
36862 A5AA           8846         12            mov	$12[bp],al
36863                                           !BCC_EOS
36864                                           ! 5352       iret_addr.flags.u.r8.flagsl &= 0xfe;
36865                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36866 A5AD           8A46         1A            mov	al,$1A[bp]
36867 A5B0           24                     FE  and	al,#$FE
36868 A5B2           8846         1A            mov	$1A[bp],al
36869                                           !BCC_EOS
36870                                           ! 5353       break;
36871 A5B5           EB           6E            jmp .73A
36872                                           !BCC_EOS
36873                                           ! 5354     case 0xb1:
36874                                           ! 5355       if (regs.u.r8.bl == 0xff) {
36875                       0000A5B7            .751:
36876                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
36877 A5B7           8A46         0C            mov	al,$C[bp]
36878 A5BA           3C                     FF  cmp	al,#$FF
36879 A5BC           75           02            jne 	.752
36880                       0000A5BE            .753:
36881                                           ! 5356         ;
36882                                           !BCC_EOS
36883                                           ! 5357       } else if (regs.u.r8.bl == 0x81) {
36884 A5BE           EB           22            jmp .754
36885                       0000A5C0            .752:
36886                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
36887 A5C0           8A46         0C            mov	al,$C[bp]
36888 A5C3           3C                     81  cmp	al,#$81
36889 A5C5           75           02            jne 	.755
36890                       0000A5C7            .756:
36891                                           ! 5358         ;
36892                                           !BCC_EOS
36893                                           ! 5359       } else if (regs.u.r8.bl == 0x83) {
36894 A5C7           EB           19            jmp .757
36895                       0000A5C9            .755:
36896                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
36897 A5C9           8A46         0C            mov	al,$C[bp]
36898 A5CC           3C                     83  cmp	al,#$83
36899 A5CE           75           02            jne 	.758
36900                       0000A5D0            .759:
36901                                           ! 5360         ;
36902                                           !BCC_EOS
36903                                           ! 5361       } else if (regs.u.r8.bl == 0x86) {
36904 A5D0           EB           10            jmp .75A
36905                       0000A5D2            .758:
36906                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
36907 A5D2           8A46         0C            mov	al,$C[bp]
36908 A5D5           3C                     86  cmp	al,#$86
36909 A5D7           75           09            jne 	.75B
36910                       0000A5D9            .75C:
36911                                           ! 5362         if (regs.u.r8.al == 0x02) {
36912                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
36913 A5D9           8A46         12            mov	al,$12[bp]
36914 A5DC           3C                     02  cmp	al,*2
36915 A5DE           75           02            jne 	.75D
36916                       0000A5E0            .75E:
36917                                           ! 5363           ;
36918                                           !BCC_EOS
36919                                           ! 5364         } else {
36920 A5E0           EB           00            jmp .75F
36921                       0000A5E2            .75D:
36922                                           ! 5365           ;
36923                                           !BCC_EOS
36924                                           ! 5366         }
36925                                           ! 5367       }
36926                       0000A5E2            .75F:
36927                                           ! 5368       regs.u.r8.ah = regs.u.r8.bl;
36928                       0000A5E2            .75B:
36929                       0000A5E2            .75A:
36930                       0000A5E2            .757:
36931                       0000A5E2            .754:
36932                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
36933 A5E2           8A46         0C            mov	al,$C[bp]
36934 A5E5           8846         13            mov	$13[bp],al
36935                                           !BCC_EOS
36936                                           ! 5369       iret_addr.flags.u.r8.flagsl |= 0x01;
36937                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36938 A5E8           8A46         1A            mov	al,$1A[bp]
36939 A5EB           0C                     01  or	al,*1
36940 A5ED           8846         1A            mov	$1A[bp],al
36941                                           !BCC_EOS
36942                                           ! 5370       break;
36943 A5F0           EB           33            jmp .73A
36944                                           !BCC_EOS
36945                                           ! 5371     default:
36946                                           ! 5372       iret_addr.flags.u.r8.flagsl |= 0x01;
36947                       0000A5F2            .760:
36948                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36949 A5F2           8A46         1A            mov	al,$1A[bp]
36950 A5F5           0C                     01  or	al,*1
36951 A5F7           8846         1A            mov	$1A[bp],al
36952                                           !BCC_EOS
36953                                           ! 5373     }
36954                                           ! 5374 }
36955 A5FA           EB           29            jmp .73A
36956                       0000A5FC            .73C:
36957 A5FC           2C                     00  sub	al,*0
36958 A5FE           72           F2            jb 	.760
36959 A600           3C                     07  cmp	al,*7
36960 A602           77           1B            ja  	.761
36961 A604           30E4                       xor	ah,ah
36962 A606           D1E0                       shl	ax,*1
36963 A608           89C3                       mov	bx,ax
36964 A60A           2E                         seg	cs
36965 A60B           FFA7       A60F            br	.762[bx]
36966                       0000A60F            .762:
36967 A60F                      A2F3            .word	.73D
36968 A611                      A317            .word	.73E
36969 A613                      A33A            .word	.73F
36970 A615                      A393            .word	.742
36971 A617                      A40D            .word	.745
36972 A619                      A465            .word	.748
36973 A61B                      A4EE            .word	.74B
36974 A61D                      A584            .word	.750
36975                       0000A61F            .761:
36976 A61F           2C                     B1  sub	al,#$B1
36977 A621           74           94            je 	.751
36978 A623           EB           CD            jmp	.760
36979                       0000A625            .73A:
36980                       FFFFFFFC            ..FFDA	=	-4
36981 A625           89EC                       mov	sp,bp
36982 A627           5D                         pop	bp
36983 A628           C3                         ret
36984                                           ! 5375   void
36985                                           ! 5376 int70_function(regs, ds, iret_addr)
36986                                           ! 5377   pusha_regs_t regs;
36987                                           export	_int70_function
36988                       0000A629            _int70_function:
36989                                           !BCC_EOS
36990                                           ! 5378   Bit16u ds;
36991                                           !BCC_EOS
36992                                           ! 5379   iret_addr_t iret_addr;
36993                                           !BCC_EOS
36994                                           ! 5380 {
36995                                           ! 5381   Bit8u registerB = 0, registerC = 0;
36996 A629           55                         push	bp
36997 A62A           89E5                       mov	bp,sp
36998 A62C           4C                         dec	sp
36999                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
37000 A62D           30C0                       xor	al,al
37001 A62F           8846         FF            mov	-1[bp],al
37002 A632           4C                         dec	sp
37003                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
37004 A633           30C0                       xor	al,al
37005 A635           8846         FE            mov	-2[bp],al
37006                                           !BCC_EOS
37007                                           ! 5382   registerB = inb_cmos( 0xB )
37008                                           ! 5382 ;
37009                                           ! Debug: list int = const $B (used reg = )
37010 A638           B8                   000B  mov	ax,*$B
37011 A63B           50                         push	ax
37012                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37013 A63C           E8         5F44            call	_inb_cmos
37014 A63F           44                         inc	sp
37015 A640           44                         inc	sp
37016                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
37017 A641           8846         FF            mov	-1[bp],al
37018                                           !BCC_EOS
37019                                           ! 5383   registerC = inb_cmos( 0xC );
37020                                           ! Debug: list int = const $C (used reg = )
37021 A644           B8                   000C  mov	ax,*$C
37022 A647           50                         push	ax
37023                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37024 A648           E8         5F38            call	_inb_cmos
37025 A64B           44                         inc	sp
37026 A64C           44                         inc	sp
37027                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
37028 A64D           8846         FE            mov	-2[bp],al
37029                                           !BCC_EOS
37030                                           ! 5384   if( ( registerB & 0x60 ) != 0 ) {
37031                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
37032 A650           8A46         FF            mov	al,-1[bp]
37033 A653           24                     60  and	al,*$60
37034                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37035 A655           84C0                       test	al,al
37036 A657         0F84         00EF            beq 	.763
37037                       0000A65B            .764:
37038                                           ! 5385     if( ( registerC & 0x20 ) != 0 ) {
37039                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
37040 A65B           8A46         FE            mov	al,-2[bp]
37041 A65E           24                     20  and	al,*$20
37042                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37043 A660           84C0                       test	al,al
37044 A662           74           04            je  	.765
37045                       0000A664            .766:
37046                                           ! 5386 #asm
37047                                           !BCC_EOS
37048                                           !BCC_ASM
37049                       00000000            _int70_function.registerC	set	0
37050                       FFFFFFFE            .int70_function.registerC	set	-2
37051                       00000016            _int70_function.ds	set	$16
37052                       00000014            .int70_function.ds	set	$14
37053                       00000001            _int70_function.registerB	set	1
37054                       FFFFFFFF            .int70_function.registerB	set	-1
37055                       00000018            _int70_function.iret_addr	set	$18
37056                       00000016            .int70_function.iret_addr	set	$16
37057                       00000006            _int70_function.regs	set	6
37058                       00000004            .int70_function.regs	set	4
37059 A664           FB                               sti
37060 A665           CD                     4A        int #0x4a
37061 A667           FA                               cli
37062                                           ! 5390 endasm
37063                                           !BCC_ENDASM
37064                                           !BCC_EOS
37065                                           ! 5391     }
37066                                           ! 5392     if( ( registerC & 0x40 ) != 0 ) {
37067                       0000A668            .765:
37068                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
37069 A668           8A46         FE            mov	al,-2[bp]
37070 A66B           24                     40  and	al,*$40
37071                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37072 A66D           84C0                       test	al,al
37073 A66F         0F84         00D7            beq 	.767
37074                       0000A673            .768:
37075                                           ! 5393       if( read_byte( 0x40, 0xA0 ) != 0 ) {
37076                                           ! Debug: list int = const $A0 (used reg = )
37077 A673           B8                   00A0  mov	ax,#$A0
37078 A676           50                         push	ax
37079                                           ! Debug: list int = const $40 (used reg = )
37080 A677           B8                   0040  mov	ax,*$40
37081 A67A           50                         push	ax
37082                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37083 A67B           E8         5F76            call	_read_byte
37084 A67E           83C4                   04  add	sp,*4
37085                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37086 A681           84C0                       test	al,al
37087 A683         0F84         00C3            beq 	.769
37088                       0000A687            .76A:
37089                                           ! 5394         Bit32u time, toggle;
37090                                           !BCC_EOS
37091                                           ! 5395         time = read_dword( 0x40, 0x9C );
37092 A687           83C4                   F8  add	sp,*-8
37093                                           ! Debug: list int = const $9C (used reg = )
37094 A68A           B8                   009C  mov	ax,#$9C
37095 A68D           50                         push	ax
37096                                           ! Debug: list int = const $40 (used reg = )
37097 A68E           B8                   0040  mov	ax,*$40
37098 A691           50                         push	ax
37099                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
37100 A692           E8         59EE            call	_read_dword
37101 A695           89D3                       mov	bx,dx
37102 A697           83C4                   04  add	sp,*4
37103                                           ! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
37104 A69A           8946         FA            mov	-6[bp],ax
37105 A69D           895E         FC            mov	-4[bp],bx
37106                                           !BCC_EOS
37107                                           ! 5396         if( time < 0x3D1 ) {
37108                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
37109 A6A0           B8                   03D1  mov	ax,#$3D1
37110 A6A3           31DB                       xor	bx,bx
37111 A6A5           8D7E         FA            lea	di,-6[bp]
37112 A6A8           E8         5A20            call	lcmpul
37113 A6AB           76           6A            jbe 	.76B
37114                       0000A6AD            .76C:
37115                                           ! 5397           Bit16u segment, offset;
37116                                           !BCC_EOS
37117                                           ! 5398           segment = read_word( 0x40, 0x98 );
37118 A6AD           83C4                   FC  add	sp,*-4
37119                                           ! Debug: list int = const $98 (used reg = )
37120 A6B0           B8                   0098  mov	ax,#$98
37121 A6B3           50                         push	ax
37122                                           ! Debug: list int = const $40 (used reg = )
37123 A6B4           B8                   0040  mov	ax,*$40
37124 A6B7           50                         push	ax
37125                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
37126 A6B8           E8         5F4C            call	_read_word
37127 A6BB           83C4                   04  add	sp,*4
37128                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
37129 A6BE           8946         F4            mov	-$C[bp],ax
37130                                           !BCC_EOS
37131                                           ! 5399           offset = read_word( 0x40, 0x9A );
37132                                           ! Debug: list int = const $9A (used reg = )
37133 A6C1           B8                   009A  mov	ax,#$9A
37134 A6C4           50                         push	ax
37135                                           ! Debug: list int = const $40 (used reg = )
37136 A6C5           B8                   0040  mov	ax,*$40
37137 A6C8           50                         push	ax
37138                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
37139 A6C9           E8         5F3B            call	_read_word
37140 A6CC           83C4                   04  add	sp,*4
37141                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
37142 A6CF           8946         F2            mov	-$E[bp],ax
37143                                           !BCC_EOS
37144                                           ! 5400           write_byte( 0x40, 0xA0, 0 );
37145                                           ! Debug: list int = const 0 (used reg = )
37146 A6D2           31C0                       xor	ax,ax
37147 A6D4           50                         push	ax
37148                                           ! Debug: list int = const $A0 (used reg = )
37149 A6D5           B8                   00A0  mov	ax,#$A0
37150 A6D8           50                         push	ax
37151                                           ! Debug: list int = const $40 (used reg = )
37152 A6D9           B8                   0040  mov	ax,*$40
37153 A6DC           50                         push	ax
37154                                           ! Debug: func () void = write_byte+0 (used reg = )
37155 A6DD           E8         5F3A            call	_write_byte
37156 A6E0           83C4                   06  add	sp,*6
37157                                           !BCC_EOS
37158                                           ! 5401           outb_cmos( 0xB, registerB & 0x37 );
37159                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
37160 A6E3           8A46         FF            mov	al,-1[bp]
37161 A6E6           24                     37  and	al,*$37
37162                                           ! Debug: list unsigned char = al+0 (used reg = )
37163 A6E8           30E4                       xor	ah,ah
37164 A6EA           50                         push	ax
37165                                           ! Debug: list int = const $B (used reg = )
37166 A6EB           B8                   000B  mov	ax,*$B
37167 A6EE           50                         push	ax
37168                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37169 A6EF           E8         5E82            call	_outb_cmos
37170 A6F2           83C4                   04  add	sp,*4
37171                                           !BCC_EOS
37172                                           ! 5402           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
37173                                           ! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
37174 A6F5           FF76         F2            push	-$E[bp]
37175                                           ! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
37176 A6F8           FF76         F4            push	-$C[bp]
37177                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37178 A6FB           E8         5EF6            call	_read_byte
37179 A6FE           83C4                   04  add	sp,*4
37180                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
37181 A701           0C                     80  or	al,#$80
37182                                           ! Debug: list unsigned char = al+0 (used reg = )
37183 A703           30E4                       xor	ah,ah
37184 A705           50                         push	ax
37185                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
37186 A706           FF76         F2            push	-$E[bp]
37187                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
37188 A709           FF76         F4            push	-$C[bp]
37189                                           ! Debug: func () void = write_byte+0 (used reg = )
37190 A70C           E8         5F0B            call	_write_byte
37191 A70F           83C4                   06  add	sp,*6
37192                                           !BCC_EOS
37193                                           ! 5403         } else {
37194 A712           83C4                   04  add	sp,*4
37195 A715           EB           30            jmp .76D
37196                       0000A717            .76B:
37197                                           ! 5404           time -= 0x3D1;
37198                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
37199 A717           B8                   03D1  mov	ax,#$3D1
37200 A71A           31DB                       xor	bx,bx
37201 A71C           53                         push	bx
37202 A71D           50                         push	ax
37203 A71E           8B46         FA            mov	ax,-6[bp]
37204 A721           8B5E         FC            mov	bx,-4[bp]
37205 A724           8D7E         F2            lea	di,-$E[bp]
37206 A727           E8         59B7            call	lsubul
37207 A72A           8946         FA            mov	-6[bp],ax
37208 A72D           895E         FC            mov	-4[bp],bx
37209 A730           83C4                   04  add	sp,*4
37210                                           !BCC_EOS
37211                                           ! 5405           write_dword( 0x40, 0x9C, time );
37212                                           ! Debug: list unsigned long time = [S+$C-8] (used reg = )
37213 A733           FF76         FC            push	-4[bp]
37214 A736           FF76         FA            push	-6[bp]
37215                                           ! Debug: list int = const $9C (used reg = )
37216 A739           B8                   009C  mov	ax,#$9C
37217 A73C           50                         push	ax
37218                                           ! Debug: list int = const $40 (used reg = )
37219 A73D           B8                   0040  mov	ax,*$40
37220 A740           50                         push	ax
37221                                           ! Debug: func () void = write_dword+0 (used reg = )
37222 A741           E8         5957            call	_write_dword
37223 A744           83C4                   08  add	sp,*8
37224                                           !BCC_EOS
37225                                           ! 5406         }
37226                                           ! 5407       }
37227                       0000A747            .76D:
37228 A747           83C4                   08  add	sp,*8
37229                                           ! 5408     }
37230                       0000A74A            .769:
37231                                           ! 5409   }
37232                       0000A74A            .767:
37233                                           ! 5410 #asm
37234                       0000A74A            .763:
37235                                           !BCC_EOS
37236                                           !BCC_ASM
37237                       00000000            _int70_function.registerC	set	0
37238                       FFFFFFFE            .int70_function.registerC	set	-2
37239                       00000016            _int70_function.ds	set	$16
37240                       00000014            .int70_function.ds	set	$14
37241                       00000001            _int70_function.registerB	set	1
37242                       FFFFFFFF            .int70_function.registerB	set	-1
37243                       00000018            _int70_function.iret_addr	set	$18
37244                       00000016            .int70_function.iret_addr	set	$16
37245                       00000006            _int70_function.regs	set	6
37246                       00000004            .int70_function.regs	set	4
37247 A74A           E8         03FC              call eoi_both_pics
37248                                           ! 5412 endasm
37249                                           !BCC_ENDASM
37250                                           !BCC_EOS
37251                                           ! 5413 }
37252 A74D           89EC                       mov	sp,bp
37253 A74F           5D                         pop	bp
37254 A750           C3                         ret
37255                                           ! 5414 #asm
37256                                           !BCC_ASM
37257                       00000012            _int70_function.ds	set	$12
37258                       00000014            _int70_function.iret_addr	set	$14
37259                       00000002            _int70_function.regs	set	2
37260                                           ;------------------------------------------
37261                                           ;- INT74h : PS/2 mouse hardware interrupt -
37262                                           ;------------------------------------------
37263                       0000A751            int74_handler:
37264 A751           FB                           sti
37265 A752           60                           pusha
37266 A753           1E                           push ds ;; save DS
37267 A754           6A                     00    push #0x00 ;; placeholder for status
37268 A756           6A                     00    push #0x00 ;; placeholder for X
37269 A758           6A                     00    push #0x00 ;; placeholder for Y
37270 A75A           6A                     00    push #0x00 ;; placeholder for Z
37271 A75C           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
37272 A75E           E8         BF88              call _int74_function
37273 A761           59                           pop cx ;; remove make_far_call from stack
37274 A762           E3           0C              jcxz int74_done
37275                                             ;; make far call to EBDA:0022
37276 A764           6A                     00    push #0x00
37277 A766           1F                           pop ds
37278 A767           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
37279 A76B           1F                           pop ds
37280 A76C           FF1E       0022              call far ptr[0x22]
37281                       0000A770            int74_done:
37282 A770           FA                           cli
37283 A771           E8         03D5              call eoi_both_pics
37284 A774           83C4                   08    add sp, #8 ;; pop status, x, y, z
37285 A777           1F                           pop ds ;; restore DS
37286 A778           61                           popa
37287 A779           CF                           iret
37288                                           ;; This will perform an IRET, but will retain value of current CF
37289                                           ;; by altering flags on stack. Better than RETF #02.
37290                       0000A77A            iret_modify_cf:
37291 A77A           72           09              jc carry_set
37292 A77C           55                           push bp
37293 A77D           89E5                         mov bp, sp
37294 A77F           8066         06        FE    and BYTE [bp + 0x06], #0xfe
37295 A783           5D                           pop bp
37296 A784           CF                           iret
37297                       0000A785            carry_set:
37298 A785           55                           push bp
37299 A786           89E5                         mov bp, sp
37300 A788           804E         06        01    or BYTE [bp + 0x06], #0x01
37301 A78C           5D                           pop bp
37302 A78D           CF                           iret
37303                                           ;----------------------
37304                                           ;- INT13h (relocated) -
37305                                           ;----------------------
37306                                           ;
37307                                           ; int13_relocated is a little bit messed up since I played with it
37308                                           ; I have to rewrite it:
37309                                           ; - call a function that detect which function to call
37310                                           ; - make all called C function get the same parameters list
37311                                           ;
37312                       0000A78E            int13_relocated:
37313                                             ;; check for an eltorito function
37314 A78E           80FC                   4A    cmp ah,#0x4a
37315 A791           72           10              jb int13_not_eltorito
37316 A793           80FC                   4D    cmp ah,#0x4d
37317 A796           77           0B              ja int13_not_eltorito
37318 A798           60                           pusha
37319 A799           06                           push es
37320 A79A           1E                           push ds
37321 A79B           16                           push ss
37322 A79C           1F                           pop ds
37323 A79D           68                   A815    push #int13_out
37324 A7A0           E9         DA0A              jmp _int13_eltorito ;; ELDX not used
37325                       0000A7A3            int13_not_eltorito:
37326 A7A3           50                           push ax
37327 A7A4           53                           push bx
37328 A7A5           51                           push cx
37329 A7A6           52                           push dx
37330                                             ;; check if emulation active
37331 A7A7           E8         96D5              call _cdemu_isactive
37332 A7AA           3C                     00    cmp al,#0x00
37333 A7AC           74           2B              je int13_cdemu_inactive
37334                                             ;; check if access to the emulated drive
37335 A7AE           E8         96F5              call _cdemu_emulated_drive
37336 A7B1           5A                           pop dx
37337 A7B2           52                           push dx
37338 A7B3           38D0                         cmp al,dl ;; int13 on emulated drive
37339 A7B5           75           0F              jne int13_nocdemu
37340 A7B7           5A                           pop dx
37341 A7B8           59                           pop cx
37342 A7B9           5B                           pop bx
37343 A7BA           58                           pop ax
37344 A7BB           60                           pusha
37345 A7BC           06                           push es
37346 A7BD           1E                           push ds
37347 A7BE           16                           push ss
37348 A7BF           1F                           pop ds
37349 A7C0           68                   A815    push #int13_out
37350 A7C3           E9         DC21              jmp _int13_cdemu ;; ELDX not used
37351                       0000A7C6            int13_nocdemu:
37352 A7C6           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
37353 A7C9           38D0                         cmp al,dl ;; al is 0x00 or 0x80
37354 A7CB           75           0C              jne int13_cdemu_inactive ;; inactive for device class
37355 A7CD           5A                           pop dx
37356 A7CE           59                           pop cx
37357 A7CF           5B                           pop bx
37358 A7D0           58                           pop ax
37359 A7D1           50                           push ax
37360 A7D2           51                           push cx
37361 A7D3           52                           push dx
37362 A7D4           53                           push bx
37363 A7D5           FECA                         dec dl ;; real drive is dl - 1
37364 A7D7           EB           08              jmp int13_legacy
37365                       0000A7D9            int13_cdemu_inactive:
37366 A7D9           5A                           pop dx
37367 A7DA           59                           pop cx
37368 A7DB           5B                           pop bx
37369 A7DC           58                           pop ax
37370                       0000A7DD            int13_noeltorito:
37371 A7DD           50                           push ax
37372 A7DE           51                           push cx
37373 A7DF           52                           push dx
37374 A7E0           53                           push bx
37375                       0000A7E1            int13_legacy:
37376 A7E1           52                           push dx ;; push eltorito value of dx instead of sp
37377 A7E2           55                           push bp
37378 A7E3           56                           push si
37379 A7E4           57                           push di
37380 A7E5           06                           push es
37381 A7E6           1E                           push ds
37382 A7E7           16                           push ss
37383 A7E8           1F                           pop ds
37384                                             ;; now the 16-bit registers can be restored with:
37385                                             ;; pop ds; pop es; popa; iret
37386                                             ;; arguments passed to functions should be
37387                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
37388 A7E9           F6C2                   80    test dl, #0x80
37389 A7EC           75           06              jnz int13_notfloppy
37390 A7EE           68                   A815    push #int13_out
37391 A7F1           E9         E607              jmp _int13_diskette_function
37392                       0000A7F4            int13_notfloppy:
37393 A7F4           80FA                   E0    cmp dl, #0xE0
37394 A7F7           72           0F              jb int13_notcdrom
37395 A7F9     66    C1EB                   10    shr ebx, #16
37396 A7FD           53                           push bx
37397 A7FE           E8         CEE7              call _int13_cdrom
37398 A801           5B                           pop bx
37399 A802     66    C1E3                   10    shl ebx, #16
37400 A806           EB           0D              jmp int13_out
37401                       0000A808            int13_notcdrom:
37402                       0000A808            int13_disk:
37403                                             ;; int13_harddisk modifies high word of EAX
37404 A808     66    C1E8                   10    shr eax, #16
37405 A80C           50                           push ax
37406 A80D           E8         BFF4              call _int13_harddisk
37407 A810           58                           pop ax
37408 A811     66    C1E0                   10    shl eax, #16
37409                       0000A815            int13_out:
37410 A815           1F                           pop ds
37411 A816           07                           pop es
37412 A817           61                           popa
37413 A818           CF                           iret
37414                                           ;----------
37415                                           ;- INT18h -
37416                                           ;----------
37417                       0000A819            int18_handler: ;; Boot Failure recovery: try the next device.
37418                                             ;; Reset SP and SS
37419 A819           B8                   0FFE    mov ax, #0x0ffe
37420 A81C           89C4                         mov sp, ax
37421 A81E           B8                   9E00    mov ax, #0x9e00
37422 A821           8ED0                         mov ss, ax
37423                                             ;; The first time we do this it will have been set to -1 so
37424                                             ;; we will start from device 0.
37425 A823           31C0                         xor ax, ax
37426 A825           8ED8                         mov ds, ax
37427 A827           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
37428 A82B           8EDB                         mov ds, bx ;; Set segment
37429 A82D           8B1E       0382              mov bx, 0x0382 ;; BX is now the sequence number
37430 A831           43                           inc bx ;; ++
37431 A832           891E       0382              mov 0x0382, bx ;; Write it back
37432 A836           8ED8                         mov ds, ax ;; and reset the segment to zero.
37433                                             ;; Call the C code for the next boot device
37434 A838           53                           push bx
37435 A839           E8         F839              call _int18_function
37436                                             ;; Boot failed: invoke the boot recovery function...
37437 A83C           CD                     18    int #0x18
37438                                           ;----------
37439                                           ;- INT19h -
37440                                           ;----------
37441                       0000A83E            int19_relocated: ;; Boot function, relocated
37442                                             ;;
37443                                             ;; *** Warning: INT 19h resets the whole machine ***
37444                                             ;;
37445                                             ;; Because PV drivers in HVM guests detach some of the emulated devices,
37446                                             ;; it is not safe to do a soft reboot by just dropping to real mode and
37447                                             ;; invoking INT 19h -- the boot drives might have disappeared!
37448                                             ;; If the user asks for a soft reboot, the only thing we can do is
37449                                             ;; reset the whole machine. When it comes back up, the normal BIOS
37450                                             ;; boot sequence will start, which is more or less the required behaviour.
37451                                             ;;
37452                                             ;; Reset SP and SS
37453 A83E           B8                   0FFE    mov ax, #0x0ffe
37454 A841           89C4                         mov sp, ax
37455 A843           B8                   9E00    mov ax, #0x9e00
37456 A846           8ED0                         mov ss, ax
37457 A848           E8         6A7C              call _machine_reset
37458                                           ;----------
37459                                           ;- INT1Ch -
37460                                           ;----------
37461                       0000A84B            int1c_handler: ;; User Timer Tick
37462 A84B           CF                           iret
37463                                           ;----------------------
37464                                           ;- POST: Floppy Drive -
37465                                           ;----------------------
37466                       0000A84C            floppy_drive_post:
37467 A84C           31C0                         xor ax, ax
37468 A84E           8ED8                         mov ds, ax
37469 A850           B0                     00    mov al, #0x00
37470 A852           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
37471 A855           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
37472 A858           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
37473 A85B           A2         0441              mov 0x0441, al ;; diskette controller status return code
37474 A85E           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
37475 A861           A2         0443              mov 0x0443, al ;; diskette controller status register 1
37476 A864           A2         0444              mov 0x0444, al ;; diskette controller status register 2
37477 A867           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
37478 A86A           A2         0446              mov 0x0446, al ;; diskette controller head number
37479 A86D           A2         0447              mov 0x0447, al ;; diskette controller sector number
37480 A870           A2         0448              mov 0x0448, al ;; diskette controller bytes written
37481 A873           A2         048B              mov 0x048b, al ;; diskette configuration data
37482                                             ;; -----------------------------------------------------------------
37483                                             ;; (048F) diskette controller information
37484                                             ;;
37485 A876           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
37486 A878           E6                     70    out 0x70, AL
37487 A87A           E4                     71    in AL, 0x71
37488 A87C           88C4                         mov ah, al ;; save byte to AH
37489                       0000A87E            look_drive0:
37490 A87E           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
37491 A881           74           04              jz f0_missing ;; jump if no drive0
37492 A883           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
37493 A885           EB           02              jmp look_drive1
37494                       0000A887            f0_missing:
37495 A887           B3                     00    mov bl, #0x00 ;; no drive0
37496                       0000A889            look_drive1:
37497 A889           88E0                         mov al, ah ;; restore from AH
37498 A88B           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
37499 A88D           74           03              jz f1_missing ;; jump if no drive1
37500 A88F           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
37501                       0000A892            f1_missing:
37502                                                              ;; leave high bits in BL zerod
37503 A892           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
37504                                             ;; -----------------------------------------------------------------
37505 A896           B0                     00    mov al, #0x00
37506 A898           A2         0490              mov 0x0490, al ;; diskette 0 media state
37507 A89B           A2         0491              mov 0x0491, al ;; diskette 1 media state
37508                                                              ;; diskette 0,1 operational starting state
37509                                                              ;; drive type has not been determined,
37510                                                              ;; has no changed detection line
37511 A89E           A2         0492              mov 0x0492, al
37512 A8A1           A2         0493              mov 0x0493, al
37513 A8A4           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
37514 A8A7           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
37515 A8AA           B0                     02    mov al, #0x02
37516 A8AC           E6                     0A    out #0x0a, al ;; clear DMA-1 channel 2 mask bit
37517                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   A8AE           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   A8B1           A3         0078              mov 0x1E*4, ax
 +a   A8B4           B8                   F000    mov ax,  #0xF000
 +a   A8B7           A3         007A              mov 0x1E*4+2, ax
37518                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   A8BA           B8                   EC59    mov ax,  #int13_diskette
 +a   A8BD           A3         0100              mov 0x40*4, ax
 +a   A8C0           B8                   F000    mov ax,  #0xF000
 +a   A8C3           A3         0102              mov 0x40*4+2, ax
37519                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   A8C6           B8                   EF57    mov ax,  #int0e_handler
 +a   A8C9           A3         0038              mov 0x0E*4, ax
 +a   A8CC           B8                   F000    mov ax,  #0xF000
 +a   A8CF           A3         003A              mov 0x0E*4+2, ax
37520 A8D2           C3                           ret
37521                                           ;--------------------
37522                                           ;- POST: HARD DRIVE -
37523                                           ;--------------------
37524                                           ; relocated here because the primary POST area isnt big enough.
37525                       0000A8D3            hard_drive_post:
37526 A8D3           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
37527 A8D5           BA                   03F6    mov dx, #0x03f6
37528 A8D8           EE                           out dx, al
37529 A8D9           31C0                         xor ax, ax
37530 A8DB           8ED8                         mov ds, ax
37531 A8DD           A2         0474              mov 0x0474, al
37532 A8E0           A2         0477              mov 0x0477, al
37533 A8E3           A2         048C              mov 0x048c, al
37534 A8E6           A2         048D              mov 0x048d, al
37535 A8E9           A2         048E              mov 0x048e, al
37536 A8EC           B0                     01    mov al, #0x01
37537 A8EE           A2         0475              mov 0x0475, al
37538 A8F1           B0                     C0    mov al, #0xc0
37539 A8F3           A2         0476              mov 0x0476, al
37540                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   A8F6           B8                   E3FE    mov ax,  #int13_handler
 +a   A8F9           A3         004C              mov 0x13*4, ax
 +a   A8FC           B8                   F000    mov ax,  #0xF000
 +a   A8FF           A3         004E              mov 0x13*4+2, ax
37541                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   A902           B8                   ABD8    mov ax,  #int76_handler
 +a   A905           A3         01D8              mov 0x76*4, ax
 +a   A908           B8                   F000    mov ax,  #0xF000
 +a   A90B           A3         01DA              mov 0x76*4+2, ax
37542                                             ;; INT 41h: hard disk 0 configuration pointer
37543                                             ;; INT 46h: hard disk 1 configuration pointer
37544                                             SET_INT_VECTOR(0x41, word ptr [0x40E], #0x003D)
 +a   A90E           B8                   003D    mov ax,  #0x003D
 +a   A911           A3         0104              mov 0x41*4, ax
 +a   A914           A1         040E              mov ax,  word ptr [0x40E]
 +a   A917           A3         0106              mov 0x41*4+2, ax
37545                                             SET_INT_VECTOR(0x46, word ptr [0x40E], #0x004D)
 +a   A91A           B8                   004D    mov ax,  #0x004D
 +a   A91D           A3         0118              mov 0x46*4, ax
 +a   A920           A1         040E              mov ax,  word ptr [0x40E]
 +a   A923           A3         011A              mov 0x46*4+2, ax
37546                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
37547 A926           B0                     12    mov al, #0x12
37548 A928           E6                     70    out #0x70, al
37549 A92A           E4                     71    in al, #0x71
37550 A92C           24                     F0    and al, #0xf0
37551 A92E           3C                     F0    cmp al, #0xf0
37552 A930           74           03              je post_d0_extended
37553 A932           E9         00D8              jmp check_for_hd1
37554                       0000A935            post_d0_extended:
37555 A935           B0                     19    mov al, #0x19
37556 A937           E6                     70    out #0x70, al
37557 A939           E4                     71    in al, #0x71
37558 A93B           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
37559 A93D           74           07              je post_d0_type47
37560                                             HALT(9031)
 +a   A93F           BA                   0400    mov dx,#0x400
 +a   A942           B8                   2347    mov ax,#9031
 +a   A945           EF                           out dx,ax
37561                       0000A946            post_d0_type47:
37562                                             ;; CMOS purpose param table offset
37563                                             ;; 1b cylinders low 0
37564                                             ;; 1c cylinders high 1
37565                                             ;; 1d heads 2
37566                                             ;; 1e write pre-comp low 5
37567                                             ;; 1f write pre-comp high 6
37568                                             ;; 20 retries/bad map/heads>8 8
37569                                             ;; 21 landing zone low C
37570                                             ;; 22 landing zone high D
37571                                             ;; 23 sectors/track E
37572 A946           31C0                         xor ax, ax
37573 A948           8ED8                         mov ds, ax
37574 A94A           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
37575 A94D           8ED8                         mov ds, ax
37576                                             ;;; Filling EBDA table for hard disk 0.
37577 A94F           B0                     1F    mov al, #0x1f
37578 A951           E6                     70    out #0x70, al
37579 A953           E4                     71    in al, #0x71
37580 A955           88C4                         mov ah, al
37581 A957           B0                     1E    mov al, #0x1e
37582 A959           E6                     70    out #0x70, al
37583 A95B           E4                     71    in al, #0x71
37584 A95D           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
37585 A960           B0                     20    mov al, #0x20
37586 A962           E6                     70    out #0x70, al
37587 A964           E4                     71    in al, #0x71
37588 A966           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
37589 A969           B0                     22    mov al, #0x22
37590 A96B           E6                     70    out #0x70, al
37591 A96D           E4                     71    in al, #0x71
37592 A96F           88C4                         mov ah, al
37593 A971           B0                     21    mov al, #0x21
37594 A973           E6                     70    out #0x70, al
37595 A975           E4                     71    in al, #0x71
37596 A977           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
37597 A97A           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
37598 A97C           E6                     70    out #0x70, al
37599 A97E           E4                     71    in al, #0x71 ;; high byte
37600 A980           88C4                         mov ah, al
37601 A982           B0                     1B    mov al, #0x1b
37602 A984           E6                     70    out #0x70, al
37603 A986           E4                     71    in al, #0x71 ;; low byte
37604 A988           89C3                         mov bx, ax ;; BX = cylinders
37605 A98A           B0                     1D    mov al, #0x1d
37606 A98C           E6                     70    out #0x70, al
37607 A98E           E4                     71    in al, #0x71
37608 A990           88C1                         mov cl, al ;; CL = heads
37609 A992           B0                     23    mov al, #0x23
37610 A994           E6                     70    out #0x70, al
37611 A996           E4                     71    in al, #0x71
37612 A998           88C2                         mov dl, al ;; DL = sectors
37613 A99A           81FB                 0400    cmp bx, #1024
37614 A99E           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
37615                       0000A9A0            hd0_post_physical_chs:
37616                                             ;; no logical CHS mapping used, just physical CHS
37617                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
37618 A9A0           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
37619 A9A4           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
37620 A9A8           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
37621 A9AC           EB           5F              jmp check_for_hd1
37622                       0000A9AE            hd0_post_logical_chs:
37623                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
37624 A9AE           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
37625 A9B2           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
37626 A9B6           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
37627 A9BA           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
37628 A9BE           B0                     A0    mov al, #0xa0
37629 A9C0           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
37630 A9C3           81FB                 0800    cmp bx, #2048
37631 A9C7           77           06              jnbe hd0_post_above_2048
37632                                             ;; 1024 < c <= 2048 cylinders
37633 A9C9           D1EB                         shr bx, #0x01
37634 A9CB           D0E1                         shl cl, #0x01
37635 A9CD           EB           22              jmp hd0_post_store_logical
37636                       0000A9CF            hd0_post_above_2048:
37637 A9CF           81FB                 1000    cmp bx, #4096
37638 A9D3           77           08              jnbe hd0_post_above_4096
37639                                             ;; 2048 < c <= 4096 cylinders
37640 A9D5           C1EB                   02    shr bx, #0x02
37641 A9D8           C0E1                   02    shl cl, #0x02
37642 A9DB           EB           14              jmp hd0_post_store_logical
37643                       0000A9DD            hd0_post_above_4096:
37644 A9DD           81FB                 2000    cmp bx, #8192
37645 A9E1           77           08              jnbe hd0_post_above_8192
37646                                             ;; 4096 < c <= 8192 cylinders
37647 A9E3           C1EB                   03    shr bx, #0x03
37648 A9E6           C0E1                   03    shl cl, #0x03
37649 A9E9           EB           06              jmp hd0_post_store_logical
37650                       0000A9EB            hd0_post_above_8192:
37651                                             ;; 8192 < c <= 16384 cylinders
37652 A9EB           C1EB                   04    shr bx, #0x04
37653 A9EE           C0E1                   04    shl cl, #0x04
37654                       0000A9F1            hd0_post_store_logical:
37655 A9F1           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
37656 A9F5           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
37657                                             ;; checksum
37658 A9F9           B1                     0F    mov cl, #0x0f ;; repeat count
37659 A9FB           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
37660 A9FE           B0                     00    mov al, #0x00 ;; sum
37661                       0000AA00            hd0_post_checksum_loop:
37662 AA00           0204                         add al, [si]
37663 AA02           46                           inc si
37664 AA03           FEC9                         dec cl
37665 AA05           75           F9              jnz hd0_post_checksum_loop
37666 AA07           F6D0                         not al ;; now take 2s complement
37667 AA09           FEC0                         inc al
37668 AA0B           8804                         mov [si], al
37669                                           ;;; Done filling EBDA table for hard disk 0.
37670                       0000AA0D            check_for_hd1:
37671                                             ;; is there really a second hard disk? if not, return now
37672 AA0D           B0                     12    mov al, #0x12
37673 AA0F           E6                     70    out #0x70, al
37674 AA11           E4                     71    in al, #0x71
37675 AA13           24                     0F    and al, #0x0f
37676 AA15           75           01              jnz post_d1_exists
37677 AA17           C3                           ret
37678                       0000AA18            post_d1_exists:
37679                                             ;; check that the hd type is really 0x0f.
37680 AA18           3C                     0F    cmp al, #0x0f
37681 AA1A           74           07              jz post_d1_extended
37682                                             HALT(9170)
 +a   AA1C           BA                   0400    mov dx,#0x400
 +a   AA1F           B8                   23D2    mov ax,#9170
 +a   AA22           EF                           out dx,ax
37683                       0000AA23            post_d1_extended:
37684                                             ;; check that the extended type is 47 - user definable
37685 AA23           B0                     1A    mov al, #0x1a
37686 AA25           E6                     70    out #0x70, al
37687 AA27           E4                     71    in al, #0x71
37688 AA29           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
37689 AA2B           74           07              je post_d1_type47
37690                                             HALT(9178)
 +a   AA2D           BA                   0400    mov dx,#0x400
 +a   AA30           B8                   23DA    mov ax,#9178
 +a   AA33           EF                           out dx,ax
37691                       0000AA34            post_d1_type47:
37692                                             ;; Table for disk1.
37693                                             ;; CMOS purpose param table offset
37694                                             ;; 0x24 cylinders low 0
37695                                             ;; 0x25 cylinders high 1
37696                                             ;; 0x26 heads 2
37697                                             ;; 0x27 write pre-comp low 5
37698                                             ;; 0x28 write pre-comp high 6
37699                                             ;; 0x29 heads>8 8
37700                                             ;; 0x2a landing zone low C
37701                                             ;; 0x2b landing zone high D
37702                                             ;; 0x2c sectors/track E
37703                                           ;;; Fill EBDA table for hard disk 1.
37704 AA34           31C0                         xor ax, ax
37705 AA36           8ED8                         mov ds, ax
37706 AA38           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
37707 AA3B           8ED8                         mov ds, ax
37708 AA3D           B0                     28    mov al, #0x28
37709 AA3F           E6                     70    out #0x70, al
37710 AA41           E4                     71    in al, #0x71
37711 AA43           88C4                         mov ah, al
37712 AA45           B0                     27    mov al, #0x27
37713 AA47           E6                     70    out #0x70, al
37714 AA49           E4                     71    in al, #0x71
37715 AA4B           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
37716 AA4E           B0                     29    mov al, #0x29
37717 AA50           E6                     70    out #0x70, al
37718 AA52           E4                     71    in al, #0x71
37719 AA54           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
37720 AA57           B0                     2B    mov al, #0x2b
37721 AA59           E6                     70    out #0x70, al
37722 AA5B           E4                     71    in al, #0x71
37723 AA5D           88C4                         mov ah, al
37724 AA5F           B0                     2A    mov al, #0x2a
37725 AA61           E6                     70    out #0x70, al
37726 AA63           E4                     71    in al, #0x71
37727 AA65           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
37728 AA68           B0                     25    mov al, #0x25 ;; get cylinders word in AX
37729 AA6A           E6                     70    out #0x70, al
37730 AA6C           E4                     71    in al, #0x71 ;; high byte
37731 AA6E           88C4                         mov ah, al
37732 AA70           B0                     24    mov al, #0x24
37733 AA72           E6                     70    out #0x70, al
37734 AA74           E4                     71    in al, #0x71 ;; low byte
37735 AA76           89C3                         mov bx, ax ;; BX = cylinders
37736 AA78           B0                     26    mov al, #0x26
37737 AA7A           E6                     70    out #0x70, al
37738 AA7C           E4                     71    in al, #0x71
37739 AA7E           88C1                         mov cl, al ;; CL = heads
37740 AA80           B0                     2C    mov al, #0x2c
37741 AA82           E6                     70    out #0x70, al
37742 AA84           E4                     71    in al, #0x71
37743 AA86           88C2                         mov dl, al ;; DL = sectors
37744 AA88           81FB                 0400    cmp bx, #1024
37745 AA8C           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
37746                       0000AA8E            hd1_post_physical_chs:
37747                                             ;; no logical CHS mapping used, just physical CHS
37748                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
37749 AA8E           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
37750 AA92           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
37751 AA96           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
37752 AA9A           C3                           ret
37753                       0000AA9B            hd1_post_logical_chs:
37754                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
37755 AA9B           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
37756 AA9F           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
37757 AAA3           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
37758 AAA7           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
37759 AAAB           B0                     A0    mov al, #0xa0
37760 AAAD           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
37761 AAB0           81FB                 0800    cmp bx, #2048
37762 AAB4           77           06              jnbe hd1_post_above_2048
37763                                             ;; 1024 < c <= 2048 cylinders
37764 AAB6           D1EB                         shr bx, #0x01
37765 AAB8           D0E1                         shl cl, #0x01
37766 AABA           EB           22              jmp hd1_post_store_logical
37767                       0000AABC            hd1_post_above_2048:
37768 AABC           81FB                 1000    cmp bx, #4096
37769 AAC0           77           08              jnbe hd1_post_above_4096
37770                                             ;; 2048 < c <= 4096 cylinders
37771 AAC2           C1EB                   02    shr bx, #0x02
37772 AAC5           C0E1                   02    shl cl, #0x02
37773 AAC8           EB           14              jmp hd1_post_store_logical
37774                       0000AACA            hd1_post_above_4096:
37775 AACA           81FB                 2000    cmp bx, #8192
37776 AACE           77           08              jnbe hd1_post_above_8192
37777                                             ;; 4096 < c <= 8192 cylinders
37778 AAD0           C1EB                   03    shr bx, #0x03
37779 AAD3           C0E1                   03    shl cl, #0x03
37780 AAD6           EB           06              jmp hd1_post_store_logical
37781                       0000AAD8            hd1_post_above_8192:
37782                                             ;; 8192 < c <= 16384 cylinders
37783 AAD8           C1EB                   04    shr bx, #0x04
37784 AADB           C0E1                   04    shl cl, #0x04
37785                       0000AADE            hd1_post_store_logical:
37786 AADE           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
37787 AAE2           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
37788                                             ;; checksum
37789 AAE6           B1                     0F    mov cl, #0x0f ;; repeat count
37790 AAE8           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
37791 AAEB           B0                     00    mov al, #0x00 ;; sum
37792                       0000AAED            hd1_post_checksum_loop:
37793 AAED           0204                         add al, [si]
37794 AAEF           46                           inc si
37795 AAF0           FEC9                         dec cl
37796 AAF2           75           F9              jnz hd1_post_checksum_loop
37797 AAF4           F6D0                         not al ;; now take 2s complement
37798 AAF6           FEC0                         inc al
37799 AAF8           8804                         mov [si], al
37800                                           ;;; Done filling EBDA table for hard disk 1.
37801 AAFA           C3                           ret
37802                                           ;--------------------
37803                                           ;- POST: EBDA segment
37804                                           ;--------------------
37805                                           ; relocated here because the primary POST area isnt big enough.
37806                       0000AAFB            ebda_post:
37807 AAFB           B8                   9FC0    mov ax, #0x9FC0
37808 AAFE           8ED8                         mov ds, ax
37809 AB00           C606       0000        01    mov byte ptr [0x0], #1
37810 AB05           31C0                         xor ax, ax ; mov EBDA seg into 40E
37811 AB07           8ED8                         mov ds, ax
37812 AB09           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
37813 AB0F           C3                           ret;;
37814                                           ;--------------------
37815                                           ;- POST: EOI + jmp via [0x40:67)
37816                                           ;--------------------
37817                                           ; relocated here because the primary POST area isnt big enough.
37818                       0000AB10            eoi_jmp_post:
37819 AB10           B0                     20    mov al, #0x20
37820 AB12           E6                     A0    out #0xA0, al ;; slave PIC EOI
37821 AB14           B0                     20    mov al, #0x20
37822 AB16           E6                     20    out #0x20, al ;; master PIC EOI
37823                       0000AB18            jmp_post_0x467:
37824 AB18           31C0                         xor ax, ax
37825 AB1A           8ED8                         mov ds, ax
37826 AB1C           FF2E       0467              jmp far ptr [0x467]
37827                       0000AB20            iret_post_0x467:
37828 AB20           31C0                         xor ax, ax
37829 AB22           8ED8                         mov ds, ax
37830 AB24           8B26       0467              mov sp, [0x467]
37831 AB28           8E16       0469              mov ss, [0x469]
37832 AB2C           CF                           iret
37833                       0000AB2D            retf_post_0x467:
37834 AB2D           31C0                         xor ax, ax
37835 AB2F           8ED8                         mov ds, ax
37836 AB31           8B26       0467              mov sp, [0x467]
37837 AB35           8E16       0469              mov ss, [0x469]
37838 AB39           CB                           retf
37839                       0000AB3A            s3_post:
37840 AB3A           E8         6E14              call _s3_resume
37841 AB3D           B3                     00    mov bl, #0x00
37842 AB3F           21C0                         and ax, ax
37843 AB41   7503    E9         3561              jz normal_post
37844 AB46           E8         67F2              call _s3_resume_panic
37845                                           ;--------------------
37846                       0000AB49            eoi_both_pics:
37847 AB49           B0                     20    mov al, #0x20
37848 AB4B           E6                     A0    out #0xA0, al ;; slave PIC EOI
37849                       0000AB4D            eoi_master_pic:
37850 AB4D           B0                     20    mov al, #0x20
37851 AB4F           E6                     20    out #0x20, al ;; master PIC EOI
37852 AB51           C3                           ret
37853                                           ;--------------------
37854                       0000AB52            BcdToBin:
37855                                             ;; in: AL in BCD format
37856                                             ;; out: AL in binary format, AH will always be 0
37857                                             ;; trashes BX
37858 AB52           88C3                         mov bl, al
37859 AB54           80E3                   0F    and bl, #0x0f ;; bl has low digit
37860 AB57           C0E8                   04    shr al, #4 ;; al has high digit
37861 AB5A           B7                     0A    mov bh, #10
37862 AB5C           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
37863 AB5E           00D8                         add al, bl ;; then add low digit
37864 AB60           C3                           ret
37865                                           ;--------------------
37866                       0000AB61            timer_tick_post:
37867                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
37868                                             ;; Timer Ticks Roller Flag (0x470:byte)
37869                                             ;; The Timer Ticks Count needs to be set according to
37870                                             ;; the current CMOS time, as if ticks have been occurring
37871                                             ;; at 18.2hz since midnight up to this point. Calculating
37872                                             ;; this is a little complicated. Here are the factors I gather
37873                                             ;; regarding this. 14,318,180 hz was the original clock speed,
37874                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
37875                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
37876                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
37877                                             ;; the timer. With a maximum 16bit timer count, this is again
37878                                             ;; divided down by 65536 to 18.2hz.
37879                                             ;;
37880                                             ;; 14,318,180 Hz clock
37881                                             ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
37882                                             ;; /4 = 1,193,181 Hz fed to timer
37883                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
37884                                             ;; 1 second = 18.20650736 ticks
37885                                             ;; 1 minute = 1092.390442 ticks
37886                                             ;; 1 hour = 65543.42651 ticks
37887                                             ;;
37888                                             ;; Given the values in the CMOS clock, one could calculate
37889                                             ;; the number of ticks by the following:
37890                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
37891                                             ;; (BcdToBin(minutes) * 1092.3904)
37892                                             ;; (BcdToBin(hours) * 65543.427)
37893                                             ;; To get a little more accuracy, since Im using integer
37894                                             ;; arithmatic, I use:
37895                                             ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
37896                                             ;; (BcdToBin(minutes) * 10923904) / 10000 +
37897                                             ;; (BcdToBin(hours) * 65543427) / 1000
37898                                             ;; assuming DS=0000
37899                                             ;; get CMOS seconds
37900 AB61     66    31C0                         xor eax, eax ;; clear EAX
37901 AB64           B0                     00    mov al, #0x00
37902 AB66           E6                     70    out #0x70, al
37903 AB68           E4                     71    in al, #0x71 ;; AL has CMOS seconds in BCD
37904 AB6A           E8         FFE5              call BcdToBin ;; EAX now has seconds in binary
37905 AB6D     66    BA               0115CF2B    mov edx, #18206507
37906 AB73     66    F7E2                         mul eax, edx
37907 AB76     66    BB               000F4240    mov ebx, #1000000
37908 AB7C     66    31D2                         xor edx, edx
37909 AB7F     66    F7F3                         div eax, ebx
37910 AB82     66    89C1                         mov ecx, eax ;; ECX will accumulate total ticks
37911                                             ;; get CMOS minutes
37912 AB85     66    31C0                         xor eax, eax ;; clear EAX
37913 AB88           B0                     02    mov al, #0x02
37914 AB8A           E6                     70    out #0x70, al
37915 AB8C           E4                     71    in al, #0x71 ;; AL has CMOS minutes in BCD
37916 AB8E           E8         FFC1              call BcdToBin ;; EAX now has minutes in binary
37917 AB91     66    BA               00A6AF80    mov edx, #10923904
37918 AB97     66    F7E2                         mul eax, edx
37919 AB9A     66    BB               00002710    mov ebx, #10000
37920 ABA0     66    31D2                         xor edx, edx
37921 ABA3     66    F7F3                         div eax, ebx
37922 ABA6     66    01C1                         add ecx, eax ;; add to total ticks
37923                                             ;; get CMOS hours
37924 ABA9     66    31C0                         xor eax, eax ;; clear EAX
37925 ABAC           B0                     04    mov al, #0x04
37926 ABAE           E6                     70    out #0x70, al
37927 ABB0           E4                     71    in al, #0x71 ;; AL has CMOS hours in BCD
37928 ABB2           E8         FF9D              call BcdToBin ;; EAX now has hours in binary
37929 ABB5     66    BA               03E81D03    mov edx, #65543427
37930 ABBB     66    F7E2                         mul eax, edx
37931 ABBE     66    BB               000003E8    mov ebx, #1000
37932 ABC4     66    31D2                         xor edx, edx
37933 ABC7     66    F7F3                         div eax, ebx
37934 ABCA     66    01C1                         add ecx, eax ;; add to total ticks
37935 ABCD     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
37936 ABD2           30C0                         xor al, al
37937 ABD4           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
37938 ABD7           C3                           ret
37939                                           ;--------------------
37940                       0000ABD8            int76_handler:
37941                                             ;; record completion in BIOS task complete flag
37942 ABD8           50                           push ax
37943 ABD9           1E                           push ds
37944 ABDA           B8                   0040    mov ax, #0x0040
37945 ABDD           8ED8                         mov ds, ax
37946 ABDF           C706       008E      00FF    mov 0x008E, #0xff
37947 ABE5           E8         FF61              call eoi_both_pics
37948 ABE8           1F                           pop ds
37949 ABE9           58                           pop ax
37950 ABEA           CF                           iret
37951                                           ;--------------------
37952                                           use32 386
37953                       0000ABEB            apm32_out_str:
37954 ABEB           50                           push eax
37955 ABEC           53                           push ebx
37956 ABED           89C3                         mov ebx, eax
37957                       0000ABEF            apm32_out_str1:
37958 ABEF           2E                           SEG CS
37959 ABF0   67      8A07                         mov al, byte ptr [bx]
37960 ABF3           3C                     00    cmp al, #0
37961 ABF5           74           04              je apm32_out_str2
37962 ABF7           EE                           outb dx, al
37963 ABF8           43                           inc ebx
37964 ABF9           EB           F4              jmp apm32_out_str1
37965                       0000ABFB            apm32_out_str2:
37966 ABFB           5B                           pop ebx
37967 ABFC           58                           pop eax
37968 ABFD           C3                           ret
37969                       0000ABFE            apm32_07_poweroff_str:
37970 ABFE                        53              .ascii "Shutdown"
37971 AC06                        00              db 0
37972                       0000AC07            apm32_07_suspend_str:
37973 AC07                        53              .ascii "Suspend"
37974 AC0E                        00              db 0
37975                       0000AC0F            apm32_07_standby_str:
37976 AC0F                        53              .ascii "Standby"
37977 AC16                        00              db 0
37978                       0000AC17            _apm32_entry:
37979 AC17     66    9C                           pushf
37980                                           ;-----------------
37981                                           ; APM interface disconnect
37982                       0000AC19            apm32_04:
37983 AC19           3C                     04    cmp al, #0x04
37984 AC1B           75           05              jne apm32_05
37985 AC1D           E9     000000A5              jmp apm32_ok
37986                                           ;-----------------
37987                                           ; APM cpu idle
37988                       0000AC22            apm32_05:
37989 AC22           3C                     05    cmp al, #0x05
37990 AC24           75           0B              jne apm32_07
37991 AC26     66    9C                           pushf ; XEN
37992 AC28           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
37993 AC29           F4                           hlt
37994 AC2A     66    9D                           popf ; XEN
37995 AC2C           E9     00000096              jmp apm32_ok
37996                                           ;-----------------
37997                                           ; APM Set Power State
37998                       0000AC31            apm32_07:
37999 AC31           3C                     07    cmp al, #0x07
38000 AC33           75           52              jne apm32_08
38001 AC35     66    83FB                   01    cmp bx, #1
38002 AC39   7405    E9     00000087              jne apm32_ok
38003 AC40     66    83F9                   03    cmp cx, #3
38004 AC44           74           0E              je apm32_07_poweroff
38005 AC46     66    83F9                   02    cmp cx, #2
38006 AC4A           74           19              je apm32_07_suspend
38007 AC4C     66    83F9                   01    cmp cx, #1
38008 AC50           74           24              je apm32_07_standby
38009 AC52           75           73              jne apm32_ok
38010                       0000AC54            apm32_07_poweroff:
38011 AC54           FA                           cli
38012 AC55     66    BA                   8900    mov dx, #0x8900
38013 AC59     66    B8                   ABFE    mov ax, #apm32_07_poweroff_str
38014 AC5D           E8     FFFFFF89              call apm32_out_str
38015                       0000AC62            apm32_07_1:
38016 AC62           F4                           hlt
38017 AC63           EB           FD              jmp apm32_07_1
38018                       0000AC65            apm32_07_suspend:
38019 AC65           52                           push edx
38020 AC66     66    BA                   8900    mov dx, #0x8900
38021 AC6A     66    B8                   AC07    mov ax, #apm32_07_suspend_str
38022 AC6E           E8     FFFFFF78              call apm32_out_str
38023 AC73           5A                           pop edx
38024 AC74           EB           51              jmp apm32_ok
38025                       0000AC76            apm32_07_standby:
38026 AC76           52                           push edx
38027 AC77     66    BA                   8900    mov dx, #0x8900
38028 AC7B     66    B8                   AC0F    mov ax, #apm32_07_standby_str
38029 AC7F           E8     FFFFFF67              call apm32_out_str
38030 AC84           5A                           pop edx
38031 AC85           EB           40              jmp apm32_ok
38032                                           ;-----------------
38033                                           ; APM Enable / Disable
38034                       0000AC87            apm32_08:
38035 AC87           3C                     08    cmp al, #0x08
38036 AC89           75           02              jne apm32_0a
38037 AC8B           EB           3A              jmp apm32_ok
38038                                           ;-----------------
38039                                           ; Get Power Status
38040                       0000AC8D            apm32_0a:
38041 AC8D           3C                     0A    cmp al, #0x0a
38042 AC8F           75           12              jne apm32_0b
38043 AC91           B7                     01    mov bh, #0x01
38044 AC93           B3                     FF    mov bl, #0xff
38045 AC95           B5                     80    mov ch, #0x80
38046 AC97           B1                     FF    mov cl, #0xff
38047 AC99     66    BA                   FFFF    mov dx, #0xffff
38048 AC9D     66    BE                   0000    mov si, #0
38049 ACA1           EB           24              jmp apm32_ok
38050                                           ;-----------------
38051                                           ; Get PM Event
38052                       0000ACA3            apm32_0b:
38053 ACA3           3C                     0B    cmp al, #0x0b
38054 ACA5           75           04              jne apm32_0e
38055 ACA7           B4                     80    mov ah, #0x80
38056 ACA9           EB           20              jmp apm32_error
38057                                           ;-----------------
38058                                           ; APM Driver Version
38059                       0000ACAB            apm32_0e:
38060 ACAB           3C                     0E    cmp al, #0x0e
38061 ACAD           75           06              jne apm32_0f
38062 ACAF           B4                     01    mov ah, #1
38063 ACB1           B0                     02    mov al, #2
38064 ACB3           EB           12              jmp apm32_ok
38065                                           ;-----------------
38066                                           ; APM Engage / Disengage
38067                       0000ACB5            apm32_0f:
38068 ACB5           3C                     0F    cmp al, #0x0f
38069 ACB7           75           02              jne apm32_10
38070 ACB9           EB           0C              jmp apm32_ok
38071                                           ;-----------------
38072                                           ; APM Get Capabilities
38073                       0000ACBB            apm32_10:
38074 ACBB           3C                     10    cmp al, #0x10
38075 ACBD           75           0C              jne apm32_unimplemented
38076 ACBF           B3                     00    mov bl, #0
38077 ACC1     66    B9                   0000    mov cx, #0
38078 ACC5           EB           00              jmp apm32_ok
38079                                           ;-----------------
38080                       0000ACC7            apm32_ok:
38081 ACC7     66    9D                           popf
38082 ACC9           F8                           clc
38083 ACCA           CB                           retf
38084                       0000ACCB            apm32_unimplemented:
38085                       0000ACCB            apm32_error:
38086 ACCB     66    9D                           popf
38087 ACCD           F9                           stc
38088 ACCE           CB                           retf
38089                                           use16 386
38090                       0000ACCF            apm16_out_str:
38091 ACCF     66    50                           push eax
38092 ACD1     66    53                           push ebx
38093 ACD3     66    89C3                         mov ebx, eax
38094                       0000ACD6            apm16_out_str1:
38095 ACD6           2E                           SEG CS
38096 ACD7           8A07                         mov al, byte ptr [bx]
38097 ACD9           3C                     00    cmp al, #0
38098 ACDB           74           05              je apm16_out_str2
38099 ACDD           EE                           outb dx, al
38100 ACDE     66    43                           inc ebx
38101 ACE0           EB           F4              jmp apm16_out_str1
38102                       0000ACE2            apm16_out_str2:
38103 ACE2     66    5B                           pop ebx
38104 ACE4     66    58                           pop eax
38105 ACE6           C3                           ret
38106                       0000ACE7            apm16_07_poweroff_str:
38107 ACE7                        53              .ascii "Shutdown"
38108 ACEF                        00              db 0
38109                       0000ACF0            apm16_07_suspend_str:
38110 ACF0                        53              .ascii "Suspend"
38111 ACF7                        00              db 0
38112                       0000ACF8            apm16_07_standby_str:
38113 ACF8                        53              .ascii "Standby"
38114 ACFF                        00              db 0
38115                       0000AD00            _apm16_entry:
38116 AD00           9C                           pushf
38117                                           ;-----------------
38118                                           ; APM interface disconnect
38119                       0000AD01            apm16_04:
38120 AD01           3C                     04    cmp al, #0x04
38121 AD03           75           03              jne apm16_05
38122 AD05           E9         008D              jmp apm16_ok
38123                                           ;-----------------
38124                                           ; APM cpu idle
38125                       0000AD08            apm16_05:
38126 AD08           3C                     05    cmp al, #0x05
38127 AD0A           75           07              jne apm16_07
38128 AD0C           9C                           pushf ; XEN
38129 AD0D           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
38130 AD0E           F4                           hlt
38131 AD0F           9D                           popf ; XEN
38132 AD10           E9         0082              jmp apm16_ok
38133                                           ;-----------------
38134                                           ; APM Set Power State
38135                       0000AD13            apm16_07:
38136 AD13           3C                     07    cmp al, #0x07
38137 AD15           75           41              jne apm16_08
38138 AD17           83FB                   01    cmp bx, #1
38139 AD1A           75           79              jne apm16_ok
38140 AD1C           83F9                   03    cmp cx, #3
38141 AD1F           74           0C              je apm16_07_poweroff
38142 AD21           83F9                   02    cmp cx, #2
38143 AD24           74           14              je apm16_07_suspend
38144 AD26           83F9                   01    cmp cx, #1
38145 AD29           74           1E              je apm16_07_standby
38146 AD2B           75           68              jne apm16_ok
38147                       0000AD2D            apm16_07_poweroff:
38148 AD2D           FA                           cli
38149 AD2E           BA                   8900    mov dx, #0x8900
38150 AD31           B8                   ACE7    mov ax, #apm16_07_poweroff_str
38151 AD34           E8         FF98              call apm16_out_str
38152                       0000AD37            apm16_07_1:
38153 AD37           F4                           hlt
38154 AD38           EB           FD              jmp apm16_07_1
38155                       0000AD3A            apm16_07_suspend:
38156 AD3A     66    52                           push edx
38157 AD3C           BA                   8900    mov dx, #0x8900
38158 AD3F           B8                   ACF0    mov ax, #apm16_07_suspend_str
38159 AD42           E8         FF8A              call apm16_out_str
38160 AD45     66    5A                           pop edx
38161 AD47           EB           4C              jmp apm16_ok
38162                       0000AD49            apm16_07_standby:
38163 AD49     66    52                           push edx
38164 AD4B           BA                   8900    mov dx, #0x8900
38165 AD4E           B8                   ACF8    mov ax, #apm16_07_standby_str
38166 AD51           E8         FF7B              call apm16_out_str
38167 AD54     66    5A                           pop edx
38168 AD56           EB           3D              jmp apm16_ok
38169                                           ;-----------------
38170                                           ; APM Enable / Disable
38171                       0000AD58            apm16_08:
38172 AD58           3C                     08    cmp al, #0x08
38173 AD5A           75           02              jne apm16_0a
38174 AD5C           EB           37              jmp apm16_ok
38175                                           ;-----------------
38176                                           ; Get Power Status
38177                       0000AD5E            apm16_0a:
38178 AD5E           3C                     0A    cmp al, #0x0a
38179 AD60           75           10              jne apm16_0b
38180 AD62           B7                     01    mov bh, #0x01
38181 AD64           B3                     FF    mov bl, #0xff
38182 AD66           B5                     80    mov ch, #0x80
38183 AD68           B1                     FF    mov cl, #0xff
38184 AD6A           BA                   FFFF    mov dx, #0xffff
38185 AD6D           BE                   0000    mov si, #0
38186 AD70           EB           23              jmp apm16_ok
38187                                           ;-----------------
38188                                           ; Get PM Event
38189                       0000AD72            apm16_0b:
38190 AD72           3C                     0B    cmp al, #0x0b
38191 AD74           75           04              jne apm16_0e
38192 AD76           B4                     80    mov ah, #0x80
38193 AD78           EB           1E              jmp apm16_error
38194                                           ;-----------------
38195                                           ; APM Driver Version
38196                       0000AD7A            apm16_0e:
38197 AD7A           3C                     0E    cmp al, #0x0e
38198 AD7C           75           06              jne apm16_0f
38199 AD7E           B4                     01    mov ah, #1
38200 AD80           B0                     02    mov al, #2
38201 AD82           EB           11              jmp apm16_ok
38202                                           ;-----------------
38203                                           ; APM Engage / Disengage
38204                       0000AD84            apm16_0f:
38205 AD84           3C                     0F    cmp al, #0x0f
38206 AD86           75           02              jne apm16_10
38207 AD88           EB           0B              jmp apm16_ok
38208                                           ;-----------------
38209                                           ; APM Get Capabilities
38210                       0000AD8A            apm16_10:
38211 AD8A           3C                     10    cmp al, #0x10
38212 AD8C           75           0A              jne apm16_unimplemented
38213 AD8E           B3                     00    mov bl, #0
38214 AD90           B9                   0000    mov cx, #0
38215 AD93           EB           00              jmp apm16_ok
38216                                           ;-----------------
38217                       0000AD95            apm16_ok:
38218 AD95           9D                           popf
38219 AD96           F8                           clc
38220 AD97           CB                           retf
38221                       0000AD98            apm16_unimplemented:
38222                       0000AD98            apm16_error:
38223 AD98           9D                           popf
38224 AD99           F9                           stc
38225 AD9A           CB                           retf
38226                       0000AD9B            apmreal_out_str:
38227 AD9B     66    50                           push eax
38228 AD9D     66    53                           push ebx
38229 AD9F     66    89C3                         mov ebx, eax
38230                       0000ADA2            apmreal_out_str1:
38231 ADA2           2E                           SEG CS
38232 ADA3           8A07                         mov al, byte ptr [bx]
38233 ADA5           3C                     00    cmp al, #0
38234 ADA7           74           05              je apmreal_out_str2
38235 ADA9           EE                           outb dx, al
38236 ADAA     66    43                           inc ebx
38237 ADAC           EB           F4              jmp apmreal_out_str1
38238                       0000ADAE            apmreal_out_str2:
38239 ADAE     66    5B                           pop ebx
38240 ADB0     66    58                           pop eax
38241 ADB2           C3                           ret
38242                       0000ADB3            apmreal_07_poweroff_str:
38243 ADB3                        53              .ascii "Shutdown"
38244 ADBB                        00              db 0
38245                       0000ADBC            apmreal_07_suspend_str:
38246 ADBC                        53              .ascii "Suspend"
38247 ADC3                        00              db 0
38248                       0000ADC4            apmreal_07_standby_str:
38249 ADC4                        53              .ascii "Standby"
38250 ADCB                        00              db 0
38251 ADCC           9C                           pushf
38252                       0000ADCD            _apmreal_entry:
38253                                           ;-----------------
38254                                           ; APM installation check
38255                       0000ADCD            apmreal_00:
38256 ADCD           3C                     00    cmp al, #0x00
38257 ADCF           75           0E              jne apmreal_01
38258 ADD1           B4                     01    mov ah, #1
38259 ADD3           B0                     02    mov al, #2
38260 ADD5           B7                     50    mov bh, #0x50
38261 ADD7           B3                     4D    mov bl, #0x4d
38262 ADD9           B9                   0003    mov cx, #0x3
38263 ADDC           E9         00D0              jmp apmreal_ok
38264                                           ;-----------------
38265                                           ; APM real mode interface connect
38266                       0000ADDF            apmreal_01:
38267 ADDF           3C                     01    cmp al, #0x01
38268 ADE1           75           03              jne apmreal_02
38269 ADE3           E9         00C9              jmp apmreal_ok
38270                                           ;-----------------
38271                                           ; APM 16 bit protected mode interface connect
38272                       0000ADE6            apmreal_02:
38273 ADE6           3C                     02    cmp al, #0x02
38274 ADE8           75           12              jne apmreal_03
38275 ADEA           BB                   AD00    mov bx, #_apm16_entry
38276 ADED           B8                   F000    mov ax, #0xf000
38277 ADF0           BE                   FFF0    mov si, #0xfff0
38278 ADF3           B9                   F000    mov cx, #0xf000
38279 ADF6           BF                   FFF0    mov di, #0xfff0
38280 ADF9           E9         00B3              jmp apmreal_ok
38281                                           ;-----------------
38282                                           ; APM 32 bit protected mode interface connect
38283                       0000ADFC            apmreal_03:
38284 ADFC           3C                     03    cmp al, #0x03
38285 ADFE           75           1B              jne apmreal_04
38286 AE00           B8                   F000    mov ax, #0xf000
38287 AE03     66    BB               0000AC17    mov ebx, #_apm32_entry
38288 AE09           B9                   F000    mov cx, #0xf000
38289 AE0C     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
38290 AE12           BA                   F000    mov dx, #0xf000
38291 AE15           BF                   FFF0    mov di, #0xfff0
38292 AE18           E9         0094              jmp apmreal_ok
38293                                           ;-----------------
38294                                           ; APM interface disconnect
38295                       0000AE1B            apmreal_04:
38296 AE1B           3C                     04    cmp al, #0x04
38297 AE1D           75           03              jne apmreal_05
38298 AE1F           E9         008D              jmp apmreal_ok
38299                                           ;-----------------
38300                                           ; APM cpu idle
38301                       0000AE22            apmreal_05:
38302 AE22           3C                     05    cmp al, #0x05
38303 AE24           75           07              jne apmreal_07
38304 AE26           9C                           pushf ; XEN
38305 AE27           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
38306 AE28           F4                           hlt
38307 AE29           9D                           popf ; XEN
38308 AE2A           E9         0082              jmp apmreal_ok
38309                                           ;-----------------
38310                                           ; APM Set Power State
38311                       0000AE2D            apmreal_07:
38312 AE2D           3C                     07    cmp al, #0x07
38313 AE2F           75           41              jne apmreal_08
38314 AE31           83FB                   01    cmp bx, #1
38315 AE34           75           79              jne apmreal_ok
38316 AE36           83F9                   03    cmp cx, #3
38317 AE39           74           0C              je apmreal_07_poweroff
38318 AE3B           83F9                   02    cmp cx, #2
38319 AE3E           74           14              je apmreal_07_suspend
38320 AE40           83F9                   01    cmp cx, #1
38321 AE43           74           1E              je apmreal_07_standby
38322 AE45           75           68              jne apmreal_ok
38323                       0000AE47            apmreal_07_poweroff:
38324 AE47           FA                           cli
38325 AE48           BA                   8900    mov dx, #0x8900
38326 AE4B           B8                   ADB3    mov ax, #apmreal_07_poweroff_str
38327 AE4E           E8         FF4A              call apmreal_out_str
38328                       0000AE51            apmreal_07_1:
38329 AE51           F4                           hlt
38330 AE52           EB           FD              jmp apmreal_07_1
38331                       0000AE54            apmreal_07_suspend:
38332 AE54     66    52                           push edx
38333 AE56           BA                   8900    mov dx, #0x8900
38334 AE59           B8                   ADBC    mov ax, #apmreal_07_suspend_str
38335 AE5C           E8         FF3C              call apmreal_out_str
38336 AE5F     66    5A                           pop edx
38337 AE61           EB           4C              jmp apmreal_ok
38338                       0000AE63            apmreal_07_standby:
38339 AE63     66    52                           push edx
38340 AE65           BA                   8900    mov dx, #0x8900
38341 AE68           B8                   ADC4    mov ax, #apmreal_07_standby_str
38342 AE6B           E8         FF2D              call apmreal_out_str
38343 AE6E     66    5A                           pop edx
38344 AE70           EB           3D              jmp apmreal_ok
38345                                           ;-----------------
38346                                           ; APM Enable / Disable
38347                       0000AE72            apmreal_08:
38348 AE72           3C                     08    cmp al, #0x08
38349 AE74           75           02              jne apmreal_0a
38350 AE76           EB           37              jmp apmreal_ok
38351                                           ;-----------------
38352                                           ; Get Power Status
38353                       0000AE78            apmreal_0a:
38354 AE78           3C                     0A    cmp al, #0x0a
38355 AE7A           75           10              jne apmreal_0b
38356 AE7C           B7                     01    mov bh, #0x01
38357 AE7E           B3                     FF    mov bl, #0xff
38358 AE80           B5                     80    mov ch, #0x80
38359 AE82           B1                     FF    mov cl, #0xff
38360 AE84           BA                   FFFF    mov dx, #0xffff
38361 AE87           BE                   0000    mov si, #0
38362 AE8A           EB           23              jmp apmreal_ok
38363                                           ;-----------------
38364                                           ; Get PM Event
38365                       0000AE8C            apmreal_0b:
38366 AE8C           3C                     0B    cmp al, #0x0b
38367 AE8E           75           04              jne apmreal_0e
38368 AE90           B4                     80    mov ah, #0x80
38369 AE92           EB           20              jmp apmreal_error
38370                                           ;-----------------
38371                                           ; APM Driver Version
38372                       0000AE94            apmreal_0e:
38373 AE94           3C                     0E    cmp al, #0x0e
38374 AE96           75           06              jne apmreal_0f
38375 AE98           B4                     01    mov ah, #1
38376 AE9A           B0                     02    mov al, #2
38377 AE9C           EB           11              jmp apmreal_ok
38378                                           ;-----------------
38379                                           ; APM Engage / Disengage
38380                       0000AE9E            apmreal_0f:
38381 AE9E           3C                     0F    cmp al, #0x0f
38382 AEA0           75           02              jne apmreal_10
38383 AEA2           EB           0B              jmp apmreal_ok
38384                                           ;-----------------
38385                                           ; APM Get Capabilities
38386                       0000AEA4            apmreal_10:
38387 AEA4           3C                     10    cmp al, #0x10
38388 AEA6           75           0C              jne apmreal_unimplemented
38389 AEA8           B3                     00    mov bl, #0
38390 AEAA           B9                   0000    mov cx, #0
38391 AEAD           EB           00              jmp apmreal_ok
38392                                           ;-----------------
38393                       0000AEAF            apmreal_ok:
38394 AEAF           9D                           popf
38395 AEB0           F8                           clc
38396 AEB1           E9         F8C6              jmp iret_modify_cf
38397                       0000AEB4            apmreal_unimplemented:
38398                       0000AEB4            apmreal_error:
38399 AEB4           9D                           popf
38400 AEB5           F9                           stc
38401 AEB6           E9         F8C1              jmp iret_modify_cf
38402 AEB9                  00000010                .align 16
38403                       0000AEC0            gdt_base:
38404 AEC0                      0000                .word 0,0
38405 AEC4                        00                .byte 0,0,0,0
38406                       0000AEC8            gdt_entry_pm_32bit_cs:
38407 AEC8                      FFFF                .word 0xffff, 0x0000
38408 AECC                        00                .byte 0x00, 0x9b, 0xcf, 0x00
38409                       0000AED0            gdt_entry_pm_16bit_cs:
38410 AED0                      FFFF                .word 0xffff, 0x0000
38411 AED4                        0F                .byte 0xf0000 >> 16, 0x9b, 0x8f, 0x0
38412                       0000AED8            gdt_entry_pm_32bit_ds:
38413 AED8                      FFFF                .word 0xffff, 0x0000
38414 AEDC                        00                .byte 0x0, 0x93, 0xcf, 0x0
38415                       0000AEE0            gdt_entry_pm_16bit_ds:
38416 AEE0                      FFFF                .word 0xffff, 0x0000
38417 AEE4                        00                .byte 0x0, 0x93, 0x8f, 0x0
38418                       0000AEE8            gdt_entry_end:
38419                       0000AEE8            protmode_gdtdesc:
38420 AEE8                      0027                .word (gdt_entry_end - gdt_base) - 1
38421 AEEA                  000FAEC0                .long gdt_base | 0xf0000
38422                       0000AEEE            realmode_gdtdesc:
38423 AEEE                      FFFF                .word 0xffff
38424 AEF0                  00000000                .long 0x0
38425                       0000AEF4            Upcall:
38426                                               ; Do an upcall into 32 bit space
38427                                               ;
38428                                               ; Input:
38429                                               ; bx: index of function to call
38430                                               ; Ouput:
38431                                               ; dx, ax: 32 bit result of call (even if 'void' is expected)
38432                                               ; Save caller state, stack frame offsets listed below
38433 AEF4           9C                             pushf
38434 AEF5           FA                             cli
38435 AEF6           1E                             push ds
38436 AEF7           06                             push es
38437 AEF8           16                             push ss
38438 AEF9     66    54                             push esp
38439                                               ; Calculate protected-mode esp from ss:sp
38440 AEFB     66    81E4             0000FFFF      and esp, #0xffff
38441 AF02     66    31C0                           xor eax, eax
38442 AF05           8CD0                           mov ax, ss
38443 AF07     66    C1E0                   04      shl eax, #4
38444 AF0B     66    01C4                           add esp, eax
38445                                               ; Switch to protected mode
38446 AF0E           2E                             seg cs
38447 AF0F         0F0116       AEE8                lgdt protmode_gdtdesc
38448 AF14         0F20C0                           mov eax, cr0
38449 AF17           0C                     01      or al, #0x1 ; protected mode on
38450 AF19         0F22C0                           mov cr0, eax
38451 AF1C     66    EA     000FAF24      0008      jmpf DWORD (0xf0000|upcall1), #(gdt_entry_pm_32bit_cs - gdt_base)
38452                       0000AF24            upcall1:
38453                                               USE32
38454 AF24     66    B8                   0018      mov ax, #(gdt_entry_pm_32bit_ds - gdt_base)
38455 AF28           8ED8                           mov ds, ax
38456 AF2A           8EC0                           mov es, ax
38457 AF2C           8ED0                           mov ss, ax
38458                                               ; Marshal arguments and call 32-bit function
38459 AF2E           B9               00000008      mov ecx, #32/4
38460                       0000AF33            upcall2:
38461 AF33           FF7424       2A                push 32 -4+14[esp]
38462 AF37           E2           FA                loop upcall2
38463 AF39           A1     000EA000                mov eax, [0x000EA000 + 0]
38464 AF3E           FFD0                           call eax
38465 AF40           83C4                   20      add esp, #32
38466 AF43           89C1                           mov ecx, eax ; Result in ecx
38467                                               ; Restore real-mode stack pointer
38468 AF45           31C0                           xor eax, eax
38469 AF47     66    8B4424       04                mov ax, 4[esp]
38470 AF4C     66    89C3                           mov bx, ax ; Real-mode ss in bx
38471 AF4F           C1E0                   04      shl eax, 4
38472 AF52           29C4                           sub esp, eax
38473                                               ; Return to real mode
38474 AF54           EA     0000AF5B      0010      jmpf upcall3, #(gdt_entry_pm_16bit_cs - gdt_base)
38475                       0000AF5B            upcall3:
38476                                               USE16
38477 AF5B           B8                   0020      mov ax, #(gdt_entry_pm_16bit_ds - gdt_base)
38478 AF5E           8ED8                           mov ds, ax
38479 AF60           8EC0                           mov es, ax
38480 AF62           8ED0                           mov ss, ax
38481 AF64         0F20C0                           mov eax, cr0
38482 AF67           24                     FE      and al, #0xfe ; protected mode off
38483 AF69         0F22C0                           mov cr0, eax
38484 AF6C           EA         AF71      F000      jmpf upcall4, #0xf0000>>4
38485                       0000AF71            upcall4:
38486 AF71           2E                             seg cs
38487 AF72         0F0116       AEEE                lgdt realmode_gdtdesc
38488                                               ; Restore real-mode ss
38489 AF77           8ED3                           mov ss, bx
38490                                               ; Convert result into dx:ax format
38491 AF79     66    89C8                           mov eax, ecx
38492 AF7C     66    C1C8                   10      ror eax, #16
38493 AF80           89C2                           mov dx, ax
38494 AF82     66    C1C8                   10      ror eax, #16
38495                                               ; Restore caller state and return
38496 AF86     66    5C                             pop esp
38497 AF88           5B                             pop bx ; skip ss
38498 AF89           07                             pop es
38499 AF8A           1F                             pop ds
38500 AF8B           9D                             popf
38501 AF8C           C3                             ret
38502                                           MACRO DoUpcall
38503                                               mov bx, #?1
38504                                               jmp Upcall
38505                                           MEND
38506                       0000AF8D            _TCGInterruptHandler: DoUpcall(0)
 +a   AF8D           BB                   0000      mov bx, #0
 +a   AF90           E9         FF61                jmp Upcall
38507                       0000AF93            _tcpa_acpi_init: DoUpcall(1)
 +a   AF93           BB                   0001      mov bx, #1
 +a   AF96           E9         FF5B                jmp Upcall
38508                       0000AF99            _tcpa_extend_acpi_log: DoUpcall(2)
 +a   AF99           BB                   0002      mov bx, #2
 +a   AF9C           E9         FF55                jmp Upcall
38509                       0000AF9F            _tcpa_calling_int19h: DoUpcall(3)
 +a   AF9F           BB                   0003      mov bx, #3
 +a   AFA2           E9         FF4F                jmp Upcall
38510                       0000AFA5            _tcpa_returned_int19h: DoUpcall(4)
 +a   AFA5           BB                   0004      mov bx, #4
 +a   AFA8           E9         FF49                jmp Upcall
38511                       0000AFAB            _tcpa_add_event_separators: DoUpcall(5)
 +a   AFAB           BB                   0005      mov bx, #5
 +a   AFAE           E9         FF43                jmp Upcall
38512                       0000AFB1            _tcpa_wake_event: DoUpcall(6)
 +a   AFB1           BB                   0006      mov bx, #6
 +a   AFB4           E9         FF3D                jmp Upcall
38513                       0000AFB7            _tcpa_add_bootdevice: DoUpcall(7)
 +a   AFB7           BB                   0007      mov bx, #7
 +a   AFBA           E9         FF37                jmp Upcall
38514                       0000AFBD            _tcpa_start_option_rom_scan: DoUpcall(8)
 +a   AFBD           BB                   0008      mov bx, #8
 +a   AFC0           E9         FF31                jmp Upcall
38515                       0000AFC3            _tcpa_option_rom: DoUpcall(9)
 +a   AFC3           BB                   0009      mov bx, #9
 +a   AFC6           E9         FF2B                jmp Upcall
38516                       0000AFC9            _tcpa_ipl: DoUpcall(10)
 +a   AFC9           BB                   000A      mov bx, #10
 +a   AFCC           E9         FF25                jmp Upcall
38517                       0000AFCF            _tcpa_measure_post: DoUpcall(11)
 +a   AFCF           BB                   000B      mov bx, #11
 +a   AFD2           E9         FF1F                jmp Upcall
38518                       0000AFD5            _tcpa_initialize_tpm: DoUpcall(12)
 +a   AFD5           BB                   000C      mov bx, #12
 +a   AFD8           E9         FF19                jmp Upcall
38519                       0000AFDB            _get_s3_waking_vector: DoUpcall(13)
 +a   AFDB           BB                   000D      mov bx, #13
 +a   AFDE           E9         FF13                jmp Upcall
38520                       0000AFE1            _pmm: DoUpcall(14)
 +a   AFE1           BB                   000E      mov bx, #14
 +a   AFE4           E9         FF0D                jmp Upcall
38521                                           ! 6676 endasm
38522                                           !BCC_ENDASM
38523                                           ! 6677 #asm
38524                                           !BCC_ASM
38525                       00000012            _int70_function.ds	set	$12
38526                       00000014            _int70_function.iret_addr	set	$14
38527                       00000002            _int70_function.regs	set	2
38528                                           MACRO POST_MEASURE
38529                                            push word #0x000f
38530                                            push #?2
38531                                            push word #0x000f
38532                                            push #?1
38533                                            call _tcpa_measure_post
38534                                            add sp, #8
38535                                           MEND
38536                                           ! 6686 endasm
38537                                           !BCC_ENDASM
38538                                           ! 6687 void
38539                                           ! Register BX used in function int70_function
38540                                           ! 6688 tcpa_do_measure_POSTs()
38541                                           ! 6689 {
38542                                           export	_tcpa_do_measure_POSTs
38543                       0000AFE7            _tcpa_do_measure_POSTs:
38544                                           ! 6690 #asm
38545                                           !BCC_ASM
38546                                            POST_MEASURE(post, nmi)
 +a   AFE7           6A                     0F   push word #0x000f
 +a   AFE9           68                   E2C3   push # nmi
 +a   AFEC           6A                     0F   push word #0x000f
 +a   AFEE           68                   E05B   push #post
 +a   AFF1           E8         FFDB             call _tcpa_measure_post
 +a   AFF4           83C4                   08   add sp, #8
38547                                            POST_MEASURE(floppy_drive_post, hard_drive_post)
 +a   AFF7           6A                     0F   push word #0x000f
 +a   AFF9           68                   A8D3   push # hard_drive_post
 +a   AFFC           6A                     0F   push word #0x000f
 +a   AFFE           68                   A84C   push #floppy_drive_post
 +a   B001           E8         FFCB             call _tcpa_measure_post
 +a   B004           83C4                   08   add sp, #8
38548                                            POST_MEASURE(hard_drive_post, ebda_post)
 +a   B007           6A                     0F   push word #0x000f
 +a   B009           68                   AAFB   push # ebda_post
 +a   B00C           6A                     0F   push word #0x000f
 +a   B00E           68                   A8D3   push #hard_drive_post
 +a   B011           E8         FFBB             call _tcpa_measure_post
 +a   B014           83C4                   08   add sp, #8
38549                                            POST_MEASURE(ebda_post, eoi_jmp_post)
 +a   B017           6A                     0F   push word #0x000f
 +a   B019           68                   AB10   push # eoi_jmp_post
 +a   B01C           6A                     0F   push word #0x000f
 +a   B01E           68                   AAFB   push #ebda_post
 +a   B021           E8         FFAB             call _tcpa_measure_post
 +a   B024           83C4                   08   add sp, #8
38550                                            POST_MEASURE(eoi_jmp_post, timer_tick_post)
 +a   B027           6A                     0F   push word #0x000f
 +a   B029           68                   AB61   push # timer_tick_post
 +a   B02C           6A                     0F   push word #0x000f
 +a   B02E           68                   AB10   push #eoi_jmp_post
 +a   B031           E8         FF9B             call _tcpa_measure_post
 +a   B034           83C4                   08   add sp, #8
38551                                            POST_MEASURE(timer_tick_post, int76_handler)
 +a   B037           6A                     0F   push word #0x000f
 +a   B039           68                   ABD8   push # int76_handler
 +a   B03C           6A                     0F   push word #0x000f
 +a   B03E           68                   AB61   push #timer_tick_post
 +a   B041           E8         FF8B             call _tcpa_measure_post
 +a   B044           83C4                   08   add sp, #8
38552 B047           C3                          ret
38553                                           ! 6698 endasm
38554                                           !BCC_ENDASM
38555                                           ! 6699 }
38556 B048           C3                         ret
38557                                           ! 6700   void
38558                                           ! 6701 int1a_function32(regs, ES, DS, FLAGS)
38559                                           ! 6702   pushad_regs_t regs;
38560                                           export	_int1a_function32
38561                       0000B049            _int1a_function32:
38562                                           !BCC_EOS
38563                                           ! 6703   Bit16u ES, DS, FLAGS;
38564                                           !BCC_EOS
38565                                           ! 6704 {
38566                                           ! 6705  Bit16u rc;
38567                                           !BCC_EOS
38568                                           ! 6706  ;
38569 B049           55                         push	bp
38570 B04A           89E5                       mov	bp,sp
38571 B04C           4C                         dec	sp
38572 B04D           4C                         dec	sp
38573                                           !BCC_EOS
38574                                           ! 6707  switch (regs.u.r8.ah) {
38575 B04E           8A46         21            mov	al,$21[bp]
38576 B051           E9         00BC            br 	.770
38577                                           ! 6708  case 0xbb:
38578                                           ! 6709   if (regs.u.r8.al != 0 &&
38579                       0000B054            .771:
38580                                           ! 6710       regs.u.r32.ebx != 0x41504354L) {
38581                                           ! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
38582 B054           8A46         20            mov	al,$20[bp]
38583 B057           84C0                       test	al,al
38584 B059           74           25            je  	.772
38585                       0000B05B            .774:
38586                                           ! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
38587                                           ! Debug: expression subtree swapping
38588 B05B           B8                   4354  mov	ax,#$4354
38589 B05E           BB                   4150  mov	bx,#$4150
38590 B061           53                         push	bx
38591 B062           50                         push	ax
38592 B063           8B46         14            mov	ax,$14[bp]
38593 B066           8B5E         16            mov	bx,$16[bp]
38594 B069           8D7E         FA            lea	di,-2+..FFD9[bp]
38595 B06C           E8         505C            call	lcmpul
38596 B06F           8D66         FE            lea	sp,2+..FFD9[bp]
38597 B072           74           0C            je  	.772
38598                       0000B074            .773:
38599                                           ! 6711       FLAGS |= 0x0001;
38600                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38601 B074           8B46         28            mov	ax,$28[bp]
38602 B077           0C                     01  or	al,*1
38603 B079           8946         28            mov	$28[bp],ax
38604                                           !BCC_EOS
38605                                           ! 6712       return;
38606 B07C           89EC                       mov	sp,bp
38607 B07E           5D                         pop	bp
38608 B07F           C3                         ret
38609                                           !BCC_EOS
38610                                           ! 6713   }
38611                                           ! 6714   switch(regs.u.r8.al) {
38612                       0000B080            .772:
38613 B080           8A46         20            mov	al,$20[bp]
38614 B083           EB           58            jmp .777
38615                                           ! 6715   case 0x00:
38616                                           ! 6716   case 0x01:
38617                       0000B085            .778:
38618                                           ! 6717   case 0x02:
38619                       0000B085            .779:
38620                                           ! 6718   case 0x03:
38621                       0000B085            .77A:
38622                                           ! 6719   case 0x04:
38623                       0000B085            .77B:
38624                                           ! 6720   case 0x05:
38625                       0000B085            .77C:
38626                                           ! 6721   case 0x06:
38627                       0000B085            .77D:
38628                                           ! 6722   case 0x07:
38629                       0000B085            .77E:
38630                                           ! 6723    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
38631                       0000B085            .77F:
38632                                           ! 6724                        ES, DS,
38633                                           ! 6725                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
38634                                           ! Debug: expression subtree swapping
38635                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
38636 B085           E8         55C5            call	_get_SS
38637                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
38638 B088           31DB                       xor	bx,bx
38639                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
38640 B08A           BF                   0004  mov	di,*4
38641 B08D           E8         50B7            call	lslul
38642 B090           53                         push	bx
38643 B091           50                         push	ax
38644                                           ! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
38645 B092           89E8                       mov	ax,bp
38646 B094           05                   0028  add	ax,*$28
38647 B097           31DB                       xor	bx,bx
38648                                           ! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
38649 B099           8D7E         FA            lea	di,-2+..FFD9[bp]
38650 B09C           E8         5024            call	laddul
38651 B09F           83C4                   04  add	sp,*4
38652                                           ! Debug: list unsigned long = bx+0 (used reg = )
38653 B0A2           53                         push	bx
38654 B0A3           50                         push	ax
38655                                           ! Debug: list unsigned short DS = [S+8+$24] (used reg = )
38656 B0A4           FF76         26            push	$26[bp]
38657                                           ! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
38658 B0A7           FF76         24            push	$24[bp]
38659                                           ! Debug: expression subtree swapping
38660                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
38661 B0AA           E8         55A0            call	_get_SS
38662                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
38663 B0AD           31DB                       xor	bx,bx
38664                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
38665 B0AF           BF                   0004  mov	di,*4
38666 B0B2           E8         5092            call	lslul
38667 B0B5           53                         push	bx
38668 B0B6           50                         push	ax
38669                                           ! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
38670 B0B7           89E8                       mov	ax,bp
38671 B0B9           05                   0004  add	ax,*4
38672 B0BC           31DB                       xor	bx,bx
38673                                           ! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
38674 B0BE           8D7E         F2            lea	di,-$A+..FFD9[bp]
38675 B0C1           E8         4FFF            call	laddul
38676 B0C4           83C4                   04  add	sp,*4
38677                                           ! Debug: list unsigned long = bx+0 (used reg = )
38678 B0C7           53                         push	bx
38679 B0C8           50                         push	ax
38680                                           ! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
38681 B0C9           E8         FEC1            call	_TCGInterruptHandler
38682 B0CC           89D3                       mov	bx,dx
38683 B0CE           83C4                   0C  add	sp,*$C
38684                                           !BCC_EOS
38685                                           ! 6726    break;
38686 B0D1           EB           2F            jmp .775
38687                                           !BCC_EOS
38688                                           ! 6727   default:
38689                                           ! 6728    FLAGS |= 0x0001;
38690                       0000B0D3            .780:
38691                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38692 B0D3           8B46         28            mov	ax,$28[bp]
38693 B0D6           0C                     01  or	al,*1
38694 B0D8           8946         28            mov	$28[bp],ax
38695                                           !BCC_EOS
38696                                           ! 6729   }
38697                                           ! 6730   break;
38698 B0DB           EB           25            jmp .775
38699                       0000B0DD            .777:
38700 B0DD           2C                     00  sub	al,*0
38701 B0DF           72           F2            jb 	.780
38702 B0E1           3C                     07  cmp	al,*7
38703 B0E3           77           1B            ja  	.781
38704 B0E5           30E4                       xor	ah,ah
38705 B0E7           D1E0                       shl	ax,*1
38706 B0E9           89C3                       mov	bx,ax
38707 B0EB           2E                         seg	cs
38708 B0EC           FFA7       B0F0            br	.782[bx]
38709                       0000B0F0            .782:
38710 B0F0                      B085            .word	.778
38711 B0F2                      B085            .word	.779
38712 B0F4                      B085            .word	.77A
38713 B0F6                      B085            .word	.77B
38714 B0F8                      B085            .word	.77C
38715 B0FA                      B085            .word	.77D
38716 B0FC                      B085            .word	.77E
38717 B0FE                      B085            .word	.77F
38718                       0000B100            .781:
38719 B100           EB           D1            jmp	.780
38720                       0000B102            .775:
38721 B102           EB           14            jmp .76E
38722                                           !BCC_EOS
38723                                           ! 6731  default:
38724                                           ! 6732   FLAGS |= 0x0001;
38725                       0000B104            .783:
38726                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38727 B104           8B46         28            mov	ax,$28[bp]
38728 B107           0C                     01  or	al,*1
38729 B109           8946         28            mov	$28[bp],ax
38730                                           !BCC_EOS
38731                                           ! 6733   break;
38732 B10C           EB           0A            jmp .76E
38733                                           !BCC_EOS
38734                                           ! 6734  }
38735                                           ! 6735  ;
38736 B10E           EB           08            jmp .76E
38737                       0000B110            .770:
38738 B110           2C                     BB  sub	al,#$BB
38739 B112         0F84         FF3E            beq 	.771
38740 B116           EB           EC            jmp	.783
38741                       0000B118            .76E:
38742                       FFFFFFFC            ..FFD9	=	-4
38743                                           !BCC_EOS
38744                                           ! 6736 }
38745 B118           89EC                       mov	sp,bp
38746 B11A           5D                         pop	bp
38747 B11B           C3                         ret
38748                                           ! 6737 #asm
38749                                           !BCC_ASM
38750                       00000026            _int1a_function32.FLAGS	set	$26
38751                       00000024            _int1a_function32.DS	set	$24
38752                       00000022            _int1a_function32.ES	set	$22
38753                       00000002            _int1a_function32.regs	set	2
38754                                           ;--------------------
38755                                           use32 386
38756 B11C                  00000010            .align 16
38757                       0000B120            bios32_structure:
38758 B120                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
38759 B124                      B130              dw bios32_entry_point, 0xf ;; 32 bit physical address
38760 B128                        00              db 0 ;; revision level
38761                                             ;; length in paragraphs and checksum stored in a word to prevent errors
38762 B129                      EC01              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
38763 B12B                        00              db 0,0,0,0,0 ;; reserved
38764 B130                  00000010            .align 16
38765                       0000B130            bios32_entry_point:
38766 B130           9C                           pushfd
38767 B131           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
38768 B136           75           29              jne unknown_service
38769 B138           B8               80000000    mov eax, #0x80000000
38770 B13D     66    BA                   0CF8    mov dx, #0x0cf8
38771 B141           EF                           out dx, eax
38772 B142     66    BA                   0CFC    mov dx, #0x0cfc
38773 B146           ED                           in eax, dx
38774 B147           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
38775 B14C           75           13              jne unknown_service
38776 B14E           BB               000F0000    mov ebx, #0x000f0000
38777 B153           B9               00000000    mov ecx, #0
38778 B158           BA               0000B170    mov edx, #pcibios_protected
38779 B15D           30C0                         xor al, al
38780 B15F           EB           02              jmp bios32_end
38781                       0000B161            unknown_service:
38782 B161           B0                     80    mov al, #0x80
38783                       0000B163            bios32_end:
38784 B163           9D                           popfd
38785 B164           CB                           retf
38786 B165                  00000010            .align 16
38787                       0000B170            pcibios_protected:
38788 B170           9C                           pushfd
38789 B171           FA                           cli
38790 B172           56                           push esi
38791 B173           57                           push edi
38792 B174           3C                     01    cmp al, #0x01 ;; installation check
38793 B176           75           14              jne pci_pro_f02
38794 B178     66    BB                   0210    mov bx, #0x0210
38795 B17C     66    B9                   0000    mov cx, #0
38796 B180           BA               20494350    mov edx, #0x20494350 ;; "PCI "
38797 B185           B0                     01    mov al, #0x01
38798 B187           E9     0000011B              jmp pci_pro_ok
38799                       0000B18C            pci_pro_f02: ;; find pci device
38800 B18C           3C                     02    cmp al, #0x02
38801 B18E           75           38              jne pci_pro_f03
38802 B190           C1E1                   10    shl ecx, #16
38803 B193     66    89D1                         mov cx, dx
38804 B196     66    31DB                         xor bx, bx
38805 B199     66    BF                   0000    mov di, #0x00
38806                       0000B19D            pci_pro_devloop:
38807 B19D           E8     0000010C              call pci_pro_select_reg
38808 B1A2     66    BA                   0CFC    mov dx, #0x0cfc
38809 B1A6           ED                           in eax, dx
38810 B1A7           39C8                         cmp eax, ecx
38811 B1A9           75           0D              jne pci_pro_nextdev
38812 B1AB     66    83FE                   00    cmp si, #0
38813 B1AF   7505    E9     000000F1              je pci_pro_ok
38814 B1B6     66    4E                           dec si
38815                       0000B1B8            pci_pro_nextdev:
38816 B1B8     66    43                           inc bx
38817 B1BA     66    81FB                 0100    cmp bx, #0x0100
38818 B1BF           75           DC              jne pci_pro_devloop
38819 B1C1           B4                     86    mov ah, #0x86
38820 B1C3           E9     000000DA              jmp pci_pro_fail
38821                       0000B1C8            pci_pro_f03: ;; find class code
38822 B1C8           3C                     03    cmp al, #0x03
38823 B1CA           75           35              jne pci_pro_f08
38824 B1CC     66    31DB                         xor bx, bx
38825 B1CF     66    BF                   0008    mov di, #0x08
38826                       0000B1D3            pci_pro_devloop2:
38827 B1D3           E8     000000D6              call pci_pro_select_reg
38828 B1D8     66    BA                   0CFC    mov dx, #0x0cfc
38829 B1DC           ED                           in eax, dx
38830 B1DD           C1E8                   08    shr eax, #8
38831 B1E0           39C8                         cmp eax, ecx
38832 B1E2           75           0D              jne pci_pro_nextdev2
38833 B1E4     66    83FE                   00    cmp si, #0
38834 B1E8   7505    E9     000000B8              je pci_pro_ok
38835 B1EF     66    4E                           dec si
38836                       0000B1F1            pci_pro_nextdev2:
38837 B1F1     66    43                           inc bx
38838 B1F3     66    81FB                 0100    cmp bx, #0x0100
38839 B1F8           75           D9              jne pci_pro_devloop2
38840 B1FA           B4                     86    mov ah, #0x86
38841 B1FC           E9     000000A1              jmp pci_pro_fail
38842                       0000B201            pci_pro_f08: ;; read configuration byte
38843 B201           3C                     08    cmp al, #0x08
38844 B203           75           1B              jne pci_pro_f09
38845 B205           E8     000000A4              call pci_pro_select_reg
38846 B20A           52                           push edx
38847 B20B     66    89FA                         mov dx, di
38848 B20E     66    83E2                   03    and dx, #0x03
38849 B212     66    81C2                 0CFC    add dx, #0x0cfc
38850 B217           EC                           in al, dx
38851 B218           5A                           pop edx
38852 B219           88C1                         mov cl, al
38853 B21B           E9     00000087              jmp pci_pro_ok
38854                       0000B220            pci_pro_f09: ;; read configuration word
38855 B220           3C                     09    cmp al, #0x09
38856 B222           75           1A              jne pci_pro_f0a
38857 B224           E8     00000085              call pci_pro_select_reg
38858 B229           52                           push edx
38859 B22A     66    89FA                         mov dx, di
38860 B22D     66    83E2                   02    and dx, #0x02
38861 B231     66    81C2                 0CFC    add dx, #0x0cfc
38862 B236     66    ED                           in ax, dx
38863 B238           5A                           pop edx
38864 B239     66    89C1                         mov cx, ax
38865 B23C           EB           69              jmp pci_pro_ok
38866                       0000B23E            pci_pro_f0a: ;; read configuration dword
38867 B23E           3C                     0A    cmp al, #0x0a
38868 B240           75           10              jne pci_pro_f0b
38869 B242           E8     00000067              call pci_pro_select_reg
38870 B247           52                           push edx
38871 B248     66    BA                   0CFC    mov dx, #0x0cfc
38872 B24C           ED                           in eax, dx
38873 B24D           5A                           pop edx
38874 B24E           89C1                         mov ecx, eax
38875 B250           EB           55              jmp pci_pro_ok
38876                       0000B252            pci_pro_f0b: ;; write configuration byte
38877 B252           3C                     0B    cmp al, #0x0b
38878 B254           75           18              jne pci_pro_f0c
38879 B256           E8     00000053              call pci_pro_select_reg
38880 B25B           52                           push edx
38881 B25C     66    89FA                         mov dx, di
38882 B25F     66    83E2                   03    and dx, #0x03
38883 B263     66    81C2                 0CFC    add dx, #0x0cfc
38884 B268           88C8                         mov al, cl
38885 B26A           EE                           out dx, al
38886 B26B           5A                           pop edx
38887 B26C           EB           39              jmp pci_pro_ok
38888                       0000B26E            pci_pro_f0c: ;; write configuration word
38889 B26E           3C                     0C    cmp al, #0x0c
38890 B270           75           1A              jne pci_pro_f0d
38891 B272           E8     00000037              call pci_pro_select_reg
38892 B277           52                           push edx
38893 B278     66    89FA                         mov dx, di
38894 B27B     66    83E2                   02    and dx, #0x02
38895 B27F     66    81C2                 0CFC    add dx, #0x0cfc
38896 B284     66    89C8                         mov ax, cx
38897 B287     66    EF                           out dx, ax
38898 B289           5A                           pop edx
38899 B28A           EB           1B              jmp pci_pro_ok
38900                       0000B28C            pci_pro_f0d: ;; write configuration dword
38901 B28C           3C                     0D    cmp al, #0x0d
38902 B28E           75           10              jne pci_pro_unknown
38903 B290           E8     00000019              call pci_pro_select_reg
38904 B295           52                           push edx
38905 B296     66    BA                   0CFC    mov dx, #0x0cfc
38906 B29A           89C8                         mov eax, ecx
38907 B29C           EF                           out dx, eax
38908 B29D           5A                           pop edx
38909 B29E           EB           07              jmp pci_pro_ok
38910                       0000B2A0            pci_pro_unknown:
38911 B2A0           B4                     81    mov ah, #0x81
38912                       0000B2A2            pci_pro_fail:
38913 B2A2           5F                           pop edi
38914 B2A3           5E                           pop esi
38915 B2A4           9D                           popfd
38916 B2A5           F9                           stc
38917 B2A6           CB                           retf
38918                       0000B2A7            pci_pro_ok:
38919 B2A7           30E4                         xor ah, ah
38920 B2A9           5F                           pop edi
38921 B2AA           5E                           pop esi
38922 B2AB           9D                           popfd
38923 B2AC           F8                           clc
38924 B2AD           CB                           retf
38925                       0000B2AE            pci_pro_select_reg:
38926 B2AE           52                           push edx
38927 B2AF           B8               00800000    mov eax, #0x800000
38928 B2B4     66    89D8                         mov ax, bx
38929 B2B7           C1E0                   08    shl eax, #8
38930 B2BA     66    81E7                 00FF    and di, #0xff
38931 B2BF     66    09F8                         or ax, di
38932 B2C2           24                     FC    and al, #0xfc
38933 B2C4     66    BA                   0CF8    mov dx, #0x0cf8
38934 B2C8           EF                           out dx, eax
38935 B2C9           5A                           pop edx
38936 B2CA           C3                           ret
38937                                           use16 386
38938                       0000B2CB            pcibios_real:
38939 B2CB     66    50                           push eax
38940 B2CD           52                           push dx
38941 B2CE     66    B8               80000000    mov eax, #0x80000000
38942 B2D4           BA                   0CF8    mov dx, #0x0cf8
38943 B2D7     66    EF                           out dx, eax
38944 B2D9           BA                   0CFC    mov dx, #0x0cfc
38945 B2DC     66    ED                           in eax, dx
38946 B2DE     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
38947 B2E4           74           07              je pci_present
38948 B2E6           5A                           pop dx
38949 B2E7     66    58                           pop eax
38950 B2E9           B4                     FF    mov ah, #0xff
38951 B2EB           F9                           stc
38952 B2EC           C3                           ret
38953                       0000B2ED            pci_present:
38954 B2ED           5A                           pop dx
38955 B2EE     66    58                           pop eax
38956 B2F0           3C                     01    cmp al, #0x01 ;; installation check
38957 B2F2           75           1A              jne pci_real_f02
38958 B2F4           B8                   0001    mov ax, #0x0001
38959 B2F7           BB                   0210    mov bx, #0x0210
38960 B2FA           B9                   0000    mov cx, #0
38961 B2FD     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
38962 B303     66    BF               000F0000    mov edi, #0xf0000
38963 B309           BF                   B170    mov di, #pcibios_protected
38964 B30C           F8                           clc
38965 B30D           C3                           ret
38966                       0000B30E            pci_real_f02: ;; find pci device
38967 B30E     66    56                           push esi
38968 B310     66    57                           push edi
38969 B312           3C                     02    cmp al, #0x02
38970 B314           75           34              jne pci_real_f03
38971 B316     66    C1E1                   10    shl ecx, #16
38972 B31A           89D1                         mov cx, dx
38973 B31C           31DB                         xor bx, bx
38974 B31E           BF                   0000    mov di, #0x00
38975                       0000B321            pci_real_devloop:
38976 B321           E8         012F              call pci_real_select_reg
38977 B324           BA                   0CFC    mov dx, #0x0cfc
38978 B327     66    ED                           in eax, dx
38979 B329     66    39C8                         cmp eax, ecx
38980 B32C           75           09              jne pci_real_nextdev
38981 B32E           83FE                   00    cmp si, #0
38982 B331   7503    E9         0115              je pci_real_ok
38983 B336           4E                           dec si
38984                       0000B337            pci_real_nextdev:
38985 B337           43                           inc bx
38986 B338           81FB                 0100    cmp bx, #0x0100
38987 B33C           75           E3              jne pci_real_devloop
38988 B33E           89CA                         mov dx, cx
38989 B340     66    C1E9                   10    shr ecx, #16
38990 B344           B8                   8602    mov ax, #0x8602
38991 B347           E9         00FB              jmp pci_real_fail
38992                       0000B34A            pci_real_f03: ;; find class code
38993 B34A           3C                     03    cmp al, #0x03
38994 B34C           75           32              jne pci_real_f08
38995 B34E           31DB                         xor bx, bx
38996 B350           BF                   0008    mov di, #0x08
38997                       0000B353            pci_real_devloop2:
38998 B353           E8         00FD              call pci_real_select_reg
38999 B356           BA                   0CFC    mov dx, #0x0cfc
39000 B359     66    ED                           in eax, dx
39001 B35B     66    C1E8                   08    shr eax, #8
39002 B35F     66    39C8                         cmp eax, ecx
39003 B362           75           09              jne pci_real_nextdev2
39004 B364           83FE                   00    cmp si, #0
39005 B367   7503    E9         00DF              je pci_real_ok
39006 B36C           4E                           dec si
39007                       0000B36D            pci_real_nextdev2:
39008 B36D           43                           inc bx
39009 B36E           81FB                 0100    cmp bx, #0x0100
39010 B372           75           DF              jne pci_real_devloop2
39011 B374           89CA                         mov dx, cx
39012 B376     66    C1E9                   10    shr ecx, #16
39013 B37A           B8                   8603    mov ax, #0x8603
39014 B37D           E9         00C5              jmp pci_real_fail
39015                       0000B380            pci_real_f08: ;; read configuration byte
39016 B380           3C                     08    cmp al, #0x08
39017 B382           75           14              jne pci_real_f09
39018 B384           E8         00CC              call pci_real_select_reg
39019 B387           52                           push dx
39020 B388           89FA                         mov dx, di
39021 B38A           83E2                   03    and dx, #0x03
39022 B38D           81C2                 0CFC    add dx, #0x0cfc
39023 B391           EC                           in al, dx
39024 B392           5A                           pop dx
39025 B393           88C1                         mov cl, al
39026 B395           E9         00B3              jmp pci_real_ok
39027                       0000B398            pci_real_f09: ;; read configuration word
39028 B398           3C                     09    cmp al, #0x09
39029 B39A           75           14              jne pci_real_f0a
39030 B39C           E8         00B4              call pci_real_select_reg
39031 B39F           52                           push dx
39032 B3A0           89FA                         mov dx, di
39033 B3A2           83E2                   02    and dx, #0x02
39034 B3A5           81C2                 0CFC    add dx, #0x0cfc
39035 B3A9           ED                           in ax, dx
39036 B3AA           5A                           pop dx
39037 B3AB           89C1                         mov cx, ax
39038 B3AD           E9         009B              jmp pci_real_ok
39039                       0000B3B0            pci_real_f0a: ;; read configuration dword
39040 B3B0           3C                     0A    cmp al, #0x0a
39041 B3B2           75           10              jne pci_real_f0b
39042 B3B4           E8         009C              call pci_real_select_reg
39043 B3B7           52                           push dx
39044 B3B8           BA                   0CFC    mov dx, #0x0cfc
39045 B3BB     66    ED                           in eax, dx
39046 B3BD           5A                           pop dx
39047 B3BE     66    89C1                         mov ecx, eax
39048 B3C1           E9         0087              jmp pci_real_ok
39049                       0000B3C4            pci_real_f0b: ;; write configuration byte
39050 B3C4           3C                     0B    cmp al, #0x0b
39051 B3C6           75           13              jne pci_real_f0c
39052 B3C8           E8         0088              call pci_real_select_reg
39053 B3CB           52                           push dx
39054 B3CC           89FA                         mov dx, di
39055 B3CE           83E2                   03    and dx, #0x03
39056 B3D1           81C2                 0CFC    add dx, #0x0cfc
39057 B3D5           88C8                         mov al, cl
39058 B3D7           EE                           out dx, al
39059 B3D8           5A                           pop dx
39060 B3D9           EB           70              jmp pci_real_ok
39061                       0000B3DB            pci_real_f0c: ;; write configuration word
39062 B3DB           3C                     0C    cmp al, #0x0c
39063 B3DD           75           13              jne pci_real_f0d
39064 B3DF           E8         0071              call pci_real_select_reg
39065 B3E2           52                           push dx
39066 B3E3           89FA                         mov dx, di
39067 B3E5           83E2                   02    and dx, #0x02
39068 B3E8           81C2                 0CFC    add dx, #0x0cfc
39069 B3EC           89C8                         mov ax, cx
39070 B3EE           EF                           out dx, ax
39071 B3EF           5A                           pop dx
39072 B3F0           EB           59              jmp pci_real_ok
39073                       0000B3F2            pci_real_f0d: ;; write configuration dword
39074 B3F2           3C                     0D    cmp al, #0x0d
39075 B3F4           75           0F              jne pci_real_f0e
39076 B3F6           E8         005A              call pci_real_select_reg
39077 B3F9           52                           push dx
39078 B3FA           BA                   0CFC    mov dx, #0x0cfc
39079 B3FD     66    89C8                         mov eax, ecx
39080 B400     66    EF                           out dx, eax
39081 B402           5A                           pop dx
39082 B403           EB           46              jmp pci_real_ok
39083                       0000B405            pci_real_f0e: ;; get irq routing options
39084 B405           3C                     0E    cmp al, #0x0e
39085 B407           75           3A              jne pci_real_unknown
39086 B409           26                           SEG ES
39087 B40A           833D                   60    cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39088 B40D           72           2B              jb pci_real_too_small
39089 B40F           26                           SEG ES
39090 B410           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39091 B414           9C                           pushf
39092 B415           1E                           push ds
39093 B416           06                           push es
39094 B417           51                           push cx
39095 B418           56                           push si
39096 B419           57                           push di
39097 B41A           FC                           cld
39098 B41B           BE                   B490    mov si, #pci_routing_table_structure_start
39099 B41E           0E                           push cs
39100 B41F           1F                           pop ds
39101 B420           26                           SEG ES
39102 B421           8B4D         02              mov cx, [di+2]
39103 B424           26                           SEG ES
39104 B425           8E45         04              mov es, [di+4]
39105 B428           89CF                         mov di, cx
39106 B42A           B9                   0060    mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
39107 B42D           F3                           rep
39108 B42E           A4                               movsb
39109 B42F           5F                           pop di
39110 B430           5E                           pop si
39111 B431           59                           pop cx
39112 B432           07                           pop es
39113 B433           1F                           pop ds
39114 B434           9D                           popf
39115 B435           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
39116 B438           EB           11              jmp pci_real_ok
39117                       0000B43A            pci_real_too_small:
39118 B43A           26                           SEG ES
39119 B43B           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39120 B43F           B4                     89    mov ah, #0x89
39121 B441           EB           02              jmp pci_real_fail
39122                       0000B443            pci_real_unknown:
39123 B443           B4                     81    mov ah, #0x81
39124                       0000B445            pci_real_fail:
39125 B445     66    5F                           pop edi
39126 B447     66    5E                           pop esi
39127 B449           F9                           stc
39128 B44A           C3                           ret
39129                       0000B44B            pci_real_ok:
39130 B44B           30E4                         xor ah, ah
39131 B44D     66    5F                           pop edi
39132 B44F     66    5E                           pop esi
39133 B451           F8                           clc
39134 B452           C3                           ret
39135                       0000B453            pci_real_select_reg:
39136 B453           52                           push dx
39137 B454     66    B8               00800000    mov eax, #0x800000
39138 B45A           89D8                         mov ax, bx
39139 B45C     66    C1E0                   08    shl eax, #8
39140 B460           81E7                 00FF    and di, #0xff
39141 B464           09F8                         or ax, di
39142 B466           24                     FC    and al, #0xfc
39143 B468           BA                   0CF8    mov dx, #0x0cf8
39144 B46B     66    EF                           out dx, eax
39145 B46D           5A                           pop dx
39146 B46E           C3                           ret
39147 B46F                  00000010            .align 16
39148                       0000B470            pci_routing_table_structure:
39149 B470                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
39150 B474                        00              db 0, 1 ;; version
39151 B476                      0080              dw 32 + (6 * 16) ;; table size
39152 B478                        00              db 0 ;; PCI interrupt router bus
39153 B479                        08              db 0x08 ;; PCI interrupt router DevFunc
39154 B47A                      0000              dw 0x0000 ;; PCI exclusive IRQs
39155 B47C                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
39156 B47E                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
39157 B480                      0000              dw 0,0 ;; Miniport data
39158 B484                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
39159 B48F                        37              db 0x37 ;; checksum
39160                       0000B490            pci_routing_table_structure_start:
39161                                             ;; first slot entry PCI-to-ISA (embedded)
39162 B490                        00              db 0 ;; pci bus number
39163 B491                        08              db 0x08 ;; pci device number (bit 7-3)
39164 B492                        61              db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
39165 B493                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39166 B495                        62              db 0x62 ;; link value INTB#
39167 B496                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39168 B498                        63              db 0x63 ;; link value INTC#
39169 B499                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39170 B49B                        60              db 0x60 ;; link value INTD#
39171 B49C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39172 B49E                        00              db 0 ;; physical slot (0 = embedded)
39173 B49F                        00              db 0 ;; reserved
39174                                             ;; second slot entry: 1st PCI slot
39175 B4A0                        00              db 0 ;; pci bus number
39176 B4A1                        10              db 0x10 ;; pci device number (bit 7-3)
39177 B4A2                        62              db 0x62 ;; link value INTA#
39178 B4A3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39179 B4A5                        63              db 0x63 ;; link value INTB#
39180 B4A6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39181 B4A8                        60              db 0x60 ;; link value INTC#
39182 B4A9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39183 B4AB                        61              db 0x61 ;; link value INTD#
39184 B4AC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39185 B4AE                        01              db 1 ;; physical slot (0 = embedded)
39186 B4AF                        00              db 0 ;; reserved
39187                                             ;; third slot entry: 2nd PCI slot
39188 B4B0                        00              db 0 ;; pci bus number
39189 B4B1                        18              db 0x18 ;; pci device number (bit 7-3)
39190 B4B2                        63              db 0x63 ;; link value INTA#
39191 B4B3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39192 B4B5                        60              db 0x60 ;; link value INTB#
39193 B4B6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39194 B4B8                        61              db 0x61 ;; link value INTC#
39195 B4B9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39196 B4BB                        62              db 0x62 ;; link value INTD#
39197 B4BC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39198 B4BE                        02              db 2 ;; physical slot (0 = embedded)
39199 B4BF                        00              db 0 ;; reserved
39200                                             ;; 4th slot entry: 3rd PCI slot
39201 B4C0                        00              db 0 ;; pci bus number
39202 B4C1                        20              db 0x20 ;; pci device number (bit 7-3)
39203 B4C2                        60              db 0x60 ;; link value INTA#
39204 B4C3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39205 B4C5                        61              db 0x61 ;; link value INTB#
39206 B4C6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39207 B4C8                        62              db 0x62 ;; link value INTC#
39208 B4C9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39209 B4CB                        63              db 0x63 ;; link value INTD#
39210 B4CC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39211 B4CE                        03              db 3 ;; physical slot (0 = embedded)
39212 B4CF                        00              db 0 ;; reserved
39213                                             ;; 5th slot entry: 4rd PCI slot
39214 B4D0                        00              db 0 ;; pci bus number
39215 B4D1                        28              db 0x28 ;; pci device number (bit 7-3)
39216 B4D2                        61              db 0x61 ;; link value INTA#
39217 B4D3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39218 B4D5                        62              db 0x62 ;; link value INTB#
39219 B4D6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39220 B4D8                        63              db 0x63 ;; link value INTC#
39221 B4D9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39222 B4DB                        60              db 0x60 ;; link value INTD#
39223 B4DC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39224 B4DE                        04              db 4 ;; physical slot (0 = embedded)
39225 B4DF                        00              db 0 ;; reserved
39226                                             ;; 6th slot entry: 5rd PCI slot
39227 B4E0                        00              db 0 ;; pci bus number
39228 B4E1                        30              db 0x30 ;; pci device number (bit 7-3)
39229 B4E2                        62              db 0x62 ;; link value INTA#
39230 B4E3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39231 B4E5                        63              db 0x63 ;; link value INTB#
39232 B4E6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39233 B4E8                        60              db 0x60 ;; link value INTC#
39234 B4E9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39235 B4EB                        61              db 0x61 ;; link value INTD#
39236 B4EC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39237 B4EE                        05              db 5 ;; physical slot (0 = embedded)
39238 B4EF                        00              db 0 ;; reserved
39239                       0000B4F0            pci_routing_table_structure_end:
39240                                           ; according to POST Memory Manager Specification Version 1.01
39241 B4F0                  00000010            .align 16
39242                       0000B4F0            pmm_structure:
39243 B4F0                        24              db 0x24,0x50,0x4d,0x4d ;; "$PMM" signature
39244 B4F4                        01              db 0x01 ;; revision
39245 B4F5                        10              db 16 ;; length
39246 B4F6                        3C              db (-((pmm_entry_point>>8)+pmm_entry_point+0x20f))&0xff;; checksum
39247 B4F7                      B500              dw pmm_entry_point,0xf000 ;; far call entrypoint
39248 B4FB                        00              db 0,0,0,0,0 ;; reserved
39249                       0000B500            pmm_entry_point:
39250 B500           9C                           pushf
39251 B501     66    60                           pushad
39252                                           ; Calculate protected-mode address of PMM function args
39253 B503     66    31C0                         xor eax, eax
39254 B506           89E0                         mov ax, sp
39255 B508     66    31DB                         xor ebx, ebx
39256 B50B           8CD3                         mov bx, ss
39257 B50D     66    C1E3                   04    shl ebx, 4
39258 B511   6766    8D5C18       26              lea ebx, [eax+ebx+38] ;; ebx=(ss<<4)+sp+4(far call)+2(pushf)+32(pushad)
39259 B517     66    53                           push ebx
39260                                           ;
39261                                           ; Stack layout at this point:
39262                                           ;
39263                                           ; : +0x0 +0x2 +0x4 +0x6 +0x8 +0xa +0xc +0xe
39264                                           ; -----------------------------------------------------------------------
39265                                           ; sp : [&arg1 ][edi ][esi ][ebp ]
39266                                           ; sp+0x10: [esp ][ebx ][edx ][ecx ]
39267                                           ; sp+0x20: [eax ][flags ][ip ][cs ][arg1 ][arg2, ...
39268                                           ;
39269 B519           E8         FAC5              call _pmm
39270 B51C           89E3                         mov bx, sp
39271 B51E           36                         SEG SS
39272 B51F           8947         20              mov [bx+0x20], ax
39273 B522           36                         SEG SS
39274 B523           8957         18              mov [bx+0x18], dx
39275 B526     66    5B                           pop ebx
39276 B528     66    61                           popad
39277 B52A           9D                           popf
39278 B52B           CB                           retf
39279                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
39280                       0000B52C            detect_parport:
39281 B52C           52                           push dx
39282 B52D           83C2                   02    add dx, #2
39283 B530           EC                           in al, dx
39284 B531           24                     DF    and al, #0xdf ; clear input mode
39285 B533           EE                           out dx, al
39286 B534           5A                           pop dx
39287 B535           B0                     AA    mov al, #0xaa
39288 B537           EE                           out dx, al
39289 B538           EC                           in al, dx
39290 B539           3C                     AA    cmp al, #0xaa
39291 B53B           75           0D              jne no_parport
39292 B53D           53                           push bx
39293 B53E           D1E3                         shl bx, #1
39294 B540           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
39295 B544           5B                           pop bx
39296 B545           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
39297 B549           43                           inc bx
39298                       0000B54A            no_parport:
39299 B54A           C3                           ret
39300                                           ; serial port detection: base address in DX, index in BX, timeout in CL
39301                       0000B54B            detect_serial:
39302 B54B           52                           push dx
39303 B54C           42                           inc dx
39304 B54D           B0                     02    mov al, #0x02
39305 B54F           EE                           out dx, al
39306 B550           EC                           in al, dx
39307 B551           3C                     02    cmp al, #0x02
39308 B553           75           19              jne no_serial
39309 B555           42                           inc dx
39310 B556           EC                           in al, dx
39311 B557           3C                     02    cmp al, #0x02
39312 B559           75           13              jne no_serial
39313 B55B           4A                           dec dx
39314 B55C           30C0                         xor al, al
39315 B55E           EE                           out dx, al
39316 B55F           5A                           pop dx
39317 B560           53                           push bx
39318 B561           D1E3                         shl bx, #1
39319 B563           8997       0400              mov [bx+0x400], dx ; Serial I/O address
39320 B567           5B                           pop bx
39321 B568           888F       047C              mov [bx+0x47c], cl ; Serial timeout
39322 B56C           43                           inc bx
39323 B56D           C3                           ret
39324                       0000B56E            no_serial:
39325 B56E           5A                           pop dx
39326 B56F           C3                           ret
39327                       0000B570            rom_checksum:
39328 B570           60                           pusha
39329 B571           1E                           push ds
39330 B572           31C0                         xor ax, ax
39331 B574           31DB                         xor bx, bx
39332 B576           31C9                         xor cx, cx
39333 B578           31D2                         xor dx, dx
39334 B57A           8A2E       0002              mov ch, [2]
39335 B57E           D1E1                         shl cx, #1
39336 B580           73           05              jnc checksum_loop
39337 B582           74           03              jz checksum_loop
39338 B584           87CA                         xchg dx, cx
39339 B586           49                           dec cx
39340                       0000B587            checksum_loop:
39341 B587           0207                         add al, [bx]
39342 B589           43                           inc bx
39343 B58A           E2           FB              loop checksum_loop
39344 B58C           85D2                         test dx, dx
39345 B58E           74           11              je checksum_out
39346 B590           0207                         add al, [bx]
39347 B592           89D1                         mov cx, dx
39348 B594           8CDA                         mov dx, ds
39349 B596           80C6                   10    add dh, #0x10
39350 B599           8EDA                         mov ds, dx
39351 B59B           31D2                         xor dx, dx
39352 B59D           31DB                         xor bx, bx
39353 B59F           EB           E6              jmp checksum_loop
39354                       0000B5A1            checksum_out:
39355 B5A1           24                     FF    and al, #0xff
39356 B5A3           1F                           pop ds
39357 B5A4           61                           popa
39358 B5A5           C3                           ret
39359                                           ;; We need a copy of this string, but we are not actually a PnP BIOS,
39360                                           ;; so make sure it is *not* aligned, so OSes will not see it if they scan.
39361 B5A6                  00000010            .align 16
39362 B5B0                        00              db 0
39363                       0000B5B1            pnp_string:
39364 B5B1                        24              .ascii "$PnP"
39365                       0000B5B5            rom_scan:
39366                                             ;; Scan for existence of valid expansion ROMS.
39367                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
39368                                             ;; General ROM: from 0xC8000..0xE9FFF in 2k increments
39369                                             ;; System ROM: only 0xF0000
39370                                             ;;
39371                                             ;; Header:
39372                                             ;; Offset Value
39373                                             ;; 0 0x55
39374                                             ;; 1 0xAA
39375                                             ;; 2 ROM length in 512-byte blocks
39376                                             ;; 3 ROM initialization entry point (FAR CALL)
39377                       0000B5B5            rom_scan_loop:
39378 B5B5           50                           push ax ;; Save AX
39379 B5B6           8ED9                         mov ds, cx
39380 B5B8           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
39381 B5BB           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
39382 B5C1   7403    E9         00C2              jne rom_scan_increment
39383 B5C6           E8         FFA7              call rom_checksum
39384 B5C9   7403    E9         00BA              jnz rom_scan_increment
39385 B5CE           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
39386                                             ;; We want our increment in 512-byte quantities, rounded to
39387                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
39388 B5D1           A8                     03    test al, #0x03
39389 B5D3           74           04              jz block_count_rounded
39390 B5D5           24                     FC    and al, #0xfc ;; needs rounding up
39391 B5D7           04                     04    add al, #0x04
39392                       0000B5D9            block_count_rounded:
39393 B5D9           50                           push ax ;; Save AX
39394 B5DA           57                           push di ;; Save DI
39395                                             ;; Push addr of ROM entry point
39396 B5DB           51                           push cx ;; Push seg
39397 B5DC           6A                     03    push #0x0003 ;; Push offset
39398                                             ;; Get the BDF into ax before invoking the option ROM
39399 B5DE           8A1E       0002              mov bl, [2]
39400 B5E2           88D8                         mov al, bl
39401 B5E4           C0E8                   07    shr al, #7
39402 B5E7           3C                     01    cmp al, #1
39403 B5E9           75           07              jne fetch_bdf
39404 B5EB           8CD8                         mov ax, ds ;; Increment the DS since rom size larger than an segment
39405 B5ED           05                   1000    add ax, #0x1000
39406 B5F0           8ED8                         mov ds, ax
39407                       0000B5F2            fetch_bdf:
39408 B5F2           C1E3                   09    shl bx, #9
39409 B5F5           31C0                         xor ax, ax
39410 B5F7           8A07                         mov al, [bx]
39411                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
39412                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
39413 B5F9           BB                   F000    mov bx, #0xf000
39414 B5FC           8EC3                         mov es, bx
39415 B5FE           8D3E       B5B1              lea di, pnp_string
39416 B602           31DB                         xor bx, bx ;; Restore DS back to 0000:
39417 B604           8EDB                         mov ds, bx
39418 B606           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
39419 B608                        FF              db 0xff ;; call_far ss:[bp+0]
39420 B609                        5E              db 0x5e
39421 B60A                        00              db 0
39422 B60B           FA                           cli ;; In case expansion ROM BIOS turns IF on
39423 B60C           83C4                   02    add sp, #2 ;; Pop offset value
39424 B60F           59                           pop cx ;; Pop seg value (restore CX)
39425                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
39426                                             ;; to init all the ROMs and then go back and build an IPL table of
39427                                             ;; all the bootable devices, but we can get away with one pass.
39428 B610           8ED9                         mov ds, cx ;; ROM base
39429 B612           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
39430 B616           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
39431 B618           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
39432 B61B           75           69              jne no_bev
39433 B61D           8B47         02              mov ax, 2[bx]
39434 B620           3D                   506E    cmp ax, #0x506e
39435 B623           75           61              jne no_bev
39436 B625           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
39437 B628           3D                   0000    cmp ax, #0x0000
39438 B62B           74           17              je no_bcv
39439                                             ;; Option ROM has BCV. Run it now.
39440 B62D           51                           push cx ;; Push seg
39441 B62E           50                           push ax ;; Push offset
39442                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
39443 B62F           BB                   F000    mov bx, #0xf000
39444 B632           8EC3                         mov es, bx
39445 B634           8D3E       B5B1              lea di, pnp_string
39446 B638           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
39447 B63A                        FF              db 0xff ;; call_far ss:[bp+0]
39448 B63B                        5E              db 0x5e
39449 B63C                        00              db 0
39450 B63D           FA                           cli ;; In case expansion ROM BIOS turns IF on
39451 B63E           83C4                   02    add sp, #2 ;; Pop offset value
39452 B641           59                           pop cx ;; Pop seg value (restore CX)
39453 B642           EB           42              jmp no_bev
39454                       0000B644            no_bcv:
39455 B644           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
39456 B647           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
39457 B64A           74           3A              je no_bev
39458                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
39459 B64C           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
39460 B64F           31DB                         xor bx, bx
39461 B651           8EDB                         mov ds, bx
39462 B653           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
39463 B657           8EDB                         mov ds, bx ;; Go to the segment where the IPL table lives
39464 B659           8B1E       0380              mov bx, 0x0380 ;; Read the number of entries so far
39465 B65D           83FB                   08    cmp bx, #8
39466 B660           74           24              je no_bev ;; Get out if the table is full
39467 B662           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
39468 B665           C787       0300      0080    mov 0x0300 +0[bx], #0x80 ;; This entry is a BEV device
39469 B66B           898F       0306              mov 0x0300 +6[bx], cx ;; Build a far pointer from the segment...
39470 B66F           8987       0304              mov 0x0300 +4[bx], ax ;; and the offset
39471 B673           83FF                   00    cmp di, #0x0000
39472 B676           74           06              je no_prod_str
39473 B678           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
39474 B67B           897F         08              mov 8[bx], di ;; and the offset
39475                       0000B67E            no_prod_str:
39476 B67E           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
39477 B681           43                           inc bx ;; We have one more entry now
39478 B682           891E       0380              mov 0x0380, bx ;; Remember that.
39479                       0000B686            no_bev:
39480 B686           5F                           pop di ;; Restore DI
39481 B687           58                           pop ax ;; Restore AX
39482                       0000B688            rom_scan_increment:
39483 B688           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
39484                                                           ;; because the segment selector is shifted left 4 bits.
39485 B68B           01C1                         add cx, ax
39486 B68D           58                           pop ax ;; Restore AX
39487 B68E           39C1                         cmp cx, ax
39488 B690   7703    E9         FF20              jbe rom_scan_loop
39489 B695           31C0                         xor ax, ax ;; Restore DS back to 0000:
39490 B697           8ED8                         mov ds, ax
39491 B699           C3                           ret
39492                                           ; Copy the SMBIOS entry point from where hvmloader left it.
39493                                           ; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
39494                                           ; but the tables themselves can be elsewhere.
39495                       0000B69A            smbios_init:
39496 B69A           50                           push ax
39497 B69B           51                           push cx
39498 B69C           06                           push es
39499 B69D           1E                           push ds
39500 B69E           57                           push di
39501 B69F           56                           push si
39502 B6A0           B9                   001F    mov cx, #0x001f ; 0x1f bytes to copy
39503 B6A3           B8                   F000    mov ax, #0xf000
39504 B6A6           8EC0                         mov es, ax ; destination segment is 0xf0000
39505 B6A8           BF                   B6F0    mov di, #smbios_entry_point ; destination offset
39506 B6AB           B8                   EB00    mov ax, #(0x000EB000>>4)
39507 B6AE           8ED8                         mov ds, ax
39508 B6B0           BE                   0000    mov si, #(0x000EB000&15)
39509 B6B3           FC                           cld
39510 B6B4           F3                           rep
39511 B6B5           A4                             movsb
39512 B6B6           5E                           pop si
39513 B6B7           5F                           pop di
39514 B6B8           1F                           pop ds
39515 B6B9           07                           pop es
39516 B6BA           59                           pop cx
39517 B6BB           58                           pop ax
39518 B6BC           C3                           ret
39519                       0000B6BD            post_init_pic:
39520 B6BD           B0                     11    mov al, #0x11 ; send initialisation commands
39521 B6BF           E6                     20    out 0x20, al
39522 B6C1           E6                     A0    out 0xa0, al
39523 B6C3           B0                     08    mov al, #0x08
39524 B6C5           E6                     21    out 0x21, al
39525 B6C7           B0                     70    mov al, #0x70
39526 B6C9           E6                     A1    out 0xa1, al
39527 B6CB           B0                     04    mov al, #0x04
39528 B6CD           E6                     21    out 0x21, al
39529 B6CF           B0                     02    mov al, #0x02
39530 B6D1           E6                     A1    out 0xa1, al
39531 B6D3           B0                     01    mov al, #0x01
39532 B6D5           E6                     21    out 0x21, al
39533 B6D7           E6                     A1    out 0xa1, al
39534 B6D9           B0                     B8    mov al, #0xb8
39535 B6DB           E6                     21    out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
39536 B6DD           B0                     8F    mov al, #0x8f
39537 B6DF           E6                     A1    out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
39538 B6E1           C3                           ret
39539 B6E2                  00000010              .align 16
39540                       0000B6F0            smbios_entry_point:
39541 B6F0                        00              db 0,0,0,0,0,0,0,0 ; 8 bytes
39542 B6F8                        00              db 0,0,0,0,0,0,0,0 ; 16 bytes
39543 B700                        00              db 0,0,0,0,0,0,0,0 ; 24 bytes
39544 B708                        00              db 0,0,0,0,0,0,0 ; 31 bytes
39545                                           ;; the following area can be used to write dynamically generated tables
39546 B70F                  00000010              .align 16
39547                       0000B710            bios_table_area_start:
39548 B710                        5F              db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
39549 B718                  000018E0              dd bios_table_area_end - bios_table_area_start
39550                                           ;--------
39551                                           ;- POST -
39552                                           ;--------
39553 E05B                                      .org 0xe05b ; POST Entry Point
39554                       0000E05B            post:
39555 E05B           31C0                         xor ax, ax
39556                                             ;; first reset the DMA controllers
39557 E05D           E6                     0D    out 0x0d,al
39558 E05F           E6                     DA    out 0xda,al
39559                                             ;; then initialize the DMA controllers
39560 E061           B0                     C0    mov al, #0xC0
39561 E063           E6                     D6    out 0xD6, al ; cascade mode of channel 4 enabled
39562 E065           B0                     00    mov al, #0x00
39563 E067           E6                     D4    out 0xD4, al ; unmask channel 4
39564                                             ;; Examine CMOS shutdown status.
39565 E069           B0                     0F    mov AL, #0x0f
39566 E06B           E6                     70    out 0x70, AL
39567 E06D           E4                     71    in AL, 0x71
39568                                             ;; backup status
39569 E06F           88C3                         mov bl, al
39570                                             ;; Reset CMOS shutdown status.
39571 E071           B0                     0F    mov AL, #0x0f
39572 E073           E6                     70    out 0x70, AL ; select CMOS register Fh
39573 E075           B0                     00    mov AL, #0x00
39574 E077           E6                     71    out 0x71, AL ; set shutdown action to normal
39575                                             ;; Examine CMOS shutdown status.
39576 E079           88D8                         mov al, bl
39577                                             ;; 0x00, 0x09, 0x0D+ = normal startup
39578 E07B           3C                     00    cmp AL, #0x00
39579 E07D           74           28              jz normal_post
39580 E07F           3C                     0D    cmp AL, #0x0d
39581 E081           73           24              jae normal_post
39582 E083           3C                     09    cmp AL, #0x09
39583 E085           74           20              je normal_post
39584                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
39585 E087           3C                     05    cmp al, #0x05
39586 E089   7503    E9         CA82              je eoi_jmp_post
39587                                             ;; 0x0A = jmp via [0x40:0x67] jump
39588 E08E           3C                     0A    cmp al, #0x0a
39589 E090   7503    E9         CA83              je jmp_post_0x467
39590                                             ;; 0x0B = iret via [0x40:0x67]
39591 E095           3C                     0B    cmp al, #0x0b
39592 E097   7503    E9         CA84              je iret_post_0x467
39593                                             ;; 0x0C = retf via [0x40:0x67]
39594 E09C           3C                     0C    cmp al, #0x0c
39595 E09E   7503    E9         CA8A              je retf_post_0x467
39596                                             ;; Examine CMOS shutdown status.
39597                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08 = Unimplemented shutdown status.
39598 E0A3           53                           push bx
39599 E0A4           E8         327C              call _shutdown_status_panic
39600                       0000E0A7            normal_post:
39601                                             ; case 0: normal startup
39602 E0A7           FA                           cli
39603 E0A8           B8                   0FFE    mov ax, #0x0ffe
39604 E0AB           89C4                         mov sp, ax
39605 E0AD           B8                   9E00    mov ax, #0x9e00
39606 E0B0           8ED0                         mov ss, ax
39607                                             ;; Save shutdown status
39608 E0B2           881E       04B0              mov 0x04b0, bl
39609 E0B6           80FB                   FE    cmp bl, #0xfe
39610 E0B9   7503    E9         CA7C              jz s3_post
39611                                             ;; zero out BIOS data area (40:00..40:ff)
39612 E0BE           8EC0                         mov es, ax
39613 E0C0           B9                   0080    mov cx, #0x0080 ;; 128 words
39614 E0C3           BF                   0400    mov di, #0x0400
39615 E0C6           FC                           cld
39616 E0C7           F3                           rep
39617 E0C8           AB                             stosw
39618 E0C9           E8         380A              call _log_bios_start
39619                                             ;; set all interrupts to default handler
39620 E0CC           31DB                         xor bx, bx ;; offset index
39621 E0CE           B9                   0100    mov cx, #0x0100 ;; counter (256 interrupts)
39622 E0D1           B8                   FF53    mov ax, #dummy_iret_handler
39623 E0D4           BA                   F000    mov dx, #0xF000
39624                       0000E0D7            post_default_ints:
39625 E0D7           8907                         mov [bx], ax
39626 E0D9           83C3                   02    add bx, #2
39627 E0DC           8917                         mov [bx], dx
39628 E0DE           83C3                   02    add bx, #2
39629 E0E1           E2           F4              loop post_default_ints
39630                                             ;; set vector 0x79 to zero
39631                                             ;; this is used by 'gardian angel' protection system
39632                                             SET_INT_VECTOR(0x79, #0, #0)
 +a   E0E3           B8                   0000    mov ax,  #0
 +a   E0E6           A3         01E4              mov 0x79*4, ax
 +a   E0E9           B8                   0000    mov ax,  #0
 +a   E0EC           A3         01E6              mov 0x79*4+2, ax
39633                                             ;; base memory in K 40:13 (word)
39634 E0EF           B8                   027F    mov ax, #(640 - 1)
39635 E0F2           A3         0413              mov 0x0413, ax
39636                                             ;; Manufacturing Test 40:12
39637                                             ;; zerod out above
39638                                             ;; Warm Boot Flag 0040:0072
39639                                             ;; value of 1234h = skip memory checks
39640                                             ;; zerod out above
39641                                             ;; Printer Services vector
39642                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   E0F5           B8                   EFD2    mov ax,  #int17_handler
 +a   E0F8           A3         005C              mov 0x17*4, ax
 +a   E0FB           B8                   F000    mov ax,  #0xF000
 +a   E0FE           A3         005E              mov 0x17*4+2, ax
39643                                             ;; Bootstrap failure vector
39644                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   E101           B8                   A819    mov ax,  #int18_handler
 +a   E104           A3         0060              mov 0x18*4, ax
 +a   E107           B8                   F000    mov ax,  #0xF000
 +a   E10A           A3         0062              mov 0x18*4+2, ax
39645                                             ;; Bootstrap Loader vector
39646                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   E10D           B8                   E6F2    mov ax,  #int19_handler
 +a   E110           A3         0064              mov 0x19*4, ax
 +a   E113           B8                   F000    mov ax,  #0xF000
 +a   E116           A3         0066              mov 0x19*4+2, ax
39647                                             ;; User Timer Tick vector
39648                                             SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
 +a   E119           B8                   A84B    mov ax,  #int1c_handler
 +a   E11C           A3         0070              mov 0x1c*4, ax
 +a   E11F           B8                   F000    mov ax,  #0xF000
 +a   E122           A3         0072              mov 0x1c*4+2, ax
39649                                             ;; Memory Size Check vector
39650                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   E125           B8                   F841    mov ax,  #int12_handler
 +a   E128           A3         0048              mov 0x12*4, ax
 +a   E12B           B8                   F000    mov ax,  #0xF000
 +a   E12E           A3         004A              mov 0x12*4+2, ax
39651                                             ;; Equipment Configuration Check vector
39652                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   E131           B8                   F84D    mov ax,  #int11_handler
 +a   E134           A3         0044              mov 0x11*4, ax
 +a   E137           B8                   F000    mov ax,  #0xF000
 +a   E13A           A3         0046              mov 0x11*4+2, ax
39653                                             ;; System Services
39654                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   E13D           B8                   F859    mov ax,  #int15_handler
 +a   E140           A3         0054              mov 0x15*4, ax
 +a   E143           B8                   F000    mov ax,  #0xF000
 +a   E146           A3         0056              mov 0x15*4+2, ax
39655                                             ;; EBDA setup
39656 E149           E8         C9AF              call ebda_post
39657                                             ;; PIT setup
39658                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E14C           B8                   FEA5    mov ax,  #int08_handler
 +a   E14F           A3         0020              mov 0x08*4, ax
 +a   E152           B8                   F000    mov ax,  #0xF000
 +a   E155           A3         0022              mov 0x08*4+2, ax
39659                                             ;; int 1C already points at dummy_iret_handler (above)
39660 E158           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
39661 E15A           E6                     43    out 0x43, al
39662 E15C           B0                     0B    mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
39663 E15E           E6                     40    out 0x40, al ; lsb
39664 E160           B0                     E9    mov al, #0xe9
39665 E162           E6                     40    out 0x40, al ; msb
39666                                             ;; Keyboard
39667                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E164           B8                   E987    mov ax,  #int09_handler
 +a   E167           A3         0024              mov 0x09*4, ax
 +a   E16A           B8                   F000    mov ax,  #0xF000
 +a   E16D           A3         0026              mov 0x09*4+2, ax
39668                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E170           B8                   E82E    mov ax,  #int16_handler
 +a   E173           A3         0058              mov 0x16*4, ax
 +a   E176           B8                   F000    mov ax,  #0xF000
 +a   E179           A3         005A              mov 0x16*4+2, ax
39669 E17C           31C0                         xor ax, ax
39670 E17E           8ED8                         mov ds, ax
39671 E180           A2         0417              mov 0x0417, al
39672 E183           A2         0418              mov 0x0418, al
39673 E186           A2         0419              mov 0x0419, al
39674 E189           A2         0471              mov 0x0471, al
39675 E18C           A2         0497              mov 0x0497, al
39676 E18F           B0                     10    mov al, #0x10
39677 E191           A2         0496              mov 0x0496, al
39678 E194           BB                   001E    mov bx, #0x001E
39679 E197           891E       041A              mov 0x041A, bx
39680 E19B           891E       041C              mov 0x041C, bx
39681 E19F           BB                   001E    mov bx, #0x001E
39682 E1A2           891E       0480              mov 0x0480, bx
39683 E1A6           BB                   003E    mov bx, #0x003E
39684 E1A9           891E       0482              mov 0x0482, bx
39685 E1AD           E8         2C3E              call _keyboard_init
39686                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
39687 E1B0           A1         0410              mov ax, 0x0410
39688 E1B3           B0                     14    mov al, #0x14
39689 E1B5           E6                     70    out 0x70, al
39690 E1B7           E4                     71    in al, 0x71
39691 E1B9           A3         0410              mov 0x0410, ax
39692                                             ;; Parallel setup
39693                                             SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
 +a   E1BC           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1BF           A3         003C              mov 0x0F*4, ax
 +a   E1C2           B8                   F000    mov ax,  #0xF000
 +a   E1C5           A3         003E              mov 0x0F*4+2, ax
39694 E1C8           31C0                         xor ax, ax
39695 E1CA           8ED8                         mov ds, ax
39696 E1CC           31DB                         xor bx, bx
39697 E1CE           B1                     14    mov cl, #0x14 ; timeout value
39698 E1D0           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
39699 E1D3           E8         D356              call detect_parport
39700 E1D6           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
39701 E1D9           E8         D350              call detect_parport
39702 E1DC           C1E3                   0E    shl bx, #0x0e
39703 E1DF           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
39704 E1E2           25                   3FFF    and ax, #0x3fff
39705 E1E5           09D8                         or ax, bx ; set number of parallel ports
39706 E1E7           A3         0410              mov 0x410, ax
39707                                             ;; Serial setup
39708                                             SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
 +a   E1EA           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1ED           A3         0030              mov 0x0C*4, ax
 +a   E1F0           B8                   F000    mov ax,  #0xF000
 +a   E1F3           A3         0032              mov 0x0C*4+2, ax
39709                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E1F6           B8                   E739    mov ax,  #int14_handler
 +a   E1F9           A3         0050              mov 0x14*4, ax
 +a   E1FC           B8                   F000    mov ax,  #0xF000
 +a   E1FF           A3         0052              mov 0x14*4+2, ax
39710 E202           31DB                         xor bx, bx
39711 E204           B1                     0A    mov cl, #0x0a ; timeout value
39712 E206           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
39713 E209           E8         D33F              call detect_serial
39714 E20C           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
39715 E20F           E8         D339              call detect_serial
39716 E212           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
39717 E215           E8         D333              call detect_serial
39718 E218           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
39719 E21B           E8         D32D              call detect_serial
39720 E21E           C1E3                   09    shl bx, #0x09
39721 E221           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
39722 E224           25                   F1FF    and ax, #0xf1ff
39723 E227           09D8                         or ax, bx ; set number of serial port
39724 E229           A3         0410              mov 0x410, ax
39725                                             ;; CMOS RTC
39726                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E22C           B8                   FE6E    mov ax,  #int1a_handler
 +a   E22F           A3         0068              mov 0x1A*4, ax
 +a   E232           B8                   F000    mov ax,  #0xF000
 +a   E235           A3         006A              mov 0x1A*4+2, ax
39727                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E238           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E23B           A3         0128              mov 0x4A*4, ax
 +a   E23E           B8                   F000    mov ax,  #0xF000
 +a   E241           A3         012A              mov 0x4A*4+2, ax
39728                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E244           B8                   FE93    mov ax,  #int70_handler
 +a   E247           A3         01C0              mov 0x70*4, ax
 +a   E24A           B8                   F000    mov ax,  #0xF000
 +a   E24D           A3         01C2              mov 0x70*4+2, ax
39729                                             ;; BIOS DATA AREA 0x4CE ???
39730 E250           E8         C90E              call timer_tick_post
39731                                             ;; PS/2 mouse setup
39732                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E253           B8                   A751    mov ax,  #int74_handler
 +a   E256           A3         01D0              mov 0x74*4, ax
 +a   E259           B8                   F000    mov ax,  #0xF000
 +a   E25C           A3         01D2              mov 0x74*4+2, ax
39733                                             ;; IRQ13 (FPU exception) setup
39734                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E25F           B8                   E2C7    mov ax,  #int75_handler
 +a   E262           A3         01D4              mov 0x75*4, ax
 +a   E265           B8                   F000    mov ax,  #0xF000
 +a   E268           A3         01D6              mov 0x75*4+2, ax
39735                                             ;; Video setup
39736                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E26B           B8                   F065    mov ax,  #int10_handler
 +a   E26E           A3         0040              mov 0x10*4, ax
 +a   E271           B8                   F000    mov ax,  #0xF000
 +a   E274           A3         0042              mov 0x10*4+2, ax
39737                                             ;; PIC
39738 E277           E8         D443              call post_init_pic
39739 E27A           B9                   C000    mov cx, #0xc000 ;; init vga bios
39740 E27D           B8                   C780    mov ax, #0xc780
39741 E280           E8         D332              call rom_scan
39742 E283           E8         30C7              call _print_bios_banner
39743                                             ;;
39744                                             ;; Floppy setup
39745                                             ;;
39746 E286           E8         C5C3              call floppy_drive_post
39747                                             ;;
39748                                             ;; Hard Drive setup
39749                                             ;;
39750 E289           E8         C647              call hard_drive_post
39751                                             ;;
39752                                             ;; ATA/ATAPI driver setup
39753                                             ;;
39754 E28C           E8         374F              call _ata_init
39755 E28F           E8         3B7D              call _ata_detect
39756                                             ;;
39757                                             ;;
39758                                             ;; eltorito floppy/harddisk emulation from cd
39759                                             ;;
39760 E292           E8         5BC0              call _cdemu_init
39761                                             ;;
39762 E295           E8         23FC              call _enable_rom_write_access
39763 E298           E8         3072              call _clobber_entry_point
39764 E29B           E8         23B2              call _fixup_base_mem_in_k
39765 E29E           E8         D3F9              call smbios_init
39766 E2A1           E8         3102              call _init_boot_vectors
39767 E2A4           B9                   C800    mov cx, #(0x000C8000 >> 4) ;; init option roms
39768 E2A7           B8                   EA00    mov ax, #(0x000EA000 >> 4)
39769 E2AA           E8         D308              call rom_scan
39770 E2AD           E8         23F5              call _disable_rom_write_access
39771 E2B0           E8         32B1              call _interactive_bootkey
39772 E2B3           FB                           sti ;; enable interrupts
39773                                             ;; Start the boot sequence. See the comments in int19_relocated
39774                                             ;; for why we use INT 18h instead of INT 19h here.
39775 E2B4           CD                     18    int #0x18
39776 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
39777                       0000E2C3            nmi:
39778                                             ;; FIXME the NMI handler should not panic
39779                                             ;; but iret when called from int75 (fpu exception)
39780 E2C3           E8         35EC              call _nmi_handler_msg
39781 E2C6           CF                           iret
39782                       0000E2C7            int75_handler:
39783 E2C7           E6                     F0    out 0xf0, al
39784 E2C9           E8         C87D              call eoi_both_pics
39785 E2CC           CD                     02    int 2
39786 E2CE           CF                           iret
39787                                           ;-------------------------------------------
39788                                           ;- INT 13h Fixed Disk Services Entry Point -
39789                                           ;-------------------------------------------
39790 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
39791                       0000E3FE            int13_handler:
39792 E3FE           E9         C38D              jmp int13_relocated
39793 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
39794                                           ;----------
39795                                           ;- INT19h -
39796                                           ;----------
39797 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
39798                       0000E6F2            int19_handler:
39799 E6F2           E9         C149              jmp int19_relocated
39800                                           ;-------------------------------------------
39801                                           ;- System BIOS Configuration Data Table
39802                                           ;-------------------------------------------
39803 E6F5                                      .org 0xe6f5
39804 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
39805 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
39806 E6F7                        FC            db 0xFC
39807 E6F8                        00            db 0x00
39808 E6F9                        01            db 1
39809                                           ; Feature byte 1
39810                                           ; b7: 1=DMA channel 3 used by hard disk
39811                                           ; b6: 1=2 interrupt controllers present
39812                                           ; b5: 1=RTC present
39813                                           ; b4: 1=BIOS calls int 15h/4Fh every key
39814                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
39815                                           ; b2: 1=extended BIOS data area used
39816                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
39817                                           ; b0: 1=Dual bus (MicroChannel + ISA)
39818 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
39819                                           ; Feature byte 2
39820                                           ; b7: 1=32-bit DMA supported
39821                                           ; b6: 1=int16h, function 9 supported
39822                                           ; b5: 1=int15h/C6h (get POS data) supported
39823                                           ; b4: 1=int15h/C7h (get mem map info) supported
39824                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
39825                                           ; b2: 1=non-8042 kb controller
39826                                           ; b1: 1=data streaming supported
39827                                           ; b0: reserved
39828 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
39829                                           ; Feature byte 3
39830                                           ; b7: not used
39831                                           ; b6: reserved
39832                                           ; b5: reserved
39833                                           ; b4: POST supports ROM-to-RAM enable/disable
39834                                           ; b3: SCSI on system board
39835                                           ; b2: info panel installed
39836                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
39837                                           ; b0: SCSI supported in IML
39838 E6FC                        00            db 0x00
39839                                           ; Feature byte 4
39840                                           ; b7: IBM private
39841                                           ; b6: EEPROM present
39842                                           ; b5-3: ABIOS presence (011 = not supported)
39843                                           ; b2: private
39844                                           ; b1: memory split above 16Mb supported
39845                                           ; b0: POSTEXT directly supported by POST
39846 E6FD                        00            db 0x00
39847                                           ; Feature byte 5 (IBM)
39848                                           ; b1: enhanced mouse
39849                                           ; b0: flash EPROM
39850 E6FE                        00            db 0x00
39851 E729                                      .org 0xe729 ; Baud Rate Generator Table
39852                                           ;----------
39853                                           ;- INT14h -
39854                                           ;----------
39855 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
39856                       0000E739            int14_handler:
39857 E739           1E                           push ds
39858 E73A           60                           pusha
39859 E73B           31C0                         xor ax, ax
39860 E73D           8ED8                         mov ds, ax
39861 E73F           E8         5F2D              call _int14_function
39862 E742           61                           popa
39863 E743           1F                           pop ds
39864 E744           CF                           iret
39865                                           ;----------------------------------------
39866                                           ;- INT 16h Keyboard Service Entry Point -
39867                                           ;----------------------------------------
39868 E82E                                      .org 0xe82e
39869                       0000E82E            int16_handler:
39870 E82E           FB                           sti
39871 E82F           1E                           push ds
39872 E830           9C                           pushf
39873 E831           60                           pusha
39874 E832           80FC                   00    cmp ah, #0x00
39875 E835           74           24              je int16_F00
39876 E837           80FC                   10    cmp ah, #0x10
39877 E83A           74           1F              je int16_F00
39878 E83C           BB                   F000    mov bx, #0xf000
39879 E83F           8EDB                         mov ds, bx
39880 E841           E8         7046              call _int16_function
39881 E844           61                           popa
39882 E845           9D                           popf
39883 E846           1F                           pop ds
39884 E847           74           09              jz int16_zero_set
39885                       0000E849            int16_zero_clear:
39886 E849           55                           push bp
39887 E84A           89E5                         mov bp, sp
39888 E84C           8066         06        BF    and BYTE [bp + 0x06], #0xbf
39889 E850           5D                           pop bp
39890 E851           CF                           iret
39891                       0000E852            int16_zero_set:
39892 E852           55                           push bp
39893 E853           89E5                         mov bp, sp
39894 E855           804E         06        40    or BYTE [bp + 0x06], #0x40
39895 E859           5D                           pop bp
39896 E85A           CF                           iret
39897                       0000E85B            int16_F00:
39898 E85B           BB                   0040    mov bx, #0x0040
39899 E85E           8EDB                         mov ds, bx
39900                       0000E860            int16_wait_for_key:
39901 E860           FA                           cli
39902 E861           8B1E       001A              mov bx, 0x001a
39903 E865           3B1E       001C              cmp bx, 0x001c
39904 E869           75           04              jne int16_key_found
39905 E86B           FB                           sti
39906 E86C           F4                           hlt
39907 E86D           EB           F1              jmp int16_wait_for_key
39908                       0000E86F            int16_key_found:
39909 E86F           BB                   F000    mov bx, #0xf000
39910 E872           8EDB                         mov ds, bx
39911 E874           E8         7013              call _int16_function
39912 E877           61                           popa
39913 E878           9D                           popf
39914 E879           1F                           pop ds
39915 E87A           CF                           iret
39916                                           ;-------------------------------------------------
39917                                           ;- INT09h : Keyboard Hardware Service Entry Point -
39918                                           ;-------------------------------------------------
39919 E987                                      .org 0xe987
39920                       0000E987            int09_handler:
39921 E987           FA                           cli
39922 E988           50                           push ax
39923 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
39924 E98B           E6                     64    out #0x64, al
39925 E98D           B0                     0B    mov al, #0x0B
39926 E98F           E6                     20    out #0x20, al
39927 E991           E4                     20    in al, #0x20
39928 E993           24                     02    and al, #0x02
39929 E995           74           3E              jz int09_finish
39930 E997           E4                     60    in al, #0x60 ;;read key from keyboard controller
39931 E999           FB                           sti
39932 E99A           1E                           push ds
39933 E99B           60                           pusha
39934 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
39935 E99E           F9                           stc
39936 E99F           CD                     15    int #0x15
39937 E9A1           73           2C              jnc int09_done
39938                                             ;; check for extended key
39939 E9A3           3C                     E0    cmp al, #0xe0
39940 E9A5           75           0E              jne int09_check_pause
39941 E9A7           31C0                         xor ax, ax
39942 E9A9           8ED8                         mov ds, ax
39943 E9AB           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x02
39944 E9AE           0C                     02    or al, #0x02
39945 E9B0           A2         0496              mov BYTE [0x496], al
39946 E9B3           EB           1A              jmp int09_done
39947                       0000E9B5            int09_check_pause: ;; check for pause key
39948 E9B5           3C                     E1    cmp al, #0xe1
39949 E9B7           75           0E              jne int09_process_key
39950 E9B9           31C0                         xor ax, ax
39951 E9BB           8ED8                         mov ds, ax
39952 E9BD           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x01
39953 E9C0           0C                     01    or al, #0x01
39954 E9C2           A2         0496              mov BYTE [0x496], al
39955 E9C5           EB           08              jmp int09_done
39956                       0000E9C7            int09_process_key:
39957 E9C7           BB                   F000    mov bx, #0xf000
39958 E9CA           8EDB                         mov ds, bx
39959 E9CC           E8         7613              call _int09_function
39960                       0000E9CF            int09_done:
39961 E9CF           61                           popa
39962 E9D0           1F                           pop ds
39963 E9D1           FA                           cli
39964 E9D2           E8         C178              call eoi_master_pic
39965                       0000E9D5            int09_finish:
39966 E9D5           B0                     AE    mov al, #0xAE ;;enable keyboard
39967 E9D7           E6                     64    out #0x64, al
39968 E9D9           58                           pop ax
39969 E9DA           CF                           iret
39970                                           ;----------------------------------------
39971                                           ;- INT 13h Diskette Service Entry Point -
39972                                           ;----------------------------------------
39973 EC59                                      .org 0xec59
39974                       0000EC59            int13_diskette:
39975 EC59           E9         BB81              jmp int13_noeltorito
39976                                           ;---------------------------------------------
39977                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
39978                                           ;---------------------------------------------
39979 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
39980                       0000EF57            int0e_handler:
39981 EF57           50                           push ax
39982 EF58           52                           push dx
39983 EF59           BA                   03F4    mov dx, #0x03f4
39984 EF5C           EC                           in al, dx
39985 EF5D           24                     C0    and al, #0xc0
39986 EF5F           3C                     C0    cmp al, #0xc0
39987 EF61           74           1E              je int0e_normal
39988 EF63           BA                   03F5    mov dx, #0x03f5
39989 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
39990 EF68           EE                           out dx, al
39991                       0000EF69            int0e_loop1:
39992 EF69           BA                   03F4    mov dx, #0x03f4
39993 EF6C           EC                           in al, dx
39994 EF6D           24                     C0    and al, #0xc0
39995 EF6F           3C                     C0    cmp al, #0xc0
39996 EF71           75           F6              jne int0e_loop1
39997                       0000EF73            int0e_loop2:
39998 EF73           BA                   03F5    mov dx, #0x03f5
39999 EF76           EC                           in al, dx
40000 EF77           BA                   03F4    mov dx, #0x03f4
40001 EF7A           EC                           in al, dx
40002 EF7B           24                     C0    and al, #0xc0
40003 EF7D           3C                     C0    cmp al, #0xc0
40004 EF7F           74           F2              je int0e_loop2
40005                       0000EF81            int0e_normal:
40006 EF81           1E                           push ds
40007 EF82           31C0                         xor ax, ax ;; segment 0000
40008 EF84           8ED8                         mov ds, ax
40009 EF86           E8         BBC4              call eoi_master_pic
40010 EF89           A0         043E              mov al, 0x043e
40011 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
40012 EF8E           A2         043E              mov 0x043e, al
40013 EF91           1F                           pop ds
40014 EF92           5A                           pop dx
40015 EF93           58                           pop ax
40016 EF94           CF                           iret
40017 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
40018                       0000EFC7            diskette_param_table:
40019                                           ;; Since no provisions are made for multiple drive types, most
40020                                           ;; values in this table are ignored. I set parameters for 1.44M
40021                                           ;; floppy here
40022 EFC7                        AF            db 0xAF
40023 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
40024 EFC9                        25            db 0x25
40025 EFCA                        02            db 0x02
40026 EFCB                        12            db 18
40027 EFCC                        1B            db 0x1B
40028 EFCD                        FF            db 0xFF
40029 EFCE                        6C            db 0x6C
40030 EFCF                        F6            db 0xF6
40031 EFD0                        0F            db 0x0F
40032 EFD1                        08            db 0x08
40033                                           ;----------------------------------------
40034                                           ;- INT17h : Printer Service Entry Point -
40035                                           ;----------------------------------------
40036 EFD2                                      .org 0xefd2
40037                       0000EFD2            int17_handler:
40038 EFD2           1E                           push ds
40039 EFD3           60                           pusha
40040 EFD4           31C0                         xor ax, ax
40041 EFD6           8ED8                         mov ds, ax
40042 EFD8           E8         AF62              call _int17_function
40043 EFDB           61                           popa
40044 EFDC           1F                           pop ds
40045 EFDD           CF                           iret
40046                       0000EFDE            diskette_param_table2:
40047                                           ;; New diskette parameter table adding 3 parameters from IBM
40048                                           ;; Since no provisions are made for multiple drive types, most
40049                                           ;; values in this table are ignored. I set parameters for 1.44M
40050                                           ;; floppy here
40051 EFDE                        AF            db 0xAF
40052 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
40053 EFE0                        25            db 0x25
40054 EFE1                        02            db 0x02
40055 EFE2                        12            db 18
40056 EFE3                        1B            db 0x1B
40057 EFE4                        FF            db 0xFF
40058 EFE5                        6C            db 0x6C
40059 EFE6                        F6            db 0xF6
40060 EFE7                        0F            db 0x0F
40061 EFE8                        08            db 0x08
40062 EFE9                        4F            db 79 ;; maximum track
40063 EFEA                        00            db 0 ;; data transfer rate
40064 EFEB                        04            db 4 ;; drive type in cmos
40065 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
40066                                             HALT(11461)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2CC5    mov ax,#11461
 +a   F04B           EF                           out dx,ax
40067 F04C           CF                           iret
40068                                           ;----------
40069                                           ;- INT10h -
40070                                           ;----------
40071 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
40072                       0000F065            int10_handler:
40073                                             ;; dont do anything, since the VGA BIOS handles int10h requests
40074 F065           CF                           iret
40075 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
40076                                           ;----------
40077                                           ;- INT12h -
40078                                           ;----------
40079 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
40080                                           ; ??? different for Pentium (machine check)?
40081                       0000F841            int12_handler:
40082 F841           1E                           push ds
40083 F842           B8                   0040    mov ax, #0x0040
40084 F845           8ED8                         mov ds, ax
40085 F847           A1         0013              mov ax, 0x0013
40086 F84A           1F                           pop ds
40087 F84B           CF                           iret
40088                                           ;----------
40089                                           ;- INT11h -
40090                                           ;----------
40091 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
40092                       0000F84D            int11_handler:
40093 F84D           1E                           push ds
40094 F84E           B8                   0040    mov ax, #0x0040
40095 F851           8ED8                         mov ds, ax
40096 F853           A1         0010              mov ax, 0x0010
40097 F856           1F                           pop ds
40098 F857           CF                           iret
40099                                           ;----------
40100                                           ;- INT15h -
40101                                           ;----------
40102 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
40103                       0000F859            int15_handler:
40104 F859           9C                           pushf
40105 F85A           80FC                   53    cmp ah, #0x53
40106 F85D           74           1C              je apm_call
40107 F85F           1E                           push ds
40108 F860           06                           push es
40109 F861           80FC                   86    cmp ah, #0x86
40110 F864           74           1D              je int15_handler32
40111 F866           80FC                   E8    cmp ah, #0xE8
40112 F869           74           18              je int15_handler32
40113 F86B           60                           pusha
40114 F86C           80FC                   C2    cmp ah, #0xC2
40115 F86F           74           0D              je int15_handler_mouse
40116 F871           E8         506B              call _int15_function
40117                       0000F874            int15_handler_mouse_ret:
40118 F874           61                           popa
40119                       0000F875            int15_handler32_ret:
40120 F875           07                           pop es
40121 F876           1F                           pop ds
40122 F877           9D                           popf
40123 F878           E9         AEFF              jmp iret_modify_cf
40124                       0000F87B            apm_call:
40125 F87B           E9         B54F              jmp _apmreal_entry
40126                       0000F87E            int15_handler_mouse:
40127 F87E           E8         555A              call _int15_function_mouse
40128 F881           EB           F1              jmp int15_handler_mouse_ret
40129                       0000F883            int15_handler32:
40130 F883     66    60                           pushad
40131 F885           E8         5C96              call _int15_function32
40132 F888     66    61                           popad
40133 F88A           EB           E9              jmp int15_handler32_ret
40134                                           ;; Protected mode IDT descriptor
40135                                           ;;
40136                                           ;; I just make the limit 0, so the machine will shutdown
40137                                           ;; if an exception occurs during protected mode memory
40138                                           ;; transfers.
40139                                           ;;
40140                                           ;; Set base to f0000 to correspond to beginning of BIOS,
40141                                           ;; in case I actually define an IDT later
40142                                           ;; Set limit to 0
40143                       0000F88C            pmode_IDT_info:
40144 F88C                      0000            dw 0x0000 ;; limit 15:00
40145 F88E                      0000            dw 0x0000 ;; base 15:00
40146 F890                        0F            db 0x0f ;; base 23:16
40147                                           ;; Real mode IDT descriptor
40148                                           ;;
40149                                           ;; Set to typical real-mode values.
40150                                           ;; base = 000000
40151                                           ;; limit = 03ff
40152                       0000F891            rmode_IDT_info:
40153 F891                      03FF            dw 0x03ff ;; limit 15:00
40154 F893                      0000            dw 0x0000 ;; base 15:00
40155 F895                        00            db 0x00 ;; base 23:16
40156                                           ;----------
40157                                           ;- INT1Ah -
40158                                           ;----------
40159 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
40160                       0000FE6E            int1a_handler:
40161 FE6E           80FC                   B1    cmp ah, #0xb1
40162 FE71           75           14              jne int1a_normal
40163 FE73           E8         B455              call pcibios_real
40164 FE76           72           03              jc pcibios_error
40165 FE78           CA                   0002    retf 2
40166                       0000FE7B            pcibios_error:
40167 FE7B           88E3                         mov bl, ah
40168 FE7D           B4                     B1    mov ah, #0xb1
40169 FE7F           1E                           push ds
40170 FE80           60                           pusha
40171 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
40172 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
40173 FE85           EB           06              jmp int1a_callfunction
40174                       0000FE87            int1a_normal:
40175 FE87           1E                           push ds
40176 FE88           60                           pusha
40177 FE89           31C0                         xor ax, ax
40178 FE8B           8ED8                         mov ds, ax
40179                       0000FE8D            int1a_callfunction:
40180 FE8D           E8         A457              call _int1a_function
40181 FE90           61                           popa
40182 FE91           1F                           pop ds
40183 FE92           CF                           iret
40184                                           ;;
40185                                           ;; int70h: IRQ8 - CMOS RTC
40186                                           ;;
40187                       0000FE93            int70_handler:
40188 FE93           1E                           push ds
40189 FE94     66    60                           pushad
40190 FE96           31C0                         xor ax, ax
40191 FE98           8ED8                         mov ds, ax
40192 FE9A           E8         A78C              call _int70_function
40193 FE9D     66    61                           popad
40194 FE9F           1F                           pop ds
40195 FEA0           CF                           iret
40196                                           ;---------
40197                                           ;- INT08 -
40198                                           ;---------
40199 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
40200                       0000FEA5            int08_handler:
40201 FEA5           FB                           sti
40202 FEA6     66    50                           push eax
40203 FEA8           1E                           push ds
40204 FEA9           31C0                         xor ax, ax
40205 FEAB           8ED8                         mov ds, ax
40206                                             ;; time to turn off drive(s)?
40207 FEAD           A0         0440              mov al,0x0440
40208 FEB0           08C0                         or al,al
40209 FEB2           74           10              jz int08_floppy_off
40210 FEB4           FEC8                         dec al
40211 FEB6           A2         0440              mov 0x0440,al
40212 FEB9           75           09              jnz int08_floppy_off
40213                                             ;; turn motor(s) off
40214 FEBB           52                           push dx
40215 FEBC           BA                   03F2    mov dx,#0x03f2
40216 FEBF           EC                           in al,dx
40217 FEC0           24                     CF    and al,#0xcf
40218 FEC2           EE                           out dx,al
40219 FEC3           5A                           pop dx
40220                       0000FEC4            int08_floppy_off:
40221 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
40222 FEC8     66    40                           inc eax
40223                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
40224 FECA     66    3D               001800B0    cmp eax, #0x001800B0
40225 FED0           72           07              jb int08_store_ticks
40226                                             ;; there has been a midnight rollover at this point
40227 FED2     66    31C0                         xor eax, eax ;; zero out counter
40228 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
40229                       0000FED9            int08_store_ticks:
40230 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
40231                                             ;; chain to user timer tick INT #0x1c
40232 FEDD           CD                     1C    int #0x1c
40233 FEDF           FA                           cli
40234 FEE0           E8         AC6A              call eoi_master_pic
40235 FEE3           1F                           pop ds
40236 FEE4     66    58                           pop eax
40237 FEE6           CF                           iret
40238 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
40239 FF00                                      .org 0xff00
40240 FF00                        28            .ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
40241                                           ;------------------------------------------------
40242                                           ;- IRET Instruction for Dummy Interrupt Handler -
40243                                           ;------------------------------------------------
40244 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
40245                       0000FF53            dummy_iret_handler:
40246 FF53           CF                           iret
40247 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
40248                                             HALT(11695)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2DAF    mov ax,#11695
 +a   FF5A           EF                           out dx,ax
40249 FF5B           CF                           iret
40250 FFF0                                      .org 0xfff0 ; Power-up Entry Point
40251 FFF0           EA         E05B      F000     jmp 0xf000:post
40252 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
40253 FFF5                        30            .ascii "06/23/99"
40254 FFFE                                      .org 0xfffe ; System Model ID
40255 FFFE                        FC            db 0xFC
40256 FFFF                        00            db 0x00 ; filler
40257 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
40258                                           ! 8242 endasm
40259                                           !BCC_ENDASM
40260                                           ! 8243 static Bit8u vgafont8[128*8]=
40261                                           ! Register BX used in function int1a_function32
40262                                           ! 8244 {
40263                                           
40264                       0000FA6E            _vgafont8:
40265                                           ! 8245  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40266 FA6E                        00            .byte	0
40267 FA6F                        00            .byte	0
40268 FA70                        00            .byte	0
40269 FA71                        00            .byte	0
40270 FA72                        00            .byte	0
40271 FA73                        00            .byte	0
40272 FA74                        00            .byte	0
40273 FA75                        00            .byte	0
40274                                           ! 8246  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
40275 FA76                        7E            .byte	$7E
40276 FA77                        81            .byte	$81
40277 FA78                        A5            .byte	$A5
40278 FA79                        81            .byte	$81
40279 FA7A                        BD            .byte	$BD
40280 FA7B                        99            .byte	$99
40281 FA7C                        81            .byte	$81
40282 FA7D                        7E            .byte	$7E
40283                                           ! 8247  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
40284 FA7E                        7E            .byte	$7E
40285 FA7F                        FF            .byte	$FF
40286 FA80                        DB            .byte	$DB
40287 FA81                        FF            .byte	$FF
40288 FA82                        C3            .byte	$C3
40289 FA83                        E7            .byte	$E7
40290 FA84                        FF            .byte	$FF
40291 FA85                        7E            .byte	$7E
40292                                           ! 8248  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40293 FA86                        6C            .byte	$6C
40294 FA87                        FE            .byte	$FE
40295 FA88                        FE            .byte	$FE
40296 FA89                        FE            .byte	$FE
40297 FA8A                        7C            .byte	$7C
40298 FA8B                        38            .byte	$38
40299 FA8C                        10            .byte	$10
40300 FA8D                        00            .byte	0
40301                                           ! 8249  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40302 FA8E                        10            .byte	$10
40303 FA8F                        38            .byte	$38
40304 FA90                        7C            .byte	$7C
40305 FA91                        FE            .byte	$FE
40306 FA92                        7C            .byte	$7C
40307 FA93                        38            .byte	$38
40308 FA94                        10            .byte	$10
40309 FA95                        00            .byte	0
40310                                           ! 8250  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
40311 FA96                        38            .byte	$38
40312 FA97                        7C            .byte	$7C
40313 FA98                        38            .byte	$38
40314 FA99                        FE            .byte	$FE
40315 FA9A                        FE            .byte	$FE
40316 FA9B                        7C            .byte	$7C
40317 FA9C                        38            .byte	$38
40318 FA9D                        7C            .byte	$7C
40319                                           ! 8251  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
40320 FA9E                        10            .byte	$10
40321 FA9F                        10            .byte	$10
40322 FAA0                        38            .byte	$38
40323 FAA1                        7C            .byte	$7C
40324 FAA2                        FE            .byte	$FE
40325 FAA3                        7C            .byte	$7C
40326 FAA4                        38            .byte	$38
40327 FAA5                        7C            .byte	$7C
40328                                           ! 8252  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
40329 FAA6                        00            .byte	0
40330 FAA7                        00            .byte	0
40331 FAA8                        18            .byte	$18
40332 FAA9                        3C            .byte	$3C
40333 FAAA                        3C            .byte	$3C
40334 FAAB                        18            .byte	$18
40335 FAAC                        00            .byte	0
40336 FAAD                        00            .byte	0
40337                                           ! 8253  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
40338 FAAE                        FF            .byte	$FF
40339 FAAF                        FF            .byte	$FF
40340 FAB0                        E7            .byte	$E7
40341 FAB1                        C3            .byte	$C3
40342 FAB2                        C3            .byte	$C3
40343 FAB3                        E7            .byte	$E7
40344 FAB4                        FF            .byte	$FF
40345 FAB5                        FF            .byte	$FF
40346                                           ! 8254  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
40347 FAB6                        00            .byte	0
40348 FAB7                        3C            .byte	$3C
40349 FAB8                        66            .byte	$66
40350 FAB9                        42            .byte	$42
40351 FABA                        42            .byte	$42
40352 FABB                        66            .byte	$66
40353 FABC                        3C            .byte	$3C
40354 FABD                        00            .byte	0
40355                                           ! 8255  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
40356 FABE                        FF            .byte	$FF
40357 FABF                        C3            .byte	$C3
40358 FAC0                        99            .byte	$99
40359 FAC1                        BD            .byte	$BD
40360 FAC2                        BD            .byte	$BD
40361 FAC3                        99            .byte	$99
40362 FAC4                        C3            .byte	$C3
40363 FAC5                        FF            .byte	$FF
40364                                           ! 8256  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
40365 FAC6                        0F            .byte	$F
40366 FAC7                        07            .byte	7
40367 FAC8                        0F            .byte	$F
40368 FAC9                        7D            .byte	$7D
40369 FACA                        CC            .byte	$CC
40370 FACB                        CC            .byte	$CC
40371 FACC                        CC            .byte	$CC
40372 FACD                        78            .byte	$78
40373                                           ! 8257  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
40374 FACE                        3C            .byte	$3C
40375 FACF                        66            .byte	$66
40376 FAD0                        66            .byte	$66
40377 FAD1                        66            .byte	$66
40378 FAD2                        3C            .byte	$3C
40379 FAD3                        18            .byte	$18
40380 FAD4                        7E            .byte	$7E
40381 FAD5                        18            .byte	$18
40382                                           ! 8258  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
40383 FAD6                        3F            .byte	$3F
40384 FAD7                        33            .byte	$33
40385 FAD8                        3F            .byte	$3F
40386 FAD9                        30            .byte	$30
40387 FADA                        30            .byte	$30
40388 FADB                        70            .byte	$70
40389 FADC                        F0            .byte	$F0
40390 FADD                        E0            .byte	$E0
40391                                           ! 8259  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
40392 FADE                        7F            .byte	$7F
40393 FADF                        63            .byte	$63
40394 FAE0                        7F            .byte	$7F
40395 FAE1                        63            .byte	$63
40396 FAE2                        63            .byte	$63
40397 FAE3                        67            .byte	$67
40398 FAE4                        E6            .byte	$E6
40399 FAE5                        C0            .byte	$C0
40400                                           ! 8260  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
40401 FAE6                        99            .byte	$99
40402 FAE7                        5A            .byte	$5A
40403 FAE8                        3C            .byte	$3C
40404 FAE9                        E7            .byte	$E7
40405 FAEA                        E7            .byte	$E7
40406 FAEB                        3C            .byte	$3C
40407 FAEC                        5A            .byte	$5A
40408 FAED                        99            .byte	$99
40409                                           ! 8261  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x0
40410 FAEE                        80            .byte	$80
40411 FAEF                        E0            .byte	$E0
40412 FAF0                        F8            .byte	$F8
40413 FAF1                        FE            .byte	$FE
40414 FAF2                        F8            .byte	$F8
40415 FAF3                        E0            .byte	$E0
40416 FAF4                        80            .byte	$80
40417                                           ! 8261 0,
40418 FAF5                        00            .byte	0
40419                                           ! 8262  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
40420 FAF6                        02            .byte	2
40421 FAF7                        0E            .byte	$E
40422 FAF8                        3E            .byte	$3E
40423 FAF9                        FE            .byte	$FE
40424 FAFA                        3E            .byte	$3E
40425 FAFB                        0E            .byte	$E
40426 FAFC                        02            .byte	2
40427 FAFD                        00            .byte	0
40428                                           ! 8263  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
40429 FAFE                        18            .byte	$18
40430 FAFF                        3C            .byte	$3C
40431 FB00                        7E            .byte	$7E
40432 FB01                        18            .byte	$18
40433 FB02                        18            .byte	$18
40434 FB03                        7E            .byte	$7E
40435 FB04                        3C            .byte	$3C
40436 FB05                        18            .byte	$18
40437                                           ! 8264  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
40438 FB06                        66            .byte	$66
40439 FB07                        66            .byte	$66
40440 FB08                        66            .byte	$66
40441 FB09                        66            .byte	$66
40442 FB0A                        66            .byte	$66
40443 FB0B                        00            .byte	0
40444 FB0C                        66            .byte	$66
40445 FB0D                        00            .byte	0
40446                                           ! 8265  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
40447 FB0E                        7F            .byte	$7F
40448 FB0F                        DB            .byte	$DB
40449 FB10                        DB            .byte	$DB
40450 FB11                        7B            .byte	$7B
40451 FB12                        1B            .byte	$1B
40452 FB13                        1B            .byte	$1B
40453 FB14                        1B            .byte	$1B
40454 FB15                        00            .byte	0
40455                                           ! 8266  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
40456 FB16                        3E            .byte	$3E
40457 FB17                        63            .byte	$63
40458 FB18                        38            .byte	$38
40459 FB19                        6C            .byte	$6C
40460 FB1A                        6C            .byte	$6C
40461 FB1B                        38            .byte	$38
40462 FB1C                        CC            .byte	$CC
40463 FB1D                        78            .byte	$78
40464                                           ! 8267  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
40465 FB1E                        00            .byte	0
40466 FB1F                        00            .byte	0
40467 FB20                        00            .byte	0
40468 FB21                        00            .byte	0
40469 FB22                        7E            .byte	$7E
40470 FB23                        7E            .byte	$7E
40471 FB24                        7E            .byte	$7E
40472 FB25                        00            .byte	0
40473                                           ! 8268  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
40474 FB26                        18            .byte	$18
40475 FB27                        3C            .byte	$3C
40476 FB28                        7E            .byte	$7E
40477 FB29                        18            .byte	$18
40478 FB2A                        7E            .byte	$7E
40479 FB2B                        3C            .byte	$3C
40480 FB2C                        18            .byte	$18
40481 FB2D                        FF            .byte	$FF
40482                                           ! 8269  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
40483 FB2E                        18            .byte	$18
40484 FB2F                        3C            .byte	$3C
40485 FB30                        7E            .byte	$7E
40486 FB31                        18            .byte	$18
40487 FB32                        18            .byte	$18
40488 FB33                        18            .byte	$18
40489 FB34                        18            .byte	$18
40490 FB35                        00            .byte	0
40491                                           ! 8270  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
40492 FB36                        18            .byte	$18
40493 FB37                        18            .byte	$18
40494 FB38                        18            .byte	$18
40495 FB39                        18            .byte	$18
40496 FB3A                        7E            .byte	$7E
40497 FB3B                        3C            .byte	$3C
40498 FB3C                        18            .byte	$18
40499 FB3D                        00            .byte	0
40500                                           ! 8271  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
40501 FB3E                        00            .byte	0
40502 FB3F                        18            .byte	$18
40503 FB40                        0C            .byte	$C
40504 FB41                        FE            .byte	$FE
40505 FB42                        0C            .byte	$C
40506 FB43                        18            .byte	$18
40507 FB44                        00            .byte	0
40508 FB45                        00            .byte	0
40509                                           ! 8272  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
40510 FB46                        00            .byte	0
40511 FB47                        30            .byte	$30
40512 FB48                        60            .byte	$60
40513 FB49                        FE            .byte	$FE
40514 FB4A                        60            .byte	$60
40515 FB4B                        30            .byte	$30
40516 FB4C                        00            .byte	0
40517 FB4D                        00            .byte	0
40518                                           ! 8273  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
40519 FB4E                        00            .byte	0
40520 FB4F                        00            .byte	0
40521 FB50                        C0            .byte	$C0
40522 FB51                        C0            .byte	$C0
40523 FB52                        C0            .byte	$C0
40524 FB53                        FE            .byte	$FE
40525 FB54                        00            .byte	0
40526 FB55                        00            .byte	0
40527                                           ! 8274  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
40528 FB56                        00            .byte	0
40529 FB57                        24            .byte	$24
40530 FB58                        66            .byte	$66
40531 FB59                        FF            .byte	$FF
40532 FB5A                        66            .byte	$66
40533 FB5B                        24            .byte	$24
40534 FB5C                        00            .byte	0
40535 FB5D                        00            .byte	0
40536                                           ! 8275  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
40537 FB5E                        00            .byte	0
40538 FB5F                        18            .byte	$18
40539 FB60                        3C            .byte	$3C
40540 FB61                        7E            .byte	$7E
40541 FB62                        FF            .byte	$FF
40542 FB63                        FF            .byte	$FF
40543 FB64                        00            .byte	0
40544 FB65                        00            .byte	0
40545                                           ! 8276  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
40546 FB66                        00            .byte	0
40547 FB67                        FF            .byte	$FF
40548 FB68                        FF            .byte	$FF
40549 FB69                        7E            .byte	$7E
40550 FB6A                        3C            .byte	$3C
40551 FB6B                        18            .byte	$18
40552 FB6C                        00            .byte	0
40553 FB6D                        00            .byte	0
40554                                           ! 8277  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40555 FB6E                        00            .byte	0
40556 FB6F                        00            .byte	0
40557 FB70                        00            .byte	0
40558 FB71                        00            .byte	0
40559 FB72                        00            .byte	0
40560 FB73                        00            .byte	0
40561 FB74                        00            .byte	0
40562 FB75                        00            .byte	0
40563                                           ! 8278  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
40564 FB76                        30            .byte	$30
40565 FB77                        78            .byte	$78
40566 FB78                        78            .byte	$78
40567 FB79                        30            .byte	$30
40568 FB7A                        30            .byte	$30
40569 FB7B                        00            .byte	0
40570 FB7C                        30            .byte	$30
40571 FB7D                        00            .byte	0
40572                                           ! 8279  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
40573 FB7E                        6C            .byte	$6C
40574 FB7F                        6C            .byte	$6C
40575 FB80                        6C            .byte	$6C
40576 FB81                        00            .byte	0
40577 FB82                        00            .byte	0
40578 FB83                        00            .byte	0
40579 FB84                        00            .byte	0
40580 FB85                        00            .byte	0
40581                                           ! 8280  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
40582 FB86                        6C            .byte	$6C
40583 FB87                        6C            .byte	$6C
40584 FB88                        FE            .byte	$FE
40585 FB89                        6C            .byte	$6C
40586 FB8A                        FE            .byte	$FE
40587 FB8B                        6C            .byte	$6C
40588 FB8C                        6C            .byte	$6C
40589 FB8D                        00            .byte	0
40590                                           ! 8281  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
40591 FB8E                        30            .byte	$30
40592 FB8F                        7C            .byte	$7C
40593 FB90                        C0            .byte	$C0
40594 FB91                        78            .byte	$78
40595 FB92                        0C            .byte	$C
40596 FB93                        F8            .byte	$F8
40597 FB94                        30            .byte	$30
40598 FB95                        00            .byte	0
40599                                           ! 8282  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
40600 FB96                        00            .byte	0
40601 FB97                        C6            .byte	$C6
40602 FB98                        CC            .byte	$CC
40603 FB99                        18            .byte	$18
40604 FB9A                        30            .byte	$30
40605 FB9B                        66            .byte	$66
40606 FB9C                        C6            .byte	$C6
40607 FB9D                        00            .byte	0
40608                                           ! 8283  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
40609 FB9E                        38            .byte	$38
40610 FB9F                        6C            .byte	$6C
40611 FBA0                        38            .byte	$38
40612 FBA1                        76            .byte	$76
40613 FBA2                        DC            .byte	$DC
40614 FBA3                        CC            .byte	$CC
40615 FBA4                        76            .byte	$76
40616 FBA5                        00            .byte	0
40617                                           ! 8284  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
40618 FBA6                        60            .byte	$60
40619 FBA7                        60            .byte	$60
40620 FBA8                        C0            .byte	$C0
40621 FBA9                        00            .byte	0
40622 FBAA                        00            .byte	0
40623 FBAB                        00            .byte	0
40624 FBAC                        00            .byte	0
40625 FBAD                        00            .byte	0
40626                                           ! 8285  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
40627 FBAE                        18            .byte	$18
40628 FBAF                        30            .byte	$30
40629 FBB0                        60            .byte	$60
40630 FBB1                        60            .byte	$60
40631 FBB2                        60            .byte	$60
40632 FBB3                        30            .byte	$30
40633 FBB4                        18            .byte	$18
40634 FBB5                        00            .byte	0
40635                                           ! 8286  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
40636 FBB6                        60            .byte	$60
40637 FBB7                        30            .byte	$30
40638 FBB8                        18            .byte	$18
40639 FBB9                        18            .byte	$18
40640 FBBA                        18            .byte	$18
40641 FBBB                        30            .byte	$30
40642 FBBC                        60            .byte	$60
40643 FBBD                        00            .byte	0
40644                                           ! 8287  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
40645 FBBE                        00            .byte	0
40646 FBBF                        66            .byte	$66
40647 FBC0                        3C            .byte	$3C
40648 FBC1                        FF            .byte	$FF
40649 FBC2                        3C            .byte	$3C
40650 FBC3                        66            .byte	$66
40651 FBC4                        00            .byte	0
40652 FBC5                        00            .byte	0
40653                                           ! 8288  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
40654 FBC6                        00            .byte	0
40655 FBC7                        30            .byte	$30
40656 FBC8                        30            .byte	$30
40657 FBC9                        FC            .byte	$FC
40658 FBCA                        30            .byte	$30
40659 FBCB                        30            .byte	$30
40660 FBCC                        00            .byte	0
40661 FBCD                        00            .byte	0
40662                                           ! 8289  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
40663 FBCE                        00            .byte	0
40664 FBCF                        00            .byte	0
40665 FBD0                        00            .byte	0
40666 FBD1                        00            .byte	0
40667 FBD2                        00            .byte	0
40668 FBD3                        30            .byte	$30
40669 FBD4                        30            .byte	$30
40670 FBD5                        60            .byte	$60
40671                                           ! 8290  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
40672 FBD6                        00            .byte	0
40673 FBD7                        00            .byte	0
40674 FBD8                        00            .byte	0
40675 FBD9                        FC            .byte	$FC
40676 FBDA                        00            .byte	0
40677 FBDB                        00            .byte	0
40678 FBDC                        00            .byte	0
40679 FBDD                        00            .byte	0
40680                                           ! 8291  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
40681 FBDE                        00            .byte	0
40682 FBDF                        00            .byte	0
40683 FBE0                        00            .byte	0
40684 FBE1                        00            .byte	0
40685 FBE2                        00            .byte	0
40686 FBE3                        30            .byte	$30
40687 FBE4                        30            .byte	$30
40688 FBE5                        00            .byte	0
40689                                           ! 8292  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
40690 FBE6                        06            .byte	6
40691 FBE7                        0C            .byte	$C
40692 FBE8                        18            .byte	$18
40693 FBE9                        30            .byte	$30
40694 FBEA                        60            .byte	$60
40695 FBEB                        C0            .byte	$C0
40696 FBEC                        80            .byte	$80
40697 FBED                        00            .byte	0
40698                                           ! 8293  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
40699 FBEE                        7C            .byte	$7C
40700 FBEF                        C6            .byte	$C6
40701 FBF0                        CE            .byte	$CE
40702 FBF1                        DE            .byte	$DE
40703 FBF2                        F6            .byte	$F6
40704 FBF3                        E6            .byte	$E6
40705 FBF4                        7C            .byte	$7C
40706 FBF5                        00            .byte	0
40707                                           ! 8294  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
40708 FBF6                        30            .byte	$30
40709 FBF7                        70            .byte	$70
40710 FBF8                        30            .byte	$30
40711 FBF9                        30            .byte	$30
40712 FBFA                        30            .byte	$30
40713 FBFB                        30            .byte	$30
40714 FBFC                        FC            .byte	$FC
40715 FBFD                        00            .byte	0
40716                                           ! 8295  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
40717 FBFE                        78            .byte	$78
40718 FBFF                        CC            .byte	$CC
40719 FC00                        0C            .byte	$C
40720 FC01                        38            .byte	$38
40721 FC02                        60            .byte	$60
40722 FC03                        CC            .byte	$CC
40723 FC04                        FC            .byte	$FC
40724 FC05                        00            .byte	0
40725                                           ! 8296  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
40726 FC06                        78            .byte	$78
40727 FC07                        CC            .byte	$CC
40728 FC08                        0C            .byte	$C
40729 FC09                        38            .byte	$38
40730 FC0A                        0C            .byte	$C
40731 FC0B                        CC            .byte	$CC
40732 FC0C                        78            .byte	$78
40733 FC0D                        00            .byte	0
40734                                           ! 8297  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
40735 FC0E                        1C            .byte	$1C
40736 FC0F                        3C            .byte	$3C
40737 FC10                        6C            .byte	$6C
40738 FC11                        CC            .byte	$CC
40739 FC12                        FE            .byte	$FE
40740 FC13                        0C            .byte	$C
40741 FC14                        1E            .byte	$1E
40742 FC15                        00            .byte	0
40743                                           ! 8298  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
40744 FC16                        FC            .byte	$FC
40745 FC17                        C0            .byte	$C0
40746 FC18                        F8            .byte	$F8
40747 FC19                        0C            .byte	$C
40748 FC1A                        0C            .byte	$C
40749 FC1B                        CC            .byte	$CC
40750 FC1C                        78            .byte	$78
40751 FC1D                        00            .byte	0
40752                                           ! 8299  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
40753 FC1E                        38            .byte	$38
40754 FC1F                        60            .byte	$60
40755 FC20                        C0            .byte	$C0
40756 FC21                        F8            .byte	$F8
40757 FC22                        CC            .byte	$CC
40758 FC23                        CC            .byte	$CC
40759 FC24                        78            .byte	$78
40760 FC25                        00            .byte	0
40761                                           ! 8300  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
40762 FC26                        FC            .byte	$FC
40763 FC27                        CC            .byte	$CC
40764 FC28                        0C            .byte	$C
40765 FC29                        18            .byte	$18
40766 FC2A                        30            .byte	$30
40767 FC2B                        30            .byte	$30
40768 FC2C                        30            .byte	$30
40769 FC2D                        00            .byte	0
40770                                           ! 8301  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
40771 FC2E                        78            .byte	$78
40772 FC2F                        CC            .byte	$CC
40773 FC30                        CC            .byte	$CC
40774 FC31                        78            .byte	$78
40775 FC32                        CC            .byte	$CC
40776 FC33                        CC            .byte	$CC
40777 FC34                        78            .byte	$78
40778 FC35                        00            .byte	0
40779                                           ! 8302  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
40780 FC36                        78            .byte	$78
40781 FC37                        CC            .byte	$CC
40782 FC38                        CC            .byte	$CC
40783 FC39                        7C            .byte	$7C
40784 FC3A                        0C            .byte	$C
40785 FC3B                        18            .byte	$18
40786 FC3C                        70            .byte	$70
40787 FC3D                        00            .byte	0
40788                                           ! 8303  0x00, 0x30, 0x30, 0x00, 0x00, 0x30,
40789 FC3E                        00            .byte	0
40790 FC3F                        30            .byte	$30
40791 FC40                        30            .byte	$30
40792 FC41                        00            .byte	0
40793 FC42                        00            .byte	0
40794                                           ! 8303  0x30, 0x00,
40795 FC43                        30            .byte	$30
40796 FC44                        30            .byte	$30
40797 FC45                        00            .byte	0
40798                                           ! 8304  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
40799 FC46                        00            .byte	0
40800 FC47                        30            .byte	$30
40801 FC48                        30            .byte	$30
40802 FC49                        00            .byte	0
40803 FC4A                        00            .byte	0
40804 FC4B                        30            .byte	$30
40805 FC4C                        30            .byte	$30
40806 FC4D                        60            .byte	$60
40807                                           ! 8305  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
40808 FC4E                        18            .byte	$18
40809 FC4F                        30            .byte	$30
40810 FC50                        60            .byte	$60
40811 FC51                        C0            .byte	$C0
40812 FC52                        60            .byte	$60
40813 FC53                        30            .byte	$30
40814 FC54                        18            .byte	$18
40815 FC55                        00            .byte	0
40816                                           ! 8306  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
40817 FC56                        00            .byte	0
40818 FC57                        00            .byte	0
40819 FC58                        FC            .byte	$FC
40820 FC59                        00            .byte	0
40821 FC5A                        00            .byte	0
40822 FC5B                        FC            .byte	$FC
40823 FC5C                        00            .byte	0
40824 FC5D                        00            .byte	0
40825                                           ! 8307  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
40826 FC5E                        60            .byte	$60
40827 FC5F                        30            .byte	$30
40828 FC60                        18            .byte	$18
40829 FC61                        0C            .byte	$C
40830 FC62                        18            .byte	$18
40831 FC63                        30            .byte	$30
40832 FC64                        60            .byte	$60
40833 FC65                        00            .byte	0
40834                                           ! 8308  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
40835 FC66                        78            .byte	$78
40836 FC67                        CC            .byte	$CC
40837 FC68                        0C            .byte	$C
40838 FC69                        18            .byte	$18
40839 FC6A                        30            .byte	$30
40840 FC6B                        00            .byte	0
40841 FC6C                        30            .byte	$30
40842 FC6D                        00            .byte	0
40843                                           ! 8309  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
40844 FC6E                        7C            .byte	$7C
40845 FC6F                        C6            .byte	$C6
40846 FC70                        DE            .byte	$DE
40847 FC71                        DE            .byte	$DE
40848 FC72                        DE            .byte	$DE
40849 FC73                        C0            .byte	$C0
40850 FC74                        78            .byte	$78
40851 FC75                        00            .byte	0
40852                                           ! 8310  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
40853 FC76                        30            .byte	$30
40854 FC77                        78            .byte	$78
40855 FC78                        CC            .byte	$CC
40856 FC79                        CC            .byte	$CC
40857 FC7A                        FC            .byte	$FC
40858 FC7B                        CC            .byte	$CC
40859 FC7C                        CC            .byte	$CC
40860 FC7D                        00            .byte	0
40861                                           ! 8311  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
40862 FC7E                        FC            .byte	$FC
40863 FC7F                        66            .byte	$66
40864 FC80                        66            .byte	$66
40865 FC81                        7C            .byte	$7C
40866 FC82                        66            .byte	$66
40867 FC83                        66            .byte	$66
40868 FC84                        FC            .byte	$FC
40869 FC85                        00            .byte	0
40870                                           ! 8312  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
40871 FC86                        3C            .byte	$3C
40872 FC87                        66            .byte	$66
40873 FC88                        C0            .byte	$C0
40874 FC89                        C0            .byte	$C0
40875 FC8A                        C0            .byte	$C0
40876 FC8B                        66            .byte	$66
40877 FC8C                        3C            .byte	$3C
40878 FC8D                        00            .byte	0
40879                                           ! 8313  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
40880 FC8E                        F8            .byte	$F8
40881 FC8F                        6C            .byte	$6C
40882 FC90                        66            .byte	$66
40883 FC91                        66            .byte	$66
40884 FC92                        66            .byte	$66
40885 FC93                        6C            .byte	$6C
40886 FC94                        F8            .byte	$F8
40887 FC95                        00            .byte	0
40888                                           ! 8314  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
40889 FC96                        FE            .byte	$FE
40890 FC97                        62            .byte	$62
40891 FC98                        68            .byte	$68
40892 FC99                        78            .byte	$78
40893 FC9A                        68            .byte	$68
40894 FC9B                        62            .byte	$62
40895 FC9C                        FE            .byte	$FE
40896 FC9D                        00            .byte	0
40897                                           ! 8315  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
40898 FC9E                        FE            .byte	$FE
40899 FC9F                        62            .byte	$62
40900 FCA0                        68            .byte	$68
40901 FCA1                        78            .byte	$78
40902 FCA2                        68            .byte	$68
40903 FCA3                        60            .byte	$60
40904 FCA4                        F0            .byte	$F0
40905 FCA5                        00            .byte	0
40906                                           ! 8316  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
40907 FCA6                        3C            .byte	$3C
40908 FCA7                        66            .byte	$66
40909 FCA8                        C0            .byte	$C0
40910 FCA9                        C0            .byte	$C0
40911 FCAA                        CE            .byte	$CE
40912 FCAB                        66            .byte	$66
40913 FCAC                        3E            .byte	$3E
40914 FCAD                        00            .byte	0
40915                                           ! 8317  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
40916 FCAE                        CC            .byte	$CC
40917 FCAF                        CC            .byte	$CC
40918 FCB0                        CC            .byte	$CC
40919 FCB1                        FC            .byte	$FC
40920 FCB2                        CC            .byte	$CC
40921 FCB3                        CC            .byte	$CC
40922 FCB4                        CC            .byte	$CC
40923 FCB5                        00            .byte	0
40924                                           ! 8318  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
40925 FCB6                        78            .byte	$78
40926 FCB7                        30            .byte	$30
40927 FCB8                        30            .byte	$30
40928 FCB9                        30            .byte	$30
40929 FCBA                        30            .byte	$30
40930 FCBB                        30            .byte	$30
40931 FCBC                        78            .byte	$78
40932 FCBD                        00            .byte	0
40933                                           ! 8319  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
40934 FCBE                        1E            .byte	$1E
40935 FCBF                        0C            .byte	$C
40936 FCC0                        0C            .byte	$C
40937 FCC1                        0C            .byte	$C
40938 FCC2                        CC            .byte	$CC
40939 FCC3                        CC            .byte	$CC
40940 FCC4                        78            .byte	$78
40941 FCC5                        00            .byte	0
40942                                           ! 8320  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
40943 FCC6                        E6            .byte	$E6
40944 FCC7                        66            .byte	$66
40945 FCC8                        6C            .byte	$6C
40946 FCC9                        78            .byte	$78
40947 FCCA                        6C            .byte	$6C
40948 FCCB                        66            .byte	$66
40949 FCCC                        E6            .byte	$E6
40950 FCCD                        00            .byte	0
40951                                           ! 8321  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
40952 FCCE                        F0            .byte	$F0
40953 FCCF                        60            .byte	$60
40954 FCD0                        60            .byte	$60
40955 FCD1                        60            .byte	$60
40956 FCD2                        62            .byte	$62
40957 FCD3                        66            .byte	$66
40958 FCD4                        FE            .byte	$FE
40959 FCD5                        00            .byte	0
40960                                           ! 8322  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
40961 FCD6                        C6            .byte	$C6
40962 FCD7                        EE            .byte	$EE
40963 FCD8                        FE            .byte	$FE
40964 FCD9                        FE            .byte	$FE
40965 FCDA                        D6            .byte	$D6
40966 FCDB                        C6            .byte	$C6
40967 FCDC                        C6            .byte	$C6
40968 FCDD                        00            .byte	0
40969                                           ! 8323  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
40970 FCDE                        C6            .byte	$C6
40971 FCDF                        E6            .byte	$E6
40972 FCE0                        F6            .byte	$F6
40973 FCE1                        DE            .byte	$DE
40974 FCE2                        CE            .byte	$CE
40975 FCE3                        C6            .byte	$C6
40976 FCE4                        C6            .byte	$C6
40977 FCE5                        00            .byte	0
40978                                           ! 8324  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
40979 FCE6                        38            .byte	$38
40980 FCE7                        6C            .byte	$6C
40981 FCE8                        C6            .byte	$C6
40982 FCE9                        C6            .byte	$C6
40983 FCEA                        C6            .byte	$C6
40984 FCEB                        6C            .byte	$6C
40985 FCEC                        38            .byte	$38
40986 FCED                        00            .byte	0
40987                                           ! 8325  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
40988 FCEE                        FC            .byte	$FC
40989 FCEF                        66            .byte	$66
40990 FCF0                        66            .byte	$66
40991 FCF1                        7C            .byte	$7C
40992 FCF2                        60            .byte	$60
40993 FCF3                        60            .byte	$60
40994 FCF4                        F0            .byte	$F0
40995 FCF5                        00            .byte	0
40996                                           ! 8326  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
40997 FCF6                        78            .byte	$78
40998 FCF7                        CC            .byte	$CC
40999 FCF8                        CC            .byte	$CC
41000 FCF9                        CC            .byte	$CC
41001 FCFA                        DC            .byte	$DC
41002 FCFB                        78            .byte	$78
41003 FCFC                        1C            .byte	$1C
41004 FCFD                        00            .byte	0
41005                                           ! 8327  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
41006 FCFE                        FC            .byte	$FC
41007 FCFF                        66            .byte	$66
41008 FD00                        66            .byte	$66
41009 FD01                        7C            .byte	$7C
41010 FD02                        6C            .byte	$6C
41011 FD03                        66            .byte	$66
41012 FD04                        E6            .byte	$E6
41013 FD05                        00            .byte	0
41014                                           ! 8328  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
41015 FD06                        78            .byte	$78
41016 FD07                        CC            .byte	$CC
41017 FD08                        E0            .byte	$E0
41018 FD09                        70            .byte	$70
41019 FD0A                        1C            .byte	$1C
41020 FD0B                        CC            .byte	$CC
41021 FD0C                        78            .byte	$78
41022 FD0D                        00            .byte	0
41023                                           ! 8329  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41024 FD0E                        FC            .byte	$FC
41025 FD0F                        B4            .byte	$B4
41026 FD10                        30            .byte	$30
41027 FD11                        30            .byte	$30
41028 FD12                        30            .byte	$30
41029 FD13                        30            .byte	$30
41030 FD14                        78            .byte	$78
41031 FD15                        00            .byte	0
41032                                           ! 8330  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
41033 FD16                        CC            .byte	$CC
41034 FD17                        CC            .byte	$CC
41035 FD18                        CC            .byte	$CC
41036 FD19                        CC            .byte	$CC
41037 FD1A                        CC            .byte	$CC
41038 FD1B                        CC            .byte	$CC
41039 FD1C                        FC            .byte	$FC
41040 FD1D                        00            .byte	0
41041                                           ! 8331  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41042 FD1E                        CC            .byte	$CC
41043 FD1F                        CC            .byte	$CC
41044 FD20                        CC            .byte	$CC
41045 FD21                        CC            .byte	$CC
41046 FD22                        CC            .byte	$CC
41047 FD23                        78            .byte	$78
41048 FD24                        30            .byte	$30
41049 FD25                        00            .byte	0
41050                                           ! 8332  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
41051 FD26                        C6            .byte	$C6
41052 FD27                        C6            .byte	$C6
41053 FD28                        C6            .byte	$C6
41054 FD29                        D6            .byte	$D6
41055 FD2A                        FE            .byte	$FE
41056 FD2B                        EE            .byte	$EE
41057 FD2C                        C6            .byte	$C6
41058 FD2D                        00            .byte	0
41059                                           ! 8333  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
41060 FD2E                        C6            .byte	$C6
41061 FD2F                        C6            .byte	$C6
41062 FD30                        6C            .byte	$6C
41063 FD31                        38            .byte	$38
41064 FD32                        38            .byte	$38
41065 FD33                        6C            .byte	$6C
41066 FD34                        C6            .byte	$C6
41067 FD35                        00            .byte	0
41068                                           ! 8334  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
41069 FD36                        CC            .byte	$CC
41070 FD37                        CC            .byte	$CC
41071 FD38                        CC            .byte	$CC
41072 FD39                        78            .byte	$78
41073 FD3A                        30            .byte	$30
41074 FD3B                        30            .byte	$30
41075 FD3C                        78            .byte	$78
41076 FD3D                        00            .byte	0
41077                                           ! 8335  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
41078 FD3E                        FE            .byte	$FE
41079 FD3F                        C6            .byte	$C6
41080 FD40                        8C            .byte	$8C
41081 FD41                        18            .byte	$18
41082 FD42                        32            .byte	$32
41083 FD43                        66            .byte	$66
41084 FD44                        FE            .byte	$FE
41085 FD45                        00            .byte	0
41086                                           ! 8336  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
41087 FD46                        78            .byte	$78
41088 FD47                        60            .byte	$60
41089 FD48                        60            .byte	$60
41090 FD49                        60            .byte	$60
41091 FD4A                        60            .byte	$60
41092 FD4B                        60            .byte	$60
41093 FD4C                        78            .byte	$78
41094 FD4D                        00            .byte	0
41095                                           ! 8337  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
41096 FD4E                        C0            .byte	$C0
41097 FD4F                        60            .byte	$60
41098 FD50                        30            .byte	$30
41099 FD51                        18            .byte	$18
41100 FD52                        0C            .byte	$C
41101 FD53                        06            .byte	6
41102 FD54                        02            .byte	2
41103 FD55                        00            .byte	0
41104                                           ! 8338  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
41105 FD56                        78            .byte	$78
41106 FD57                        18            .byte	$18
41107 FD58                        18            .byte	$18
41108 FD59                        18            .byte	$18
41109 FD5A                        18            .byte	$18
41110 FD5B                        18            .byte	$18
41111 FD5C                        78            .byte	$78
41112 FD5D                        00            .byte	0
41113                                           ! 8339  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
41114 FD5E                        10            .byte	$10
41115 FD5F                        38            .byte	$38
41116 FD60                        6C            .byte	$6C
41117 FD61                        C6            .byte	$C6
41118 FD62                        00            .byte	0
41119 FD63                        00            .byte	0
41120 FD64                        00            .byte	0
41121 FD65                        00            .byte	0
41122                                           ! 8340  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
41123 FD66                        00            .byte	0
41124 FD67                        00            .byte	0
41125 FD68                        00            .byte	0
41126 FD69                        00            .byte	0
41127 FD6A                        00            .byte	0
41128 FD6B                        00            .byte	0
41129 FD6C                        00            .byte	0
41130 FD6D                        FF            .byte	$FF
41131                                           ! 8341  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
41132 FD6E                        30            .byte	$30
41133 FD6F                        30            .byte	$30
41134 FD70                        18            .byte	$18
41135 FD71                        00            .byte	0
41136 FD72                        00            .byte	0
41137 FD73                        00            .byte	0
41138 FD74                        00            .byte	0
41139 FD75                        00            .byte	0
41140                                           ! 8342  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
41141 FD76                        00            .byte	0
41142 FD77                        00            .byte	0
41143 FD78                        78            .byte	$78
41144 FD79                        0C            .byte	$C
41145 FD7A                        7C            .byte	$7C
41146 FD7B                        CC            .byte	$CC
41147 FD7C                        76            .byte	$76
41148 FD7D                        00            .byte	0
41149                                           ! 8343  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
41150 FD7E                        E0            .byte	$E0
41151 FD7F                        60            .byte	$60
41152 FD80                        60            .byte	$60
41153 FD81                        7C            .byte	$7C
41154 FD82                        66            .byte	$66
41155 FD83                        66            .byte	$66
41156 FD84                        DC            .byte	$DC
41157 FD85                        00            .byte	0
41158                                           ! 8344  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
41159 FD86                        00            .byte	0
41160 FD87                        00            .byte	0
41161 FD88                        78            .byte	$78
41162 FD89                        CC            .byte	$CC
41163 FD8A                        C0            .byte	$C0
41164 FD8B                        CC            .byte	$CC
41165 FD8C                        78            .byte	$78
41166 FD8D                        00            .byte	0
41167                                           ! 8345  0x1c, 0x0c, 0x0c, 0x7c, 0
41168 FD8E                        1C            .byte	$1C
41169 FD8F                        0C            .byte	$C
41170 FD90                        0C            .byte	$C
41171 FD91                        7C            .byte	$7C
41172                                           ! 8345 xcc, 0xcc, 0x76, 0x00,
41173 FD92                        CC            .byte	$CC
41174 FD93                        CC            .byte	$CC
41175 FD94                        76            .byte	$76
41176 FD95                        00            .byte	0
41177                                           ! 8346  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
41178 FD96                        00            .byte	0
41179 FD97                        00            .byte	0
41180 FD98                        78            .byte	$78
41181 FD99                        CC            .byte	$CC
41182 FD9A                        FC            .byte	$FC
41183 FD9B                        C0            .byte	$C0
41184 FD9C                        78            .byte	$78
41185 FD9D                        00            .byte	0
41186                                           ! 8347  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
41187 FD9E                        38            .byte	$38
41188 FD9F                        6C            .byte	$6C
41189 FDA0                        60            .byte	$60
41190 FDA1                        F0            .byte	$F0
41191 FDA2                        60            .byte	$60
41192 FDA3                        60            .byte	$60
41193 FDA4                        F0            .byte	$F0
41194 FDA5                        00            .byte	0
41195                                           ! 8348  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41196 FDA6                        00            .byte	0
41197 FDA7                        00            .byte	0
41198 FDA8                        76            .byte	$76
41199 FDA9                        CC            .byte	$CC
41200 FDAA                        CC            .byte	$CC
41201 FDAB                        7C            .byte	$7C
41202 FDAC                        0C            .byte	$C
41203 FDAD                        F8            .byte	$F8
41204                                           ! 8349  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
41205 FDAE                        E0            .byte	$E0
41206 FDAF                        60            .byte	$60
41207 FDB0                        6C            .byte	$6C
41208 FDB1                        76            .byte	$76
41209 FDB2                        66            .byte	$66
41210 FDB3                        66            .byte	$66
41211 FDB4                        E6            .byte	$E6
41212 FDB5                        00            .byte	0
41213                                           ! 8350  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
41214 FDB6                        30            .byte	$30
41215 FDB7                        00            .byte	0
41216 FDB8                        70            .byte	$70
41217 FDB9                        30            .byte	$30
41218 FDBA                        30            .byte	$30
41219 FDBB                        30            .byte	$30
41220 FDBC                        78            .byte	$78
41221 FDBD                        00            .byte	0
41222                                           ! 8351  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
41223 FDBE                        0C            .byte	$C
41224 FDBF                        00            .byte	0
41225 FDC0                        0C            .byte	$C
41226 FDC1                        0C            .byte	$C
41227 FDC2                        0C            .byte	$C
41228 FDC3                        CC            .byte	$CC
41229 FDC4                        CC            .byte	$CC
41230 FDC5                        78            .byte	$78
41231                                           ! 8352  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
41232 FDC6                        E0            .byte	$E0
41233 FDC7                        60            .byte	$60
41234 FDC8                        66            .byte	$66
41235 FDC9                        6C            .byte	$6C
41236 FDCA                        78            .byte	$78
41237 FDCB                        6C            .byte	$6C
41238 FDCC                        E6            .byte	$E6
41239 FDCD                        00            .byte	0
41240                                           ! 8353  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41241 FDCE                        70            .byte	$70
41242 FDCF                        30            .byte	$30
41243 FDD0                        30            .byte	$30
41244 FDD1                        30            .byte	$30
41245 FDD2                        30            .byte	$30
41246 FDD3                        30            .byte	$30
41247 FDD4                        78            .byte	$78
41248 FDD5                        00            .byte	0
41249                                           ! 8354  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
41250 FDD6                        00            .byte	0
41251 FDD7                        00            .byte	0
41252 FDD8                        CC            .byte	$CC
41253 FDD9                        FE            .byte	$FE
41254 FDDA                        FE            .byte	$FE
41255 FDDB                        D6            .byte	$D6
41256 FDDC                        C6            .byte	$C6
41257 FDDD                        00            .byte	0
41258                                           ! 8355  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
41259 FDDE                        00            .byte	0
41260 FDDF                        00            .byte	0
41261 FDE0                        F8            .byte	$F8
41262 FDE1                        CC            .byte	$CC
41263 FDE2                        CC            .byte	$CC
41264 FDE3                        CC            .byte	$CC
41265 FDE4                        CC            .byte	$CC
41266 FDE5                        00            .byte	0
41267                                           ! 8356  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
41268 FDE6                        00            .byte	0
41269 FDE7                        00            .byte	0
41270 FDE8                        78            .byte	$78
41271 FDE9                        CC            .byte	$CC
41272 FDEA                        CC            .byte	$CC
41273 FDEB                        CC            .byte	$CC
41274 FDEC                        78            .byte	$78
41275 FDED                        00            .byte	0
41276                                           ! 8357  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
41277 FDEE                        00            .byte	0
41278 FDEF                        00            .byte	0
41279 FDF0                        DC            .byte	$DC
41280 FDF1                        66            .byte	$66
41281 FDF2                        66            .byte	$66
41282 FDF3                        7C            .byte	$7C
41283 FDF4                        60            .byte	$60
41284 FDF5                        F0            .byte	$F0
41285                                           ! 8358  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
41286 FDF6                        00            .byte	0
41287 FDF7                        00            .byte	0
41288 FDF8                        76            .byte	$76
41289 FDF9                        CC            .byte	$CC
41290 FDFA                        CC            .byte	$CC
41291 FDFB                        7C            .byte	$7C
41292 FDFC                        0C            .byte	$C
41293 FDFD                        1E            .byte	$1E
41294                                           ! 8359  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
41295 FDFE                        00            .byte	0
41296 FDFF                        00            .byte	0
41297 FE00                        DC            .byte	$DC
41298 FE01                        76            .byte	$76
41299 FE02                        66            .byte	$66
41300 FE03                        60            .byte	$60
41301 FE04                        F0            .byte	$F0
41302 FE05                        00            .byte	0
41303                                           ! 8360  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
41304 FE06                        00            .byte	0
41305 FE07                        00            .byte	0
41306 FE08                        7C            .byte	$7C
41307 FE09                        C0            .byte	$C0
41308 FE0A                        78            .byte	$78
41309 FE0B                        0C            .byte	$C
41310 FE0C                        F8            .byte	$F8
41311 FE0D                        00            .byte	0
41312                                           ! 8361  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
41313 FE0E                        10            .byte	$10
41314 FE0F                        30            .byte	$30
41315 FE10                        7C            .byte	$7C
41316 FE11                        30            .byte	$30
41317 FE12                        30            .byte	$30
41318 FE13                        34            .byte	$34
41319 FE14                        18            .byte	$18
41320 FE15                        00            .byte	0
41321                                           ! 8362  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
41322 FE16                        00            .byte	0
41323 FE17                        00            .byte	0
41324 FE18                        CC            .byte	$CC
41325 FE19                        CC            .byte	$CC
41326 FE1A                        CC            .byte	$CC
41327 FE1B                        CC            .byte	$CC
41328 FE1C                        76            .byte	$76
41329 FE1D                        00            .byte	0
41330                                           ! 8363  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41331 FE1E                        00            .byte	0
41332 FE1F                        00            .byte	0
41333 FE20                        CC            .byte	$CC
41334 FE21                        CC            .byte	$CC
41335 FE22                        CC            .byte	$CC
41336 FE23                        78            .byte	$78
41337 FE24                        30            .byte	$30
41338 FE25                        00            .byte	0
41339                                           ! 8364  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
41340 FE26                        00            .byte	0
41341 FE27                        00            .byte	0
41342 FE28                        C6            .byte	$C6
41343 FE29                        D6            .byte	$D6
41344 FE2A                        FE            .byte	$FE
41345 FE2B                        FE            .byte	$FE
41346 FE2C                        6C            .byte	$6C
41347 FE2D                        00            .byte	0
41348                                           ! 8365  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
41349 FE2E                        00            .byte	0
41350 FE2F                        00            .byte	0
41351 FE30                        C6            .byte	$C6
41352 FE31                        6C            .byte	$6C
41353 FE32                        38            .byte	$38
41354 FE33                        6C            .byte	$6C
41355 FE34                        C6            .byte	$C6
41356 FE35                        00            .byte	0
41357                                           ! 8366  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41358 FE36                        00            .byte	0
41359 FE37                        00            .byte	0
41360 FE38                        CC            .byte	$CC
41361 FE39                        CC            .byte	$CC
41362 FE3A                        CC            .byte	$CC
41363 FE3B                        7C            .byte	$7C
41364 FE3C                        0C            .byte	$C
41365 FE3D                        F8            .byte	$F8
41366                                           ! 8367  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
41367 FE3E                        00            .byte	0
41368 FE3F                        00            .byte	0
41369 FE40                        FC            .byte	$FC
41370 FE41                        98            .byte	$98
41371 FE42                        30            .byte	$30
41372 FE43                        64            .byte	$64
41373 FE44                        FC            .byte	$FC
41374 FE45                        00            .byte	0
41375                                           ! 8368  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
41376 FE46                        1C            .byte	$1C
41377 FE47                        30            .byte	$30
41378 FE48                        30            .byte	$30
41379 FE49                        E0            .byte	$E0
41380 FE4A                        30            .byte	$30
41381 FE4B                        30            .byte	$30
41382 FE4C                        1C            .byte	$1C
41383 FE4D                        00            .byte	0
41384                                           ! 8369  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
41385 FE4E                        18            .byte	$18
41386 FE4F                        18            .byte	$18
41387 FE50                        18            .byte	$18
41388 FE51                        00            .byte	0
41389 FE52                        18            .byte	$18
41390 FE53                        18            .byte	$18
41391 FE54                        18            .byte	$18
41392 FE55                        00            .byte	0
41393                                           ! 8370  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
41394 FE56                        E0            .byte	$E0
41395 FE57                        30            .byte	$30
41396 FE58                        30            .byte	$30
41397 FE59                        1C            .byte	$1C
41398 FE5A                        30            .byte	$30
41399 FE5B                        30            .byte	$30
41400 FE5C                        E0            .byte	$E0
41401 FE5D                        00            .byte	0
41402                                           ! 8371  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41403 FE5E                        76            .byte	$76
41404 FE5F                        DC            .byte	$DC
41405 FE60                        00            .byte	0
41406 FE61                        00            .byte	0
41407 FE62                        00            .byte	0
41408 FE63                        00            .byte	0
41409 FE64                        00            .byte	0
41410 FE65                        00            .byte	0
41411                                           ! 8372  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
41412 FE66                        00            .byte	0
41413 FE67                        10            .byte	$10
41414 FE68                        38            .byte	$38
41415 FE69                        6C            .byte	$6C
41416 FE6A                        C6            .byte	$C6
41417 FE6B                        C6            .byte	$C6
41418 FE6C                        FE            .byte	$FE
41419 FE6D                        00            .byte	0
41420                                           ! 8373 };
41421                                           !BCC_EOS
41422                                           ! 8374 #asm
41423                                           !BCC_ASM
41424 CFF0                                      .org 0xcff0
41425                       0000CFF0            bios_table_area_end:
41426                                           ! 8377 endasm
41427                                           !BCC_ENDASM
41428                                           ! 8378 
41429                       0000CFF0            .723:
41430                       0000CFF0            .784:
41431 CFF0                        00            .byte	0
41432                       0000CFF1            .722:
41433                       0000CFF1            .785:
41434 CFF1                        50            .ascii	"Powering off in 30 seconds."
41435 D00C                        0A            .byte	$A
41436 D00D                        00            .byte	0
41437                       0000D00E            .721:
41438                       0000D00E            .786:
41439 D00E                        0A            .byte	$A
41440 D00F                        4E            .ascii	"No bootable device."
41441 D022                        0A            .byte	$A
41442 D023                        00            .byte	0
41443                       0000D024            .70B:
41444                       0000D024            .787:
41445 D024                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
41446 D049                        0A            .byte	$A
41447 D04A                        00            .byte	0
41448                       0000D04B            .6F5:
41449                       0000D04B            .788:
41450 D04B                        66            .ascii	"floppy: int13: bad floppy type"
41451 D069                        0A            .byte	$A
41452 D06A                        00            .byte	0
41453                       0000D06B            .6DD:
41454                       0000D06B            .789:
41455 D06B                        69            .ascii	"int13_diskette_function: write error"
41456 D08F                        0A            .byte	$A
41457 D090                        00            .byte	0
41458                       0000D091            .6D7:
41459                       0000D091            .78A:
41460 D091                        69            .ascii	"int13_diskette: ctrl not ready"
41461 D0AF                        0A            .byte	$A
41462 D0B0                        00            .byte	0
41463                       0000D0B1            .6BC:
41464                       0000D0B1            .78B:
41465 D0B1                        69            .ascii	"int13_diskette_function: read error"
41466 D0D4                        0A            .byte	$A
41467 D0D5                        00            .byte	0
41468                       0000D0D6            .6B6:
41469                       0000D0D6            .78C:
41470 D0D6                        69            .ascii	"int13_diskette: ctrl not ready"
41471 D0F4                        0A            .byte	$A
41472 D0F5                        00            .byte	0
41473                       0000D0F6            .6A4:
41474                       0000D0F6            .78D:
41475 D0F6                        69            .ascii	"int13_diskette: ctrl not ready"
41476 D114                        0A            .byte	$A
41477 D115                        00            .byte	0
41478                       0000D116            .5F3:
41479                       0000D116            .78E:
41480 D116                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
41481 D13E                        20            .ascii	" report"
41482 D145                        0A            .byte	$A
41483 D146                        00            .byte	0
41484                       0000D147            .59D:
41485                       0000D147            .78F:
41486 D147                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
41487 D16F                        62            .ascii	"bits lba"
41488 D177                        0A            .byte	$A
41489 D178                        00            .byte	0
41490                       0000D179            .4A5:
41491                       0000D179            .790:
41492 D179                        73            .ascii	"setkbdcomm"
41493 D183                        00            .byte	0
41494                       0000D184            .49E:
41495                       0000D184            .791:
41496 D184                        73            .ascii	"sendmouse"
41497 D18D                        00            .byte	0
41498                       0000D18E            .49B:
41499                       0000D18E            .792:
41500 D18E                        65            .ascii	"enabmouse"
41501 D197                        00            .byte	0
41502                       0000D198            .494:
41503                       0000D198            .793:
41504 D198                        65            .ascii	"enabmouse"
41505 D1A1                        00            .byte	0
41506                       0000D1A2            .491:
41507                       0000D1A2            .794:
41508 D1A2                        69            .ascii	"inhibmouse"
41509 D1AC                        00            .byte	0
41510                       0000D1AD            .48A:
41511                       0000D1AD            .795:
41512 D1AD                        69            .ascii	"inhibmouse"
41513 D1B7                        00            .byte	0
41514                       0000D1B8            .46D:
41515                       0000D1B8            .796:
41516 D1B8                        4B            .ascii	"KBD: int16h: out of keyboard input"
41517 D1DA                        0A            .byte	$A
41518 D1DB                        00            .byte	0
41519                       0000D1DC            .43F:
41520                       0000D1DC            .797:
41521 D1DC                        4B            .ascii	"KBD: int16h: out of keyboard input"
41522 D1FE                        0A            .byte	$A
41523 D1FF                        00            .byte	0
41524                       0000D200            .3F1:
41525                       0000D200            .798:
41526 D200                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
41527 D218                        0A            .byte	$A
41528 D219                        00            .byte	0
41529                       0000D21A            .3DB:
41530                       0000D21A            .799:
41531 D21A                        4D            .ascii	"Mouse status returned %02x (should be ac"
41532 D242                        6B            .ascii	"k)"
41533 D244                        0A            .byte	$A
41534 D245                        00            .byte	0
41535                       0000D246            .3CB:
41536                       0000D246            .79A:
41537 D246                        4D            .ascii	"Mouse status returned %02x (should be ac"
41538 D26E                        6B            .ascii	"k)"
41539 D270                        0A            .byte	$A
41540 D271                        00            .byte	0
41541                       0000D272            .3C8:
41542                       0000D272            .79B:
41543 D272                        4D            .ascii	"Mouse status returned %02x (should be ac"
41544 D29A                        6B            .ascii	"k)"
41545 D29C                        0A            .byte	$A
41546 D29D                        00            .byte	0
41547                       0000D29E            .3A6:
41548                       0000D29E            .79C:
41549 D29E                        4D            .ascii	"Mouse reset returned %02x (should be ack"
41550 D2C6                        29            .ascii	")"
41551 D2C7                        0A            .byte	$A
41552 D2C8                        00            .byte	0
41553                       0000D2C9            .37E:
41554                       0000D2C9            .79D:
41555 D2C9                        45            .ascii	"EISA BIOS not present"
41556 D2DE                        0A            .byte	$A
41557 D2DF                        00            .byte	0
41558                       0000D2E0            .2E9:
41559                       0000D2E0            .79E:
41560 D2E0                        25            .ascii	"%dMB medium detected"
41561 D2F4                        0A            .byte	$A
41562 D2F5                        00            .byte	0
41563                       0000D2F6            .2E4:
41564                       0000D2F6            .79F:
41565 D2F6                        55            .ascii	"Unsupported sector size %u"
41566 D310                        0A            .byte	$A
41567 D311                        00            .byte	0
41568                       0000D312            .2DF:
41569                       0000D312            .7A0:
41570 D312                        57            .ascii	"Waiting for device to detect medium... "
41571 D339                        00            .byte	0
41572                       0000D33A            .2D1:
41573                       0000D33A            .7A1:
41574 D33A                        6E            .ascii	"not implemented for non-ATAPI device"
41575 D35E                        0A            .byte	$A
41576 D35F                        00            .byte	0
41577                       0000D360            .248:
41578                       0000D360            .7A2:
41579 D360                        0A            .byte	$A
41580 D361                        00            .byte	0
41581                       0000D362            .243:
41582                       0000D362            .7A3:
41583 D362                        6D            .ascii	"master"
41584 D368                        00            .byte	0
41585                       0000D369            .242:
41586                       0000D369            .7A4:
41587 D369                        20            .ascii	" slave"
41588 D36F                        00            .byte	0
41589                       0000D370            .241:
41590                       0000D370            .7A5:
41591 D370                        61            .ascii	"ata%d %s: Unknown device"
41592 D388                        0A            .byte	$A
41593 D389                        00            .byte	0
41594                       0000D38A            .23F:
41595                       0000D38A            .7A6:
41596 D38A                        20            .ascii	" ATAPI-%d Device"
41597 D39A                        0A            .byte	$A
41598 D39B                        00            .byte	0
41599                       0000D39C            .23D:
41600                       0000D39C            .7A7:
41601 D39C                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
41602 D3B4                        0A            .byte	$A
41603 D3B5                        00            .byte	0
41604                       0000D3B6            .239:
41605                       0000D3B6            .7A8:
41606 D3B6                        25            .ascii	"%c"
41607 D3B8                        00            .byte	0
41608                       0000D3B9            .232:
41609                       0000D3B9            .7A9:
41610 D3B9                        6D            .ascii	"master"
41611 D3BF                        00            .byte	0
41612                       0000D3C0            .231:
41613                       0000D3C0            .7AA:
41614 D3C0                        20            .ascii	" slave"
41615 D3C6                        00            .byte	0
41616                       0000D3C7            .230:
41617                       0000D3C7            .7AB:
41618 D3C7                        61            .ascii	"ata%d %s: "
41619 D3D1                        00            .byte	0
41620                       0000D3D2            .22E:
41621                       0000D3D2            .7AC:
41622 D3D2                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
41623 D3F0                        0A            .byte	$A
41624 D3F1                        00            .byte	0
41625                       0000D3F2            .22C:
41626                       0000D3F2            .7AD:
41627 D3F2                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
41628 D410                        0A            .byte	$A
41629 D411                        00            .byte	0
41630                       0000D412            .228:
41631                       0000D412            .7AE:
41632 D412                        25            .ascii	"%c"
41633 D414                        00            .byte	0
41634                       0000D415            .221:
41635                       0000D415            .7AF:
41636 D415                        6D            .ascii	"master"
41637 D41B                        00            .byte	0
41638                       0000D41C            .220:
41639                       0000D41C            .7B0:
41640 D41C                        20            .ascii	" slave"
41641 D422                        00            .byte	0
41642                       0000D423            .21F:
41643                       0000D423            .7B1:
41644 D423                        61            .ascii	"ata%d %s: "
41645 D42D                        00            .byte	0
41646                       0000D42E            .1F4:
41647                       0000D42E            .7B2:
41648 D42E                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
41649 D456                        65            .ascii	"e"
41650 D457                        0A            .byte	$A
41651 D458                        00            .byte	0
41652                       0000D459            .1BB:
41653                       0000D459            .7B3:
41654 D459                        61            .ascii	"ata-detect: Failed to detect ATA device"
41655 D480                        0A            .byte	$A
41656 D481                        00            .byte	0
41657                       0000D482            .157:
41658                       0000D482            .7B4:
41659 D482                        49            .ascii	"INT18: BOOT FAILURE"
41660 D495                        0A            .byte	$A
41661 D496                        00            .byte	0
41662                       0000D497            .156:
41663                       0000D497            .7B5:
41664 D497                        4E            .ascii	"NMI Handler called"
41665 D4A9                        0A            .byte	$A
41666 D4AA                        00            .byte	0
41667                       0000D4AB            .155:
41668                       0000D4AB            .7B6:
41669 D4AB                        43            .ascii	"CDROM boot failure code : %04x"
41670 D4C9                        0A            .byte	$A
41671 D4CA                        00            .byte	0
41672                       0000D4CB            .154:
41673                       0000D4CB            .7B7:
41674 D4CB                        0A            .byte	$A,$A
41675 D4CD                        00            .byte	0
41676                       0000D4CE            .153:
41677                       0000D4CE            .7B8:
41678 D4CE                        3A            .ascii	": could not read the boot disk"
41679 D4EC                        00            .byte	0
41680                       0000D4ED            .151:
41681                       0000D4ED            .7B9:
41682 D4ED                        3A            .ascii	": not a bootable disk"
41683 D502                        00            .byte	0
41684                       0000D503            .14C:
41685                       0000D503            .7BA:
41686 D503                        42            .ascii	"Boot from %s failed"
41687 D516                        00            .byte	0
41688                       0000D517            .14B:
41689                       0000D517            .7BB:
41690 D517                        42            .ascii	"Bad drive type"
41691 D525                        0A            .byte	$A
41692 D526                        00            .byte	0
41693                       0000D527            .147:
41694                       0000D527            .7BC:
41695 D527                        2E            .ascii	"..."
41696 D52A                        0A            .byte	$A
41697 D52B                        00            .byte	0
41698                       0000D52C            .146:
41699                       0000D52C            .7BD:
41700 D52C                        20            .ascii	" [%S]"
41701 D531                        00            .byte	0
41702                       0000D532            .142:
41703                       0000D532            .7BE:
41704 D532                        42            .ascii	"Booting from %s"
41705 D541                        00            .byte	0
41706                       0000D542            .141:
41707                       0000D542            .7BF:
41708 D542                        42            .ascii	"Bad drive type"
41709 D550                        0A            .byte	$A
41710 D551                        00            .byte	0
41711                       0000D552            .13A:
41712                       0000D552            .7C0:
41713 D552                        0A            .byte	$A
41714 D553                        00            .byte	0
41715                       0000D554            .12E:
41716                       0000D554            .7C1:
41717 D554                        0A            .byte	$A
41718 D555                        00            .byte	0
41719                       0000D556            .12D:
41720                       0000D556            .7C2:
41721 D556                        20            .ascii	" [%S]"
41722 D55B                        00            .byte	0
41723                       0000D55C            .12A:
41724                       0000D55C            .7C3:
41725 D55C                        25            .ascii	"%s"
41726 D55E                        00            .byte	0
41727                       0000D55F            .128:
41728                       0000D55F            .7C4:
41729 D55F                        25            .ascii	"%s"
41730 D561                        0A            .byte	$A
41731 D562                        00            .byte	0
41732                       0000D563            .121:
41733                       0000D563            .7C5:
41734 D563                        25            .ascii	"%d. "
41735 D567                        00            .byte	0
41736                       0000D568            .11C:
41737                       0000D568            .7C6:
41738 D568                        53            .ascii	"Select boot device:"
41739 D57B                        0A            .byte	$A,$A
41740 D57D                        00            .byte	0
41741                       0000D57E            .112:
41742                       0000D57E            .7C7:
41743 D57E                        0A            .byte	$A,$A
41744 D580                        50            .ascii	"Press F12 for boot menu."
41745 D598                        0A            .byte	$A,$A
41746 D59A                        00            .byte	0
41747                       0000D59B            .10A:
41748                       0000D59B            .7C8:
41749 D59B                        61            .ascii	"apmbios pcibios eltorito PMM "
41750 D5B8                        0A            .byte	$A,$A
41751 D5BA                        00            .byte	0
41752                       0000D5BB            .109:
41753                       0000D5BB            .7C9:
41754 D5BB                        30            .ascii	"06/23/99"
41755 D5C3                        00            .byte	0
41756                       0000D5C4            .108:
41757                       0000D5C4            .7CA:
41758 D5C4                        42            .ascii	"Bochs BIOS - build: %s"
41759 D5DA                        0A            .byte	$A
41760 D5DB                        25            .ascii	"%s"
41761 D5DD                        0A            .byte	$A
41762 D5DE                        4F            .ascii	"Options: "
41763 D5E7                        00            .byte	0
41764                       0000D5E8            .107:
41765                       0000D5E8            .7CB:
41766 D5E8                        52            .ascii	"Returned from s3_resume."
41767 D600                        0A            .byte	$A
41768 D601                        00            .byte	0
41769                       0000D602            .106:
41770                       0000D602            .7CC:
41771 D602                        55            .ascii	"Unimplemented shutdown status: %02x"
41772 D625                        0A            .byte	$A
41773 D626                        00            .byte	0
41774                       0000D627            .105:
41775                       0000D627            .7CD:
41776 D627                        43            .ascii	"Couldn't reset the machine"
41777 D641                        0A            .byte	$A
41778 D642                        00            .byte	0
41779                       0000D643            .104:
41780                       0000D643            .7CE:
41781 D643                        4B            .ascii	"Keyboard error:%u"
41782 D654                        0A            .byte	$A
41783 D655                        00            .byte	0
41784                       0000D656            .8D:
41785                       0000D656            .7CF:
41786 D656                        62            .ascii	"bios_printf: unknown format"
41787 D671                        0A            .byte	$A
41788 D672                        00            .byte	0
41789                       0000D673            .41:
41790                       0000D673            .7D0:
41791 D673                        46            .ascii	"FATAL: "
41792 D67A                        00            .byte	0
41793 D67B                                      .bss
41794                                           
41795                                           ! 0 errors detected

Symbols:
..FFD9                      0 FFFC A   ..FFDA                      0 FFFC A   
..FFDB                      0 FFE0 A   ..FFDC                      0 FFE0 A   
..FFDD                      0 FFCA A   ..FFDE                      0 FFCA A   
..FFDF                      0 FFCA A   ..FFE0                      0 FFCA A   
..FFE1                      0 FFCA A   ..FFE2                      0 FFCA A   
..FFE3                      0 FFFC A   ..FFE4                      0 FFFC A   
..FFE5                      0 FFFC A   ..FFE6                      0 FFDE A   
..FFE7                      0 FFDE A   ..FFE8                      0 FFDE A   
..FFE9                      0 FFDE A   ..FFEA                      0 FFD2 A   
..FFEB                      0 FFDE A   ..FFEC                      0 FFD8 A   
..FFED                      0 FFD8 A   ..FFEE                      0 FFD8 A   
..FFEF                      0 FFD8 A   ..FFF0                      0 FFCA A   
..FFF1                      0 FFD8 A   ..FFF2                      0 FFF8 A   
..FFF3                      0 FFF4 A   ..FFF4                      0 FFE6 A   
..FFF5                      0 FFE6 A   ..FFF6                      0 FFF0 A   
..FFF7                      0 FFEC A   ..FFF8                      0 FFF6 A   
..FFF9                      0 F7E2 A   ..FFFA                      0 FFD4 A   
..FFFB                      0 FDBA A   ..FFFC                      0 FDBA A   
..FFFD                      0 FDD8 A   ..FFFE                      0 FDD8 A   
..FFFF                      0 FFC2 A   .1                          0 0194 A   
.10                         0 075F A   .100                        0 128A A   
.101                        0 1281 A   .102                        0 12A0 A   
.103                        0 1297 A   .104                        0 D643 A   
.105                        0 D627 A   .106                        0 D602 A   
.107                        0 D5E8 A   .108                        0 D5C4 A   
.109                        0 D5BB A   .10A                        0 D59B A   
.10B                        0 1374 A   .10C                        0 137E A   
.10D                        0 1388 A   .10E                        0 1392 A   
.10F                        0 139C A   .11                         0 0749 A   
.110                        0 1540 A   .111                        0 153A A   
.112                        0 D57E A   .113                        0 1758 A   
.114                        0 174F A   .115                        0 159B A   
.116                        0 15AB A   .117                        0 15A8 A   
.118                        0 15B7 A   .119                        0 15B0 A   
.11A                        0 15AD A   .11B                        0 15B7 A   
.11C                        0 D568 A   .11D                        0 16E7 A   
.11E                        0 16D4 A   .11F                        0 16DB A   
.12                         0 078D A   .120                        0 15DD A   
.121                        0 D563 A   .122                        0 16D4 A   
.124                        0 16B8 A   .125                        0 1619 A   
.126                        0 1619 A   .127                        0 1619 A   
.128                        0 D55F A   .129                        0 163C A   
.12A                        0 D55C A   .12B                        0 16A6 A   
.12C                        0 1665 A   .12D                        0 D556 A   
.12E                        0 D554 A   .12F                        0 16E7 A   
.13                         0 0779 A   .130                        0 173F A   
.131                        0 1738 A   .132                        0 16F0 A   
.133                        0 170C A   .134                        0 1704 A   
.135                        0 16FD A   .136                        0 1738 A   
.137                        0 1738 A   .138                        0 1716 A   
.139                        0 173F A   .13A                        0 D552 A   
.13B                        0 1758 A   .13C                        0 1776 A   
.13D                        0 1770 A   .13E                        0 1793 A   
.13F                        0 1785 A   .14                         0 076E A   
.140                        0 177D A   .141                        0 D542 A   
.142                        0 D532 A   .143                        0 1813 A   
.144                        0 17D2 A   .145                        0 17BB A   
.146                        0 D52C A   .147                        0 D527 A   
.148                        0 1844 A   .149                        0 1837 A   
.14A                        0 182F A   .14B                        0 D517 A   
.14C                        0 D503 A   .14D                        0 188E A   
.14E                        0 186B A   .14F                        0 1881 A   
.15                         0 0761 A   .150                        0 1872 A   
.151                        0 D4ED A   .152                        0 188E A   
.153                        0 D4CE A   .154                        0 D4CB A   
.155                        0 D4AB A   .156                        0 D497 A   
.157                        0 D482 A   .158                        0 1907 A   
.159                        0 18F3 A   .15A                        0 1919 A   
.15B                        0 1926 A   .15C                        0 1928 A   
.15D                        0 198B A   .15E                        0 1985 A   
.15F                        0 197A A   .16                         0 0779 A   
.160                        0 1A7C A   .161                        0 1A6E A   
.162                        0 1A75 A   .163                        0 19FE A   
.164                        0 1A7C A   .165                        0 1C4D A   
.166                        0 1C3D A   .167                        0 1C44 A   
.168                        0 1A84 A   .169                        0 1C4D A   
.16A                        0 1C94 A   .16B                        0 1C86 A   
.16C                        0 1C8D A   .16D                        0 1C54 A   
.16E                        0 1C94 A   .16F                        0 1E08 A   
.17                         0 078D A   .170                        0 1E05 A   
.171                        0 1CD7 A   .172                        0 1D04 A   
.173                        0 1CF9 A   .174                        0 1D98 A   
.175                        0 1D20 A   .176                        0 1D0B A   
.177                        0 1D18 A   .178                        0 1D14 A   
.179                        0 1D1A A   .17A                        0 1D98 A   
.17B                        0 1D44 A   .17C                        0 1D27 A   
.17D                        0 1D3D A   .17E                        0 1D39 A   
.17F                        0 1D30 A   .18                         0 0780 A   
.180                        0 1D3F A   .181                        0 1D98 A   
.182                        0 1D68 A   .183                        0 1D4B A   
.184                        0 1D61 A   .185                        0 1D5D A   
.186                        0 1D54 A   .187                        0 1D63 A   
.188                        0 1D98 A   .189                        0 1D8C A   
.18A                        0 1D6F A   .18B                        0 1D85 A   
.18C                        0 1D81 A   .18D                        0 1D78 A   
.18E                        0 1D87 A   .18F                        0 1D98 A   
.19                         0 07E2 A   .190                        0 1D98 A   
.191                        0 1D93 A   .192                        0 1DA6 A   
.193                        0 1D9F A   .194                        0 1DC6 A   
.195                        0 1DB7 A   .196                        0 1DD6 A   
.197                        0 1DCF A   .198                        0 1E05 A   
.199                        0 1E03 A   .19A                        0 1DDD A   
.19B                        0 2C87 A   .19C                        0 2C77 A   
.19D                        0 2C7E A   .19E                        0 1F45 A   
.19F                        0 1FB8 A   .1A                         0 07CC A   
.1A0                        0 1FB4 A   .1A1                        0 1FBA A   
.1A2                        0 21AE A   .1A3                        0 2069 A   
.1A4                        0 205F A   .1A5                        0 209E A   
.1A6                        0 209A A   .1A7                        0 20A0 A   
.1A8                        0 21AE A   .1A9                        0 20E6 A   
.1AA                        0 20DC A   .1AB                        0 2149 A   
.1AC                        0 2129 A   .1AD                        0 2121 A   
.1AE                        0 21AE A   .1AF                        0 2181 A   
.1B                         0 0810 A   .1B0                        0 2161 A   
.1B1                        0 2159 A   .1B2                        0 2151 A   
.1B3                        0 21AE A   .1B4                        0 21AE A   
.1B5                        0 2191 A   .1B6                        0 2189 A   
.1B7                        0 2709 A   .1B8                        0 21D4 A   
.1B9                        0 225C A   .1BA                        0 224E A   
.1BB                        0 D459 A   .1BC                        0 2275 A   
.1BD                        0 2271 A   .1BE                        0 2277 A   
.1BF                        0 2292 A   .1C                         0 07FC A   
.1C0                        0 228E A   .1C1                        0 2294 A   
.1C2                        0 232E A   .1C3                        0 22FA A   
.1C4                        0 2353 A   .1C5                        0 24B0 A   
.1C6                        0 249F A   .1C7                        0 24A8 A   
.1C8                        0 2491 A   .1C9                        0 24B0 A   
.1CA                        0 24FB A   .1CC                        0 24EB A   
.1CD                        0 24E1 A   .1CE                        0 24E3 A   
.1CF                        0 24E5 A   .1D                         0 07F1 A   
.1D0                        0 24E7 A   .1D1                        0 267A A   
.1D3                        0 2664 A   .1D4                        0 2502 A   
.1D5                        0 2505 A   .1D6                        0 255C A   
.1D7                        0 2553 A   .1D8                        0 2599 A   
.1D9                        0 256E A   .1DA                        0 2565 A   
.1DB                        0 2599 A   .1DC                        0 2580 A   
.1DD                        0 2577 A   .1DE                        0 2599 A   
.1DF                        0 2592 A   .1E                         0 07E4 A   
.1E0                        0 2589 A   .1E1                        0 2599 A   
.1E2                        0 25BA A   .1E3                        0 2635 A   
.1E4                        0 25C3 A   .1E5                        0 25EE A   
.1E6                        0 25E7 A   .1E7                        0 2635 A   
.1E8                        0 2660 A   .1E9                        0 2657 A   
.1EA                        0 2638 A   .1EB                        0 2657 A   
.1EC                        0 2655 A   .1ED                        0 2660 A   
.1EE                        0 268A A   .1EF                        0 2683 A   
.1F                         0 07FC A   .1F0                        0 2898 A   
.1F1                        0 2712 A   .1F2                        0 279A A   
.1F3                        0 278C A   .1F4                        0 D42E A   
.1F5                        0 27C8 A   .1F6                        0 27C4 A   
.1F7                        0 27CA A   .1F8                        0 27E5 A   
.1F9                        0 27E1 A   .1FA                        0 27E7 A   
.1FB                        0 2AB9 A   .1FD                        0 2AAD A   
.1FE                        0 28A1 A   .1FF                        0 2902 A   
.2                          0 05ED A   .20                         0 0810 A   
.200                        0 2963 A   .201                        0 2952 A   
.202                        0 295B A   .203                        0 2939 A   
.204                        0 2952 A   .205                        0 2950 A   
.206                        0 2963 A   .207                        0 29F1 A   
.208                        0 29DE A   .209                        0 29E7 A   
.20A                        0 296C A   .20B                        0 29F1 A   
.20C                        0 2A59 A   .20D                        0 2A48 A   
.20E                        0 2A51 A   .20F                        0 2A0B A   
.21                         0 0803 A   .210                        0 2A46 A   
.211                        0 2A28 A   .212                        0 2A48 A   
.213                        0 2A59 A   .214                        0 2AA9 A   
.215                        0 2A61 A   .216                        0 2AA9 A   
.217                        0 2A98 A   .218                        0 2AA1 A   
.219                        0 2A7B A   .21A                        0 2AA9 A   
.21B                        0 2C71 A   .21D                        0 2C61 A   
.21E                        0 2ABF A   .21F                        0 D423 A   
.22                         0 087D A   .220                        0 D41C A   
.221                        0 D415 A   .222                        0 2ACC A   
.223                        0 2AC7 A   .224                        0 2ACF A   
.225                        0 2B29 A   .226                        0 2B02 A   
.227                        0 2AED A   .228                        0 D412 A   
.229                        0 2B29 A   .22A                        0 2B52 A   
.22B                        0 2B37 A   .22C                        0 D3F2 A   
.22D                        0 2B7E A   .22E                        0 D3D2 A   
.22F                        0 2B81 A   .23                         0 0864 A   
.230                        0 D3C7 A   .231                        0 D3C0 A   
.232                        0 D3B9 A   .233                        0 2B8E A   
.234                        0 2B89 A   .235                        0 2B91 A   
.236                        0 2BEB A   .237                        0 2BC4 A   
.238                        0 2BAF A   .239                        0 D3B6 A   
.23A                        0 2BEB A   .23B                        0 2C20 A   
.23C                        0 2C09 A   .23D                        0 D39C A   
.23E                        0 2C35 A   .23F                        0 D38A A   
.24                         0 08AB A   .240                        0 2C37 A   
.241                        0 D370 A   .242                        0 D369 A   
.243                        0 D362 A   .244                        0 2C44 A   
.245                        0 2C3F A   .246                        0 2C47 A   
.247                        0 2C87 A   .248                        0 D360 A   
.249                        0 2E0B A   .24A                        0 2D87 A   
.24B                        0 2D92 A   .24C                        0 2D8E A   
.24D                        0 2D94 A   .24E                        0 2DFA A   
.24F                        0 2DCF A   .25                         0 0897 A   
.250                        0 2DC8 A   .251                        0 2DE9 A   
.252                        0 2DD6 A   .253                        0 2DFA A   
.254                        0 2EBC A   .255                        0 2EB0 A   
.256                        0 2EC4 A   .257                        0 2F0B A   
.258                        0 2F04 A   .259                        0 308C A   
.25A                        0 2F25 A   .25B                        0 302B A   
.25C                        0 2F6F A   .25D                        0 2F48 A   
.25E                        0 2F3D A   .25F                        0 2F31 A   
.26                         0 088C A   .260                        0 2F33 A   
.262                        0 30EC A   .263                        0 30E8 A   
.264                        0 30EE A   .265                        0 3137 A   
.266                        0 312E A   .267                        0 3147 A   
.268                        0 3147 A   .269                        0 3140 A   
.26A                        0 31E1 A   .26B                        0 31DE A   
.26C                        0 3148 A   .26D                        0 31CC A   
.26E                        0 31B8 A   .26F                        0 31C8 A   
.27                         0 087F A   .270                        0 31C1 A   
.271                        0 31DE A   .272                        0 31DC A   
.273                        0 31D5 A   .274                        0 31E1 A   
.275                        0 328D A   .276                        0 3281 A   
.277                        0 3295 A   .278                        0 32DC A   
.279                        0 32D5 A   .27A                        0 345D A   
.27B                        0 32F6 A   .27C                        0 33FC A   
.27D                        0 3340 A   .27E                        0 3319 A   
.27F                        0 330E A   .28                         0 0897 A   
.280                        0 3302 A   .281                        0 3304 A   
.283                        0 34BD A   .284                        0 34B9 A   
.285                        0 34BF A   .286                        0 3508 A   
.287                        0 34FF A   .288                        0 3518 A   
.289                        0 3518 A   .28A                        0 3511 A   
.28B                        0 35AF A   .28C                        0 35AC A   
.28D                        0 3519 A   .28E                        0 359A A   
.28F                        0 3586 A   .29                         0 08AB A   
.290                        0 3596 A   .291                        0 358F A   
.292                        0 35AC A   .293                        0 35AA A   
.294                        0 35A3 A   .295                        0 35AF A   
.296                        0 35FD A   .297                        0 35F6 A   
.298                        0 360D A   .299                        0 3606 A   
.29A                        0 3676 A   .29B                        0 3671 A   
.29C                        0 3682 A   .29D                        0 367D A   
.29E                        0 36CE A   .29F                        0 36C7 A   
.2A                         0 089E A   .2A0                        0 3739 A   
.2A1                        0 3735 A   .2A2                        0 373B A   
.2A3                        0 3782 A   .2A4                        0 3779 A   
.2A5                        0 3792 A   .2A6                        0 3792 A   
.2A7                        0 378B A   .2A8                        0 37DD A   
.2A9                        0 37C6 A   .2AA                        0 3A4F A   
.2AB                        0 3A4C A   .2AC                        0 3A49 A   
.2AD                        0 37E6 A   .2AE                        0 3812 A   
.2AF                        0 37ED A   .2B                         0 091E A   
.2B0                        0 3826 A   .2B1                        0 3858 A   
.2B2                        0 3855 A   .2B3                        0 384C A   
.2B4                        0 3868 A   .2B5                        0 3861 A   
.2B6                        0 38C7 A   .2B7                        0 38B1 A   
.2B8                        0 38DB A   .2B9                        0 3908 A   
.2BA                        0 38E8 A   .2BB                        0 3929 A   
.2BC                        0 3943 A   .2BD                        0 393E A   
.2BE                        0 3951 A   .2BF                        0 394C A   
.2C                         0 090B A   .2C0                        0 395F A   
.2C1                        0 395A A   .2C2                        0 3986 A   
.2C3                        0 3968 A   .2C4                        0 3986 A   
.2C5                        0 397F A   .2C6                        0 3976 A   
.2C7                        0 39AD A   .2C8                        0 398D A   
.2C9                        0 39C5 A   .2CA                        0 3A4C A   
.2CB                        0 3A5F A   .2CC                        0 3A58 A   
.2CD                        0 3AD1 A   .2CE                        0 3ACA A   
.2CF                        0 3B43 A   .2D                         0 08F5 A   
.2D0                        0 3B2E A   .2D1                        0 D33A A   
.2D2                        0 3C35 A   .2D3                        0 3C25 A   
.2D4                        0 3B7A A   .2D5                        0 3BAF A   
.2D6                        0 3BA9 A   .2D7                        0 3C09 A   
.2D8                        0 3BC8 A   .2D9                        0 3BD6 A   
.2DA                        0 3BCF A   .2DB                        0 3C09 A   
.2DC                        0 3BEB A   .2DD                        0 3BE4 A   
.2DE                        0 3BDD A   .2DF                        0 D312 A   
.2E                         0 091E A   .2E0                        0 3C35 A   
.2E1                        0 3CDC A   .2E2                        0 3CC1 A   
.2E3                        0 3CA9 A   .2E4                        0 D2F6 A   
.2E5                        0 3D79 A   .2E6                        0 3D67 A   
.2E7                        0 3DBF A   .2E8                        0 3D9B A   
.2E9                        0 D2E0 A   .2EA                        0 3E06 A   
.2EB                        0 3E00 A   .2EC                        0 3E2A A   
.2ED                        0 3E24 A   .2EE                        0 3E4E A   
.2EF                        0 3E48 A   .2F                         0 09CE A   
.2F0                        0 3ECD A   .2F1                        0 3ED3 A   
.2F2                        0 3F30 A   .2F3                        0 3F1F A   
.2F4                        0 3F28 A   .2F5                        0 3F0D A   
.2F6                        0 3F1F A   .2F7                        0 3F1D A   
.2F8                        0 3F30 A   .2F9                        0 3F3F A   
.2FA                        0 3F38 A   .2FB                        0 3F5F A   
.2FC                        0 3F5F A   .2FD                        0 3F53 A   
.2FE                        0 3F55 A   .2FF                        0 3FD6 A   
.3                          0 05E2 A   .30                         0 09C0 A   
.300                        0 3FCF A   .301                        0 3FE5 A   
.302                        0 3FDE A   .303                        0 403C A   
.304                        0 402A A   .305                        0 4033 A   
.306                        0 3FED A   .307                        0 402A A   
.308                        0 4023 A   .309                        0 403C A   
.30A                        0 4095 A   .30B                        0 4083 A   
.30C                        0 408C A   .30D                        0 4044 A   
.30E                        0 4083 A   .30F                        0 407C A   
.31                         0 094A A   .310                        0 4095 A   
.311                        0 41CD A   .312                        0 41C6 A   
.313                        0 41DC A   .314                        0 41D5 A   
.315                        0 41EB A   .316                        0 41E4 A   
.317                        0 41FA A   .318                        0 41F3 A   
.319                        0 4209 A   .31A                        0 4202 A   
.31B                        0 4218 A   .31C                        0 4211 A   
.31D                        0 4247 A   .31E                        0 4234 A   
.31F                        0 4272 A   .32                         0 0994 A   
.320                        0 4261 A   .321                        0 424F A   
.322                        0 4272 A   .323                        0 42C5 A   
.324                        0 42BE A   .325                        0 448A A   
.326                        0 4483 A   .327                        0 45D2 A   
.329                        0 45BA A   .32A                        0 449A A   
.32B                        0 44D0 A   .32C                        0 4506 A   
.32D                        0 453C A   .32E                        0 4635 A   
.32F                        0 45E3 A   .33                         0 096E A   
.330                        0 4617 A   .331                        0 45F4 A   
.332                        0 4635 A   .333                        0 4657 A   
.334                        0 4646 A   .335                        0 48D3 A   
.336                        0 46B0 A   .337                        0 46A7 A   
.338                        0 48D1 A   .33A                        0 48B9 A   
.33B                        0 46B6 A   .33C                        0 46FB A   
.33D                        0 46DD A   .33E                        0 4734 A   
.33F                        0 4772 A   .34                         0 09B4 A   
.340                        0 47C4 A   .341                        0 47AB A   
.342                        0 4785 A   .343                        0 47AB A   
.344                        0 479E A   .345                        0 47C4 A   
.346                        0 47BD A   .347                        0 47DA A   
.348                        0 47CB A   .349                        0 47F8 A   
.34A                        0 47F0 A   .34B                        0 4803 A   
.34C                        0 4855 A   .34D                        0 483C A   
.34E                        0 4816 A   .34F                        0 483C A   
.35                         0 09B4 A   .350                        0 482F A   
.351                        0 4855 A   .352                        0 484E A   
.353                        0 486E A   .354                        0 485C A   
.355                        0 487D A   .356                        0 4887 A   
.357                        0 48AF A   .358                        0 48DB A   
.359                        0 4DD7 A   .35B                        0 4D87 A   
.35C                        0 48FE A   .35D                        0 4989 A   
.35F                        0 4977 A   .36                         0 09A2 A   
.360                        0 4903 A   .361                        0 491A A   
.362                        0 4932 A   .363                        0 4953 A   
.364                        0 4968 A   .365                        0 498C A   
.366                        0 499C A   .367                        0 49A7 A   
.368                        0 49B7 A   .369                        0 4A81 A   
.36A                        0 49C0 A   .36B                        0 4A72 A   
.36C                        0 49D6 A   .36D                        0 4A7F A   
.36E                        0 4AD5 A   .36F                        0 4AC1 A   
.37                         0 09CE A   .370                        0 4A88 A   
.371                        0 4AD5 A   .372                        0 4AD8 A   
.373                        0 4B13 A   .374                        0 4B0C A   
.375                        0 4CE5 A   .376                        0 4D0B A   
.377                        0 4D05 A   .378                        0 4D16 A   
.379                        0 4D19 A   .37A                        0 4D1C A   
.37B                        0 4D2C A   .37C                        0 4D48 A   
.37D                        0 4D59 A   .37E                        0 D2C9 A   
.37F                        0 4D76 A   .38                         0 0A17 A   
.380                        0 543E A   .382                        0 5436 A   
.383                        0 4DFA A   .384                        0 5423 A   
.386                        0 53FE A   .387                        0 4E00 A   
.388                        0 4EFD A   .38A                        0 4EEF A   
.38B                        0 4E06 A   .38C                        0 4E47 A   
.38D                        0 4E1C A   .38E                        0 4E47 A   
.38F                        0 4E36 A   .39                         0 0A08 A   
.390                        0 4E2F A   .391                        0 4E5C A   
.392                        0 4E86 A   .393                        0 4E75 A   
.394                        0 4ECA A   .395                        0 4E9C A   
.396                        0 4ECA A   .397                        0 4EB6 A   
.398                        0 4EAF A   .399                        0 4EDC A   
.39A                        0 4F00 A   .39B                        0 4F00 A   
.39C                        0 4F65 A   .39D                        0 4F07 A   
.39E                        0 4F1F A   .39F                        0 4F0E A   
.3A                         0 0A0F A   .3A0                        0 5004 A   
.3A1                        0 4F7D A   .3A2                        0 4F9C A   
.3A3                        0 4F90 A   .3A4                        0 4FB7 A   
.3A5                        0 4FA3 A   .3A6                        0 D29E A   
.3A7                        0 5004 A   .3A8                        0 4FBE A   
.3A9                        0 5004 A   .3AA                        0 4FD1 A   
.3AB                        0 5004 A   .3AC                        0 4FE4 A   
.3AD                        0 5016 A   .3AE                        0 5076 A   
.3B                         0 09F7 A   .3B0                        0 5053 A   
.3B1                        0 501B A   .3B2                        0 5022 A   
.3B3                        0 5029 A   .3B4                        0 5030 A   
.3B5                        0 5037 A   .3B6                        0 503E A   
.3B7                        0 5045 A   .3B8                        0 504C A   
.3B9                        0 5074 A   .3BA                        0 5066 A   
.3BB                        0 50D4 A   .3BC                        0 507D A   
.3BD                        0 50C5 A   .3BE                        0 5090 A   
.3BF                        0 50D2 A   .3C                         0 0A08 A   
.3C0                        0 50E1 A   .3C1                        0 50E4 A   
.3C2                        0 5180 A   .3C3                        0 50F3 A   
.3C4                        0 5171 A   .3C5                        0 5106 A   
.3C6                        0 512D A   .3C7                        0 5119 A   
.3C8                        0 D272 A   .3C9                        0 5162 A   
.3CA                        0 514E A   .3CB                        0 D246 A   
.3CC                        0 517E A   .3CD                        0 518D A   
.3CE                        0 519B A   .3CF                        0 51DE A   
.3D                         0 0A06 A   .3D0                        0 51B1 A   
.3D1                        0 51EB A   .3D2                        0 51EE A   
.3D3                        0 5362 A   .3D5                        0 534E A   
.3D6                        0 51F4 A   .3D7                        0 52A4 A   
.3D8                        0 520F A   .3D9                        0 5236 A   
.3DA                        0 5222 A   .3DB                        0 D21A A   
.3DC                        0 52A4 A   .3DD                        0 523D A   
.3DE                        0 52A4 A   .3DF                        0 5250 A   
.3E                         0 0A17 A   .3E0                        0 52A4 A   
.3E1                        0 5263 A   .3E2                        0 52A4 A   
.3E3                        0 5276 A   .3E4                        0 52C1 A   
.3E5                        0 52C1 A   .3E6                        0 52DC A   
.3E7                        0 52CE A   .3E8                        0 52E8 A   
.3E9                        0 5308 A   .3EA                        0 52EF A   
.3EB                        0 5303 A   .3EC                        0 5305 A   
.3ED                        0 531E A   .3EE                        0 530F A   
.3EF                        0 532B A   .3F                         0 0A5B A   
.3F0                        0 5338 A   .3F1                        0 D200 A   
.3F2                        0 5365 A   .3F3                        0 53C5 A   
.3F4                        0 53AF A   .3F5                        0 53A8 A   
.3F6                        0 53C3 A   .3F7                        0 53B8 A   
.3F8                        0 53CD A   .3F9                        0 53EF A   
.3FA                        0 5421 A   .3FB                        0 5411 A   
.3FC                        0 5425 A   .3FD                        0 5886 A   
.3FF                        0 5878 A   .4                          0 05CD A   
.40                         0 0A40 A   .400                        0 5537 A   
.401                        0 557D A   .402                        0 5865 A   
.404                        0 5857 A   .405                        0 5583 A   
.406                        0 55B7 A   .407                        0 55B1 A   
.408                        0 5650 A   .409                        0 55CC A   
.40A                        0 55F2 A   .40B                        0 55D7 A   
.40C                        0 564D A   .40D                        0 5643 A   
.40E                        0 570B A   .40F                        0 5705 A   
.41                         0 D673 A   .410                        0 565A A   
.411                        0 56CB A   .412                        0 56BA A   
.413                        0 56C3 A   .414                        0 5661 A   
.415                        0 56BA A   .416                        0 56B8 A   
.417                        0 56A0 A   .418                        0 56CB A   
.419                        0 56DE A   .41A                        0 56D3 A   
.41B                        0 570B A   .41C                        0 572D A   
.41D                        0 5770 A   .41E                        0 576A A   
.41F                        0 57E1 A   .42                         0 0DDD A   
.420                        0 57D0 A   .421                        0 57D9 A   
.422                        0 5777 A   .423                        0 57D0 A   
.424                        0 57CE A   .425                        0 57B6 A   
.426                        0 57E1 A   .427                        0 5842 A   
.428                        0 57EE A   .429                        0 5842 A   
.42A                        0 581A A   .42B                        0 5850 A   
.42C                        0 5867 A   .42D                        0 5971 A   
.42E                        0 58CE A   .42F                        0 58FC A   
.43                         0 0DC7 A   .430                        0 58ED A   
.431                        0 58DF A   .432                        0 58FC A   
.433                        0 5970 A   .434                        0 5909 A   
.435                        0 5953 A   .436                        0 5944 A   
.437                        0 5936 A   .438                        0 5953 A   
.439                        0 5CB3 A   .43B                        0 5C69 A   
.43C                        0 597B A   .43D                        0 599F A   
.43E                        0 5991 A   .43F                        0 D1DC A   
.44                         0 0A5E A   .440                        0 59B4 A   
.441                        0 59AD A   .442                        0 59A6 A   
.443                        0 59C0 A   .444                        0 59C0 A   
.445                        0 59BB A   .446                        0 59D2 A   
.447                        0 59F3 A   .448                        0 59E7 A   
.449                        0 5A08 A   .44A                        0 5A01 A   
.44B                        0 59FA A   .44C                        0 5A14 A   
.44D                        0 5A14 A   .44E                        0 5A0F A   
.44F                        0 5A2E A   .45                         0 0A73 A   
.450                        0 5A4D A   .451                        0 5A71 A   
.452                        0 5A65 A   .453                        0 5A7B A   
.454                        0 5A7E A   .455                        0 5A8B A   
.456                        0 5AD2 A   .457                        0 5AB8 A   
.458                        0 5AAB A   .459                        0 5AD2 A   
.45A                        0 5AC7 A   .45B                        0 5B48 A   
.45C                        0 5ADB A   .45D                        0 5B48 A   
.45E                        0 5AE8 A   .45F                        0 5B48 A   
.46                         0 0A65 A   .460                        0 5B3D A   
.461                        0 5AE8 A   .462                        0 5B17 A   
.463                        0 5AFD A   .464                        0 5AF0 A   
.465                        0 5B17 A   .466                        0 5B0C A   
.467                        0 5B3D A   .468                        0 5B1E A   
.469                        0 5B48 A   .46A                        0 5B51 A   
.46B                        0 5B75 A   .46C                        0 5B67 A   
.46D                        0 D1B8 A   .46E                        0 5B88 A   
.46F                        0 5B83 A   .47                         0 0DC0 A   
.470                        0 5B7C A   .471                        0 5B9A A   
.472                        0 5BBB A   .473                        0 5BAF A   
.474                        0 5BCE A   .475                        0 5BC9 A   
.476                        0 5BC2 A   .477                        0 5BE8 A   
.478                        0 5C46 A   .479                        0 5C53 A   
.47A                        0 5C55 A   .47B                        0 5C67 A   
.47C                        0 5C5C A   .47D                        0 5C67 A   
.47E                        0 5CA2 A   .47F                        0 5C7C A   
.48                         0 0DB1 A   .480                        0 5D8E A   
.481                        0 5D0B A   .482                        0 5D85 A   
.483                        0 5D5E A   .484                        0 5D74 A   
.485                        0 5D6E A   .486                        0 5D94 A   
.487                        0 5D98 A   .488                        0 5DDE A   
.489                        0 5DCC A   .48A                        0 D1AD A   
.48B                        0 5DFD A   .48C                        0 5DEE A   
.48D                        0 5DEE A   .48E                        0 5DFD A   
.48F                        0 5E30 A   .49                         0 0A7C A   
.490                        0 5E1E A   .491                        0 D1A2 A   
.492                        0 5E8B A   .493                        0 5E79 A   
.494                        0 D198 A   .495                        0 5EAA A   
.496                        0 5E9B A   .497                        0 5E9B A   
.498                        0 5EAA A   .499                        0 5ED7 A   
.49A                        0 5EC5 A   .49B                        0 D18E A   
.49C                        0 5F2F A   .49D                        0 5F1D A   
.49E                        0 D184 A   .49F                        0 5F6A A   
.4A                         0 0AAB A   .4A0                        0 5F5B A   
.4A1                        0 5F5B A   .4A2                        0 5F6A A   
.4A3                        0 5FB7 A   .4A4                        0 5FA6 A   
.4A5                        0 D179 A   .4A6                        0 5FF9 A   
.4A7                        0 5FF5 A   .4A8                        0 6604 A   
.4AA                        0 65A7 A   .4AB                        0 6037 A   
.4AC                        0 6072 A   .4AD                        0 6091 A   
.4AE                        0 60B0 A   .4AF                        0 60CF A   
.4B                         0 0A8A A   .4B0                        0 60EE A   
.4B1                        0 610D A   .4B2                        0 6175 A   
.4B3                        0 6116 A   .4B4                        0 6159 A   
.4B5                        0 613B A   .4B6                        0 6175 A   
.4B7                        0 6178 A   .4B8                        0 61E0 A   
.4B9                        0 6181 A   .4BA                        0 61C4 A   
.4BB                        0 61A6 A   .4BC                        0 61E0 A   
.4BD                        0 61E3 A   .4BE                        0 6226 A   
.4BF                        0 6208 A   .4C                         0 0A83 A   
.4C0                        0 6242 A   .4C1                        0 6245 A   
.4C2                        0 6288 A   .4C3                        0 626A A   
.4C4                        0 62A4 A   .4C5                        0 62A7 A   
.4C6                        0 62E8 A   .4C7                        0 62B0 A   
.4C8                        0 62EB A   .4C9                        0 6310 A   
.4CA                        0 62F4 A   .4CB                        0 6313 A   
.4CC                        0 634E A   .4CD                        0 636D A   
.4CE                        0 6379 A   .4CF                        0 6376 A   
.4D                         0 0DAF A   .4D0                        0 6379 A   
.4D1                        0 6385 A   .4D2                        0 6382 A   
.4D3                        0 6390 A   .4D4                        0 638C A   
.4D5                        0 63D6 A   .4D6                        0 6399 A   
.4D7                        0 6583 A   .4D8                        0 641C A   
.4D9                        0 63DF A   .4DA                        0 6583 A   
.4DB                        0 6457 A   .4DC                        0 6433 A   
.4DD                        0 6425 A   .4DE                        0 642C A   
.4DF                        0 6583 A   .4E                         0 0B46 A   
.4E0                        0 64F4 A   .4E1                        0 6462 A   
.4E2                        0 64B7 A   .4E3                        0 6481 A   
.4E4                        0 64F1 A   .4E5                        0 6583 A   
.4E6                        0 654F A   .4E7                        0 6513 A   
.4E8                        0 6583 A   .4E9                        0 6591 A   
.4EA                        0 6591 A   .4EB                        0 658A A   
.4EC                        0 6615 A   .4ED                        0 660D A   
.4EE                        0 669B A   .4EF                        0 6695 A   
.4F                         0 0AD0 A   .4F0                        0 66A9 A   
.4F1                        0 66A3 A   .4F2                        0 6720 A   
.4F3                        0 671C A   .4F4                        0 6759 A   
.4F5                        0 6755 A   .4F6                        0 67E6 A   
.4F7                        0 6795 A   .4F8                        0 67E4 A   
.4F9                        0 67DE A   .4FA                        0 67ED A   
.4FB                        0 6843 A   .4FC                        0 683D A   
.4FD                        0 6836 A   .4FE                        0 686B A   
.4FF                        0 6865 A   .5                          0 05E2 A   
.50                         0 0AC9 A   .500                        0 7691 A   
.502                        0 7613 A   .503                        0 6875 A   
.504                        0 6889 A   .505                        0 68D1 A   
.506                        0 68C9 A   .507                        0 68D7 A   
.508                        0 68DA A   .509                        0 68DA A   
.50A                        0 68DA A   .50B                        0 693A A   
.50C                        0 6934 A   .50D                        0 692D A   
.50E                        0 6926 A   .50F                        0 69AF A   
.51                         0 0ADD A   .510                        0 69A9 A   
.511                        0 69A1 A   .512                        0 6999 A   
.513                        0 69C1 A   .514                        0 69BB A   
.515                        0 6A7D A   .516                        0 6A0B A   
.517                        0 6A03 A   .518                        0 6ABC A   
.519                        0 6A89 A   .51A                        0 6AED A   
.51B                        0 6B20 A   .51C                        0 6B0F A   
.51D                        0 6B29 A   .51E                        0 6B36 A   
.51F                        0 6C14 A   .52                         0 0AD7 A   
.520                        0 6C4C A   .521                        0 6C44 A   
.522                        0 6C5D A   .523                        0 6C60 A   
.524                        0 6D11 A   .525                        0 6D31 A   
.526                        0 6D31 A   .527                        0 6D31 A   
.528                        0 6D31 A   .529                        0 6DAB A   
.52A                        0 6DA5 A   .52B                        0 6E11 A   
.52C                        0 6E0B A   .52D                        0 6DE7 A   
.52E                        0 6E2F A   .52F                        0 6E29 A   
.53                         0 0AEC A   .530                        0 6E1D A   
.531                        0 6E6E A   .532                        0 6E3B A   
.533                        0 6E9F A   .534                        0 6ED9 A   
.535                        0 6EC8 A   .536                        0 6EE2 A   
.537                        0 6EE2 A   .538                        0 6EEB A   
.539                        0 6EFF A   .53A                        0 6F1D A   
.53B                        0 6F17 A   .53C                        0 710A A   
.53D                        0 6F27 A   .53E                        0 7073 A   
.53F                        0 704B A   .54                         0 0AE4 A   
.540                        0 6FFB A   .541                        0 703C A   
.542                        0 703E A   .544                        0 709D A   
.545                        0 7387 A   .546                        0 7114 A   
.547                        0 71EF A   .548                        0 71EB A   
.549                        0 71F1 A   .54A                        0 720D A   
.54B                        0 7209 A   .54C                        0 720F A   
.54D                        0 7226 A   .54E                        0 7222 A   
.54F                        0 7228 A   .55                         0 0AF2 A   
.550                        0 7241 A   .551                        0 723D A   
.552                        0 7243 A   .553                        0 7322 A   
.554                        0 730F A   .555                        0 7333 A   
.556                        0 736A A   .557                        0 735C A   
.558                        0 7363 A   .559                        0 733F A   
.55A                        0 736A A   .55B                        0 75CC A   
.55C                        0 7391 A   .55D                        0 748A A   
.55E                        0 7439 A   .55F                        0 748A A   
.56                         0 0B43 A   .560                        0 751E A   
.561                        0 74E0 A   .562                        0 751E A   
.563                        0 75AC A   .564                        0 759E A   
.565                        0 75A5 A   .566                        0 7580 A   
.567                        0 75AC A   .568                        0 75D5 A   
.569                        0 75FC A   .56B                        0 75EA A   
.56C                        0 75DA A   .56D                        0 75DA A   
.56E                        0 75DA A   .56F                        0 75DA A   
.57                         0 0B35 A   .570                        0 75E2 A   
.571                        0 75FF A   .572                        0 75FF A   
.573                        0 75FF A   .574                        0 75FF A   
.575                        0 75FF A   .576                        0 7608 A   
.577                        0 7608 A   .578                        0 7608 A   
.579                        0 7608 A   .57A                        0 7608 A   
.57B                        0 765B A   .57C                        0 7629 A   
.57D                        0 768E A   .57E                        0 766E A   
.57F                        0 7726 A   .58                         0 0B3C A   
.580                        0 7720 A   .581                        0 7719 A   
.582                        0 774E A   .583                        0 7748 A   
.584                        0 8156 A   .586                        0 80D8 A   
.587                        0 7758 A   .588                        0 7758 A   
.589                        0 7758 A   .58A                        0 7758 A   
.58B                        0 7758 A   .58C                        0 7758 A   
.58D                        0 7758 A   .58E                        0 7758 A   
.58F                        0 7761 A   .59                         0 0AFB A   
.590                        0 7761 A   .591                        0 7761 A   
.592                        0 7775 A   .593                        0 77BD A   
.594                        0 77B5 A   .595                        0 77C3 A   
.596                        0 77C6 A   .597                        0 77DA A   
.598                        0 77FA A   .599                        0 77FA A   
.59A                        0 77FA A   .59B                        0 787D A   
.59C                        0 7861 A   .59D                        0 D147 A   
.59E                        0 78B3 A   .59F                        0 78AD A   
.5A                         0 0B22 A   .5A0                        0 78A1 A   
.5A1                        0 79BA A   .5A2                        0 79A9 A   
.5A3                        0 79C3 A   .5A4                        0 79D0 A   
.5A5                        0 79CA A   .5A6                        0 7AD8 A   
.5A8                        0 7AC8 A   .5A9                        0 79F3 A   
.5AA                        0 7A15 A   .5AB                        0 79FA A   
.5AC                        0 7A46 A   .5AD                        0 7A68 A   
.5AE                        0 7A4D A   .5AF                        0 7A97 A   
.5B                         0 0B1A A   .5B0                        0 7A93 A   
.5B1                        0 7A99 A   .5B2                        0 7AA9 A   
.5B3                        0 7AB4 A   .5B4                        0 7AB0 A   
.5B5                        0 7AB6 A   .5B6                        0 7AE1 A   
.5B7                        0 7B16 A   .5B8                        0 7B05 A   
.5B9                        0 7B41 A   .5BA                        0 7B30 A   
.5BB                        0 7B4A A   .5BC                        0 7B68 A   
.5BD                        0 7B62 A   .5BE                        0 7C3E A   
.5BF                        0 7B72 A   .5C                         0 0B2B A   
.5C0                        0 7E41 A   .5C1                        0 7C48 A   
.5C2                        0 7D1C A   .5C3                        0 7D18 A   
.5C4                        0 7D1E A   .5C5                        0 7E24 A   
.5C6                        0 7E16 A   .5C7                        0 7E1D A   
.5C8                        0 7DF9 A   .5C9                        0 7E24 A   
.5CA                        0 8086 A   .5CB                        0 7E4B A   
.5CC                        0 7F44 A   .5CD                        0 7EF3 A   
.5CE                        0 7F44 A   .5CF                        0 7FD8 A   
.5D                         0 0B43 A   .5D0                        0 7F9A A   
.5D1                        0 7FD8 A   .5D2                        0 8066 A   
.5D3                        0 8058 A   .5D4                        0 805F A   
.5D5                        0 803A A   .5D6                        0 8066 A   
.5D7                        0 808F A   .5D8                        0 80A3 A   
.5D9                        0 80CA A   .5DB                        0 80B8 A   
.5DC                        0 80A8 A   .5DD                        0 80A8 A   
.5DE                        0 80A8 A   .5DF                        0 80A8 A   
.5E                         0 0DAA A   .5E0                        0 80B0 A   
.5E1                        0 80CD A   .5E2                        0 80CD A   
.5E3                        0 80CD A   .5E4                        0 80CD A   
.5E5                        0 80CD A   .5E6                        0 80CD A   
.5E7                        0 80CD A   .5E8                        0 80CD A   
.5E9                        0 8120 A   .5EA                        0 80EE A   
.5EB                        0 8153 A   .5EC                        0 8133 A   
.5ED                        0 8393 A   .5EF                        0 8375 A   
.5F                         0 0B62 A   .5F0                        0 81CD A   
.5F1                        0 81CD A   .5F2                        0 81CD A   
.5F3                        0 D116 A   .5F4                        0 81E7 A   
.5F5                        0 8365 A   .5F6                        0 8355 A   
.5F7                        0 836C A   .5F8                        0 846D A   
.5F9                        0 8467 A   .5FA                        0 844E A   
.5FB                        0 899E A   .5FD                        0 8923 A   
.5FE                        0 8477 A   .5FF                        0 8477 A   
.6                          0 05DC A   .60                         0 0B4D A   
.600                        0 8477 A   .601                        0 8477 A   
.602                        0 8477 A   .603                        0 8477 A   
.604                        0 8477 A   .605                        0 8477 A   
.606                        0 8480 A   .607                        0 8480 A   
.608                        0 8494 A   .609                        0 84DC A   
.60A                        0 84D4 A   .60B                        0 84E2 A   
.60C                        0 84E5 A   .60D                        0 84E5 A   
.60E                        0 857A A   .60F                        0 8574 A   
.61                         0 0DAA A   .610                        0 8598 A   
.611                        0 8592 A   .612                        0 858A A   
.613                        0 8582 A   .614                        0 85AA A   
.615                        0 85A4 A   .616                        0 8807 A   
.617                        0 87EC A   .618                        0 8810 A   
.619                        0 88EF A   .61B                        0 88E3 A   
.61C                        0 88BD A   .61D                        0 88C9 A   
.61E                        0 88D5 A   .61F                        0 8905 A   
.62                         0 0CFA A   .620                        0 8919 A   
.621                        0 8919 A   .622                        0 8919 A   
.623                        0 8919 A   .624                        0 8919 A   
.625                        0 8919 A   .626                        0 8919 A   
.627                        0 8919 A   .628                        0 8919 A   
.629                        0 8919 A   .62A                        0 8919 A   
.62B                        0 8919 A   .62C                        0 8919 A   
.62D                        0 8919 A   .62E                        0 8919 A   
.62F                        0 8968 A   .63                         0 0B6B A   
.630                        0 8936 A   .631                        0 899B A   
.632                        0 897B A   .633                        0 8A3C A   
.634                        0 8A33 A   .635                        0 8A27 A   
.636                        0 8A3C A   .637                        0 8A8F A   
.638                        0 8A88 A   .639                        0 8A94 A   
.63A                        0 8ADC A   .63B                        0 8AD3 A   
.63C                        0 8AC7 A   .63D                        0 8ADC A   
.63E                        0 8B1B A   .63F                        0 8AE3 A   
.64                         0 0C15 A   .640                        0 8AFE A   
.641                        0 8AF5 A   .642                        0 8AE4 A   
.643                        0 8AFE A   .644                        0 8B47 A   
.645                        0 8B3D A   .646                        0 8B5C A   
.647                        0 8B56 A   .648                        0 8B70 A   
.649                        0 8B69 A   .64A                        0 8B9B A   
.64B                        0 8B95 A   .64C                        0 8BBA A   
.64D                        0 8BB4 A   .64E                        0 8BDB A   
.64F                        0 8BCD A   .65                         0 0BA2 A   
.650                        0 8BE3 A   .651                        0 8BFD A   
.652                        0 8BEA A   .653                        0 8CBD A   
.654                        0 8C17 A   .655                        0 8C04 A   
.656                        0 8CBD A   .657                        0 8C31 A   
.658                        0 8C1E A   .659                        0 8CBD A   
.65A                        0 8C4A A   .65B                        0 8C38 A   
.65C                        0 8CBD A   .65D                        0 8C63 A   
.65E                        0 8C51 A   .65F                        0 8CBD A   
.66                         0 0BE9 A   .660                        0 8C7C A   
.661                        0 8C6A A   .662                        0 8CBD A   
.663                        0 8C95 A   .664                        0 8C83 A   
.665                        0 8CBD A   .666                        0 8CAE A   
.667                        0 8C9C A   .668                        0 8CBD A   
.669                        0 8CCC A   .66A                        0 8CC4 A   
.66B                        0 8CD2 A   .66C                        0 8D44 A   
.66D                        0 8D3D A   .66E                        0 8D2A A   
.66F                        0 8D44 A   .67                         0 0BAC A   
.670                        0 8D7A A   .671                        0 8D6A A   
.672                        0 8D88 A   .673                        0 8DD9 A   
.674                        0 8DCB A   .675                        0 8DE1 A   
.676                        0 8DF0 A   .677                        0 8DE8 A   
.678                        0 8DF7 A   .679                        0 9EEF A   
.67B                        0 9EB0 A   .67C                        0 8E11 A   
.67D                        0 8E3E A   .67E                        0 8E1E A   
.67F                        0 8E5F A   .68                         0 0C12 A   
.680                        0 8E51 A   .681                        0 8E67 A   
.682                        0 8E8E A   .683                        0 8E6E A   
.684                        0 8EBB A   .685                        0 8EF9 A   
.686                        0 8EF1 A   .687                        0 8EFD A   
.688                        0 8EFD A   .689                        0 8EFD A   
.68A                        0 8F70 A   .68B                        0 8F46 A   
.68C                        0 8F3F A   .68D                        0 8F38 A   
.68E                        0 8F31 A   .68F                        0 8F2A A   
.69                         0 0CF7 A   .690                        0 8FA9 A   
.691                        0 8F7F A   .692                        0 8FF1 A   
.693                        0 8FB8 A   .694                        0 8FF1 A   
.695                        0 8FC7 A   .696                        0 93AE A   
.697                        0 8FFA A   .698                        0 902A A   
.699                        0 9023 A   .69A                        0 9073 A   
.69B                        0 9049 A   .69C                        0 921A A   
.69D                        0 9213 A   .69E                        0 91BB A   
.69F                        0 9200 A   .6A                         0 0C48 A   
.6A0                        0 91D3 A   .6A1                        0 921A A   
.6A2                        0 9270 A   .6A3                        0 9262 A   
.6A4                        0 D0F6 A   .6A5                        0 9383 A   
.6A6                        0 9359 A   .6A7                        0 9785 A   
.6A8                        0 975D A   .6A9                        0 93B7 A   
.6AA                        0 93E7 A   .6AB                        0 93E0 A   
.6AC                        0 9430 A   .6AD                        0 9406 A   
.6AE                        0 95C9 A   .6AF                        0 95C2 A   
.6B                         0 0C1C A   .6B0                        0 956A A   
.6B1                        0 95AF A   .6B2                        0 9582 A   
.6B3                        0 95C9 A   .6B4                        0 961F A   
.6B5                        0 9611 A   .6B6                        0 D0D6 A   
.6B7                        0 9733 A   .6B8                        0 9708 A   
.6B9                        0 9725 A   .6BA                        0 9711 A   
.6BB                        0 9733 A   .6BC                        0 D0B1 A   
.6BD                        0 9785 A   .6BE                        0 9788 A   
.6BF                        0 97E7 A   .6C                         0 0CF7 A   
.6C0                        0 97CB A   .6C1                        0 97C4 A   
.6C2                        0 97BD A   .6C3                        0 97B6 A   
.6C4                        0 97AF A   .6C5                        0 9816 A   
.6C6                        0 97F6 A   .6C7                        0 985E A   
.6C8                        0 9825 A   .6C9                        0 985E A   
.6CA                        0 9834 A   .6CB                        0 988E A   
.6CC                        0 9887 A   .6CD                        0 98D6 A   
.6CE                        0 98AC A   .6CF                        0 9A2E A   
.6D                         0 0CF7 A   .6D0                        0 9A27 A   
.6D1                        0 99D9 A   .6D2                        0 9A14 A   
.6D3                        0 99F1 A   .6D4                        0 9A2E A   
.6D5                        0 9A84 A   .6D6                        0 9A76 A   
.6D7                        0 D091 A   .6D8                        0 9B98 A   
.6D9                        0 9B6D A   .6DA                        0 9B8A A   
.6DB                        0 9B76 A   .6DC                        0 9B98 A   
.6DD                        0 D06B A   .6DE                        0 9BC5 A   
.6DF                        0 9C07 A   .6E                         0 0C58 A   
.6E0                        0 9BD2 A   .6E1                        0 9C28 A   
.6E2                        0 9C21 A   .6E3                        0 9C38 A   
.6E4                        0 9C31 A   .6E5                        0 9C4D A   
.6E6                        0 9C3F A   .6E7                        0 9C55 A   
.6E8                        0 9D72 A   .6EA                        0 9D4B A   
.6EB                        0 9C8F A   .6EC                        0 9CA1 A   
.6ED                        0 9CB5 A   .6EE                        0 9CC9 A   
.6EF                        0 9CDD A   .6F                         0 0C4F A   
.6F0                        0 9CF1 A   .6F1                        0 9D04 A   
.6F2                        0 9D16 A   .6F3                        0 9D28 A   
.6F4                        0 9D3B A   .6F5                        0 D04B A   
.6F6                        0 9D70 A   .6F7                        0 9D5E A   
.6F8                        0 9D8B A   .6F9                        0 9DAE A   
.6FA                        0 9D98 A   .6FB                        0 9DCF A   
.6FC                        0 9DC1 A   .6FD                        0 9DD7 A   
.6FE                        0 9DF2 A   .6FF                        0 9DE6 A   
.7                          0 05ED A   .70                         0 0C65 A   
.700                        0 9DFD A   .701                        0 9E01 A   
.702                        0 9E2E A   .703                        0 9E0E A   
.704                        0 9E4E A   .705                        0 9E6E A   
.706                        0 9E8E A   .707                        0 9ED5 A   
.708                        0 9EC3 A   .709                        0 9F22 A   
.70A                        0 9F15 A   .70B                        0 D024 A   
.70C                        0 A069 A   .70D                        0 9F76 A   
.70E                        0 9F6D A   .70F                        0 9F63 A   
.71                         0 0C5F A   .710                        0 9FFD A   
.711                        0 9F97 A   .712                        0 9FFD A   
.713                        0 9FE6 A   .714                        0 9FDF A   
.715                        0 9FFD A   .716                        0 9FF6 A   
.717                        0 A03B A   .718                        0 A004 A   
.719                        0 A05F A   .71A                        0 A057 A   
.71B                        0 A071 A   .71C                        0 A112 A   
.71D                        0 A0E8 A   .71E                        0 A14E A   
.71F                        0 A14E A   .72                         0 0C74 A   
.720                        0 A119 A   .721                        0 D00E A   
.722                        0 CFF1 A   .723                        0 CFF0 A   
.724                        0 A16A A   .725                        0 A166 A   
.726                        0 A2C5 A   .728                        0 A2A9 A   
.729                        0 A17F A   .72A                        0 A17F A   
.72B                        0 A18B A   .72C                        0 A187 A   
.72D                        0 A18D A   .72E                        0 A1DD A   
.72F                        0 A1CC A   .73                         0 0C6C A   
.730                        0 A216 A   .731                        0 A1F4 A   
.732                        0 A1E5 A   .733                        0 A216 A   
.734                        0 A206 A   .735                        0 A22F A   
.736                        0 A255 A   .737                        0 A23C A   
.738                        0 A287 A   .739                        0 A2A3 A   
.73A                        0 A625 A   .73C                        0 A5FC A   
.73D                        0 A2F3 A   .73E                        0 A317 A   
.73F                        0 A33A A   .74                         0 0C7A A   
.740                        0 A34C A   .741                        0 A341 A   
.742                        0 A393 A   .743                        0 A39D A   
.744                        0 A39A A   .745                        0 A40D A   
.746                        0 A424 A   .747                        0 A419 A   
.748                        0 A465 A   .749                        0 A47A A   
.74A                        0 A46C A   .74B                        0 A4EE A   
.74C                        0 A513 A   .74D                        0 A508 A   
.74E                        0 A51D A   .74F                        0 A51A A   
.75                         0 0CF7 A   .750                        0 A584 A   
.751                        0 A5B7 A   .752                        0 A5C0 A   
.753                        0 A5BE A   .754                        0 A5E2 A   
.755                        0 A5C9 A   .756                        0 A5C7 A   
.757                        0 A5E2 A   .758                        0 A5D2 A   
.759                        0 A5D0 A   .75A                        0 A5E2 A   
.75B                        0 A5E2 A   .75C                        0 A5D9 A   
.75D                        0 A5E2 A   .75E                        0 A5E0 A   
.75F                        0 A5E2 A   .76                         0 0CE9 A   
.760                        0 A5F2 A   .761                        0 A61F A   
.762                        0 A60F A   .763                        0 A74A A   
.764                        0 A65B A   .765                        0 A668 A   
.766                        0 A664 A   .767                        0 A74A A   
.768                        0 A673 A   .769                        0 A74A A   
.76A                        0 A687 A   .76B                        0 A717 A   
.76C                        0 A6AD A   .76D                        0 A747 A   
.76E                        0 B118 A   .77                         0 0CF0 A   
.770                        0 B110 A   .771                        0 B054 A   
.772                        0 B080 A   .773                        0 B074 A   
.774                        0 B05B A   .775                        0 B102 A   
.777                        0 B0DD A   .778                        0 B085 A   
.779                        0 B085 A   .77A                        0 B085 A   
.77B                        0 B085 A   .77C                        0 B085 A   
.77D                        0 B085 A   .77E                        0 B085 A   
.77F                        0 B085 A   .78                         0 0C83 A   
.780                        0 B0D3 A   .781                        0 B100 A   
.782                        0 B0F0 A   .783                        0 B104 A   
.784                        0 CFF0 A   .785                        0 CFF1 A   
.786                        0 D00E A   .787                        0 D024 A   
.788                        0 D04B A   .789                        0 D06B A   
.78A                        0 D091 A   .78B                        0 D0B1 A   
.78C                        0 D0D6 A   .78D                        0 D0F6 A   
.78E                        0 D116 A   .78F                        0 D147 A   
.79                         0 0CD6 A   .790                        0 D179 A   
.791                        0 D184 A   .792                        0 D18E A   
.793                        0 D198 A   .794                        0 D1A2 A   
.795                        0 D1AD A   .796                        0 D1B8 A   
.797                        0 D1DC A   .798                        0 D200 A   
.799                        0 D21A A   .79A                        0 D246 A   
.79B                        0 D272 A   .79C                        0 D29E A   
.79D                        0 D2C9 A   .79E                        0 D2E0 A   
.79F                        0 D2F6 A   .7A                         0 0CCE A   
.7A0                        0 D312 A   .7A1                        0 D33A A   
.7A2                        0 D360 A   .7A3                        0 D362 A   
.7A4                        0 D369 A   .7A5                        0 D370 A   
.7A6                        0 D38A A   .7A7                        0 D39C A   
.7A8                        0 D3B6 A   .7A9                        0 D3B9 A   
.7AA                        0 D3C0 A   .7AB                        0 D3C7 A   
.7AC                        0 D3D2 A   .7AD                        0 D3F2 A   
.7AE                        0 D412 A   .7AF                        0 D415 A   
.7B                         0 0CDF A   .7B0                        0 D41C A   
.7B1                        0 D423 A   .7B2                        0 D42E A   
.7B3                        0 D459 A   .7B4                        0 D482 A   
.7B5                        0 D497 A   .7B6                        0 D4AB A   
.7B7                        0 D4CB A   .7B8                        0 D4CE A   
.7B9                        0 D4ED A   .7BA                        0 D503 A   
.7BB                        0 D517 A   .7BC                        0 D527 A   
.7BD                        0 D52C A   .7BE                        0 D532 A   
.7BF                        0 D542 A   .7C                         0 0CF7 A   
.7C0                        0 D552 A   .7C1                        0 D554 A   
.7C2                        0 D556 A   .7C3                        0 D55C A   
.7C4                        0 D55F A   .7C5                        0 D563 A   
.7C6                        0 D568 A   .7C7                        0 D57E A   
.7C8                        0 D59B A   .7C9                        0 D5BB A   
.7CA                        0 D5C4 A   .7CB                        0 D5E8 A   
.7CC                        0 D602 A   .7CD                        0 D627 A   
.7CE                        0 D643 A   .7CF                        0 D656 A   
.7D                         0 0DAA A   .7D0                        0 D673 A   
.7E                         0 0D39 A   .7F                         0 0D01 A   
.8                          0 06F1 A   .80                         0 0D25 A   
.81                         0 0D0B A   .82                         0 0D37 A   
.83                         0 0DAA A   .84                         0 0D52 A   
.85                         0 0D40 A   .86                         0 0DAA A   
.87                         0 0D87 A   .88                         0 0D59 A   
.89                         0 0DAA A   .8A                         0 0D9C A   
.8B                         0 0D8E A   .8C                         0 0DAA A   
.8D                         0 D656 A   .8E                         0 0DC0 A   
.8F                         0 0DDD A   .9                          0 06E2 A   
.90                         0 0DEA A   .91                         0 0DE6 A   
.92                         0 0E22 A   .93                         0 0E08 A   
.94                         0 0DFB A   .95                         0 0E22 A   
.96                         0 0E17 A   .97                         0 0E60 A   
.98                         0 0E55 A   .99                         0 0E2A A   
.9A                         0 0E55 A   .9B                         0 0E46 A   
.9C                         0 0E60 A   .9D                         0 0E9D A   
.9E                         0 0E83 A   .9F                         0 0E76 A   
.A                          0 0709 A   .A0                         0 0E9D A   
.A1                         0 0E92 A   .A2                         0 0EAC A   
.A3                         0 0EA4 A   .A4                         0 0EDC A   
.A5                         0 0EC2 A   .A6                         0 0EB4 A   
.A7                         0 0EDC A   .A8                         0 0ED1 A   
.A9                         0 0EEC A   .AA                         0 0EE3 A   
.AB                         0 0F02 A   .AC                         0 0EF9 A   
.AD                         0 0F40 A   .AE                         0 0F26 A   
.AF                         0 0F18 A   .B                          0 06FA A   
.B0                         0 0F40 A   .B1                         0 0F35 A   
.B2                         0 0F50 A   .B3                         0 0F47 A   
.B4                         0 0F80 A   .B5                         0 0F66 A   
.B6                         0 0F58 A   .B7                         0 0F80 A   
.B8                         0 0F75 A   .B9                         0 0F90 A   
.BA                         0 0F87 A   .BB                         0 0FA6 A   
.BC                         0 0F9D A   .BD                         0 1000 A   
.BE                         0 0FE6 A   .BF                         0 0FD8 A   
.C                          0 072D A   .C0                         0 1000 A   
.C1                         0 0FF5 A   .C2                         0 1010 A   
.C3                         0 1007 A   .C4                         0 1040 A   
.C5                         0 1026 A   .C6                         0 1018 A   
.C7                         0 1040 A   .C8                         0 1035 A   
.C9                         0 1050 A   .CA                         0 1047 A   
.CB                         0 1066 A   .CC                         0 105D A   
.CD                         0 1096 A   .CE                         0 107C A   
.CF                         0 106E A   .D                          0 0712 A   
.D0                         0 1096 A   .D1                         0 108B A   
.D2                         0 10A6 A   .D3                         0 109D A   
.D4                         0 10BC A   .D5                         0 10B3 A   
.D6                         0 10FA A   .D7                         0 10E0 A   
.D8                         0 10D2 A   .D9                         0 10FA A   
.DA                         0 10EF A   .DB                         0 110A A   
.DC                         0 1101 A   .DD                         0 113A A   
.DE                         0 1120 A   .DF                         0 1112 A   
.E                          0 0722 A   .E0                         0 113A A   
.E1                         0 112F A   .E2                         0 114A A   
.E3                         0 1141 A   .E4                         0 1160 A   
.E5                         0 1157 A   .E6                         0 119E A   
.E7                         0 1184 A   .E8                         0 1176 A   
.E9                         0 119E A   .EA                         0 1193 A   
.EB                         0 11AE A   .EC                         0 11A5 A   
.ED                         0 11EC A   .EE                         0 11D2 A   
.EF                         0 11C4 A   .F                          0 0719 A   
.F0                         0 11EC A   .F1                         0 11E1 A   
.F2                         0 11FC A   .F3                         0 11F3 A   
.F4                         0 123A A   .F5                         0 1220 A   
.F6                         0 1212 A   .F7                         0 123A A   
.F8                         0 122F A   .F9                         0 124A A   
.FA                         0 1241 A   .FB                         0 127A A   
.FC                         0 1260 A   .FD                         0 1252 A   
.FE                         0 127A A   .FF                         0 126F A   
.FFDD                       0 89D5 A   .FFDE                       0 89BF A   
.FFDF                       0 89A9 A   .FFE0                       0 89CB A   
.FFE2                       0 899E A   .FFE3                       0 83C0 A   
.FFE4                       0 8393 A   .FFE6                       0 8190 A   
.FFE7                       0 817A A   .FFE8                       0 8164 A   
.FFE9                       0 8186 A   .FFEB                       0 8159 A   
.FFEC                       0 769F A   .FFED                       0 76CB A   
.FFEE                       0 76B5 A   .FFEF                       0 76C1 A   
.FFF1                       0 7694 A   .FFF4                       0 5867 A   
.FFFA                       0 3C3C A   BcdToBin                    0 AB52 A   
Upcall                      0 AEF4 A   _TCGInterruptHandler        0 AF8D A   
_apm16_entry                0 AD00 A   _apm32_entry                0 AC17 A   
_apmreal_entry              0 ADCD A   _ata_cmd_data_in            0 2E27 A E 
_ata_cmd_data_out           0 31F8 A E _ata_cmd_non_data           0 2E20 A E 
_ata_cmd_packet             0 35C6 A E _ata_detect                 0 1E0F A E 
_ata_init                   0 19DE A E _ata_reset                  0 2CD3 A E 
_atapi_get_sense            0 3A76 A E _atapi_is_cdrom             0 3DE3 A E 
_atapi_is_ready             0 3AFB A E _await_ide                  0 1CB8 A   
_bios_cvs_version_string    0 0194 A   _bios_printf                0 0A1B A E 
_cdemu_emulated_drive       0 3EA6 A E _cdemu_init                 0 3E55 A E 
_cdemu_isactive             0 3E7F A E _cdrom_boot                 0 3EEB A E 
_check_for_keystroke        0 09D4 A E _clobber_entry_point        0 130D A E 
_debugger_off               0 1940 A E _debugger_on                0 192E A E 
_delay_ticks                0 0922 A E _delay_ticks_and_check_for+ 0 09EA A E 
_dequeue_key                0 5CB7 A E _determine_floppy_media     0 9F3C A E 
_disable_rom_write_access   0 06A5 A E _drivetypes                 0 1374 A   
_eltorito                   0 3ED3 A   _enable_mouse_int_and_even+ 0 5E65 A E 
_enable_rom_write_access    0 0694 A E _enqueue_key                0 6635 A E 
_fixup_base_mem_in_k        0 0650 A E _floppy_drive_exists        0 8DB3 A E 
_floppy_drive_recal         0 8D00 A E _floppy_media_known         0 8B1F A E 
_floppy_media_sense         0 8BA2 A E _floppy_prepare_controller  0 8A40 A E 
_floppy_reset_controller    0 89F2 A E _get_CS                     0 064A A E 
_get_SS                     0 064D A E _get_boot_vector            0 1503 A   
_get_keystroke              0 09E2 A E _get_mouse_data             0 5F53 A E 
_get_s3_waking_vector       0 AFDB A   _inb                        0 053E A E 
_inb_cmos                   0 0583 A E _inhibit_mouse_int_and_eve+ 0 5DB8 A E 
_init_boot_vectors          0 13A6 A   _init_rtc                   0 058F A E 
_int09_function             0 5FE2 A E _int13_cdemu                0 83E7 A E 
_int13_cdrom                0 76E8 A E _int13_diskette_function    0 8DFB A E 
_int13_eltorito             0 81AD A E _int13_harddisk             0 6804 A E 
_int14_function             0 466F A E _int15_function             0 48DF A E 
_int15_function32           0 551E A E _int15_function_mouse       0 4DDB A E 
_int16_function             0 588A A E _int17_function             0 9F3D A E 
_int18_function             0 A075 A E _int18_panic_msg            0 18C4 A E 
_int1a_function             0 A2E7 A E _int1a_function32           0 B049 A E 
_int70_function             0 A629 A E _int74_function             0 66E9 A E 
_interactive_bootkey        0 1564 A E _inw                        0 0549 A E 
_isotag                     0 3ECD A   _keyboard_init              0 0DEE A E 
_keyboard_panic             0 12B2 A E _log_bios_start             0 18D6 A E 
_machine_reset              0 12C7 A E _memcpyb                    0 0024 A E 
_memcpyd                    0 0053 A E _memsetb                    0 0000 A E 
_nmi_handler_msg            0 18B2 A E _outb                       0 0554 A E 
_outb_cmos                  0 0574 A E _outw                       0 0564 A E 
_panic_msg_keyb_buffer_ful+ 0 5D98 A   _pmm                        0 AFE1 A   
_print_bios_banner          0 134D A E _print_boot_device          0 175C A E 
_print_boot_failure         0 1825 A E _print_cdromboot_failure    0 189D A E 
_put_int                    0 072F A E _put_luint                  0 0837 A E 
_put_str                    0 08EE A E _put_uint                   0 07B4 A E 
_read_byte                  0 05F4 A E _read_dword                 0 0083 A E 
_read_word                  0 0607 A E _rtc_updating               0 05C0 A E 
_s3_resume                  0 1951 A E _s3_resume_panic            0 133B A E 
_scan_to_scanascii          0 01C4 A   _send                       0 06C7 A E 
_send_to_mouse_ctrl         0 5F09 A E _set_diskette_current_cyl   0 9F0B A E 
_set_diskette_ret_status    0 9EF3 A E _set_e820_range             0 5442 A E 
_set_enable_a20             0 18DB A E _set_kbd_command_byte       0 5F94 A E 
_shutdown_status_panic      0 1323 A E _tcpa_acpi_init             0 AF93 A   
_tcpa_add_bootdevice        0 AFB7 A   _tcpa_add_event_separators  0 AFAB A   
_tcpa_calling_int19h        0 AF9F A   _tcpa_do_measure_POSTs      0 AFE7 A E 
_tcpa_extend_acpi_log       0 AF99 A   _tcpa_initialize_tpm        0 AFD5 A   
_tcpa_ipl                   0 AFC9 A   _tcpa_measure_post          0 AFCF A   
_tcpa_option_rom            0 AFC3 A   _tcpa_returned_int19h       0 AFA5 A   
_tcpa_start_option_rom_sca+ 0 AFBD A   _tcpa_wake_event            0 AFB1 A   
_vgafont8                   0 FA6E A   _wrch                       0 06B7 A E 
_write_byte                 0 061A A E _write_dword                0 009B A E 
_write_word                 0 0632 A E apm16_04                    0 AD01 A   
apm16_05                    0 AD08 A   apm16_07                    0 AD13 A   
apm16_07_1                  0 AD37 A   apm16_07_poweroff           0 AD2D A   
apm16_07_poweroff_str       0 ACE7 A   apm16_07_standby            0 AD49 A   
apm16_07_standby_str        0 ACF8 A   apm16_07_suspend            0 AD3A A   
apm16_07_suspend_str        0 ACF0 A   apm16_08                    0 AD58 A   
apm16_0a                    0 AD5E A   apm16_0b                    0 AD72 A   
apm16_0e                    0 AD7A A   apm16_0f                    0 AD84 A   
apm16_10                    0 AD8A A   apm16_error                 0 AD98 A   
apm16_ok                    0 AD95 A   apm16_out_str               0 ACCF A   
apm16_out_str1              0 ACD6 A   apm16_out_str2              0 ACE2 A   
apm16_unimplemented         0 AD98 A   apm32_04                    0 AC19 A   
apm32_05                    0 AC22 A   apm32_07                    0 AC31 A   
apm32_07_1                  0 AC62 A   apm32_07_poweroff           0 AC54 A   
apm32_07_poweroff_str       0 ABFE A   apm32_07_standby            0 AC76 A   
apm32_07_standby_str        0 AC0F A   apm32_07_suspend            0 AC65 A   
apm32_07_suspend_str        0 AC07 A   apm32_08                    0 AC87 A   
apm32_0a                    0 AC8D A   apm32_0b                    0 ACA3 A   
apm32_0e                    0 ACAB A   apm32_0f                    0 ACB5 A   
apm32_10                    0 ACBB A   apm32_error                 0 ACCB A   
apm32_ok                    0 ACC7 A   apm32_out_str               0 ABEB A   
apm32_out_str1              0 ABEF A   apm32_out_str2              0 ABFB A   
apm32_unimplemented         0 ACCB A   apm_call                    0 F87B A   
apmreal_00                  0 ADCD A   apmreal_01                  0 ADDF A   
apmreal_02                  0 ADE6 A   apmreal_03                  0 ADFC A   
apmreal_04                  0 AE1B A   apmreal_05                  0 AE22 A   
apmreal_07                  0 AE2D A   apmreal_07_1                0 AE51 A   
apmreal_07_poweroff         0 AE47 A   apmreal_07_poweroff_str     0 ADB3 A   
apmreal_07_standby          0 AE63 A   apmreal_07_standby_str      0 ADC4 A   
apmreal_07_suspend          0 AE54 A   apmreal_07_suspend_str      0 ADBC A   
apmreal_08                  0 AE72 A   apmreal_0a                  0 AE78 A   
apmreal_0b                  0 AE8C A   apmreal_0e                  0 AE94 A   
apmreal_0f                  0 AE9E A   apmreal_10                  0 AEA4 A   
apmreal_error               0 AEB4 A   apmreal_ok                  0 AEAF A   
apmreal_out_str             0 AD9B A   apmreal_out_str1            0 ADA2 A   
apmreal_out_str2            0 ADAE A   apmreal_unimplemented       0 AEB4 A   
ata_in_16                   0 316E A   ata_in_32                   0 3172 A   
ata_in_adjust               0 315A A   ata_in_done                 0 3175 A   
ata_in_no_adjust            0 3161 A   ata_out_16                  0 353F A   
ata_out_32                  0 3544 A   ata_out_adjust              0 352B A   
ata_out_done                0 3548 A   ata_out_no_adjust           0 3532 A   
ata_packet_after            0 3A01 A   ata_packet_done             0 3A1B A   
ata_packet_in_16            0 39FA A   ata_packet_in_32            0 39FE A   
ata_packet_in_after_16      0 3A0E A   ata_packet_in_after_32      0 3A13 A   
ata_packet_in_after_32_loo+ 0 3A15 A   ata_packet_in_before_16     0 39D8 A   
ata_packet_in_before_32     0 39DD A   ata_packet_in_before_32_lo+ 0 39DF A   
ata_packet_no_before        0 39E5 A   bios32_end                  0 B163 A   
bios32_entry_point          0 B130 A   bios32_structure            0 B120 A   
bios_table_area_end         0 CFF0 A   bios_table_area_start       0 B710 A   
block_count_rounded         0 B5D9 A   carry_set                   0 A785 A   
check_for_hd1               0 AA0D A   checksum_loop               0 B587 A   
checksum_out                0 B5A1 A   detect_parport              0 B52C A   
detect_serial               0 B54B A   diskette_param_table        0 EFC7 A   
diskette_param_table2       0 EFDE A   done                        0 09E1 A   
dummy_iret_handler          0 FF53 A   ebda_post                   0 AAFB A   
eoi_both_pics               0 AB49 A   eoi_jmp_post                0 AB10 A   
eoi_master_pic              0 AB4D A   f0_missing                  0 A887 A   
f1_missing                  0 A892 A   fetch_bdf                   0 B5F2 A   
floppy_drive_post           0 A84C A   gdt_base                    0 AEC0 A   
gdt_entry_end               0 AEE8 A   gdt_entry_pm_16bit_cs       0 AED0 A   
gdt_entry_pm_16bit_ds       0 AEE0 A   gdt_entry_pm_32bit_cs       0 AEC8 A   
gdt_entry_pm_32bit_ds       0 AED8 A   halt2_loop                  0 0DE7 A   
hard_drive_post             0 A8D3 A   hd0_post_above_2048         0 A9CF A   
hd0_post_above_4096         0 A9DD A   hd0_post_above_8192         0 A9EB A   
hd0_post_checksum_loop      0 AA00 A   hd0_post_logical_chs        0 A9AE A   
hd0_post_physical_chs       0 A9A0 A   hd0_post_store_logical      0 A9F1 A   
hd1_post_above_2048         0 AABC A   hd1_post_above_4096         0 AACA A   
hd1_post_above_8192         0 AAD8 A   hd1_post_checksum_loop      0 AAED A   
hd1_post_logical_chs        0 AA9B A   hd1_post_physical_chs       0 AA8E A   
hd1_post_store_logical      0 AADE A   idiv_                       0 0165 A   
idiv_u                      0 0169 A   int08_floppy_off            0 FEC4 A   
int08_handler               0 FEA5 A   int08_store_ticks           0 FED9 A   
int09_check_pause           0 E9B5 A   int09_done                  0 E9CF A   
int09_finish                0 E9D5 A   int09_handler               0 E987 A   
int09_process_key           0 E9C7 A   int0e_handler               0 EF57 A   
int0e_loop1                 0 EF69 A   int0e_loop2                 0 EF73 A   
int0e_normal                0 EF81 A   int10_handler               0 F065 A   
int11_handler               0 F84D A   int12_handler               0 F841 A   
int13_cdemu_inactive        0 A7D9 A   int13_cdrom_rme_end         0 7B28 A   
int13_disk                  0 A808 A   int13_diskette              0 EC59 A   
int13_handler               0 E3FE A   int13_legacy                0 A7E1 A   
int13_nocdemu               0 A7C6 A   int13_noeltorito            0 A7DD A   
int13_not_eltorito          0 A7A3 A   int13_notcdrom              0 A808 A   
int13_notfloppy             0 A7F4 A   int13_out                   0 A815 A   
int13_relocated             0 A78E A   int14_handler               0 E739 A   
int1586_tick                0 556C A   int1586_tick_end            0 557A A   
int15_handler               0 F859 A   int15_handler32             0 F883 A   
int15_handler32_ret         0 F875 A   int15_handler_mouse         0 F87E A   
int15_handler_mouse_ret     0 F874 A   int16_F00                   0 E85B A   
int16_handler               0 E82E A   int16_key_found             0 E86F A   
int16_wait_for_key          0 E860 A   int16_zero_clear            0 E849 A   
int16_zero_set              0 E852 A   int17_handler               0 EFD2 A   
int18_handler               0 A819 A   int19_handler               0 E6F2 A   
int19_load_done             0 A1C0 A   int19_relocated             0 A83E A   
int1a_callfunction          0 FE8D A   int1a_handler               0 FE6E A   
int1a_normal                0 FE87 A   int1c_handler               0 A84B A   
int70_handler               0 FE93 A   int74_done                  0 A770 A   
int74_handler               0 A751 A   int75_handler               0 E2C7 A   
int76_handler               0 ABD8 A   iret_modify_cf              0 A77A A   
iret_post_0x467             0 AB20 A   jmp_post_0x467              0 AB18 A   
laddl                       0 00C3 A   laddul                      0 00C3 A   
landl                       0 00BB A   landul                      0 00BB A   
lcmpl                       0 00CB A   lcmpul                      0 00CB A   
ldecl                       0 0102 A   ldecul                      0 0102 A   
ldivul                      0 016E A   lincl                       0 010F A   
lincul                      0 010F A   lmull                       0 00E9 A   
lmulul                      0 00E9 A   look_drive0                 0 A87E A   
look_drive1                 0 A889 A   lorl                        0 0107 A   
lorul                       0 0107 A   lsl_exit                    0 0164 A   
lsl_loop                    0 0158 A   lsll                        0 0147 A   
lslul                       0 0147 A   lsr_exit                    0 0146 A   
lsr_loop                    0 013A A   lsrul                       0 0129 A   
lsubl                       0 00E1 A   lsubul                      0 00E1 A   
ltstl                       0 0114 A   ltstul                      0 0114 A   
memcpyb_end                 0 004B A   memcpyd_end                 0 007B A   
memsetb_end                 0 001E A   nmi                         0 E2C3 A   
no_bcv                      0 B644 A   no_bev                      0 B686 A   
no_key                      0 09DF A   no_parport                  0 B54A A   
no_prod_str                 0 B67E A   no_serial                   0 B56E A   
normal_post                 0 E0A7 A   pci_present                 0 B2ED A   
pci_pro_devloop             0 B19D A   pci_pro_devloop2            0 B1D3 A   
pci_pro_f02                 0 B18C A   pci_pro_f03                 0 B1C8 A   
pci_pro_f08                 0 B201 A   pci_pro_f09                 0 B220 A   
pci_pro_f0a                 0 B23E A   pci_pro_f0b                 0 B252 A   
pci_pro_f0c                 0 B26E A   pci_pro_f0d                 0 B28C A   
pci_pro_fail                0 B2A2 A   pci_pro_nextdev             0 B1B8 A   
pci_pro_nextdev2            0 B1F1 A   pci_pro_ok                  0 B2A7 A   
pci_pro_select_reg          0 B2AE A   pci_pro_unknown             0 B2A0 A   
pci_real_devloop            0 B321 A   pci_real_devloop2           0 B353 A   
pci_real_f02                0 B30E A   pci_real_f03                0 B34A A   
pci_real_f08                0 B380 A   pci_real_f09                0 B398 A   
pci_real_f0a                0 B3B0 A   pci_real_f0b                0 B3C4 A   
pci_real_f0c                0 B3DB A   pci_real_f0d                0 B3F2 A   
pci_real_f0e                0 B405 A   pci_real_fail               0 B445 A   
pci_real_nextdev            0 B337 A   pci_real_nextdev2           0 B36D A   
pci_real_ok                 0 B44B A   pci_real_select_reg         0 B453 A   
pci_real_too_small          0 B43A A   pci_real_unknown            0 B443 A   
pci_routing_table_structur+ 0 B470 A   pci_routing_table_structur+ 0 B4F0 A   
pci_routing_table_structur+ 0 B490 A   pcibios_error               0 FE7B A   
pcibios_protected           0 B170 A   pcibios_real                0 B2CB A   
pmm_entry_point             0 B500 A   pmm_structure               0 B4F0 A   
pmode_IDT_info              0 F88C A   pnp_string                  0 B5B1 A   
post                        0 E05B A   post_d0_extended            0 A935 A   
post_d0_type47              0 A946 A   post_d1_exists              0 AA18 A   
post_d1_extended            0 AA23 A   post_d1_type47              0 AA34 A   
post_default_ints           0 E0D7 A   post_init_pic               0 B6BD A   
protected_mode              0 4C8E A   protmode_gdtdesc            0 AEE8 A   
real_mode                   0 4CB8 A   realmode_gdtdesc            0 AEEE A   
retf_post_0x467             0 AB2D A   rmode_IDT_info              0 F891 A   
rom_checksum                0 B570 A   rom_scan                    0 B5B5 A   
rom_scan_increment          0 B688 A   rom_scan_loop               0 B5B5 A   
s3_post                     0 AB3A A   smbios_entry_point          0 B6F0 A   
smbios_init                 0 B69A A   timer_tick_post             0 AB61 A   
unknown_service             0 B161 A   upcall1                     0 AF24 A   
upcall2                     0 AF33 A   upcall3                     0 AF5B A   
upcall4                     0 AF71 A   

00000 errors
00000 warnings
